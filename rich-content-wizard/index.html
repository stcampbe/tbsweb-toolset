<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WordToCodeâ„¢ - Rich Content Wizard</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/js-beautify/1.14.0/beautify-html.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/monaco-editor@0.49.0/min/vs/loader.js"></script>
    <style>
        /* Custom styles for the editor */
        html, body {
            height: 100%; /* Ensure html and body take full viewport height */
            margin: 0;
            padding: 0;
            overflow: hidden; /* Prevent body from scrolling */
        }

        body {
            font-family: 'Inter', sans-serif; /* Using Inter font */
            display: flex;
            flex-direction: column;
            background-color: #09090b; /* Very dark zinc */
        }
        .editor-container {
            display: flex;
            flex-grow: 1; /* Allow container to grow and fill available space */
            padding: 1rem; /* Apply padding to all sides */
            gap: 1rem; /* Space between editor and richtext-output */
            margin: 0;
            width: 100%; /* Full width */
            box-sizing: border-box; /* Include padding in total height */
        }
        .code-panel, .richtext-output-panel { /* Updated class name */
            background-color: #18181b; /* Darker zinc */
            border-radius: 0.75rem; /* rounded-xl */
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3); /* Darker shadow */
            padding: 1rem;
            display: flex;
            flex-direction: column; /* Keep column for header, content area, and footer */
            width: 100%; /* Take full width of container */
            height: 100%; /* Take full height of container */
            box-sizing: border-box; /* Include padding and border in element's total width/height */
            overflow: hidden; /* Important: Panel itself should not scroll, its children should */
        }

        /* Resizer bar styling (removed from layout, but keeping styles for reference if needed) */
        .resizer {
            width: 10px; /* Width of the draggable bar */
            background-color: #3f3f46; /* Medium zinc */
            cursor: ew-resize; /* East-west resize cursor */
            flex-shrink: 0; /* Prevent resizer from shrinking */
            border-radius: 0.25rem; /* Slightly rounded corners */
            transition: background-color 0.2s ease; /* Smooth transition on hover */
            display: none; /* Hide resizer in toggle view */
        }
        .resizer:hover {
            background-color: #52525b; /* Lighter zinc on hover */
        }

        textarea {
            width: 100%;
            flex-grow: 1;
            border: 1px solid #3f3f46; /* Medium zinc border */
            border-radius: 0.5rem; /* rounded-lg */
            padding: 0.75rem;
            font-family: monospace; /* Monospace font for code */
            font-size: 0.9rem;
            resize: none; /* Prevent manual resizing */
            outline: none; /* Remove default outline */
            background-color: #27272a; /* Darker zinc for textarea */
            color: #ffffff; /* White text color */
        }
        iframe {
            width: 100%;
            height: 100%; /* Make iframe fill its parent's height */
            flex-grow: 1;
            border: 1px solid #3f3f46; /* Medium zinc border */
            border-radius: 0.5rem; /* rounded-lg */
            background-color: #ffffff; /* Rich-Text Output window background remains white */
            overflow: auto; /* Ensure iframe itself can scroll if its content overflows */
        }
        h1 {
            color: #ffffff; /* White text for H1 in editor panel */
            margin-bottom: 1rem;
            text-align: center;
        }
        h2 {
            color: #ffffff; /* White text for H2 in panel headers */
        }
        label {
            color: #d4d4d8; /* Zinc-300 for labels */
        }
        input[type="text"] {
            background-color: #27272a; /* Darker zinc for input */
            color: #ffffff; /* White text for input */
            border-color: #3f3f46; /* Medium zinc border for input */
        }
        input[type="text"]::placeholder {
            color: #a1a1aa; /* Zinc-400 for placeholder text */
        }

        /* Responsive adjustments (will be simpler with toggle view) */
        @media (max-width: 768px) {
            .editor-container {
                flex-direction: column; /* Stack vertically on small screens */
            }
            .code-panel, .richtext-output-panel { /* Updated class name */
                min-height: 300px; /* Adjust min height for smaller screens */
            }
            .resizer {
                width: 100%; /* Full width for vertical resizer on small screens */
                height: 10px; /* Height for vertical resizer */
                cursor: ns-resize; /* North-south resize cursor */
            }
            /* Stack editor and sidebar vertically on small screens */
            .code-panel > .flex-grow {
                flex-direction: column;
            }
            .code-panel #monacoEditorContainer {
                width: 100%; /* Full width on small screens */
            }
            .code-panel #sidebar {
                width: 100%; /* Full width on small screens */
            }
        }

        /* Styles for button group */
        .button-group {
            display: flex;
            width: 100%; /* Make it span full width */
            border-radius: 0.5rem; /* rounded-md */
            box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05); /* shadow-sm */
            border: 1px solid #3f3f46; /* Darker border for button group */
            flex-wrap: wrap; /* Keep for responsiveness on smaller screens */
        }

        .button-group button {
            flex: 1; /* Make buttons take up equal space */
            border-radius: 0; /* Remove individual button rounded corners */
            border: none; /* Remove individual button borders */
            margin: 0; /* Remove individual button margins */
            padding: 0.5rem 0.75rem; /* Consistent padding */
            font-size: 0.875rem; /* text-sm */
            line-height: 1.25rem; /* leading-5 */
            position: relative; /* For z-index if needed */
            color: #ffffff; /* White text for all buttons */
            font-weight: bold; /* Make buttons bold */
        }

        /* Specific styles for the Sections and Headings buttons - NO FLEX */
        #toggleSectionsBtn,
        #toggleHeadingsBtn {
            flex: none; /* Override flex: 1; for these specific buttons */
            width: auto; /* Allow buttons to size based on content */
            border: 1px solid #3f3f46; /* Add border back for individual buttons */
            border-radius: 0.5rem; /* Add rounded corners back for individual buttons */
            margin-left: 0.5rem; /* Add spacing between them and other buttons */
        }

        /* Adjust border between buttons in the main button groups */
        .button-group:not(.no-border-buttons) button:not(:last-child) {
            border-right: 1px solid rgba(63, 63, 70, 0.5); /* Darker separator between buttons */
        }
        .button-group.no-border-buttons button:not(:last-child) {
            border-right: none; /* Remove border for this specific group */
        }

        /* Specific styling for the byline and URL/Image source button groups */
        .button-group.individual-rounded-buttons {
            border: none; /* Remove group border */
            box-shadow: none; /* Remove group shadow */
            width: auto; /* Allow the group to size to content */
            gap: 0.5rem; /* Add gap between individual buttons */
        }

        .button-group.individual-rounded-buttons button {
            flex: none; /* Do not make buttons take equal space */
            border-radius: 0.5rem; /* Ensure rounded corners */
            border: 1px solid #3f3f46; /* Add individual button border */
            padding: 0.5rem 0.75rem; /* Consistent padding */
        }
        /* Remove right border for individual rounded buttons */
        .button-group.individual-rounded-buttons button:not(:last-child) {
            border-right: 1px solid #3f3f46; /* Keep individual border */
        }


        .button-group button:first-child {
            border-top-left-radius: 0.5rem;
            border-bottom-left-radius: 0.5rem;
        }

        .button-group button:last-child {
            border-top-right-radius: 0.5rem;
            border-bottom-right-radius: 0.5rem;
        }

        .button-group button:hover {
            z-index: 1; /* Bring hovered button to front to show full border/shadow */
        }

        /* Visibility classes for toggle view */
        .panel-hidden {
            display: none;
        }
        .panel-visible {
            display: flex; /* Or 'block' for iframe if it's not a flex container */
        }


        /* Customize section styles (removed, but keeping styles for reference if needed) */
        .customize-section {
            background-color: #27272a; /* Same as input background */
            border-radius: 0.5rem;
            padding: 1rem; /* Re-added padding */
            margin-bottom: 1rem; /* Re-added margin-bottom */
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .customize-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            /* Removed padding-bottom, margin-bottom, border-bottom */
        }

        .customize-content {
            height: 0; /* Changed from max-height: 0; */
            overflow: hidden;
            /* Unified transition for smoother effect */
            transition: height 0.5s ease-in-out, padding 0.5s ease-in-out; /* Transition height and padding */
            padding: 0 1rem; /* Padding for content area, default to 0 for collapsed */
            background-color: #3f3f46; /* Match header background */
            border-radius: 0 0 0.5rem 0.5rem; /* Rounded bottom corners */
        }

        .collapsible-content.expanded {
            /* height: auto; will be set by JS dynamically */
            padding-top: 0.75rem; /* Add padding to content when expanded */
            padding-bottom: 0.75rem; /* Add padding to content when expanded */
        }

        .customize-header svg {
            transition: transform 0.3s ease;
        }

        .customize-header.expanded svg {
            transform: rotate(180deg);
        }

        /* Adjustments for button spacing */
        .code-panel h2 .inline-flex.mr-auto button,
        .richtext-output-panel h2 .inline-flex.mr-auto button { /* Updated class name */
            margin-right: 0.5rem; /* Default margin for buttons within the group */
        }

        /* When in fullscreen editor mode, remove margin from the first button group */
        .editor-container.fullscreen-editor .code-panel h2 .inline-flex.mr-auto {
            margin-left: 0 !important; /* Remove any left margin on the button container */
        }

        /* When in fullscreen richtext-output mode, remove margin from the first button group */
        .editor-container.fullscreen-richtext .richtext-output-panel h2 .inline-flex.mr-auto { /* Updated class name */
            margin-left: 0 !important; /* Remove any left margin on the button */
        }

        /* Ensure the button itself doesn't have an undesired left margin when its parent is adjusted */
        .editor-container.fullscreen-editor .code-panel h2 .inline-flex.mr-auto #fullScreenBtn,
        .editor-container.fullscreen-editor .code-panel h2 .inline-flex.mr-auto #exitFullScreenBtn,
        .editor-container.fullscreen-richtext .richtext-output-panel h2 .inline-flex.mr-auto #fullScreenRichTextBtn, /* Updated ID */
        .editor-container.fullscreen-richtext .richtext-output-panel h2 .inline-flex.mr-auto #exitFullScreenRichTextBtn { /* Updated ID */
            margin-left: 0; /* Explicitly remove any left margin on the button */
        }

        /* Modal styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .modal-content {
            background-color: #18181b; /* Darker zinc */
            padding: 2rem;
            border-radius: 0.75rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            color: #ffffff;
            text-align: left; /* Left align content */
            max-width: 90%;
            width: 400px;
        }

        .modal-content h3 {
            font-size: 1.5rem;
            font-weight: bold;
            margin-bottom: 1rem;
            text-align: left; /* Ensure title is left aligned */
        }

        .modal-content p {
            margin-bottom: 1.5rem;
        }

        .modal-content button {
            background-color: #52525b; /* Zinc-600 */
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            font-weight: bold;
            transition: background-color 0.2s ease;
        }

        .modal-content button:hover {
            background-color: #3f3f46; /* Zinc-700 */
        }

        .modal-content .button-group {
            border: none; /* Remove border for button groups inside modal */
            box-shadow: none; /* Remove shadow for button groups inside modal */
            width: auto; /* Allow buttons to size naturally */
        }

        .modal-content .button-group button {
            flex: none; /* Prevent buttons from taking equal space */
            margin: 0.25rem; /* Add some margin between buttons */
            border: 1px solid #3f3f46; /* Add border back for individual buttons */
            border-radius: 0.5rem; /* Add rounded corners back for individual buttons */
            padding: 0.3rem 0.6rem; /* Reduced padding for smaller buttons */
            font-size: 0.8rem; /* Reduced font size for smaller buttons */
        }

        .modal-content .button-group button.active {
            background-color: #27272a; /* Zinc-800 for active state */
            color: white;
            border-color: #27272a;
        }

        /* Monaco Editor specific styling */
        #monacoEditorContainer {
            min-height: 200px; /* Ensure it has a minimum height */
            /* Monaco editor will take full height of its flex parent */
        }

        /* Styles for collapsible sections */
        .collapsible-section {
            background-color: #3f3f46; /* Medium zinc for section background */
            border-radius: 0.5rem;
            margin-bottom: 0.75rem; /* Space between sections */
            overflow: hidden; /* Hide overflowing content during collapse */
        }

        .collapsible-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem 1rem;
            cursor: pointer;
            background-color: #3f3f46; /* Medium zinc for header background */
            border-bottom: 1px solid #52525b; /* Lighter zinc border */
            border-radius: 0.5rem 0.5rem 0 0; /* Rounded top corners */
        }

        .collapsible-header.collapsed {
            border-bottom: none; /* No border when collapsed */
            border-radius: 0.5rem; /* Fully rounded when collapsed */
        }

        .collapsible-header h4 {
            font-size: 1rem;
            font-weight: bold;
            color: #ffffff;
        }

        .collapsible-header svg {
            transition: transform 0.3s ease;
        }

        .collapsible-header.expanded svg {
            transform: rotate(180deg);
        }

        .collapsible-content {
            height: 0; /* Changed from max-height: 0; */
            overflow: hidden;
            /* Unified transition for smoother effect */
            transition: height 0.5s ease-in-out, padding 0.5s ease-in-out; /* Transition height and padding */
            padding: 0 1rem; /* Padding for content area, default to 0 for collapsed */
            background-color: #3f3f46; /* Match header background */
            border-radius: 0 0 0.5rem 0.5rem; /* Rounded bottom corners */
        }

        .collapsible-content.expanded {
            /* height: auto; will be set by JS dynamically */
            padding-top: 0.75rem; /* Add padding to content when expanded */
            padding-bottom: 0.75rem; /* Add padding to content when expanded */
        }

        /* Toggle Switch Styles */
        .toggle-switch-container {
            display: flex;
            align-items: center;
            justify-content: space-between; /* Space out label and switch */
            margin-bottom: 0.5rem; /* Space between switches */
            padding: 0.5rem 0; /* Vertical padding for each switch row */
        }

        .toggle-switch-label {
            color: #d4d4d8; /* Light gray for label text */
            font-size: 0.9rem;
            flex-grow: 1; /* Allow label to take available space */
        }

        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 44px; /* Width of the pill */
            height: 24px; /* Height of the pill */
            border-radius: 12px; /* Half of height for pill shape */
            background-color: #71717a; /* Off state background - Zinc-600 */
            cursor: pointer;
            transition: background-color 0.3s ease;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-switch-slider {
            position: absolute;
            content: "";
            height: 20px; /* Height of the inner circle */
            width: 20px; /* Width of the inner circle */
            left: 2px; /* Initial position for off state */
            bottom: 2px;
            background-color: #ffffff; /* Circle color */
            border-radius: 50%;
            transition: transform 0.3s ease;
        }

        /* Checked state styles (applied to the .toggle-switch label itself) */
        .toggle-switch.is-checked {
            background-color: #22c55e; /* Green for on state */
        }

        .toggle-switch.is-checked .toggle-switch-slider {
            transform: translateX(20px); /* Move circle to the right */
        }

        /* Custom style for HTML character entities in Monaco Editor */
        .entity-highlight {
            color: gold !important; /* Use !important to ensure override */
        }

        /* Styling for disabled button */
        #runSelectedBtn:disabled, #runSelectedTableBtn:disabled,
        #autoEncodeBtn:disabled, #autoFormatBtn:disabled, #copyCodeBtn:disabled,
        #exportHtmlBtn:disabled, #importHtmlBtn:disabled, #clearAllBtn:disabled,
        #toggleEditorViewBtnCode:disabled { /* Added toggleEditorViewBtnCode here */
            background-color: #4a4a4a; /* Darker gray for disabled state */
            cursor: not-allowed;
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div class="flex flex-col h-full">
        <div class="editor-container">
            <div id="richtextOutputPanel" class="richtext-output-panel panel-visible">
                <div class="flex items-center mb-4">
                    <h2 class="text-xl font-semibold text-white">Rich-Text Editor</h2>
                    <button id="toggleEditorViewBtnRichText" class="ml-4 px-4 py-2 text-base font-semibold bg-sky-700 text-white rounded-md hover:bg-sky-800 focus:outline-none focus:ring-2 focus:ring-sky-600 focus:ring-opacity-50 font-bold">
                        Go to HTML
                    </button>
                    <!-- New toggle for Rich-Text panel, now in a container -->
                    <div class="ml-4 p-2 bg-zinc-700 rounded-lg flex items-center">
                        <span class="toggle-switch-label text-white text-sm mr-2">Auto-Clean MSO</span>
                        <label class="toggle-switch">
                            <input type="checkbox" id="toggleAutoCleanMsoOnSwitchRichText">
                            <span class="toggle-switch-slider"></span>
                        </label>
                    </div>
                </div>
                <iframe id="default_ifr"></iframe>
            </div>

            <div id="codePanel" class="code-panel panel-hidden">
                <div class="flex items-center mb-4 flex-wrap">
                    <h2 class="text-xl font-semibold text-white">HTML Editor</h2>
                    <button id="toggleEditorViewBtnCode" class="ml-4 px-4 py-2 text-base font-semibold bg-sky-700 text-white rounded-md hover:bg-sky-800 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50 font-bold">
                        Go to Rich-Text
                    </button>
                    <!-- New toggle for HTML panel, now in a container -->
                    <div class="ml-4 p-2 bg-zinc-700 rounded-lg flex items-center">
                        <span class="toggle-switch-label text-white text-sm mr-2">Auto-Clean MSO</span>
                        <label class="toggle-switch">
                            <input type="checkbox" id="toggleAutoCleanMsoOnSwitchCode">
                            <span class="toggle-switch-slider"></span>
                        </label>
                    </div>
                    <div class="inline-flex space-x-2 ml-auto mt-2 sm:mt-0">
                        <button id="importHtmlBtn" class="px-3 py-1 text-sm bg-purple-700 text-white rounded-md hover:bg-purple-800 focus:outline-none focus:ring-2 focus:ring-purple-600 focus:ring-opacity-50 font-bold">Import HTML</button>
                        <button id="exportHtmlBtn" class="px-3 py-1 text-sm bg-red-700 text-white rounded-md hover:bg-red-800 focus:outline-none focus:ring-2 focus:ring-red-600 focus:ring-opacity-50 font-bold">Export HTML</button>
                        <input type="file" id="htmlFileInput" accept=".html" style="display: none;">
                    </div>
                </div>
                
                <div class="flex flex-grow gap-4">
                    <div id="monacoEditorContainer" class="flex-grow border border-zinc-700 rounded-lg overflow-hidden"></div>
                    
                    <div id="sidebar" class="w-1/4 bg-zinc-800 rounded-lg p-4 flex-shrink-0 flex flex-col">
                        <h3 class="text-lg font-semibold text-white mb-4">Formatting</h3>
                        
                        <div class="collapsible-section">
                            <div class="collapsible-header" id="generalCleaningHeader">
                                <h4 class="text-white">General Cleaning</h4>
                                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" class="w-5 h-5 text-white">
                                    <path stroke-linecap="round" stroke-linejoin="round" d="M19.5 8.25l-7.5 7.5-7.5-7.5" />
                                </svg>
                            </div>
                            <div class="collapsible-content" id="generalCleaningContent">
                                <button id="runSelectedBtn" class="w-full px-4 py-2 mb-4 text-sm bg-green-600 text-white rounded-md hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-opacity-50 font-semibold">
                                    Run Selected
                                </button>

                                <div class="toggle-switch-container">
                                    <span class="toggle-switch-label">Clean URLs</span>
                                    <label class="toggle-switch">
                                        <input type="checkbox" id="toggleUrlCleaning">
                                        <span class="toggle-switch-slider"></span>
                                    </label>
                                </div>

                                <div class="toggle-switch-container">
                                    <span class="toggle-switch-label">Clean Spaces</span>
                                    <label class="toggle-switch">
                                        <input type="checkbox" id="toggleAutoSpacing">
                                        <span class="toggle-switch-slider"></span>
                                    </label>
                                </div>
                                
                                <div class="toggle-switch-container">
                                    <span class="toggle-switch-label">Clean Single Breaks</span>
                                    <label class="toggle-switch">
                                        <input type="checkbox" id="toggleCleanSingleBreaks"> <span class="toggle-switch-slider"></span>
                                    </label>
                                </div>

                                <div class="toggle-switch-container">
                                    <span class="toggle-switch-label">Clean &lt;u&gt; | &lt;b&gt; | &lt;i&gt;</span>
                                    <label class="toggle-switch">
                                        <input type="checkbox" id="toggleCleanFormattingTags"> <span class="toggle-switch-slider"></span>
                                    </label>
                                </div>

                                <div class="toggle-switch-container">
                                    <span class="toggle-switch-label">Clean MSO Code</span>
                                    <label class="toggle-switch">
                                        <input type="checkbox" id="toggleCleanMsoCode">
                                        <span class="toggle-switch-slider"></span>
                                    </label>
                                </div>
                            </div>
                        </div>

                        <div class="collapsible-section">
                            <div class="collapsible-header" id="tableCleaningHeader">
                                <h4 class="text-white">Table Cleaning</h4>
                                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" class="w-5 h-5 text-white">
                                    <path stroke-linecap="round" stroke-linejoin="round" d="M19.5 8.25l-7.5 7.5-7.5-7.5" />
                                    </svg>
                            </div>
                            <div class="collapsible-content" id="tableCleaningContent">
                                <button id="runSelectedTableBtn" class="w-full px-4 py-2 mb-4 text-sm bg-green-600 text-white rounded-md hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-opacity-50 font-semibold">
                                    Run Selected
                                </button>
                                
                                <div class="toggle-switch-container">
                                    <span class="toggle-switch-label">Responsive Tables</span>
                                    <label class="toggle-switch">
                                        <input type="checkbox" id="toggleResponsiveTables">
                                        <span class="toggle-switch-slider"></span>
                                    </label>
                                </div>

                                <div class="toggle-switch-container">
                                    <span class="toggle-switch-label">WET Alignment</span>
                                    <label class="toggle-switch">
                                        <input type="checkbox" id="toggleWetAlignment">
                                        <span class="toggle-switch-slider"></span>
                                    </label>
                                </div>

                                <div class="toggle-switch-container">
                                    <span class="toggle-switch-label">Apply Basic Classes</span>
                                    <label class="toggle-switch">
                                        <input type="checkbox" id="toggleApplyBasicClasses">
                                        <span class="toggle-switch-slider"></span>
                                    </label>
                                </div>

                                <div class="toggle-switch-container">
                                    <span class="toggle-switch-label">Remove &lt;p&gt; Tags</span>
                                    <label class="toggle-switch">
                                        <input type="checkbox" id="toggleRemovePTags">
                                        <span class="toggle-switch-slider"></span>
                                    </label>
                                </div>
                            </div>
                        </div>

                        <div class="collapsible-section">
                            <div class="collapsible-header" id="componentsHeader">
                                <h4 class="text-white">Components</h4>
                                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" class="w-5 h-5 text-white">
                                    <path stroke-linecap="round" stroke-linejoin="round" d="M19.5 8.25l-7.5 7.5-7.5-7.5" />
                                </svg>
                            </div>
                            <div class="collapsible-content" id="componentsContent">
                                <p class="text-zinc-300 text-sm mb-2">Content for components will go here.</p>
                                <button class="mt-2 px-3 py-1 text-xs bg-green-600 text-white rounded-md hover:bg-green-700">Button Comp</button>
                                <button class="mt-2 ml-2 px-3 py-1 text-xs bg-green-600 text-white rounded-md hover:bg-green-700">Card Comp</button>
                            </div>
                        </div>
                    </div>

                </div>

                <div class="mt-auto pt-4 flex justify-center space-x-2">
                    <button id="clearAllBtn" class="px-4 py-2 text-sm bg-zinc-700 text-white rounded-md hover:bg-zinc-600 focus:outline-none focus:ring-2 focus:ring-zinc-500 focus:ring-opacity-50 font-semibold">Clear All</button>
                    <button id="autoEncodeBtn" class="px-4 py-2 text-sm bg-red-700 text-white rounded-md hover:bg-red-800 focus:outline-none focus:ring-2 focus:ring-red-600 focus:ring-opacity-50 font-semibold">
                        Auto-Encode
                    </button>
                    <button id="autoFormatBtn" class="px-4 py-2 text-sm bg-red-700 text-white rounded-md hover:bg-red-800 focus:outline-none focus:ring-2 focus:ring-red-600 focus:ring-opacity-50 font-semibold">
                        Auto-Indent
                    </button>
                    <button id="copyCodeBtn" class="px-4 py-2 text-sm bg-zinc-700 text-white rounded-md hover:bg-zinc-600 focus:outline-none focus:ring-2 focus:ring-zinc-500 focus:ring-opacity-50 font-semibold">
                        Copy Code
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Get references to the elements
        const default_ifr = document.getElementById('default_ifr');
        const codePanel = document.getElementById('codePanel');
        const richtextOutputPanel = document.getElementById('richtextOutputPanel');
        const toggleEditorViewBtnRichText = document.getElementById('toggleEditorViewBtnRichText'); 
        const toggleEditorViewBtnCode = document.getElementById('toggleEditorViewBtnCode'); 
        const copyCodeBtn = document.getElementById('copyCodeBtn');
        const autoFormatBtn = document.getElementById('autoFormatBtn');
        const autoEncodeBtn = document.getElementById('autoEncodeBtn'); // New button reference
        const exportHtmlBtn = document.getElementById('exportHtmlBtn');
        const importHtmlBtn = document.getElementById('importHtmlBtn');
        const htmlFileInput = document.getElementById('htmlFileInput');
        // Removed undoBtn and redoBtn as per user request
        const clearAllBtn = document.getElementById('clearAllBtn');
        const runSelectedBtn = document.getElementById('runSelectedBtn'); // Get reference to Run Selected button
        const runSelectedTableBtn = document.getElementById('runSelectedTableBtn'); // Get reference to Run Selected Table button
        
        // Removed references to the removed toggles
        const toggleUrlCleaning = document.getElementById('toggleUrlCleaning'); // Get reference to URL Cleaning toggle
        const toggleAutoSpacing = document.getElementById('toggleAutoSpacing'); // Get reference to Auto-Spacing toggle
        const toggleCleanSingleBreaks = document.getElementById('toggleCleanSingleBreaks'); // New toggle reference
        // Removed toggleCleanComments as it's now integrated into MSO Code cleaning
        const toggleCleanMsoCode = document.getElementById('toggleCleanMsoCode'); // New toggle reference for Clean MSO Code
        const toggleCleanFormattingTags = document.getElementById('toggleCleanFormattingTags'); // New toggle for formatting tags

        // Table cleaning toggles
        const toggleResponsiveTables = document.getElementById('toggleResponsiveTables');
        const toggleWetAlignment = document.getElementById('toggleWetAlignment');
        const toggleApplyBasicClasses = document.getElementById('toggleApplyBasicClasses');
        const toggleRemovePTags = document.getElementById('toggleRemovePTags');

        // New Auto-Clean MSO when switching toggles
        const toggleAutoCleanMsoOnSwitchRichText = document.getElementById('toggleAutoCleanMsoOnSwitchRichText');
        const toggleAutoCleanMsoOnSwitchCode = document.getElementById('toggleAutoCleanMsoOnSwitchCode');


        // Array of all general cleaning toggles for easy iteration
        const generalCleaningToggles = [
            toggleUrlCleaning,
            toggleAutoSpacing,
            toggleCleanSingleBreaks,
            toggleCleanFormattingTags,
            toggleCleanMsoCode // Moved to last
        ];

        // Array of all table cleaning toggles for easy iteration
        const tableCleaningToggles = [
            toggleResponsiveTables,
            toggleWetAlignment,
            toggleApplyBasicClasses,
            toggleRemovePTags
        ];

        // Array of all buttons that display temporary messages
        const tempMessageButtons = [
            copyCodeBtn,
            autoFormatBtn,
            autoEncodeBtn,
            exportHtmlBtn,
            importHtmlBtn,
            clearAllBtn,
            runSelectedBtn,
            runSelectedTableBtn
        ];


        let richTextEditorInstance; // HugeRTE editor instance
        let monacoEditorInstance; // Monaco editor instance
        let currentView = 'richtext'; // 'richtext' or 'code'

        // Separate content storage for each editor
        let richTextContent = '';
        let htmlOutputContent = ''; // This will now hold the content for Monaco

        // Variable to hold the HugeRTE editor instance from the iframe
        let richTextEditorInstanceFromIframe;

        /**
         * Decodes HTML entities within a string to their actual Unicode characters.
         * Uses a temporary textarea element for reliable decoding.
         * @param {string} html - The HTML string containing entities.
         * @returns {string} The HTML string with entities decoded.
         */
        function decodeHtmlEntities(html) {
            const textarea = document.createElement('textarea');
            textarea.innerHTML = html; // Browser decodes entities when setting innerHTML
            return textarea.value; // Retrieving value gives the decoded string
        }

        /**
         * Cleans HTML content for display in HugeRTE.
         * This function is specifically for preparing content *before* setting it to the rich text editor.
         * It decodes HTML entities to ensure they render correctly in the visual editor.
         * @param {string} content - The HTML content to clean.
         * @returns {string} The cleaned HTML content.
         */
        function cleanHtmlForRichTextDisplay(content) {
            // Ensure content passed to rich text editor is also decoded
            return decodeHtmlEntities(content);
        }

        /**
         * Applies URL cleaning to HTML content.
         * Converts specific absolute URLs to relative paths and removes target/rel attributes from <a> tags.
         * Also removes <a> tags that ONLY contain a name attribute (i.e., no href).
         * @param {string} htmlString - The HTML content to clean.
         * @returns {string} The cleaned HTML content.
         */
        function applyUrlCleaning(htmlString) {
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = htmlString;

            const urlMappings = [
                { old: 'https://canada-preview.adobecqms.net/en/treasury-board-secretariat', new: '/content/canadasite/en/treasury-board-secretariat' },
                { old: 'https://canada-preview.adobecqms.net/fr/secretariat-conseil-tresor', new: '/content/canadasite/fr/secretariat-conseil-tresor' },
                { old: 'https://canada-preview.adobecqms.net/en/government', new: '/content/canadasite/en/government' },
                { old: 'https://canada-preview.adobecqms.net/fr/gouvernement', new: '/content/canadasite/fr/gouvernement' },
                { old: 'https://www.canada.ca/en/treasury-board-secretariat', new: '/content/canadasite/en/treasury-board-secretariat' },
                { old: 'https://www.canada.ca/fr/secretariat-conseil-tresor', new: '/content/canadasite/fr/secretariat-conseil-tresor' },
                { old: 'https://www.canada.ca/en/government', new: '/content/canadasite/en/government' },
                { old: 'https://www.canada.ca/fr/gouvernement', new: '/content/canadasite/fr/gouvernement' }
            ];

            // Patterns to prepend with /content/canadasite
            const prependPatterns = [
                '/en/treasury-board-secretariat', 'en/treasury-board-secretariat',
                '/fr/secretariat-conseil-tresor', 'fr/secretariat-conseil-tresor',
                '/en/government', 'en/government',
                '/fr/gouvernement', 'fr/gouvernement'
            ];

            const aElements = tempDiv.querySelectorAll('a');
            aElements.forEach(a => {
                let href = a.getAttribute('href');
                const name = a.getAttribute('name');

                // Case 1: Remove <a> tags that ONLY contain a name attribute (no href)
                if (name && !href) {
                    const parent = a.parentNode;
                    if (parent) {
                        // Move children out of the <a> tag
                        while (a.firstChild) {
                            parent.insertBefore(a.firstChild, a);
                        }
                        // Remove the <a> tag itself
                        parent.removeChild(a);
                    }
                    return; // Skip further processing for this <a> tag
                }

                // Case 2: Process <a> tags with href
                if (href) {
                    // Rule: Prepend /content/canadasite to specific relative links
                    let prepended = false;
                    for (const pattern of prependPatterns) {
                        if (href.startsWith(pattern)) {
                            if (href.startsWith('/')) {
                                href = '/content/canadasite' + href;
                            } else {
                                href = '/content/canadasite/' + href;
                            }
                            a.setAttribute('href', href);
                            prepended = true;
                            break; // Stop after the first match
                        }
                    }

                    // If already prepended, skip other URL conversions for this link
                    if (prepended) {
                        // Remove target attribute
                        if (a.hasAttribute('target')) {
                            a.removeAttribute('target');
                        }

                        // Remove rel attribute
                        if (a.hasAttribute('rel')) {
                            a.removeAttribute('rel');
                        }
                        return;
                    }

                    // Specific handling for "/content/canadasite" or "/content/dam" links
                    if (href.includes('/content/canadasite') || href.includes('/content/dam')) {
                        const contentPath = href.includes('/content/canadasite') ? '/content/canadasite' : '/content/dam';
                        const contentIndex = href.indexOf(contentPath);
                        if (contentIndex !== 0) {
                            href = href.substring(contentIndex);
                        }
                        a.setAttribute('href', href);
                    } else {
                        // Convert other URLs using existing mappings
                        for (const mapping of urlMappings) {
                            if (href.startsWith(mapping.old)) {
                                href = href.replace(mapping.old, mapping.new);
                                a.setAttribute('href', href);
                                break; // Stop after the first match
                            }
                        }
                    }
                }

                // Remove target attribute
                if (a.hasAttribute('target')) {
                    a.removeAttribute('target');
                }

                // Remove rel attribute
                if (a.hasAttribute('rel')) {
                    a.removeAttribute('rel');
                }
            });

            return tempDiv.innerHTML;
        }

        /**
         * Applies auto-spacing and cleans multiple <br> tags in HTML content.
         * Replaces multiple spaces with a single space, and trims leading/trailing spaces
         * within block-level elements. Also replaces sequences of two or more <br> tags with </p><p>.
         * NEW: Also cleans `<br clear="all">` tags.
         * NEW: Also cleans `<span style="mso-spacerun: yes">` tags, preserving only normal spaces within them.
         * NEW: Removes empty <p> tags (including &nbsp;) if they are outside of tables.
         * NEW: Removes empty <li>, <div>, and <section> tags (including &nbsp;) anywhere.
         * @param {string} htmlString - The HTML content to clean.
         * @returns {string} The cleaned HTML content.
         */
        function applyAutoSpacing(htmlString) {
            const parser = new DOMParser();
            const doc = parser.parseFromString(htmlString, 'text/html');
            const body = doc.body;

            // 1. Handle <span style="mso-spacerun: yes"> tags
            const spacerunSpans = body.querySelectorAll('span[style*="mso-spacerun: yes"]');
            spacerunSpans.forEach(span => {
                const parent = span.parentNode;
                if (parent) {
                    // Check if the span's text content contains a normal space
                    if (span.textContent.includes(' ')) {
                        // Replace the span with a single normal space
                        parent.replaceChild(doc.createTextNode(' '), span);
                    } else {
                        // Remove the span entirely if it doesn't contain a normal space
                        parent.removeChild(span);
                    }
                }
            });

            // Serialize the modified DOM back to a string for further processing
            let cleanedHtml = body.innerHTML;

            // 2. Replace multiple spaces with a single space and trim.
            cleanedHtml = cleanedHtml.replace(/\s+/g, ' ').trim();

            // 3. Replace sequences of two or more <br> tags (with optional whitespace) with </p><p>');
            // This handles <br><br>, <br> <br>, <br/><br/>, etc.
            cleanedHtml = cleanedHtml.replace(/(<br\s*\/?>\s*){2,}/gi, '</p><p>');

            // 4. Remove <br clear="all"> tags
            cleanedHtml = cleanedHtml.replace(/<br\s+clear="all"\s*\/?>/gi, '');

            // Re-parse to work with DOM for new rules
            doc.body.innerHTML = cleanedHtml;

            // 5. Remove empty <p> tags (including &nbsp;) if they are outside of tables.
            const paragraphs = Array.from(body.querySelectorAll('p'));
            for (let i = paragraphs.length - 1; i >= 0; i--) {
                const p = paragraphs[i];
                const trimmedContent = p.innerHTML.trim();
                const isEmptyOrNBSP = trimmedContent === '' || trimmedContent === '&nbsp;' || trimmedContent === '\u00A0';
                const isInsideTable = p.closest('table');

                if (isEmptyOrNBSP && !isInsideTable) {
                    if (p.parentNode) {
                        p.parentNode.removeChild(p);
                    }
                }
            }

            // 6. Remove empty <li>, <div>, and <section> tags (including &nbsp;) anywhere.
            const elementsToClean = Array.from(body.querySelectorAll('li, div, section'));
            for (let i = elementsToClean.length - 1; i >= 0; i--) {
                const element = elementsToClean[i];
                const trimmedContent = element.innerHTML.trim();
                const isEmptyOrNBSP = trimmedContent === '' || trimmedContent === '&nbsp;' || trimmedContent === '\u00A0';

                if (isEmptyOrNBSP) {
                    if (element.parentNode) {
                        element.parentNode.removeChild(element);
                    }
                }
            }

            return body.innerHTML;
        }

        /**
         * Converts single <br> tags into paragraph breaks (</p><p>) while ignoring <br> tags within tables.
         * This simplified version does not attempt to preserve inline element nesting across the break.
         * @param {string} htmlString - The HTML content to process.
         * @returns {string} The processed HTML content.
         */
        function applyCleanSingleBreaks(htmlString) {
            const parser = new DOMParser();
            const doc = parser.parseFromString(htmlString, 'text/html');
            const brElements = Array.from(doc.querySelectorAll('br')); 

            // Process elements in reverse order to avoid issues with DOM manipulation affecting iteration
            for (let i = brElements.length - 1; i >= 0; i--) {
                const br = brElements[i];

                // Check if br still exists in the DOM and has a parent
                if (!br || !br.parentNode) {
                    continue; 
                }

                let currentParent = br.parentNode;
                let isInsideTable = false;
                // Traverse up the DOM tree to check if the <br> is inside a <table>
                while (currentParent && currentParent !== doc.body) {
                    if (currentParent.tagName && currentParent.tagName.toLowerCase() === 'table') {
                        isInsideTable = true;
                        break;
                    }
                    currentParent = currentParent.parentNode;
                }

                if (isInsideTable) {
                    continue; // Skip this <br> if it's inside a table
                }

                // Create a new paragraph element
                const newParagraph = doc.createElement('p');
                
                // Move all siblings after the <br> into the new paragraph
                while (br.nextSibling) {
                    newParagraph.appendChild(br.nextSibling);
                }

                // Insert the new paragraph after the original parent of the <br>
                // This effectively closes the current paragraph and starts a new one.
                if (br.parentNode.parentNode) {
                    br.parentNode.parentNode.insertBefore(newParagraph, br.parentNode.nextSibling);
                } else {
                    // Fallback for very unusual structures where parentNode.parentNode is null
                    doc.body.appendChild(newParagraph);
                }
                
                // Remove the <br> itself
                br.parentNode.removeChild(br);
            }

            return doc.body.innerHTML;
        }


        /**
         * Removes <p>&nbsp;</p> tags that are not within <table> or <li> tags.
         * @param {string} htmlString - The HTML content to clean.
         * @returns {string} The cleaned HTML content.
         */
        function removeEmptyParagraphsOutsideTablesAndLists(htmlString) {
            const parser = new DOMParser();
            const doc = parser.parseFromString(htmlString, 'text/html');
            const paragraphs = doc.querySelectorAll('p');

            for (let i = paragraphs.length - 1; i >= 0; i--) {
                const p = paragraphs[i];
                // Check if the paragraph contains only &nbsp; or is effectively empty after decoding
                // After decodeHtmlEntities, &nbsp; becomes a non-breaking space character (\u00A0)
                const containsOnlyNBSP = p.innerHTML.trim() === '&nbsp;' || p.innerHTML.trim() === '\u00A0';

                if (containsOnlyNBSP) {
                    let parent = p.parentElement;
                    let isInsideTableOrList = false;
                    while (parent) {
                        if (parent.tagName === 'TABLE' || parent.tagName === 'LI') {
                            isInsideTableOrList = true;
                            break;
                        }
                        parent = parent.parentElement;
                    }

                    if (!isInsideTableOrList) {
                        p.parentNode.removeChild(p);
                    }
                }
            }
            return doc.body.innerHTML;
        }

        /**
         * Removes empty <p> tags and <p> tags that contain only a single non-breaking space,
         * specifically if they have a class starting with "Mso" and are not within a table.
         * @param {string} htmlString - The HTML content to clean.
         * @returns {string} The cleaned HTML content.
         */
        function removeEmptyParagraphs(htmlString) {
            const parser = new DOMParser();
            const doc = parser.parseFromString(htmlString, 'text/html');
            const paragraphs = doc.querySelectorAll('p');

            for (let i = paragraphs.length - 1; i >= 0; i--) {
                const p = paragraphs[i];
                
                // Condition 1: Check if the paragraph is empty or contains only a non-breaking space
                const trimmedContent = p.innerHTML.trim();
                const isEmptyOrNBSP = trimmedContent === '' || trimmedContent === '&nbsp;' || trimmedContent === '\u00A0';

                // Condition 2: Check if the paragraph has a class attribute starting with "Mso"
                const hasMsoClass = p.classList.length > 0 && p.className.startsWith('Mso');

                // Condition 3: Check if the paragraph is NOT within a table
                const isInsideTable = p.closest('table');

                if (isEmptyOrNBSP && hasMsoClass && !isInsideTable) {
                    if (p.parentNode) {
                        p.parentNode.removeChild(p);
                    }
                }
            }
            return doc.body.innerHTML;
        }

        /**
         * Removes inline width and height styles from all elements in the HTML content.
         * @param {string} htmlString - The HTML content to clean.
         * @returns {string} The cleaned HTML content.
         */
        function removeInlineWidthHeightStyles(htmlString) {
            const parser = new DOMParser();
            const doc = parser.parseFromString(htmlString, 'text/html');
            const allElements = doc.querySelectorAll('*');

            allElements.forEach(element => {
                if (element.hasAttribute('style')) {
                    let style = element.getAttribute('style');
                    // Remove width: ...; and height: ...;
                    style = style.replace(/width:\s*[^;]+;?/gi, '');
                    style = style.replace(/height:\s*[^;]+;?/gi, '');
                    // Clean up extra spaces or semicolons
                    style = style.replace(/;{2,}/g, ';').trim();
                    if (style.endsWith(';')) {
                        style = style.slice(0, -1);
                    }

                    if (style) {
                        element.setAttribute('style', style);
                    } else {
                        element.removeAttribute('style');
                    }
                }
            });
            return doc.body.innerHTML;
        }

        /**
         * Converts common character entities and named entities to their numeric HTML entity equivalents.
         * This function operates on an HTML string, parsing it to a temporary DOM, modifying text nodes,
         * and then serializing it back to a string, ensuring numeric entities are preserved.
         * @param {string} htmlString - The HTML content to process.
         * @returns {string} The processed HTML string with numeric entities.
         */
        function convertAllEntitiesToNumeric(htmlString) {
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = htmlString; // This parses entities to characters

            const walker = document.createTreeWalker(
                tempDiv,
                NodeFilter.SHOW_TEXT,
                {
                    acceptNode: function(textNode) {
                        let parent = textNode.parentNode;
                        while (parent) {
                            const tagName = parent.tagName ? parent.tagName.toLowerCase() : '';
                            if (tagName === 'script' || tagName === 'style' || tagName === 'time') {
                                return NodeFilter.FILTER_REJECT;
                            }
                            parent = parent.parentNode;
                        }
                        return NodeFilter.FILTER_ACCEPT;
                    }
                },
                false
            );

            let currentNode;
            const textNodesToProcess = [];
            while (currentNode = walker.nextNode()) {
                textNodesToProcess.push(currentNode);
            }

            textNodesToProcess.forEach(textNode => {
                let text = textNode.nodeValue;
                // Replace specific named entities/characters with their numeric character references
                text = text.replace(/â€™/g, '&#8217;');     // literal â€™
                text = text.replace(/&rsquo;/g, '&#8217;'); // &rsquo;
                text = text.replace(/â€œ/g, '&#8220;');     // literal â€œ
                text = text.replace(/&ldquo;/g, '&#8220;'); // &ldquo;
                text = text.replace(/â€/g, '&#8221;');     // literal â€
                text = text.replace(/&rdquo;/g, '&#8221;'); // &rdquo;
                text = text.replace(/Â«/g, '&#171;');     // literal Â«
                text = text.replace(/&laquo;/g, '&#171;'); // &laquo;
                text = text.replace(/Â»/g, '&#187;');     // literal Â»
                text = text.replace(/&raquo;/g, '&#187;'); // &raquo;
                text = text.replace(/\u00A0/g, '&#160;'); // This converts literal NBSP char to numeric entity
                text = text.replace(/&nbsp;/g, '&#160;'); // This handles named NBSP entity to numeric

                textNode.nodeValue = text;
            });

            let processedHtml = tempDiv.innerHTML; // This re-serializes characters to entities

            // Final string-based replacements to ensure numeric entities are explicitly present
            // This is a safeguard against browser's innerHTML serialization re-converting entities.
            processedHtml = processedHtml.replace(/&nbsp;/g, '&#160;');
            processedHtml = processedHtml.replace(/&rsquo;/g, '&#8217;');
            processedHtml = processedHtml.replace(/&ldquo;/g, '&#8220;');
            processedHtml = processedHtml.replace(/&rdquo;/g, '&#8221;');
            processedHtml = processedHtml.replace(/&laquo;/g, '&#171;');
            processedHtml = processedHtml.replace(/&raquo;/g, '&#187;');

            // Handle double encoding if it occurs (e.g., &amp;#160; -> &#160;)
            processedHtml = processedHtml.replace(/&amp;#(\d+);/g, '&#$1;');

            return processedHtml;
        }

        /**
         * Filters and preserves only specified HTML tags and their contents, and text nodes,
         * from a source DOM node. Disallowed tags are unwrapped, preserving their allowed children.
         * @param {HTMLElement} sourceNode - The DOM node whose children are to be filtered.
         * @param {Document} doc - The document object to create new elements.
         * @returns {string} The HTML string containing only the preserved content.
         */
        function filterAndPreserveContent(sourceNode, doc) {
            let tempContainer = doc.createElement('div'); // Use a div as a temporary container

            Array.from(sourceNode.childNodes).forEach(child => {
                if (child.nodeType === Node.TEXT_NODE) {
                    // Always preserve text nodes (including character entities which are parsed into text nodes)
                    tempContainer.appendChild(child.cloneNode(true));
                } else if (child.nodeType === Node.ELEMENT_NODE) {
                    const tagName = child.tagName.toLowerCase();
                    const hasClassOrId = child.hasAttribute('class') || child.hasAttribute('id');

                    // List of always-allowed tags (no class/ID condition)
                    const alwaysAllowedTags = ['p', 'br', 'br /', 'mark', 'strong', 'a', 'em', 'u', 'sup', 'sub', 'section'];

                    if (alwaysAllowedTags.includes(tagName)) {
                        // If it's an always-allowed tag, clone it (without children initially)
                        const clonedChild = child.cloneNode(false);
                        // Recursively populate its content
                        clonedChild.innerHTML = filterAndPreserveContent(child, doc);
                        tempContainer.appendChild(clonedChild);
                    } else if ((tagName === 'span' || tagName === 'div') && hasClassOrId) {
                        // If it's a span or div with class/ID, clone it (without children initially)
                        const clonedChild = child.cloneNode(false);
                        // Recursively populate its content
                        clonedChild.innerHTML = filterAndPreserveContent(child, doc);
                        tempContainer.appendChild(clonedChild);
                    } else {
                        // If the element is not explicitly allowed (e.g., a span without class/ID, or any other disallowed tag),
                        // unwrap it by recursively processing its children and appending them directly to the current container.
                        const unwrappedContentHtml = filterAndPreserveContent(child, doc);
                        // Create a temporary div to parse the HTML string back into nodes
                        const tempUnwrapDiv = doc.createElement('div');
                        tempUnwrapDiv.innerHTML = unwrappedContentHtml;
                        // Append the children of the temporary div to the main tempContainer
                        while (tempUnwrapDiv.firstChild) {
                            tempContainer.appendChild(tempUnwrapDiv.firstChild);
                        }
                    }
                }
                // Other node types (comments, processing instructions) are implicitly ignored.
            });
            return tempContainer.innerHTML; // Return the HTML string of preserved content
        }

        /**
         * Cleans content within heading tags (h1-h6) based on specific rules.
         * Preserves text nodes, 'a' tags, 'em' tags.
         * Unwraps specific MSO-related spans, font-related spans, and divs without class/id.
         * Removes comments.
         * @param {HTMLElement} node - The DOM node whose children are to be filtered (e.g., an h1 tag).
         * @param {Document} doc - The document object to create new elements.
         * @returns {string} The HTML string containing only the preserved content for the heading.
         */
        function cleanHeadingContent(node, doc) {
            let tempContainer = doc.createElement('div');

            Array.from(node.childNodes).forEach(child => {
                if (child.nodeType === Node.TEXT_NODE) {
                    tempContainer.appendChild(child.cloneNode(true));
                } else if (child.nodeType === Node.COMMENT_NODE) {
                    // Explicitly remove comment nodes
                    // Do nothing, effectively removing the comment
                } else if (child.nodeType === Node.ELEMENT_NODE) {
                    const tagName = child.tagName.toLowerCase();
                    const styleAttr = child.getAttribute('style') || '';
                    const classAttr = child.getAttribute('class') || '';

                    // Always preserve <a> and <em> tags
                    if (tagName === 'a' || tagName === 'em') {
                        const clonedChild = child.cloneNode(false);
                        // Recursively clean content within the preserved tag
                        clonedChild.innerHTML = cleanHeadingContent(child, doc);
                        tempContainer.appendChild(clonedChild);
                    }
                    // Keep div with class or id (e.g., for structured content within headings)
                    else if (tagName === 'div' && (child.hasAttribute('class') || child.hasAttribute('id'))) {
                        const clonedChild = child.cloneNode(false);
                        // Recursively clean content within the preserved div
                        clonedChild.innerHTML = cleanHeadingContent(child, doc);
                        tempContainer.appendChild(clonedChild);
                    }
                    // Unwrap specific MSO-related spans and other unwanted elements
                    // This includes MsoListIgnore, Heading spans, font/font-family spans,
                    // general Mso spans, and div without class/id.
                    else if (
                        (tagName === 'span' && styleAttr.includes('mso-list: Ignore')) ||
                        (tagName === 'span' && classAttr.startsWith('Heading')) ||
                        (tagName === 'span' && styleAttr.includes('font:')) ||
                        (tagName === 'span' && styleAttr.includes('font-family:')) ||
                        (tagName === 'span' && classAttr.startsWith('Mso')) || // Catch-all for other Mso spans
                        (tagName === 'div' && !(child.hasAttribute('class') || child.hasAttribute('id'))) // Unwrap div without class/id
                    ) {
                        // Recursively clean content and then unwrap the current element
                        const unwrappedContentHtml = cleanHeadingContent(child, doc);
                        const tempUnwrapDiv = doc.createElement('div');
                        tempUnwrapDiv.innerHTML = unwrappedContentHtml;
                        while (tempUnwrapDiv.firstChild) {
                            tempContainer.appendChild(tempUnwrapDiv.firstChild);
                        }
                    }
                    // For any other element not explicitly handled above, unwrap its content.
                    // This acts as a fallback to ensure only allowed content remains.
                    else {
                        const unwrappedContentHtml = cleanHeadingContent(child, doc);
                        const tempUnwrapDiv = doc.createElement('div');
                        tempUnwrapDiv.innerHTML = unwrappedContentHtml;
                        while (tempUnwrapDiv.firstChild) {
                            tempContainer.appendChild(tempUnwrapDiv.firstChild);
                        }
                    }
                }
            });
            return tempContainer.innerHTML;
        }

        /**
         * Applies cleaning for Microsoft Office specific code.
         * @param {string} htmlString - The HTML content to clean.
         * @returns {string} The cleaned HTML content.
         */
        function applyCleanMsoCode(htmlString) {
            const parser = new DOMParser();
            const doc = parser.parseFromString(htmlString, 'text/html');
            const body = doc.body;

            // Helper to get the level from style attribute for lists
            function getLevel(styleAttr) {
                if (!styleAttr) return null;
                const match = styleAttr.match(/level(\d+)/);
                return match ? parseInt(match[1], 10) : null;
            }

            // Helper to extract allowed content for lists
            function extractAllowedContentForLists(sourceNode) {
                let contentHtml = '';
                const childrenToProcess = Array.from(sourceNode.childNodes);

                childrenToProcess.forEach(child => {
                    if (child.nodeType === Node.ELEMENT_NODE && child.tagName.toLowerCase() === 'span' && child.hasAttribute('style') && child.getAttribute('style').includes('mso-list: Ignore')) {
                        return;
                    }

                    if (child.nodeType === Node.TEXT_NODE) {
                        contentHtml += child.nodeValue;
                    } else if (child.nodeType === Node.ELEMENT_NODE) {
                        const tagName = child.tagName.toLowerCase();
                        const hasClassOrId = child.hasAttribute('class') || child.hasAttribute('id');

                        if (tagName === 'br' || tagName === 'strong' || tagName === 'a' || tagName === 'em' || tagName === 'u' || tagName === 'sup' || tagName === 'sub' || tagName === 'section') {
                            contentHtml += child.outerHTML;
                        } else if ((tagName === 'span' || tagName === 'div') && hasClassOrId) {
                            const clonedChild = child.cloneNode(false);
                            clonedChild.innerHTML = extractAllowedContentForLists(clonedChild);
                            contentHtml += clonedChild.outerHTML;
                        } else {
                            contentHtml += extractAllowedContentForLists(child);
                        }
                    }
                });
                return contentHtml;
            }

            // Helper to determine list type
            function detectListType(pElement) {
                const msoListIgnoreSpan = pElement.querySelector('span[style*="mso-list: Ignore"]');
                if (msoListIgnoreSpan) {
                    const bulletText = msoListIgnoreSpan.textContent.trim();
                    if (/^\d+(\.\d+)+[\.\)]*$/.test(bulletText)) {
                        return 'complex-bullet';
                    }
                    if (/^[A-Za-z](\.\d+)+[\.\)]*$/.test(bulletText)) {
                        return 'complex-bullet';
                    }
                    if (/^\d+[\.\)]$/.test(bulletText)) {
                        return 'ordered-numeric';
                    }
                    if (/^[a-z][\.\)]$/.test(bulletText)) {
                        return 'ordered-alpha';
                    }
                }
                return 'unordered';
            }

            // ORDER OF OPERATIONS within applyCleanMsoCode:
            // 1. COMPLETELY REMOVE <a> tags with "msocomanchor" class
            // 2. Transform <p> with HeadingX span to hX and unwrap span.
            // 3. Span lang's
            // 4. Headings (calls cleanHeadingContent)
            // 5. Lists
            // 6. Clean COMM/FN/EDN
            // 7. Table related
            // 8. The rest (other MSO cleaning, including new span unwrapping rules)

            // 1. COMPLETELY REMOVE <a> tags and the content within for <a> tags with "msocomanchor" in the class attribute.
            const msoAnchorLinks = body.querySelectorAll('a[class*="msocomanchor"]');
            msoAnchorLinks.forEach(link => {
                if (link.parentNode) {
                    link.parentNode.removeChild(link);
                }
            });

            // 2. For spans that start with "Heading" in the class, check for a number from 1-6 beside it (Heading2),
            // make the <p> that its a child of into the corresponding h tag (h1-h6) and UNWRAP (ONLY remove tag) the span preserving its content.
            const headingSpans = body.querySelectorAll('span[class^="Heading"]');
            headingSpans.forEach(span => {
                const classList = Array.from(span.classList);
                let headingLevel = null;

                for (const cls of classList) {
                    const match = cls.match(/^Heading(\d)$/);
                    if (match && parseInt(match[1], 10) >= 1 && parseInt(match[1], 10) <= 6) {
                        headingLevel = parseInt(match[1], 10);
                        break;
                    }
                }

                if (headingLevel !== null) {
                    const parentP = span.closest('p');
                    if (parentP) {
                        const newHeadingTag = doc.createElement(`h${headingLevel}`);
                        
                        // Move all children of the span into the new heading tag
                        while (span.firstChild) {
                            newHeadingTag.appendChild(span.firstChild);
                        }
                        
                        // Move all other children of the parentP (that are not the span) into the new heading tag
                        // This ensures any text or other elements directly within the <p> but outside the <span>
                        // are also moved to the new heading.
                        // Iterate in reverse to avoid issues with childNodes changing during removal
                        const pChildren = Array.from(parentP.childNodes);
                        for (let i = pChildren.length - 1; i >= 0; i--) {
                            const node = pChildren[i];
                            if (node !== span) { // Only move nodes that are not the target span
                                newHeadingTag.prepend(node); // Prepend to maintain order
                            }
                        }

                        if (parentP.parentNode) {
                            parentP.parentNode.replaceChild(newHeadingTag, parentP);
                        }
                    }
                }
            });

            // 3. Unwraps <span> tags with a 'lang' attribute OR 'mso-ansi-language' in style,
            //    ONLY if they're within an element that has "Mso" in its class or "mso-" in its style. Preserve content.
            const spanLangOrAnsiElements = doc.querySelectorAll('span[lang], span[style*="mso-ansi-language"]');
            for (let i = spanLangOrAnsiElements.length - 1; i >= 0; i--) {
                const span = spanLangOrAnsiElements[i];
                let parent = span.parentElement;
                let shouldUnwrap = false;
                while (parent && parent !== doc.body) {
                    const classAttr = parent.getAttribute('class');
                    const styleAttr = parent.getAttribute('style');

                    if ((classAttr && classAttr.includes('Mso')) || (styleAttr && styleAttr.includes('mso-'))) {
                        shouldUnwrap = true;
                        break;
                    }
                    parent = parent.parentElement;
                }

                if (shouldUnwrap && span.parentNode) {
                    while (span.firstChild) {
                        span.parentNode.insertBefore(span.firstChild, span);
                    }
                    span.parentNode.removeChild(span);
                }
            }

            // 4. Clean content within headings (h1-h6)
            const headingTags = doc.querySelectorAll('h1, h2, h3, h4, h5, h6');
            headingTags.forEach(heading => {
                heading.innerHTML = cleanHeadingContent(heading, doc);
                Array.from(heading.attributes).forEach(attr => heading.removeAttribute(attr.name));
            });

            // 5. Process <p> tags with "MsoListParagraph" class, converting them to <ul><li> structures
            const paragraphs = Array.from(body.querySelectorAll('p'));
            const paragraphsToReplace = new Map();
            const paragraphsToRemove = new Set();

            for (let i = 0; i < paragraphs.length; i++) {
                const p = paragraphs[i];
                const classList = Array.from(p.classList);
                const isMsoListParagraph = classList.some(cls =>
                    cls === 'MsoListParagraphCxSpFirst' ||
                    cls === 'MsoListParagraphCxSpMiddle' ||
                    cls === 'MsoListParagraphCxSpLast' ||
                    cls === 'MsoListParagraph'
                );

                if (paragraphsToRemove.has(p)) {
                    continue;
                }

                if (isMsoListParagraph) {
                    const pStyle = p.getAttribute('style') || '';
                    const level = getLevel(pStyle);

                    if (isMsoListParagraph && level === null) {
                        p.removeAttribute('class');
                        p.classList.add('MsoNormal');
                        continue;
                    }

                    const msoListIgnoreSpan = p.querySelector('span[style*="mso-list: Ignore"]');
                    let bulletTextToPrepend = '';
                    let listType = 'unordered';

                    if (msoListIgnoreSpan) {
                        bulletTextToPrepend = msoListIgnoreSpan.textContent.trim();
                        listType = detectListType(p);
                        msoListIgnoreSpan.parentNode.removeChild(msoListIgnoreSpan);
                    }

                    let newRootListElement;

                    if (listType === 'ordered-numeric') {
                        newRootListElement = doc.createElement('ol');
                    } else if (listType === 'ordered-alpha') {
                        newRootListElement = doc.createElement('ol');
                        newRootListElement.classList.add('lst-lwr-alph');
                    } else {
                        newRootListElement = doc.createElement('ul');
                    }

                    let currentListStack = [newRootListElement];
                    let currentParentList = newRootListElement;

                    const li = doc.createElement('li');
                    let listItemContent = extractAllowedContentForLists(p);

                    if (listType === 'complex-bullet') {
                        li.innerHTML = bulletTextToPrepend + ' ' + listItemContent;
                    } else {
                        li.innerHTML = listItemContent;
                    }
                    currentParentList.appendChild(li);
                    paragraphsToReplace.set(p, newRootListElement);

                    let nextSibling = p.nextElementSibling;
                    let currentSequenceIndex = i + 1;

                    while (nextSibling && nextSibling.nodeType === Node.ELEMENT_NODE && nextSibling.tagName.toLowerCase() === 'p') {
                        const nextP = nextSibling;
                        const nextPClassList = Array.from(nextP.classList);
                        const isNextPListParagraph = nextPClassList.some(cls =>
                            cls === 'MsoListParagraphCxSpFirst' ||
                            cls === 'MsoListParagraphCxSpMiddle' ||
                            cls === 'MsoListParagraphCxSpLast' ||
                            cls === 'MsoListParagraph'
                        );

                        const nextPStyle = nextP.getAttribute('style') || '';
                        const nextLevelCheck = getLevel(nextPStyle);
                        if (isNextPListParagraph && nextLevelCheck === null) {
                            nextP.removeAttribute('class');
                            nextP.classList.add('MsoNormal');
                            break;
                        }

                        if (isNextPListParagraph) {
                            const nextLevel = getLevel(nextP.getAttribute('style') || '');
                            let currentDepth = currentListStack.length;

                            const nextMsoListIgnoreSpan = nextP.querySelector('span[style*="mso-list: Ignore"]');
                            let nextBulletTextToPrepend = '';
                            let nextListType = 'unordered';

                            if (nextMsoListIgnoreSpan) {
                                nextBulletTextToPrepend = nextMsoListIgnoreSpan.textContent.trim();
                                nextListType = detectListType(nextP);
                                nextMsoListIgnoreSpan.parentNode.removeChild(nextMsoListIgnoreSpan);
                            }

                            if (nextLevel > currentDepth) {
                                let nestedListElement;
                                
                                if (nextListType === 'ordered-numeric') {
                                    nestedListElement = doc.createElement('ol');
                                } else if (nextListType === 'ordered-alpha') {
                                    nestedListElement = doc.createElement('ol');
                                    nestedListElement.classList.add('lst-lwr-alph');
                                } else {
                                    nestedListElement = doc.createElement('ul');
                                }

                                for (let k = currentDepth; k > nextLevel; k--) {
                                    currentListStack.pop();
                                    currentParentList = currentListStack[currentListStack.length - 1];
                                }
                                while (currentListStack.length < nextLevel) {
                                     let targetLi = currentParentList.lastElementChild;
                                     if (!targetLi || targetLi.tagName.toLowerCase() !== 'li') {
                                         targetLi = doc.createElement('li');
                                         currentParentList.appendChild(targetLi);
                                     }
                                     let newNestedList;
                                     if (currentListStack.length + 1 === nextLevel) {
                                         if (nextListType === 'ordered-numeric') {
                                             newNestedList = doc.createElement('ol');
                                         } else if (nextListType === 'ordered-alpha') {
                                             newNestedList = doc.createElement('ol');
                                             newNestedList.classList.add('lst-lwr-alph');
                                         } else {
                                             newNestedList = doc.createElement('ul');
                                         }
                                     } else {
                                         newNestedList = doc.createElement('ul');
                                     }
                                     targetLi.appendChild(newNestedList);
                                     currentListStack.push(newNestedList);
                                     currentParentList = newNestedList;
                                 }

                            } else if (nextLevel < currentDepth) {
                                for (let k = currentDepth; k > nextLevel; k--) {
                                    currentListStack.pop();
                                    currentParentList = currentListStack[currentListStack.length - 1];
                                }
                            }

                            const nextLi = doc.createElement('li');
                            let nextListItemContent = extractAllowedContentForLists(nextP);
                            if (nextListType === 'complex-bullet') {
                                nextLi.innerHTML = nextBulletTextToPrepend + ' ' + nextListItemContent;
                            } else {
                                nextLi.innerHTML = nextListItemContent;
                            }
                            currentParentList.appendChild(nextLi);
                            paragraphsToRemove.add(nextP);

                            nextSibling = nextP.nextElementSibling;
                            currentSequenceIndex++;
                        } else {
                            break;
                        }
                    }
                    i = currentSequenceIndex - 1;
                }
            }

            paragraphs.forEach(p => {
                if (paragraphsToReplace.has(p)) {
                    if (p.parentNode) {
                        p.parentNode.replaceChild(paragraphsToReplace.get(p), p);
                    }
                } else if (paragraphsToRemove.has(p)) {
                    if (p.parentNode) {
                        p.parentNode.removeChild(p);
                    }
                }
            });

            // 6. Apply cleaning for comments, footnotes, and endnotes
            const spanCommentElements = doc.querySelectorAll('span[class*="MsoComment"]');
            for (let i = spanCommentElements.length - 1; i >= 0; i--) {
                const span = spanCommentElements[i];
                if (!span.classList.contains('MsoCommentReference') && span.parentNode) {
                    while (span.firstChild) {
                        span.parentNode.insertBefore(span.firstChild, span);
                    }
                    span.parentNode.removeChild(span);
                }
            }

            const aElements = doc.querySelectorAll('a');
            aElements.forEach(a => {
                const href = a.getAttribute('href');
                const name = a.getAttribute('name');
                if (href && href.includes('#_edn') && name && name.includes('_edn')) {
                    if (a.parentNode) {
                        a.parentNode.removeChild(a);
                    }
                }
            });

            const divMsoElementsForRemoval = doc.querySelectorAll('div[style*="mso-element: comment"], div[style*="mso-element: endnote-list"]');
            for (let i = divMsoElementsForRemoval.length - 1; i >= 0; i--) {
                const div = divMsoElementsForRemoval[i];
                if (div.parentNode) {
                    div.parentNode.removeChild(div);
                }
            }

            const divCommentListElements = doc.querySelectorAll('div[style*="mso-element: comment-list"]');
            for (let i = divCommentListElements.length - 1; i >= 0; i--) {
                const div = divCommentListElements[i];
                if (div.parentNode) {
                    div.parentNode.removeChild(div);
                }
            }

            const spanCommentReferenceElements = doc.querySelectorAll('span.MsoCommentReference');
            for (let i = spanCommentReferenceElements.length - 1; i >= 0; i--) {
                const span = spanCommentReferenceElements[i];
                if (span.parentNode) {
                    span.parentNode.removeChild(span);
                }
            }

            const msoCommentStyleElements = doc.querySelectorAll('[style*="mso-comment"]');
            Array.from(msoCommentStyleElements).forEach(element => {
                if (element.parentNode && !element.hasAttribute('data-removed')) {
                    const style = element.getAttribute('style') || '';
                    if (element.tagName.toLowerCase() === 'div' && (style.includes('mso-element: comment') || style.includes('mso-element: endnote-list') || style.includes('mso-element: comment-list'))) {
                        element.parentNode.removeChild(element);
                        element.setAttribute('data-removed', 'true');
                    } else if (element.tagName.toLowerCase() === 'span' && element.classList.contains('MsoCommentReference')) {
                        element.parentNode.removeChild(element);
                        element.setAttribute('data-removed', 'true');
                    } else {
                        while (element.firstChild) {
                            element.parentNode.insertBefore(element.firstChild, element);
                        }
                        element.parentNode.removeChild(element);
                    }
                }
            });

            const ftnLinks = doc.querySelectorAll('a[href^="#_ftn"]');
            ftnLinks.forEach(a => {
                // Remove title and name attributes regardless
                if (a.hasAttribute('title')) {
                    a.removeAttribute('title');
                }
                if (a.hasAttribute('name')) {
                    a.removeAttribute('name');
                }

                // Only wrap if it's not already inside a <sup> tag
                if (a.parentNode && a.parentNode.tagName.toLowerCase() !== 'sup') {
                    const supElement = doc.createElement('sup');
                    // Insert the sup element before the a tag
                    a.parentNode.insertBefore(supElement, a);
                    // Then append the a tag into the sup element
                    supElement.appendChild(a);
                }
            });

            const footnoteListDivs = doc.querySelectorAll('div[style*="mso-element: footnote-list"]');
            for (let i = footnoteListDivs.length - 1; i >= 0; i--) {
                const div = footnoteListDivs[i];
                if (div.parentNode) {
                    const asideElement = doc.createElement('aside');
                    const preservedContentHtml = filterAndPreserveContent(div, doc);
                    asideElement.innerHTML = preservedContentHtml;
                    div.parentNode.replaceChild(asideElement, div);
                }
            }

            // 7. Table related cleaning
            const colgroupElements = doc.querySelectorAll('colgroup');
            for (let i = colgroupElements.length - 1; i >= 0; i--) {
                if (colgroupElements[i].parentNode) {
                    colgroupElements[i].parentNode.removeChild(colgroupElements[i]);
                }
            }

            const colElements = doc.querySelectorAll('col');
            for (let i = colElements.length - 1; i >= 0; i--) {
                if (colElements[i].parentNode) {
                    colElements[i].parentNode.removeChild(colElements[i]);
                }
            }

            const tableRelatedTags = doc.querySelectorAll('table, thead, tbody, tfoot, tr, th, td');
            tableRelatedTags.forEach(element => {
                const attributesToKeep = ['rowspan', 'colspan', 'class', 'id', 'headers', 'scope'];
                const attributesToRemove = [];
                for (let j = 0; j < element.attributes.length; j++) {
                    const attr = element.attributes[j];
                    if (!attributesToKeep.includes(attr.name.toLowerCase())) {
                        attributesToRemove.push(attr.name);
                    }
                }
                attributesToRemove.forEach(attrName => {
                    element.removeAttribute(attrName);
                });
            });

            doc.querySelectorAll('table').forEach(table => {
                const classAttr = table.getAttribute('class');
                if (classAttr && classAttr.includes('MsoTable')) {
                    table.removeAttribute('class');
                }
            });

            doc.querySelectorAll('table td[class^="xl"] span').forEach(span => {
                if (span.parentNode) {
                    while (span.firstChild) {
                        span.parentNode.insertBefore(span.firstChild, span);
                    }
                    span.parentNode.removeChild(span);
                }
            });

            doc.querySelectorAll('td').forEach(td => {
                const classAttr = td.getAttribute('class');
                if (classAttr && classAttr.startsWith('xl')) {
                    td.removeAttribute('class');
                }
            });

            doc.querySelectorAll('table p').forEach(p => {
                const parentCell = p.closest('td, th');

                if (parentCell) {
                    const classAttr = p.getAttribute('class');
                    if (classAttr && (classAttr.includes('Mso') || classAttr.includes('Aligned'))) {
                        p.removeAttribute('class');
                    }

                    if (p.hasAttribute('style')) {
                        p.removeAttribute('style');
                    }

                    const alignAttr = p.getAttribute('align');
                    if (alignAttr) {
                        p.removeAttribute('align');
                        let tailwindAlignClass = '';
                        switch (alignAttr.toLowerCase()) {
                            case 'left':
                                tailwindAlignClass = 'text-left';
                                break;
                            case 'center':
                                tailwindAlignClass = 'text-center';
                                break;
                            case 'right':
                                tailwindAlignClass = 'text-right';
                                break;
                        }
                        if (tailwindAlignClass) {
                            parentCell.classList.add(tailwindAlignClass);
                        }
                    }
                }
            });

            // 8. The rest of the cleaning operations
            const msoBookmarkSpans = doc.querySelectorAll('span[style*="mso-bookmark"]');
            for (let i = msoBookmarkSpans.length - 1; i >= 0; i--) {
                const span = msoBookmarkSpans[i];
                if (span.parentNode) {
                    while (span.firstChild) {
                        span.parentNode.insertBefore(span.firstChild, span);
                    }
                    span.parentNode.removeChild(span);
                }
            }

            const classUnwrapSpans = body.querySelectorAll('span.normaltextrun, span.eop, span.eoc, span.eocx');
            for (let i = classUnwrapSpans.length - 1; i >= 0; i--) {
                const span = classUnwrapSpans[i];
                if (span.parentNode) {
                    while (span.firstChild) {
                        span.parentNode.insertBefore(span.firstChild, span);
                    }
                    span.parentNode.removeChild(span);
                }
            }

            const styleUnwrapSpans = body.querySelectorAll('span[style*="font:"], span[style*="font-family:"]');
            for (let i = styleUnwrapSpans.length - 1; i >= 0; i--) {
                const span = styleUnwrapSpans[i];
                if (span.parentNode) {
                    while (span.firstChild) {
                        span.parentNode.insertBefore(span.firstChild, span);
                    }
                    span.parentNode.removeChild(span);
                }
            }

            const msoClassSpans = doc.querySelectorAll('span[class^="Mso"]');
            for (let i = msoClassSpans.length - 1; i >= 0; i--) {
                const span = msoClassSpans[i];
                if (span.parentNode) {
                    while (span.firstChild) {
                        span.parentNode.insertBefore(span.firstChild, span);
                    }
                    span.parentNode.removeChild(span);
                }
            }

            const tagsToRemoveStyleFrom = doc.querySelectorAll('strong, a, em, u, sup, sub');
            tagsToRemoveStyleFrom.forEach(element => {
                if (element.hasAttribute('style')) {
                    element.removeAttribute('style');
                }
            });

            const divAlignElements = doc.querySelectorAll('div[align]');
            for (let i = divAlignElements.length - 1; i >= 0; i--) {
                const div = divAlignElements[i];
                if (div.parentNode) {
                    while (div.firstChild) {
                        div.parentNode.insertBefore(div.firstChild, div);
                    }
                    div.parentNode.removeChild(div);
                }
            }

            const msoTocParagraphs = doc.querySelectorAll('p[class*="MsoToc"]');
            msoTocParagraphs.forEach(p => {
                Array.from(p.attributes).forEach(attr => p.removeAttribute(attr.name));
                const tempDiv = doc.createElement('div');
                Array.from(p.childNodes).forEach(node => {
                    if (node.nodeType === Node.ELEMENT_NODE && node.tagName.toLowerCase() === 'a' && node.hasAttribute('href')) {
                        const clonedA = node.cloneNode(true);
                        const linkText = clonedA.textContent;
                        while (clonedA.firstChild) {
                            clonedA.removeChild(clonedA.firstChild);
                        }
                        clonedA.appendChild(doc.createTextNode(linkText));
                        tempDiv.appendChild(clonedA);
                    } else if (node.nodeType === Node.TEXT_NODE) {
                        tempDiv.appendChild(node.cloneNode(true));
                    }
                });
                while (p.firstChild) {
                    p.removeChild(p.firstChild);
                }
                while (tempDiv.firstChild) {
                    p.appendChild(tempDiv.firstChild);
                }
            });

            doc.querySelectorAll('img').forEach(img => {
                const src = img.getAttribute('src');
                if (src && (src.startsWith('file://') || src.startsWith('data:'))) {
                    const replacementDiv = doc.createElement('div');
                    replacementDiv.classList.add('clearfix');
                    const replacementMark = doc.createElement('mark');
                    replacementMark.textContent = 'IMAGE NOT IMPORTED';
                    replacementDiv.appendChild(replacementMark);
                    if (img.parentNode) {
                        img.parentNode.replaceChild(replacementDiv, img);
                    }
                }
            });

            const allParagraphs = doc.querySelectorAll('p');
            Array.from(allParagraphs).forEach(p => {
                const classAttr = p.getAttribute('class') || '';
                const isMsoParagraph = classAttr.startsWith('Mso');
                const isInsideTable = p.closest('table');
                const isMsoListParagraph = classAttr.startsWith('MsoList');

                if (isMsoParagraph && !isInsideTable && !isMsoListParagraph) {
                    Array.from(p.attributes).forEach(attr => p.removeAttribute(attr.name));
                    const preservedContentHtml = filterAndPreserveContent(p, doc);
                    p.innerHTML = preservedContentHtml;
                }
            });

            const msoElementDivs = doc.querySelectorAll('div[style*="mso-element"]');
            for (let i = msoElementDivs.length - 1; i >= 0; i--) {
                const div = msoElementDivs[i];
                const style = div.getAttribute('style') || '';

                if (style.includes('mso-element: footnote-list')) {
                    continue;
                }

                if (div.parentNode) {
                    while (div.firstChild) {
                        div.parentNode.insertBefore(div.firstChild, div);
                    }
                    div.parentNode.removeChild(div);
                }
            }

            doc.querySelectorAll('strong span[style*="font-weight: bold"]').forEach(span => {
                if (span.parentNode) {
                    while (span.firstChild) {
                        span.parentNode.insertBefore(span.firstChild, span);
                    }
                    span.parentNode.removeChild(span);
                }
            });

            let currentHtml = doc.body.innerHTML;
            currentHtml = removeEmptyParagraphs(currentHtml);
            doc.body.innerHTML = currentHtml;

            return doc.body.innerHTML;
        }

        /**
         * Cleans common formatting tags: removes <u>, converts <b> to <strong>, and <i> to <em>.
         * @param {string} htmlString - The HTML content to clean.
         * @returns {string} The cleaned HTML content.
         */
        function applyCleanFormattingTags(htmlString) {
            const parser = new DOMParser();
            const doc = parser.parseFromString(htmlString, 'text/html');

            // 1. Remove <u> tags (unwrap them)
            const uElements = Array.from(doc.querySelectorAll('u'));
            for (let i = uElements.length - 1; i >= 0; i--) {
                const u = uElements[i];
                if (u.parentNode) {
                    while (u.firstChild) {
                        u.parentNode.insertBefore(u.firstChild, u);
                    }
                    u.parentNode.removeChild(u);
                }
            }

            // 2. Convert <b> to <strong>
            const bElements = Array.from(doc.querySelectorAll('b'));
            for (let i = bElements.length - 1; i >= 0; i--) {
                const b = bElements[i];
                if (b.parentNode) {
                    const strong = doc.createElement('strong');
                    while (b.firstChild) {
                        strong.appendChild(b.firstChild);
                    }
                    b.parentNode.replaceChild(strong, b);
                }
            }

            // 3. Convert <i> to <em>
            const iElements = Array.from(doc.querySelectorAll('i'));
            for (let i = iElements.length - 1; i >= 0; i--) {
                const i_tag = iElements[i]; // Renamed to avoid conflict with loop variable
                if (i_tag.parentNode) {
                    const em = doc.createElement('em');
                    while (i_tag.firstChild) {
                        em.appendChild(i_tag.firstChild);
                    }
                    i_tag.parentNode.replaceChild(em, i_tag);
                }
            }

            return doc.body.innerHTML;
        }


        /**
         * Function to set the content of the HugeRTE editor.
         * This is called from the parent window.
         */
        window.setRichEditorContent = function(content) {
            // console.log("Parent: Attempting to set HugeRTE content.");
            if (richTextEditorInstance) {
                richTextEditorInstance.setContent(cleanHtmlForRichTextDisplay(content));
                richTextEditorInstance.focus(); // Re-focus the rich editor after content update
                // console.log('Parent: HugeRTE updated from HTML editor.');
            } else {
                console.warn('Parent: HugeRTE editor not yet initialized. Content will be set once ready.');
            }
        };

        /**
         * Function to get the content from the HugeRTE editor.
         * This is called from the parent window.
         */
        window.getRichEditorContent = function() {
            // console.log("Parent: Attempting to get HugeRTE content.");
            if (richTextEditorInstance) {
                const content = richTextEditorInstance.getContent();
                // console.log("Parent: HugeRTE content requested by parent.");
                return content;
            } else {
                console.warn('Iframe: HugeRTE editor not yet initialized. Cannot get content.');
                return '';
            }
        };

        /**
         * Updates the disabled state of the "Go to Rich-Text" button.
         * It is disabled if any other button that displays a temporary message is active.
         */
        function updateToggleEditorViewBtnCodeState() {
            const anyTempMessageActive = tempMessageButtons.some(btn => btn.getAttribute('data-temp-active') === 'true');
            toggleEditorViewBtnCode.disabled = anyTempMessageActive;
        }

        /**
         * Toggles the active editor view between 'richtext' and 'code'.
         * Includes automatic content synchronization.
         */
        function toggleEditorView() {
            // Prevent toggling if the button is disabled
            if (toggleEditorViewBtnCode.disabled && currentView === 'code') {
                return;
            }
            if (toggleEditorViewBtnRichText.disabled && currentView === 'richtext') {
                return;
            }

            console.log("Toggle Editor View triggered. Current view:", currentView);
            if (currentView === 'richtext') {
                // --- Logic when switching FROM Rich-Text TO Code ---
                // 1. Get content from Rich-Text editor.
                if (default_ifr.contentWindow && default_ifr.contentWindow.getRichEditorContent) {
                    richTextContent = default_ifr.contentWindow.getRichEditorContent();
                    // console.log("Syncing from Rich Text to HTML. Rich Text Content length:", richTextContent.length); // Line 1823
                } else {
                    console.warn("Rich Text Editor not ready for content retrieval on toggle. Using empty string.");
                    richTextContent = '';
                }

                // Apply Clean MSO Code if the toggle is ON
                let processedContent = richTextContent;
                if (toggleAutoCleanMsoOnSwitchRichText.checked) {
                    processedContent = applyCleanMsoCode(processedContent);
                    console.log("Auto-Clean MSO applied when switching to HTML editor.");
                }

                // Apply URL cleaning when switching TO the HTML editor
                processedContent = applyUrlCleaning(processedContent);
                console.log("URL cleaning applied when switching to HTML editor.");
                
                // 2. Update HTML output content and Monaco editor.
                htmlOutputContent = processedContent;
                if (monacoEditorInstance) {
                    monacoEditorInstance.setValue(htmlOutputContent);
                    monacoEditorInstance.focus();
                    applyEntityHighlighting();
                    console.log("Monaco editor updated with Rich Text content.");
                } else {
                    console.warn('Monaco editor not yet initialized. Content will be set once ready.');
                }

                // Run Auto-Encode and Auto-Indent when switching to HTML editor
                autoEncodeBtn.click();
                autoFormatBtn.click();
                // console.log("Auto-Encode and Auto-Indent applied on switch to HTML editor."); // Line 1837

                // 3. Switch panel visibility.
                richtextOutputPanel.classList.remove('panel-visible');
                richtextOutputPanel.classList.add('panel-hidden');
                codePanel.classList.remove('panel-hidden');
                codePanel.classList.add('panel-visible');
                
                // 4. Update button styles.
                // "Go to HTML" button (toggleEditorViewBtnRichText) is now inactive/hidden.
                // Remove all color classes and set to default zinc.
                toggleEditorViewBtnRichText.classList.remove('bg-green-600', 'hover:bg-green-700', 'bg-sky-700', 'hover:bg-sky-800');
                toggleEditorViewBtnRichText.classList.add('bg-zinc-700', 'hover:bg-zinc-600');
                
                // "Go to Rich-Text" button (toggleEditorViewBtnCode) is now active/visible.
                // It should be blue.
                toggleEditorViewBtnCode.classList.remove('bg-green-600', 'hover:bg-green-700', 'bg-zinc-700', 'hover:bg-zinc-600');
                toggleEditorViewBtnCode.classList.add('bg-sky-700', 'hover:bg-sky-800');
                
                currentView = 'code';
                console.log("Switched to Code View.");
            } else { // currentView === 'code'
                // --- Logic when switching FROM Code TO Rich-Text ---
                // 1. Get content from Monaco editor.
                if (monacoEditorInstance) {
                    htmlOutputContent = monacoEditorInstance.getValue();
                    console.log("Syncing from HTML to Rich Text. HTML Output Content length:", htmlOutputContent.length);
                } else {
                    console.warn("Monaco editor not ready for content retrieval on toggle. Using empty string.");
                    htmlOutputContent = '';
                }

                // Apply Clean MSO Code if the toggle is ON
                let processedContent = htmlOutputContent;
                if (toggleAutoCleanMsoOnSwitchCode.checked) {
                    processedContent = applyCleanMsoCode(processedContent);
                    // console.log("Auto-Clean MSO applied when switching to Rich-Text editor."); // Line 1859
                }

                // 2. Update Rich Text content and editor.
                richTextContent = processedContent;
                if (default_ifr.contentWindow && default_ifr.contentWindow.setRichEditorContent) {
                    default_ifr.contentWindow.setRichEditorContent(cleanHtmlForRichTextDisplay(richTextContent));
                    console.log("HugeRTE editor updated with HTML content.");
                } else {
                    console.warn("Rich Text Editor not ready for content setting on toggle.");
                }
                
                // 3. Switch panel visibility.
                codePanel.classList.remove('panel-visible');
                codePanel.classList.add('panel-hidden');
                richtextOutputPanel.classList.remove('panel-hidden');
                richtextOutputPanel.classList.add('panel-visible');

                // 4. Update button styles.
                // "Go to Rich-Text" button (toggleEditorViewBtnCode) is now inactive/hidden.
                // It should be blue.
                toggleEditorViewBtnCode.classList.remove('bg-green-600', 'hover:bg-green-700', 'bg-zinc-700', 'hover:bg-zinc-600');
                toggleEditorViewBtnCode.classList.add('bg-sky-700', 'hover:bg-sky-800');
                
                // "Go to HTML" button (toggleEditorViewBtnRichText) is now active/visible.
                // Its color depends on the MSO toggle.
                updateGoToHtmlButtonColor(); // This function handles its specific coloring.
                
                currentView = 'richtext';
                console.log("Switched to Rich Text View.");
                if (richTextEditorInstance) {
                    richTextEditorInstance.focus();
                }
            }
        }

        // Variable to store Monaco decorations for entities
        let entityDecorations = [];

        /**
         * Applies highlighting to HTML character entities in the Monaco editor.
         */
        function applyEntityHighlighting() {
            if (!monacoEditorInstance) return;

            const model = monacoEditorInstance.getModel();
            if (!model) return;

            const newDecorations = [];
            const text = model.getValue();
            // Regex to find HTML entities like &nbsp; &#160; &amp;
            const regex = /&[a-zA-Z0-9#]+;/g; 

            let match;
            while ((match = regex.exec(text)) !== null) {
                const startPos = model.getPositionAt(match.index);
                const endPos = model.getPositionAt(match.index + match[0].length);

                newDecorations.push({
                    range: new monaco.Range(startPos.lineNumber, startPos.column, endPos.lineNumber, endPos.column),
                    options: {
                        inlineClassName: 'entity-highlight',
                        hoverMessage: { value: 'HTML Character Entity' } // Optional: show tooltip on hover
                    }
                });
            }

            // Apply the new decorations and clear old ones
            entityDecorations = monacoEditorInstance.deltaDecorations(entityDecorations, newDecorations);
        }

        // Function to update the state of the "Run Selected" button
        function updateRunButtonState() {
            const anyToggleChecked = generalCleaningToggles.some(toggle => toggle.checked);
            runSelectedBtn.disabled = !anyToggleChecked;
            if (anyToggleChecked) {
                runSelectedBtn.classList.remove('bg-gray-600', 'cursor-not-allowed', 'opacity-60');
                runSelectedBtn.classList.add('bg-green-600', 'hover:bg-green-700');
            } else {
                runSelectedBtn.classList.add('bg-gray-600', 'cursor-not-allowed', 'opacity-60');
                runSelectedBtn.classList.remove('bg-green-600', 'hover:bg-green-700');
            }
        }

        // Function to update the state of the "Run Selected Table" button
        function updateRunTableButtonState() {
            const anyTableToggleChecked = tableCleaningToggles.some(toggle => toggle.checked);
            runSelectedTableBtn.disabled = !anyTableToggleChecked;
            if (anyTableToggleChecked) {
                runSelectedTableBtn.classList.remove('bg-gray-600', 'cursor-not-allowed', 'opacity-60');
                runSelectedTableBtn.classList.add('bg-green-600', 'hover:bg-green-700');
            } else {
                runSelectedTableBtn.classList.add('bg-gray-600', 'cursor-not-allowed', 'opacity-60');
                runSelectedTableBtn.classList.remove('bg-green-600', 'hover:bg-green-700');
            }
        }

        /**
         * Updates the color of the "Go to HTML" button based on the "Auto-Clean MSO when switching" toggle state.
         * This function is now responsible for setting the correct color for the "Go to HTML" button
         * when the `currentView` is 'richtext' (meaning the "Go to HTML" button is visible and active).
         */
        function updateGoToHtmlButtonColor() {
            // This function is called when the rich text panel is visible and the "Go to HTML" button is active.
            // Its color should reflect the state of toggleAutoCleanMsoOnSwitchRichText.
            if (toggleAutoCleanMsoOnSwitchRichText.checked) {
                toggleEditorViewBtnRichText.classList.remove('bg-sky-700', 'hover:bg-sky-800', 'bg-zinc-700', 'hover:bg-zinc-600');
                toggleEditorViewBtnRichText.classList.add('bg-green-600', 'hover:bg-green-700');
            } else {
                toggleEditorViewBtnRichText.classList.remove('bg-green-600', 'hover:bg-green-700', 'bg-zinc-700', 'hover:bg-zinc-600');
                toggleEditorViewBtnRichText.classList.add('bg-sky-700', 'hover:bg-sky-800');
            }
        }


        // Initialize and set up event listeners on window load
        window.onload = function() {
            console.log("Parent window.onload triggered.");
            // Initial setup: Ensure rich text panel is visible and code panel is hidden
            richtextOutputPanel.classList.add('panel-visible');
            codePanel.classList.add('panel-hidden');
            
            // Set initial button styles based on default view (richtext)
            // The "Go to HTML" button is visible initially, so its color depends on the MSO toggle.
            // The "Go to Rich-Text" button is hidden initially, so it should have its default blue color.
            toggleEditorViewBtnCode.classList.add('bg-sky-700', 'hover:bg-sky-800');
            toggleEditorViewBtnCode.classList.remove('bg-sky-700', 'hover:bg-sky-800', 'bg-zinc-700', 'hover:bg-zinc-600');
            updateGoToHtmlButtonColor(); // Call to set initial color for "Go to HTML" button


            // Initialize Monaco Editor
            require.config({ paths: { 'vs': 'https://cdn.jsdelivr.net/npm/monaco-editor@0.49.0/min/vs' } });
            require(['vs/editor/editor.main'], function () {
                monacoEditorInstance = monaco.editor.create(document.getElementById('monacoEditorContainer'), {
                    value: htmlOutputContent, // Set initial content
                    language: 'html',
                    theme: 'vs-dark', // Or 'hc-black'
                    automaticLayout: true, // Important for responsiveness
                    minimap: { enabled: false },
                    fontSize: 14,
                    tabSize: 4,
                    insertSpaces: true,
                    // Additional options for better UX
                    scrollBeyondLastLine: false,
                    wordWrap: 'on',
                    wrappingIndent: 'same',
                });
                console.log("Monaco editor initialized.");

                // Update htmlOutputContent on Monaco content change
                monacoEditorInstance.onDidChangeModelContent(() => {
                    htmlOutputContent = monacoEditorInstance.getValue();
                    applyEntityHighlighting(); // Re-apply highlighting on content change
                });

                // Apply initial highlighting after Monaco is created
                applyEntityHighlighting();

                // Ensure Monaco refreshes layout on window resize
                window.addEventListener('resize', () => {
                    if (monacoEditorInstance) {
                        monacoEditorInstance.layout();
                    }
                });
            });

            copyCodeBtn.addEventListener('click', async () => {
                const codeContent = monacoEditorInstance ? monacoEditorInstance.getValue() : '';
                try {
                    const tempTextArea = document.createElement('textarea');
                    tempTextArea.value = codeContent;
                    document.body.appendChild(tempTextArea);
                    tempTextArea.select();
                    document.execCommand('copy');
                    document.body.removeChild(tempTextArea);
                    const originalText = copyCodeBtn.textContent;
                    copyCodeBtn.textContent = 'Copied!';
                    copyCodeBtn.classList.add('bg-green-500', 'hover:bg-green-600');
                    copyCodeBtn.classList.remove('bg-zinc-700', 'hover:bg-zinc-600');
                    copyCodeBtn.disabled = true; // Disable the button
                    copyCodeBtn.setAttribute('data-temp-active', 'true'); // Mark as active
                    updateToggleEditorViewBtnCodeState(); // Update Go to Rich-Text button state
                    setTimeout(() => {
                        copyCodeBtn.textContent = originalText;
                        copyCodeBtn.classList.remove('bg-green-500', 'hover:bg-green-600');
                        copyCodeBtn.classList.add('bg-zinc-700', 'hover:bg-zinc-600');
                        copyCodeBtn.disabled = false; // Re-enable the button
                        copyCodeBtn.removeAttribute('data-temp-active'); // Unmark as active
                        updateToggleEditorViewBtnCodeState(); // Update Go to Rich-Text button state
                    }, 1500);
                } catch (err) {
                    console.error('Failed to copy text: ', err);
                }
            });

            autoFormatBtn.addEventListener('click', () => {
                if (monacoEditorInstance) {
                    const currentContent = monacoEditorInstance.getValue();
                    // Use js_beautify to format the HTML content
                    const formattedContent = html_beautify(currentContent, {
                        indent_size: 4, // You can customize indentation size
                        space_in_paren: true // Example option
                    });
                    monacoEditorInstance.setValue(formattedContent);
                    applyEntityHighlighting(); // Re-apply highlighting after formatting

                    const originalText = autoFormatBtn.textContent;
                    autoFormatBtn.textContent = 'Formatted!';
                    autoFormatBtn.classList.add('bg-green-500', 'hover:bg-green-600');
                    autoFormatBtn.classList.remove('bg-red-700', 'hover:bg-red-800');
                    autoFormatBtn.disabled = true; // Disable the button
                    autoFormatBtn.setAttribute('data-temp-active', 'true'); // Mark as active
                    updateToggleEditorViewBtnCodeState(); // Update Go to Rich-Text button state
                    setTimeout(() => {
                        autoFormatBtn.textContent = originalText;
                        autoFormatBtn.classList.remove('bg-green-500', 'hover:bg-green-600');
                        autoFormatBtn.classList.add('bg-red-700', 'hover:bg-red-800');
                        autoFormatBtn.disabled = false; // Re-enable the button
                        autoFormatBtn.removeAttribute('data-temp-active'); // Unmark as active
                        updateToggleEditorViewBtnCodeState(); // Update Go to Rich-Text button state
                    }, 1500);
                }
            });

            // New Auto-Encode button event listener
            autoEncodeBtn.addEventListener('click', () => {
                if (monacoEditorInstance) {
                    const currentContent = monacoEditorInstance.getValue();
                    const encodedContent = convertAllEntitiesToNumeric(currentContent);
                    monacoEditorInstance.setValue(encodedContent);
                    htmlOutputContent = encodedContent; // Keep the main content variable updated
                    applyEntityHighlighting(); // Re-apply highlighting after encoding

                    const originalText = autoEncodeBtn.textContent;
                    autoEncodeBtn.textContent = 'Encoded!';
                    autoEncodeBtn.classList.add('bg-green-500', 'hover:bg-green-600');
                    autoEncodeBtn.classList.remove('bg-red-700', 'hover:bg-red-800');
                    autoEncodeBtn.disabled = true; // Disable the button
                    autoEncodeBtn.setAttribute('data-temp-active', 'true'); // Mark as active
                    updateToggleEditorViewBtnCodeState(); // Update Go to Rich-Text button state
                    setTimeout(() => {
                        autoEncodeBtn.textContent = originalText;
                        autoEncodeBtn.classList.remove('bg-green-500', 'hover:bg-green-600');
                        autoEncodeBtn.classList.add('bg-red-700', 'hover:bg-red-800');
                        autoEncodeBtn.disabled = false; // Re-enable the button
                        autoEncodeBtn.removeAttribute('data-temp-active'); // Unmark as active
                        updateToggleEditorViewBtnCodeState(); // Update Go to Rich-Text button state
                    }, 1500);
                }
            });

            exportHtmlBtn.addEventListener('click', () => {
                const htmlContent = monacoEditorInstance ? monacoEditorInstance.getValue() : '';
                const blob = new Blob([htmlContent], { type: 'text/html' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'index.html';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                const originalText = exportHtmlBtn.textContent;
                exportHtmlBtn.textContent = 'Exported!';
                exportHtmlBtn.classList.add('bg-green-500', 'hover:bg-green-600');
                exportHtmlBtn.classList.remove('bg-red-700', 'hover:bg-red-800');
                exportHtmlBtn.disabled = true; // Disable the button
                exportHtmlBtn.setAttribute('data-temp-active', 'true'); // Mark as active
                updateToggleEditorViewBtnCodeState(); // Update Go to Rich-Text button state
                setTimeout(() => {
                    exportHtmlBtn.textContent = originalText;
                    exportHtmlBtn.classList.remove('bg-green-500', 'hover:bg-green-600');
                    exportHtmlBtn.classList.add('bg-red-700', 'hover:bg-red-800');
                    exportHtmlBtn.disabled = false; // Re-enable the button
                    exportHtmlBtn.removeAttribute('data-temp-active'); // Unmark as active
                    updateToggleEditorViewBtnCodeState(); // Update Go to Rich-Text button state
                }, 1500);
            });

            importHtmlBtn.addEventListener('click', () => htmlFileInput.click());
            htmlFileInput.addEventListener('change', (event) => {
                const file = event.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        const importedContent = e.target.result;
                        if (monacoEditorInstance) {
                            monacoEditorInstance.setValue(importedContent);
                            htmlOutputContent = importedContent; // Update stored content
                            applyEntityHighlighting(); // Re-apply highlighting after import
                        }
                        const originalText = importHtmlBtn.textContent;
                        importHtmlBtn.textContent = 'Imported!';
                        importHtmlBtn.classList.add('bg-green-500', 'hover:bg-green-600');
                        importHtmlBtn.classList.remove('bg-purple-700', 'hover:bg-purple-800');
                        importHtmlBtn.disabled = true; // Disable the button
                        importHtmlBtn.setAttribute('data-temp-active', 'true'); // Mark as active
                        updateToggleEditorViewBtnCodeState(); // Update Go to Rich-Text button state
                        setTimeout(() => {
                            importHtmlBtn.textContent = originalText;
                            importHtmlBtn.classList.remove('bg-green-500', 'hover:bg-green-600');
                            importHtmlBtn.classList.add('bg-purple-700', 'hover:bg-purple-800');
                            importHtmlBtn.disabled = false; // Re-enable the button
                            importHtmlBtn.removeAttribute('data-temp-active'); // Unmark as active
                            updateToggleEditorViewBtnCodeState(); // Update Go to Rich-Text button state
                        }, 1500);
                    };
                    reader.onerror = () => {
                        // Error handling for file read removed.
                    };
                    reader.readAsText(file);
                }
            });

            // Event listeners for the new individual toggle buttons
            toggleEditorViewBtnRichText.addEventListener('click', toggleEditorView);
            toggleEditorViewBtnCode.addEventListener('click', toggleEditorView);

            // Clear All button event listener
            clearAllBtn.addEventListener('click', () => {
                if (monacoEditorInstance) {
                    monacoEditorInstance.setValue(''); // Clear Monaco content
                    htmlOutputContent = ''; // Clear stored content
                    applyEntityHighlighting(); // Re-apply highlighting after clearing
                }
                const originalText = clearAllBtn.textContent;
                clearAllBtn.textContent = 'Cleared!';
                clearAllBtn.classList.add('bg-green-500', 'hover:bg-green-600');
                clearAllBtn.classList.remove('bg-zinc-700', 'hover:bg-zinc-600');
                clearAllBtn.disabled = true; // Disable the button
                clearAllBtn.setAttribute('data-temp-active', 'true'); // Mark as active
                updateToggleEditorViewBtnCodeState(); // Update Go to Rich-Text button state
                setTimeout(() => {
                    clearAllBtn.textContent = originalText;
                    clearAllBtn.classList.remove('bg-green-500', 'hover:bg-green-600');
                    clearAllBtn.classList.add('bg-zinc-700', 'hover:bg-zinc-600');
                    clearAllBtn.disabled = false; // Re-enable the button
                    clearAllBtn.removeAttribute('data-temp-active'); // Unmark as active
                    updateToggleEditorViewBtnCodeState(); // Update Go to Rich-Text button state
                }, 1500);
            });

            // Initial content for the iframe
            const iframeDocument = default_ifr.contentDocument || default_ifr.contentWindow.document;
            iframeDocument.open();
            iframeDocument.write(`
                <!DOCTYPE html>
                <html lang="en">
                <head>
                    <meta charset="UTF-8">
                    <meta name="viewport" content="width=device-width, initial-scale=1.0">
                    <title>Rich Editor</title>
                    <script src="https://cdn.jsdelivr.net/npm/hugerte@1/hugerte.min.js"><\/script>
                    <script src="https://cdn.tailwindcss.com"><\/script>
                    <style>
                        html, body {
                            height: 100%; /* Ensure html and body take full height */
                            margin: 0;
                            /* Removed padding from html, body to avoid height calculation issues */
                            box-sizing: border-box; /* Include padding in height calculations for all elements */
                        }
                        body {
                            font-family: sans-serif;
                            background-color: #ffffff; /* White background for iframe body */
                            color: #333;
                            display: flex; /* Use flexbox for body to make form fill height */
                            flex-direction: column;
                            padding: 1rem; /* Add padding to the body of the iframe */
                        }
                        form {
                            height: 100%;
                            display: flex;
                            flex-direction: column;
                        }
                        textarea {
                            width: 100%;
                            flex-grow: 1;
                            border: 1px solid #ccc;
                            border-radius: 0.5rem;
                            padding: 0.75rem;
                            font-size: 1rem;
                            resize: none; /* Prevent manual resizing */
                            box-sizing: border-box; /* Include padding in width/height */
                        }
                        /* Style for HugeRTE container */
                        .tox.tox-tinymce { /* Use .tox.tox-tinymce as HugeRTE uses TinyMCE classes */
                            height: 100% !important; /* Force full height */
                            display: flex; /* Make it a flex container */
                            flex-direction: column; /* Stack its children vertically */
                        }
                        .tox-editor-container {
                            flex-grow: 1; /* Allow the editor area to grow */
                            display: flex;
                            flex-direction: column;
                        }
                        .tox-edit-area {
                            flex-grow: 1; /* Allow the editing area to grow */
                            display: flex;
                            flex-direction: column;
                        }
                        .tox-edit-area__iframe {
                            flex-grow: 1; /* Make the actual iframe within TinyMCE fill space */
                        }
                    </style>
                </head>
                <body>
                    <form method="post">
                        <textarea id="richEditor"></textarea>
                    </form>
                    <script type="text/javascript">
                        console.log("Iframe script started executing.");
                        // Global variable to hold the HugeRTE editor instance
                        let richTextEditorInstance;
                        // Flag to prevent infinite loop when updating HugeRTE from CodeMirror
                        let isUpdatingFromCodeMirror = false;

                        /**
                         * Function to set the content of the HugeRTE editor.
                         * This is called from the parent window.
                         */
                        window.setRichEditorContent = function(content) {
                            // console.log("Iframe: setRichEditorContent called by parent.");
                            if (richTextEditorInstance && !isUpdatingFromCodeMirror) {
                                isUpdatingFromCodeMirror = true;
                                richTextEditorInstance.setContent(content);
                                richTextEditorInstance.focus(); // Re-focus the rich editor after content update
                                // console.log('Iframe: HugeRTE updated from parent.');
                                isUpdatingFromCodeMirror = false;
                            } else {
                                console.warn('Iframe: HugeRTE editor not yet initialized or isUpdatingFromCodeMirror is true. Content will be set once ready.');
                            }
                        };

                        /**
                         * Function to get the content from the HugeRTE editor.
                         * This is called from the parent window.
                         */
                        window.getRichEditorContent = function() {
                            // console.log("Iframe: getRichEditorContent called by parent.");
                            if (richTextEditorInstance) {
                                const content = richTextEditorInstance.getContent();
                                // console.log("Iframe: HugeRTE content requested by parent.");
                                return content;
                            } else {
                                console.warn('Iframe: HugeRTE editor not yet initialized. Cannot get content.');
                                return '';
                            }
                        };

                        /**
                         * HugeRTE init
                         */
                        if (typeof hugerte === 'undefined') {
                            console.error("Iframe: HugeRTE library not loaded!");
                        } else {
                            console.log("Iframe: HugeRTE library loaded. Initializing editor.");
                            hugerte.init({
                                selector: '#richEditor',
                                toolbar: 'undo redo styles bold italic alignleft aligncenter alignright numlist bullist table',
                                plugins: [ 'table', 'lists' ],
                                height: '100%', // Explicitly set height for TinyMCE
                                tab_focus: false, // Allow tab to indent instead of changing focus
                                formats: { // Define custom formats for alignment to use classes
                                    alignleft: { selector: 'p,h1,h2,h3,h4,h5,h6,td,th,div,ul,ol,li,table,img', classes: 'text-left', exact: true },
                                    aligncenter: { selector: 'p,h1,h2,h3,h4,h5,h6,td,th,div,ul,ol,li,table,img', classes: 'text-center', exact: true },
                                    alignright: { selector: 'p,h1,h2,h3,h4,h5,h6,td,th,div,ul,ol,li,table,img', classes: 'text-right', exact: true },
                                },
                                init_instance_callback: function(editorInstance) {
                                    console.log('Iframe: HugeRTE editor initialized inside iframe.');
                                    richTextEditorInstance = editorInstance; // Store the instance globally
                                    // Expose the instance to the parent window
                                    if (window.parent) {
                                        window.parent.richTextEditorInstanceFromIframe = editorInstance;
                                        console.log("Iframe: HugeRTE instance exposed to parent.");
                                    }

                                    // Handle Tab key for indentation and outdentation, especially for lists
                                    editorInstance.on('keydown', (event) => {
                                        if (event.key === 'Tab') {
                                            event.preventDefault(); // Prevent default tab behavior (focus change)
                                            // No content modification (no spaces, no styles)
                                            editorInstance.focus(); // Explicitly refocus the editor after command
                                        }
                                    });

                                    // Initial content sync when editor loads
                                    console.log('Iframe: HugeRTE editor ready.');
                                    // Set initial content if parent already has some
                                    if (window.parent.richTextContent) {
                                        editorInstance.setContent(window.parent.richTextContent);
                                        console.log("Iframe: Initial HugeRTE content set from parent.");
                                    }
                                }
                            });
                        }
                    <\/script>
                </body>
                </html>
            `);
            iframeDocument.close();

            // After the iframe content is loaded and the editor is initialized within it,
            // the iframe's script will assign its editor instance to window.parent.richTextEditorInstanceFromIframe
            // We can then pick it up here.
            default_ifr.onload = () => {
                console.log("Parent: Iframe finished loading.");
                if (default_ifr.contentWindow && default_ifr.contentWindow.richTextEditorInstanceFromIframe) {
                    richTextEditorInstanceFromIframe = default_ifr.contentWindow.richTextEditorInstanceFromIframe;
                    console.log("Parent: HugeRTE instance captured by parent.");
                } else {
                    console.warn("Parent: Could not capture HugeRTE instance from iframe. Is HugeRTE initializing correctly inside?");
                }
            };

            // Collapsible section logic
            const collapsibleSections = document.querySelectorAll('.collapsible-section');

            function toggleCollapsible(header, content) {
                const isExpanded = header.classList.contains('expanded');

                // Collapse all other sections first
                collapsibleSections.forEach(section => {
                    const otherHeader = section.querySelector('.collapsible-header');
                    const otherContent = section.querySelector('.collapsible-content');
                    if (otherHeader !== header && otherHeader.classList.contains('expanded')) {
                        otherHeader.classList.remove('expanded');
                        otherHeader.classList.add('collapsed');
                        // Collapse content by setting height to 0 and removing padding
                        otherContent.style.height = '0';
                        otherContent.style.paddingTop = '0';
                        otherContent.style.paddingBottom = '0';
                    }
                });

                // Then toggle the clicked section
                if (isExpanded) {
                    header.classList.remove('expanded');
                    header.classList.add('collapsed');
                    content.style.height = '0';
                    content.style.paddingTop = '0';
                    content.style.paddingBottom = '0';
                } else {
                    header.classList.add('expanded');
                    header.classList.remove('collapsed');
                    // Set height to scrollHeight to animate to full height
                    content.style.height = content.scrollHeight + 'px';
                    content.style.paddingTop = '0.75rem';
                    content.style.paddingBottom = '0.75rem';

                    // After transition, set height to 'auto' to handle dynamic content changes
                    content.addEventListener('transitionend', function handler() {
                        if (header.classList.contains('expanded')) { // Only set to auto if still expanded
                            content.style.height = 'auto';
                        }
                        content.removeEventListener('transitionend', handler);
                    });
                }
            }

            // Initialize all sections as collapsed and attach event listeners
            collapsibleSections.forEach(section => {
                const header = section.querySelector('.collapsible-header');
                const content = section.querySelector('.collapsible-content');
                header.classList.add('collapsed'); // Ensure all start collapsed
                header.addEventListener('click', () => {
                    toggleCollapsible(header, content);
                });
            });
            

            // Toggle switch logic for general cleaning toggles
            generalCleaningToggles.forEach(switchElement => {
                // Set initial state based on checked attribute
                if (switchElement.checked) {
                    switchElement.closest('.toggle-switch').classList.add('is-checked');
                }

                switchElement.addEventListener('change', (event) => {
                    const switchId = event.target.id;
                    const isChecked = event.target.checked;
                    const parentLabel = event.target.closest('.toggle-switch');

                    if (isChecked) {
                        parentLabel.classList.add('is-checked');
                    } else {
                        parentLabel.classList.remove('is-checked');
                    }
                    console.log(`Toggle switch '${switchId}' is now: ${isChecked ? 'ON' : 'OFF'}`);
                    updateRunButtonState(); // Update button state on toggle change
                });
            });

            // Toggle switch logic for table cleaning toggles
            tableCleaningToggles.forEach(switchElement => {
                // Set initial state based on checked attribute
                if (switchElement.checked) {
                    switchElement.closest('.toggle-switch').classList.add('is-checked');
                }

                switchElement.addEventListener('change', (event) => {
                    const switchId = event.target.id;
                    const isChecked = event.target.checked;
                    const parentLabel = event.target.closest('.toggle-switch');

                    if (isChecked) {
                        parentLabel.classList.add('is-checked');
                    } else {
                        parentLabel.classList.remove('is-checked');
                    }
                    console.log(`Table Toggle switch '${switchId}' is now: ${isChecked ? 'ON' : 'OFF'}`);
                    updateRunTableButtonState(); // Update button state on toggle change
                });
            });

            // Event listeners for Auto-Clean MSO when switching toggles
            toggleAutoCleanMsoOnSwitchRichText.addEventListener('change', (event) => {
                const isChecked = event.target.checked;
                const parentLabel = event.target.closest('.toggle-switch');
                if (isChecked) {
                    parentLabel.classList.add('is-checked');
                } else {
                    parentLabel.classList.remove('is-checked');
                }
                toggleAutoCleanMsoOnSwitchCode.checked = isChecked; // Sync state
                toggleAutoCleanMsoOnSwitchCode.closest('.toggle-switch').classList.toggle('is-checked', isChecked);
                console.log(`Auto-Clean MSO on RichText switch is now: ${isChecked ? 'ON' : 'OFF'}`);
                updateGoToHtmlButtonColor(); // Update button color
            });

            toggleAutoCleanMsoOnSwitchCode.addEventListener('change', (event) => {
                const isChecked = event.target.checked;
                const parentLabel = event.target.closest('.toggle-switch');
                if (isChecked) {
                    parentLabel.classList.add('is-checked');
                } else {
                    parentLabel.classList.remove('is-checked');
                }
                toggleAutoCleanMsoOnSwitchRichText.checked = isChecked; // Sync state
                toggleAutoCleanMsoOnSwitchRichText.closest('.toggle-switch').classList.toggle('is-checked', isChecked);
                console.log(`Auto-Clean MSO on Code switch is now: ${isChecked ? 'ON' : 'OFF'}`);
                // No button color update needed here as it's the "Go to Rich-Text" button
            });


            // Call updateRunButtonState initially to set the correct state on load
            updateRunButtonState();
            updateRunTableButtonState(); // Call for table button as well
            // updateGoToHtmlButtonColor(); // Initial call is now handled directly in window.onload for better control

            // Functionality for "Run Selected" button for General Cleaning
            runSelectedBtn.addEventListener('click', () => {
                // Prevent execution if button is disabled
                if (runSelectedBtn.disabled) {
                    return;
                }
                console.log("Run Selected button clicked.");

                let contentToClean;
                if (currentView === 'richtext') {
                    contentToClean = window.getRichEditorContent();
                    // When running from rich text, entities are already decoded
                    // and empty paragraphs outside tables/lists are removed by toggleEditorView
                } else { // currentView === 'code'
                    contentToClean = monacoEditorInstance.getValue();
                    // If running from code view, ensure entities are decoded before cleaning functions
                    contentToClean = decodeHtmlEntities(contentToClean);
                }
                
                let cleanedContent = contentToClean; // Start with current content

                if (toggleUrlCleaning.checked) {
                    cleanedContent = applyUrlCleaning(cleanedContent);
                    console.log("Clean URLs applied.");
                }

                if (toggleAutoSpacing.checked) {
                    cleanedContent = applyAutoSpacing(cleanedContent);
                    console.log("Clean Spaces applied.");
                }

                // Apply Clean Formatting Tags if checked
                if (toggleCleanFormattingTags.checked) {
                    cleanedContent = applyCleanFormattingTags(cleanedContent);
                    console.log("Clean <u> | <b> | <i> applied.");
                }

                // New condition for Clean Single Breaks
                if (toggleCleanSingleBreaks.checked) {
                    cleanedContent = applyCleanSingleBreaks(cleanedContent);
                    console.log("Clean Single Breaks applied.");
                }

                // Apply Clean MSO Code if checked (now includes COMM/FN/EDN)
                if (toggleCleanMsoCode.checked) {
                    cleanedContent = applyCleanMsoCode(cleanedContent);
                    console.log("Clean MSO Code (including COMM/FN/EDN) applied.");
                }

                // Update the active editor with the final cleaned content
                if (currentView === 'richtext') {
                    window.setRichEditorContent(cleanedContent);
                } else { // currentView === 'code'
                    monacoEditorInstance.setValue(cleanedContent);
                    htmlOutputContent = cleanedContent; // Keep the main content variable updated
                    applyEntityHighlighting(); // Re-apply highlighting after cleaning
                }

                // Always run Auto-Indent after any cleaning operation
                autoFormatBtn.click();
                console.log("Auto-Indent applied after cleaning.");

                // Turn off all general cleaning toggles after running
                generalCleaningToggles.forEach(toggle => {
                    if (toggle.checked) {
                        toggle.checked = false;
                        toggle.closest('.toggle-switch').classList.remove('is-checked');
                    }
                });
                console.log("All general cleaning toggles turned off.");
                updateRunButtonState(); // Update button state after toggles are turned off


                // Provide visual feedback
                const originalText = runSelectedBtn.textContent;
                runSelectedBtn.textContent = 'Cleaned!';
                runSelectedBtn.classList.add('bg-sky-500', 'hover:bg-sky-600');
                runSelectedBtn.classList.remove('bg-green-600', 'hover:bg-green-700');
                runSelectedBtn.disabled = true; // Disable the button
                runSelectedBtn.setAttribute('data-temp-active', 'true'); // Mark as active
                updateToggleEditorViewBtnCodeState(); // Update Go to Rich-Text button state
                setTimeout(() => {
                    runSelectedBtn.textContent = originalText;
                    runSelectedBtn.classList.remove('bg-sky-500', 'hover:bg-sky-600');
                    runSelectedBtn.classList.add('bg-green-600', 'hover:bg-green-700');
                    runSelectedBtn.disabled = false; // Re-enable the button
                    runSelectedBtn.removeAttribute('data-temp-active'); // Unmark as active
                    updateToggleEditorViewBtnCodeState(); // Update Go to Rich-Text button state
                }, 1500);
            });

            // Functionality for "Run Selected" button for Table Cleaning
            runSelectedTableBtn.addEventListener('click', () => {
                // Prevent execution if button is disabled
                if (runSelectedTableBtn.disabled) {
                    return;
                }
                console.log("Run Selected Table button clicked.");

                let contentToClean;
                if (currentView === 'richtext') {
                    contentToClean = window.getRichEditorContent();
                    // When running from rich text, entities are already decoded
                    // and empty paragraphs outside tables/lists are removed by toggleEditorView
                } else { // currentView === 'code'
                    contentToClean = monacoEditorInstance.getValue();
                    // If running from code view, ensure entities are decoded before cleaning functions
                    contentToClean = decodeHtmlEntities(contentToClean);
                }
                
                let cleanedContent = contentToClean; // Start with current content

                if (toggleResponsiveTables.checked) {
                    // Assuming this function exists or will be added
                    // cleanedContent = applyResponsiveTables(cleanedContent);
                    console.log("Responsive Tables applied (placeholder).");
                }

                if (toggleWetAlignment.checked) {
                    // Assuming this function exists or will be added
                    // cleanedContent = applyWetAlignment(cleanedContent);
                    console.log("WET Alignment applied (placeholder).");
                }

                if (toggleApplyBasicClasses.checked) {
                    // You can add other table-specific basic class applications here if needed.
                    console.log("Apply Basic Classes applied (placeholder).");
                }

                if (toggleRemovePTags.checked) {
                    // Assuming this function exists or will be added
                    // cleanedContent = removePTagsFromTables(cleanedContent);
                    console.log("Remove <p> Tags applied (placeholder).");
                }

                // Update the active editor with the final cleaned content
                if (currentView === 'richtext') {
                    window.setRichEditorContent(cleanedContent);
                } else { // currentView === 'code'
                    monacoEditorInstance.setValue(cleanedContent);
                    htmlOutputContent = cleanedContent; // Keep the main content variable updated
                    applyEntityHighlighting(); // Re-apply highlighting after cleaning
                }

                // Always run Auto-Indent after any cleaning operation
                autoFormatBtn.click();
                console.log("Auto-Indent applied after table cleaning.");

                // Turn off all table cleaning toggles after running
                tableCleaningToggles.forEach(toggle => {
                    if (toggle.checked) {
                        toggle.checked = false;
                        toggle.closest('.toggle-switch').classList.remove('is-checked');
                    }
                });
                console.log("All table cleaning toggles turned off.");
                updateRunTableButtonState(); // Update button state after toggles are turned off

                // Provide visual feedback
                const originalText = runSelectedTableBtn.textContent;
                runSelectedTableBtn.textContent = 'Cleaned!';
                runSelectedTableBtn.classList.add('bg-sky-500', 'hover:bg-sky-600');
                runSelectedTableBtn.classList.remove('bg-green-600', 'hover:bg-green-700');
                runSelectedTableBtn.disabled = true; // Disable the button
                runSelectedTableBtn.setAttribute('data-temp-active', 'true'); // Mark as active
                updateToggleEditorViewBtnCodeState(); // Update Go to Rich-Text button state
                setTimeout(() => {
                    runSelectedTableBtn.textContent = originalText;
                    runSelectedTableBtn.classList.remove('bg-sky-500', 'hover:bg-sky-600');
                    runSelectedTableBtn.classList.add('bg-green-600', 'hover:bg-green-700');
                    runSelectedTableBtn.disabled = false; // Re-enable the button
                    runSelectedTableBtn.removeAttribute('data-temp-active'); // Unmark as active
                    updateToggleEditorViewBtnCodeState(); // Update Go to Rich-Text button state
                }, 1500);
            });
        };
    </script>
</body>
</html>
