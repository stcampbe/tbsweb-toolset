<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WordToCodeâ„¢ - Rich Content Wizard</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/js-beautify/1.14.0/beautify-html.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/monaco-editor@0.49.0/min/vs/loader.js"></script>
    <style>
        /* Custom styles for the editor */
        html, body {
            height: 100%; /* Ensure html and body take full viewport height */
            margin: 0;
            padding: 0;
            overflow: hidden; /* Prevent body from scrolling; all scrolling should be within panels */
        }

        body {
            font-family: 'Inter', sans-serif; /* Using Inter font */
            display: flex;
            flex-direction: column;
            background-color: #09090b; /* Very dark zinc */
        }
        .editor-container {
            display: flex;
            flex-grow: 1; /* Allow container to grow and fill available space */
            padding: 1rem; /* Apply padding to all sides */
            gap: 1rem; /* Space between editor and richtext-output */
            margin: 0;
            width: 100%; /* Full width */
            height: 100%; /* Explicitly make editor-container take full height of flex parent (body) */
            box-sizing: border-box; /* Include padding in total height */
            overflow-y: hidden; /* Prevent editor container from scrolling its children */
        }
        .code-panel, .richtext-output-panel {
            background-color: #18181b; /* Darker zinc */
            border-radius: 0.75rem; /* rounded-xl */
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3); /* Darker shadow */
            padding: 1rem;
            display: flex;
            flex-direction: column; /* Keep column for header, content area, and footer */
            flex-grow: 1; /* Allow panels to grow and shrink horizontally */
            flex-shrink: 1;
            flex-basis: 0; /* Important for equal distribution in flex row */
            height: 100%; /* Take full height of container */
            box-sizing: border-box; /* Include padding and border in element's total width/height */
            overflow-y: hidden; /* Prevent main panels from scrolling; internal elements will manage their own scroll */
            overflow-x: hidden; /* Prevent horizontal scrollbar on panels unless explicitly needed */
        }

        /* Resizer bar styling */
        .resizer {
            width: 10px; /* Width of the draggable bar */
            background-color: #3f3f46; /* Medium zinc */
            cursor: ew-resize; /* East-west resize cursor */
            flex-shrink: 0; /* Prevent resizer from shrinking */
            border-radius: 0.25rem; /* Slightly rounded corners */
            transition: background-color 0.2s ease; /* Smooth transition on hover */
        }
        .resizer:hover {
            background-color: #52525b; /* Lighter zinc on hover */
        }

        /* Monaco Editor specific styling */
        #monacoEditorContainer {
            min-height: 200px; /* Ensure it has a minimum height */
            flex-basis: 75%; /* Initial basis: 75% */
            flex-grow: 0;   /* Controlled by JS */
            flex-shrink: 0; /* Controlled by JS */
            height: 100%; /* Make Monaco take full height of its flex parent */
            /* Monaco editor will handle its own internal scrolling due to automaticLayout: true */
        }

        /* Rich-Text Iframe styling */
        iframe {
            width: 100%;
            height: 100%; /* Make iframe fill its parent's height */
            flex-grow: 1; /* Allow iframe to take all available vertical space */
            border: 1px solid #3f3f46; /* Medium zinc border */
            border-radius: 0.5rem; /* rounded-lg */
            background-color: #ffffff; /* Rich-Text Output window background remains white */
            overflow: auto; /* Ensure iframe itself can scroll if its content overflows */
        }

        /* Sidebar styling */
        #sidebar {
            flex-basis: 25%; /* Initial basis: 25% */
            flex-grow: 0;   /* Controlled by JS */
            flex-grow: 1; /* Allow it to grow vertically to fill available space */
            overflow-y: auto; /* Enable vertical scrolling for sidebar content */
            overflow-x: hidden; /* Prevent horizontal scrolling on sidebar */
            min-height: 0; /* Crucial for flex items to scroll correctly if content overflows */
            background-color: #18181b; /* Darker zinc */
            border-radius: 0.75rem; /* rounded-xl */
            padding: 1rem;
            display: flex;
            flex-direction: column; /* Keep column for header, content area, and footer */
            box-sizing: border-box; /* Include padding and border in element's total width/height */
        }

        h1 {
            color: #ffffff; /* White text for H1 in editor panel */
            margin-bottom: 1rem;
            text-align: center;
        }
        h2 {
            color: #ffffff; /* White text for H2 in panel headers */
        }
        label {
            color: #d4d4d8; /* Zinc-300 for labels */
        }
        input[type="text"] {
            background-color: #27272a; /* Darker zinc for input */
            color: #ffffff; /* White text for input */
            border-color: #3f3f46; /* Medium zinc border for input */
        }
        input[type="text"]::placeholder {
            color: #a1a1aa; /* Zinc-400 for placeholder text */
        }

        /* Add flex-shrink: 0 to the button containers at the top and bottom of panels */
        /* For Richtext panel header */
        #richtextOutputPanel > div.flex.items-center.mb-4 {
            flex-shrink: 0;
        }
        /* For Code panel header */
        #codePanel > div.flex.items-center.mb-4.flex-wrap {
            flex-shrink: 0;
        }
        /* For Code panel footer */
        #codePanel > div.mt-auto.pt-4.flex.justify-center.space-x-2 {
            flex-shrink: 0;
        }

        /* The main content area within the code panel (Monaco + Sidebar) */
        /* This div needs to correctly take up remaining vertical space */
        .code-panel > .flex.flex-grow.gap-4 {
            flex-grow: 1; /* Ensures it takes all remaining vertical space */
            height: 100%; /* Explicit height is often helpful in nested flex */
            display: flex; /* Already a flex container */
            gap: 1rem; /* Space between Monaco and Sidebar */
            overflow: hidden; /* Prevent this container from scrolling */
        }


        /* Responsive adjustments */
        @media (max-width: 768px) {
            .editor-container {
                flex-direction: column; /* Stack vertically on small screens */
            }
            .resizer {
                width: 100%; /* Full width for vertical resizer on small screens */
                height: 10px; /* Height for vertical resizer */
                cursor: ns-resize; /* North-south resize cursor */
            }
            /* Stack editor and sidebar vertically on small screens */
            .code-panel > .flex-grow { /* Target the div containing Monaco and Sidebar */
                flex-direction: column;
            }
            #monacoEditorContainer {
                width: 100%; /* Full width on small screens */
            }
            #sidebar {
                width: 100%; /* Full width on small screens */
            }
        }

        /* Styles for button group */
        .button-group {
            display: flex;
            width: 100%; /* Make it span full width */
            border-radius: 0.5rem; /* rounded-md */
            box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05); /* shadow-sm */
            border: 1px solid #3f3f46; /* Darker border for button group */
            flex-wrap: wrap; /* Keep for responsiveness on smaller screens */
        }

        .button-group button {
            flex: 1; /* Make buttons take up equal space */
            border-radius: 0; /* Remove individual button rounded corners */
            border: none; /* Remove individual button borders */
            margin: 0; /* Remove individual button margins */
            padding: 0.5rem 0.75rem; /* Consistent padding */
            font-size: 0.875rem; /* text-sm */
            line-height: 1.25rem; /* leading-5 */
            position: relative; /* For z-index if needed */
            color: #ffffff; /* White text for all buttons */
            font-weight: bold; /* Make buttons bold */
        }

        /* Specific styles for the Sections and Headings buttons - NO FLEX */
        #toggleSectionsBtn,
        #toggleHeadingsBtn {
            flex: none; /* Override flex: 1; for these specific buttons */
            width: auto; /* Allow buttons to size based on content */
            border: 1px solid #3f3f46; /* Add border back for individual buttons */
            border-radius: 0.5rem; /* Add rounded corners back for individual buttons */
            margin-left: 0.5rem; /* Add spacing between them and other buttons */
        }

        /* Adjust border between buttons in the main button groups */
        .button-group:not(.no-border-buttons) button:not(:last-child) {
            border-right: 1px solid rgba(63, 63, 70, 0.5); /* Darker separator between buttons */
        }
        .button-group.no-border-buttons button:not(:last-child) {
            border-right: none; /* Remove border for this specific group */
        }

        /* Specific styling for the byline and URL/Image source button groups */
        .button-group.individual-rounded-buttons {
            border: none; /* Remove group border */
            box-shadow: none; /* Remove group shadow */
            width: auto; /* Allow the group to size to content */
            gap: 0.5rem; /* Add gap between individual buttons */
        }

        .button-group.individual-rounded-buttons button {
            flex: none; /* Do not make buttons take equal space */
            border-radius: 0.5rem; /* Ensure rounded corners */
            border: 1px solid #3f3f46; /* Add individual button border */
            padding: 0.5rem 0.75rem; /* Consistent padding */
        }
        /* Remove right border for individual rounded buttons */
        .button-group.individual-rounded-buttons button:not(:last-child) {
            border-right: 1px solid #3f3f46; /* Keep individual border */
        }


        .button-group button:first-child {
            border-top-left-radius: 0.5rem;
            border-bottom-left-radius: 0.5rem;
        }

        .button-group button:last-child {
            border-top-right-radius: 0.5rem;
            border-bottom-right-radius: 0.5rem;
        }

        .button-group button:hover {
            z-index: 1; /* Bring hovered button to front to show full border/shadow */
        }

        /* Visibility classes for toggle view */
        .panel-hidden {
            display: none;
        }
        .panel-visible {
            display: flex; /* Or 'block' for iframe if it's not a flex container */
        }


        /* Customize section styles (removed, but keeping styles for reference if needed) */
        .customize-section {
            background-color: #27272a; /* Same as input background */
            border-radius: 0.5rem;
            padding: 1rem; /* Re-added padding */
            margin-bottom: 1rem; /* Re-added margin-bottom */
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .customize-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            /* Removed padding-bottom, margin-bottom, border-bottom */
        }

        .customize-content {
            /* Now uses max-height instead of height */
            max-height: 0; /* Changed from height: 0; */
            overflow: hidden;
            /* Unified transition for smoother effect */
            transition: max-height 0.5s ease-in-out, padding 0.5s ease-in-out; /* Transition max-height and padding */
            padding: 0 1rem; /* Padding for content area, default to 0 for collapsed */
            background-color: #3f3f46; /* Match header background */
            border-radius: 0 0 0.5rem 0.5rem; /* Rounded bottom corners */
        }

        .collapsible-content.expanded {
            /* max-height will be set by JS dynamically to scrollHeight or a large value */
            padding-top: 0.75rem; /* Add padding to content when expanded */
            padding-bottom: 0.75rem; /* Add padding to content when expanded */
        }

        .customize-header svg {
            transition: transform 0.3s ease;
        }

        .customize-header.expanded svg {
            transform: rotate(180deg);
        }

        /* Adjustments for button spacing */
        .code-panel h2 .inline-flex.mr-auto button,
        .richtext-output-panel h2 .inline-flex.mr-auto button {
            margin-right: 0.5rem; /* Default margin for buttons within the group */
        }

        /* When in fullscreen editor mode, remove margin from the first button group */
        .editor-container.fullscreen-editor .code-panel h2 .inline-flex.mr-auto {
            margin-left: 0 !important; /* Remove any left margin on the button container */
        }

        /* When in fullscreen richtext-output mode, remove margin from the first button group */
        .editor-container.fullscreen-richtext .richtext-output-panel h2 .inline-flex.mr-auto {
            margin-left: 0 !important; /* Remove any left margin on the button */
        }

        /* Ensure the button itself doesn't have an undesired left margin when its parent is adjusted */
        .editor-container.fullscreen-editor .code-panel h2 .inline-flex.mr-auto #fullScreenBtn,
        .editor-container.fullscreen-editor .code-panel h2 .inline-flex.mr-auto #exitFullScreenBtn,
        .editor-container.fullscreen-richtext .richtext-output-panel h2 .inline-flex.mr-auto #fullScreenRichTextBtn,
        .editor-container.fullscreen-richtext .richtext-output-panel h2 .inline-flex.mr-auto #exitFullScreenRichTextBtn {
            margin-left: 0; /* Explicitly remove any left margin on the button */
        }

        /* Modal styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .modal-content {
            background-color: #18181b; /* Darker zinc */
            padding: 2rem;
            border-radius: 0.75rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            color: #ffffff;
            text-align: left; /* Left align content */
            max-width: 90%;
            width: 400px;
        }

        .modal-content h3 {
            font-size: 1.5rem;
            font-weight: bold;
            margin-bottom: 1rem;
            text-align: left; /* Ensure title is left aligned */
        }

        .modal-content p {
            margin-bottom: 1.5rem;
        }

        .modal-content button {
            background-color: #52525b; /* Zinc-600 */
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            font-weight: bold;
            transition: background-color 0.2s ease;
        }

        .modal-content button:hover {
            background-color: #3f3f46; /* Zinc-700 */
        }

        .modal-content .button-group {
            border: none; /* Remove border for button groups inside modal */
            box-shadow: none; /* Remove shadow for button groups inside modal */
            width: auto; /* Allow buttons to size naturally */
        }

        .modal-content .button-group button {
            flex: none; /* Prevent buttons from taking equal space */
            margin: 0.25rem; /* Add some margin between buttons */
            border: 1px solid #3f3f46; /* Add border back for individual buttons */
            border-radius: 0.5rem; /* Add rounded corners back for individual buttons */
            padding: 0.3rem 0.6rem; /* Reduced padding for smaller buttons */
            font-size: 0.8rem; /* Reduced font size for smaller buttons */
        }

        .modal-content .button-group button.active {
            background-color: #27272a; /* Zinc-800 for active state */
            color: white;
            border-color: #27272a;
        }

        /* Styles for collapsible sections */
        .collapsible-section {
            background-color: #3f3f46; /* Medium zinc for section background */
            border-radius: 0.5rem;
            margin-bottom: 0.75rem; /* Space between sections */
            overflow: hidden; /* Hide overflowing content during collapse */
        }

        .collapsible-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem 1rem;
            cursor: pointer;
            background-color: #3f3f46; /* Medium zinc for header background */
            border-bottom: 1px solid #52525b; /* Lighter zinc border */
            border-radius: 0.5rem 0.5rem 0 0; /* Rounded top corners */
        }

        .collapsible-header.collapsed {
            border-bottom: none; /* No border when collapsed */
            border-radius: 0.5rem; /* Fully rounded when collapsed */
        }

        .collapsible-header h4 {
            font-size: 1rem;
            font-weight: bold;
            color: #ffffff;
        }

        .collapsible-header svg {
            transition: transform 0.3s ease;
        }

        .collapsible-header.expanded svg {
            transform: rotate(180deg);
        }

        .collapsible-content {
            /* Now uses max-height instead of height */
            max-height: 0; /* Changed from height: 0; */
            overflow: hidden;
            /* Unified transition for smoother effect */
            transition: max-height 0.5s ease-in-out, padding 0.5s ease-in-out; /* Transition max-height and padding */
            padding: 0 1rem; /* Padding for content area, default to 0 for collapsed */
            background-color: #3f3f46; /* Match header background */
            border-radius: 0 0 0.5rem 0.5rem; /* Rounded bottom corners */
        }

        .collapsible-content.expanded {
            /* max-height will be set by JS dynamically to scrollHeight or a large value */
            padding-top: 0.75rem; /* Add padding to content when expanded */
            padding-bottom: 0.75rem; /* Add padding to content when expanded */
        }

        /* Toggle Switch Styles */
        .toggle-switch-container {
            display: flex;
            align-items: center;
            margin-bottom: 0.5rem; /* Space between switches */
            padding: 0.5rem 0; /* Vertical padding for each switch row */
            /* Removed flex-direction: row-reverse; */
            /* Removed justify-content: flex-end; */
            gap: 0.5rem; /* Space between toggle and label */
            margin-left: auto; /* Push the entire container to the right */
        }

        .toggle-switch-label {
            color: #d4d4d8; /* Light gray for label text */
            font-size: 0.9rem;
            /* Removed flex-grow: 1; */
            flex-shrink: 1; /* Allow label to shrink */
            min-width: 0; /* Allow text to wrap within the label */
            /* Removed text-align: right; */
        }

        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 44px; /* Width of the pill */
            height: 24px; /* Height of the pill */
            border-radius: 12px; /* Half of height for pill shape */
            background-color: #71717a; /* Off state background - Zinc-600 */
            cursor: pointer;
            transition: background-color 0.3s ease;
            flex-shrink: 0; /* Prevent the switch from shrinking */
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-switch-slider {
            position: absolute;
            content: "";
            height: 20px; /* Height of the inner circle */
            width: 20px; /* Width of the inner circle */
            left: 2px; /* Initial position for off state */
            bottom: 2px;
            background-color: #ffffff; /* Circle color */
            border-radius: 50%;
            transition: transform 0.3s ease;
        }

        /* Checked state styles (applied to the .toggle-switch label itself) */
        .toggle-switch.is-checked {
            background-color: #22c55e; /* Green for on state */
        }

        .toggle-switch.is-checked .toggle-switch-slider {
            transform: translateX(20px); /* Move circle to the right */
        }

        /* Custom style for HTML character entities in Monaco Editor */
        .entity-highlight {
            color: gold !important; /* Use !important to ensure override */
        }

        /* Styling for disabled button */
        #runSelectedBtn:disabled, #runSelectedTableBtn:disabled,
        #autoEncodeBtn:disabled, #autoFormatBtn:disabled, #copyCodeBtn:disabled,
        #exportHtmlBtn:disabled, #importHtmlBtn:disabled, #clearAllBtn:disabled,
        #toggleEditorViewBtnCode:disabled {
            background-color: #4a4a4a; /* Darker gray for disabled state */
            cursor: not-allowed;
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div class="editor-container">
        <div id="richtextOutputPanel" class="richtext-output-panel panel-visible">
            <div class="flex items-center mb-4">
                <h2 class="text-xl font-semibold text-white">Rich-Text Editor</h2>
                <button id="toggleEditorViewBtnRichText" class="ml-4 px-4 py-2 text-base font-semibold bg-sky-700 text-white rounded-md hover:bg-sky-800 focus:outline-none focus:ring-2 focus:ring-sky-600 focus:ring-opacity-50 font-bold">
                    Go to HTML
                </button>
                <!-- Auto-Clean MSO toggle for Rich-Text Editor -->
                <div class="ml-4 p-2 bg-zinc-700 rounded-lg flex items-center gap-2">
                    <label class="toggle-switch">
                        <input type="checkbox" id="toggleAutoCleanMsoOnSwitchRichText">
                        <span class="toggle-switch-slider"></span>
                    </label>
                    <span class="toggle-switch-label text-white text-sm">Auto-Clean MSO</span>
                </div>
            </div>
            <iframe id="default_ifr"></iframe>
        </div>

        <div id="codePanel" class="code-panel panel-hidden">
            <div class="flex items-center mb-4 flex-wrap">
                <h2 class="text-xl font-semibold text-white">HTML Editor</h2>
                <button id="toggleEditorViewBtnCode" class="ml-4 px-4 py-2 text-base font-semibold bg-sky-700 text-white rounded-md hover:bg-sky-800 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50 font-bold">
                    Go to Rich-Text
                </button>
                <!-- Auto-Clean MSO toggle for HTML Editor -->
                <div class="ml-4 p-2 bg-zinc-700 rounded-lg flex items-center gap-2">
                    <label class="toggle-switch">
                        <input type="checkbox" id="toggleAutoCleanMsoOnSwitchCode">
                        <span class="toggle-switch-slider"></span>
                    </label>
                    <span class="toggle-switch-label text-white text-sm">Auto-Clean MSO</span>
                </div>
                <div class="inline-flex space-x-2 ml-auto mt-2 sm:mt-0">
                    <button id="importHtmlBtn" class="px-3 py-1 text-sm bg-purple-700 text-white rounded-md hover:bg-purple-800 focus:outline-none focus:ring-2 focus:ring-purple-600 focus:ring-opacity-50 font-bold">Import HTML</button>
                    <button id="exportHtmlBtn" class="px-3 py-1 text-sm bg-red-700 text-white rounded-md hover:bg-red-800 focus:outline-none focus:ring-2 focus:ring-red-600 focus:ring-opacity-50 font-bold">Export HTML</button>
                    <input type="file" id="htmlFileInput" accept=".html" style="display: none;">
                </div>
            </div>
            
            <div class="flex flex-grow gap-4">
                <div id="monacoEditorContainer" class="flex-grow border border-zinc-700 rounded-lg overflow-hidden"></div>
                
                <!-- Resizer for Monaco and Sidebar -->
                <div id="monacoResizer" class="resizer"></div>

                <div id="sidebar">
                    <h3 class="text-lg font-semibold text-white mb-4">Formatting</h3>
                    
                    <div>
                        <button id="runSelectedBtn" class="w-full px-4 py-2 mb-4 text-sm bg-green-600 text-white rounded-md hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-opacity-50 font-semibold">
                            Run Selected
                        </button>

                        <div class="toggle-switch-container">
                            <label class="toggle-switch">
                                <input type="checkbox" id="toggleCleanLists">
                                <span class="toggle-switch-slider"></span>
                            </label>
                            <span class="toggle-switch-label">Clean MSO Lists</span>
                        </div>

                        <div class="toggle-switch-container">
                            <label class="toggle-switch">
                                <input type="checkbox" id="toggleCleanTablesBasic">
                                <span class="toggle-switch-slider"></span>
                            </label>
                            <span class="toggle-switch-label">Clean MSO Tables</span>
                        </div>

                        <div class="toggle-switch-container">
                            <label class="toggle-switch">
                                <input type="checkbox" id="toggleCleanMsoCode">
                                <span class="toggle-switch-slider"></span>
                            </label>
                            <span class="toggle-switch-label">Clean MSO Code</span>
                        </div>

                        <div class="toggle-switch-container">
                            <label class="toggle-switch">
                                <input type="checkbox" id="toggleUrlCleaning">
                                <span class="toggle-switch-slider"></span>
                            </label>
                            <span class="toggle-switch-label">Clean URLs</span>
                        </div>

                        <div class="toggle-switch-container">
                            <label class="toggle-switch">
                                <input type="checkbox" id="toggleAutoSpacing">
                                <span class="toggle-switch-slider"></span>
                            </label>
                            <span class="toggle-switch-label">Clean Spaces</span>
                        </div>
                        
                        <div class="toggle-switch-container">
                            <label class="toggle-switch">
                                <input type="checkbox" id="toggleCleanSingleBreaks"> 
                                <span class="toggle-switch-slider"></span>
                            </label>
                            <span class="toggle-switch-label">Clean Single Breaks</span>
                        </div>

                        <div class="toggle-switch-container">
                            <label class="toggle-switch">
                                <input type="checkbox" id="toggleCleanFormattingTags"> 
                                <span class="toggle-switch-slider"></span>
                            </label>
                            <span class="toggle-switch-label">Clean &lt;u&gt; | &lt;b&gt; | &lt;i&gt;</span>
                        </div>
                    </div>

                </div>

            </div>

            <div class="mt-auto pt-4 flex justify-center space-x-2">
                <button id="clearAllBtn" class="px-4 py-2 text-sm bg-zinc-700 text-white rounded-md hover:bg-zinc-600 focus:outline-none focus:ring-2 focus:ring-zinc-500 focus:ring-opacity-50 font-semibold">Clear All</button>
                <button id="autoEncodeBtn" class="px-4 py-2 text-sm bg-red-700 text-white rounded-md hover:bg-red-800 focus:outline-none focus:ring-2 focus:ring-red-600 focus:ring-opacity-50 font-semibold">
                    Auto-Encode
                </button>
                <button id="autoFormatBtn" class="px-4 py-2 text-sm bg-red-700 text-white rounded-md hover:bg-red-800 focus:outline-none focus:ring-2 focus:ring-red-600 focus:ring-opacity-50 font-semibold">
                    Auto-Indent
                </button>
                <button id="copyCodeBtn" class="px-4 py-2 text-sm bg-zinc-700 text-white rounded-md hover:bg-zinc-600 focus:outline-none focus:ring-2 focus:ring-zinc-500 focus:ring-opacity-50 font-semibold">
                    Copy Code
                </button>
            </div>
        </div>
    </div>

    <script>
        // Get references to the elements
        const default_ifr = document.getElementById('default_ifr');
        const codePanel = document.getElementById('codePanel');
        const richtextOutputPanel = document.getElementById('richtextOutputPanel');
        const toggleEditorViewBtnRichText = document.getElementById('toggleEditorViewBtnRichText'); 
        const toggleEditorViewBtnCode = document.getElementById('toggleEditorViewBtnCode'); 
        const copyCodeBtn = document.getElementById('copyCodeBtn');
        const autoFormatBtn = document.getElementById('autoFormatBtn');
        const autoEncodeBtn = document.getElementById('autoEncodeBtn'); // New button reference
        const exportHtmlBtn = document.getElementById('exportHtmlBtn');
        const importHtmlBtn = document.getElementById('importHtmlBtn');
        const htmlFileInput = document.getElementById('htmlFileInput');
        const clearAllBtn = document.getElementById('clearAllBtn');
        const runSelectedBtn = document.getElementById('runSelectedBtn'); // Get reference to Run Selected button

        // Monaco Resizer elements
        const monacoEditorContainer = document.getElementById('monacoEditorContainer');
        const monacoResizer = document.getElementById('monacoResizer');
        const sidebar = document.getElementById('sidebar');

        // Toggle references
        const toggleUrlCleaning = document.getElementById('toggleUrlCleaning');
        const toggleAutoSpacing = document.getElementById('toggleAutoSpacing');
        const toggleCleanSingleBreaks = document.getElementById('toggleCleanSingleBreaks');
        const toggleCleanMsoCode = document.getElementById('toggleCleanMsoCode');
        const toggleCleanFormattingTags = document.getElementById('toggleCleanFormattingTags');
        const toggleCleanLists = document.getElementById('toggleCleanLists');
        // Removed toggleCleanImgs as it's merged
        const toggleCleanTablesBasic = document.getElementById('toggleCleanTablesBasic');

        // Auto-Clean MSO when switching toggles
        const toggleAutoCleanMsoOnSwitchRichText = document.getElementById('toggleAutoCleanMsoOnSwitchRichText');
        const toggleAutoCleanMsoOnSwitchCode = document.getElementById('toggleAutoCleanMsoOnSwitchCode');

        // Array of all general cleaning toggles for easy iteration
        const generalCleaningToggles = [
            toggleCleanLists,
            toggleCleanTablesBasic,
            toggleUrlCleaning,
            toggleAutoSpacing,
            toggleCleanSingleBreaks,
            toggleCleanFormattingTags,
            toggleCleanMsoCode // Clean IMGs is now part of MsoCode
        ];

        // Array of all buttons that display temporary messages
        const tempMessageButtons = [
            copyCodeBtn,
            autoFormatBtn,
            autoEncodeBtn,
            exportHtmlBtn,
            importHtmlBtn,
            clearAllBtn,
            runSelectedBtn
        ];

        let richTextEditorInstance; // HugeRTE editor instance
        let monacoEditorInstance; // Monaco editor instance
        let currentView = 'richtext'; // 'richtext' or 'code'

        // Separate content storage for each editor
        let richTextContent = '';
        let htmlOutputContent = ''; // This will now hold the content for Monaco

        // Variable to hold the HugeRTE editor instance from the iframe
        let richTextEditorInstanceFromIframe;


        /**
         * Decodes HTML entities within a string to their actual Unicode characters.
         * Uses a temporary textarea element for reliable decoding.
         * @param {string} html - The HTML string containing entities.
         * @returns {string} The HTML string with entities decoded.
         */
        function decodeHtmlEntities(html) {
            const textarea = document.createElement('textarea');
            textarea.innerHTML = html; // Browser decodes entities when setting innerHTML
            return textarea.value; // Retrieving value gives the decoded string
        }

        /**
         * Cleans HTML content for display in HugeRTE.
         * This function is specifically for preparing content *before* setting it to the rich text editor.
         * It decodes HTML entities to ensure they render correctly in the visual editor.
         * @param {string} content - The HTML content to clean.
         * @returns {string} The cleaned HTML content.
         */
        function cleanHtmlForRichTextDisplay(content) {
            // Ensure content passed to rich text editor is also decoded
            return decodeHtmlEntities(content);
        }

        /**
         * Applies URL cleaning to HTML content.
         * Converts specific absolute URLs to relative paths and removes target/rel attributes from <a> tags.
         * Also removes <a> tags that ONLY contain a name attribute (i.e., no href).
         * @param {string} htmlString - The HTML content to clean.
         * @returns {string} The cleaned HTML content.
         */
        function applyUrlCleaning(htmlString) {
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = htmlString;

            const urlMappings = [
                { old: 'https://canada-preview.adobecqms.net/en/treasury-board-secretariat', new: '/content/canadasite/en/treasury-board-secretariat' },
                { old: 'https://canada-preview.adobecqms.net/fr/secretariat-conseil-tresor', new: '/content/canadasite/fr/secretariat-conseil-tresor' },
                { old: 'https://canada-preview.adobecqms.net/en/government', new: '/content/canadasite/en/government' },
                { old: 'https://canada-preview.adobecqms.net/fr/gouvernement', new: '/content/canadasite/fr/gouvernement' },
                { old: 'https://www.canada.ca/en/treasury-board-secretariat', new: '/content/canadasite/en/treasury-board-secretariat' },
                { old: 'https://www.canada.ca/fr/secretariat-conseil-tresor', new: '/content/canadasite/fr/secretaria-conseil-tresor' },
                { old: 'https://www.canada.ca/en/government', new: '/content/canadasite/en/government' },
                { old: 'https://www.canada.ca/fr/gouvernement', new: '/content/canadasite/fr/gouvernement' }
            ];

            // Patterns to prepend with /content/canadasite
            const prependPatterns = [
                '/en/treasury-board-secretariat', 'en/treasury-board-secretariat',
                '/fr/secretariat-conseil-tresor', 'fr/secretariat-conseil-tresor',
                '/en/government', 'en/government',
                '/fr/gouvernement', 'fr/gouvernement'
            ];

            const aElements = tempDiv.querySelectorAll('a');
            aElements.forEach(a => {
                let href = a.getAttribute('href');
                const name = a.getAttribute('name');

                // Case 1: Remove <a> tags that ONLY contain a name attribute (no href)
                if (name && !href) {
                    const parent = a.parentNode;
                    if (parent) {
                        // Move children out of the <a> tag
                        while (a.firstChild) {
                            parent.insertBefore(a.firstChild, a);
                        }
                        // Remove the <a> tag itself
                        parent.removeChild(a);
                    }
                    return; // Skip further processing for this <a> tag
                }

                // Case 2: Process <a> tags with href
                if (href) {
                    // Handle Outlook Safelinks
                    if (href.startsWith('https://can01.safelinks.protection.outlook.com')) {
                        try {
                            const urlObj = new URL(href);
                            const actualUrlParam = urlObj.searchParams.get('url');
                            if (actualUrlParam) {
                                // Decode the actual URL parameter to get the clean link
                                href = decodeURIComponent(actualUrlParam);
                                a.setAttribute('href', href);
                            }
                        } catch (e) {
                            console.error("Error parsing Outlook Safelink URL:", e);
                            // Fallback: If parsing fails, keep the original safelink or remove it
                            // For now, we'll just keep the original href if parsing fails.
                        }
                    }

                    // Rule: Prepend /content/canadasite to specific relative links
                    let prepended = false;
                    for (const pattern of prependPatterns) {
                        if (href.startsWith(pattern)) {
                            if (href.startsWith('/')) {
                                href = '/content/canadasite' + href;
                            } else {
                                href = '/content/canadasite/' + href;
                            }
                            a.setAttribute('href', href);
                            prepended = true;
                            break; // Stop after the first match
                        }
                    }

                    // If already prepended, skip other URL conversions for this link
                    if (prepended) {
                        // Remove target attribute
                        if (a.hasAttribute('target')) {
                            a.removeAttribute('target');
                        }

                        // Remove rel attribute
                        if (a.hasAttribute('rel')) {
                            a.removeAttribute('rel');
                        }
                        return;
                    }

                    // Specific handling for "/content/canadasite" or "/content/dam" links
                    if (href.includes('/content/canadasite') || href.includes('/content/dam')) {
                        const contentPath = href.includes('/content/canadasite') ? '/content/canadasite' : '/content/dam';
                        const contentIndex = href.indexOf(contentPath);
                        if (contentIndex !== 0) {
                            href = href.substring(contentIndex);
                        }
                        a.setAttribute('href', href);
                    } else {
                        // Convert other URLs using existing mappings
                        for (const mapping of urlMappings) {
                            if (href.startsWith(mapping.old)) {
                                href = href.replace(mapping.old, mapping.new);
                                a.setAttribute('href', href);
                                break; // Stop after the first match
                            }
                        }
                    }
                }

                // Remove target attribute
                if (a.hasAttribute('target')) {
                    a.removeAttribute('target');
                }

                // Remove rel attribute
                if (a.hasAttribute('rel')) {
                    a.removeAttribute('rel');
                }
            });

            return tempDiv.innerHTML;
        }

        /**
         * Applies auto-spacing and cleans multiple <br> tags in HTML content.
         * Includes new rules for non-breaking spaces and empty tag removal/replacement.
         * Also trims leading/trailing spaces and non-breaking spaces within <p>, heading, and <li> tags.
         * @param {string} htmlString - The HTML content to clean.
         * @returns {string} The cleaned HTML content.
         */
        function applyAutoSpacing(htmlString) {
            const parser = new DOMParser();
            let doc = parser.parseFromString(htmlString, 'text/html');
            const body = doc.body;

            // 1. Unwrap <div> and <span> elements if they have no attributes.
            const elementsToUnwrap = Array.from(body.querySelectorAll('div, span'));
            elementsToUnwrap.forEach(element => {
                if (element.attributes.length === 0) {
                    const parent = element.parentNode;
                    if (parent) {
                        while (element.firstChild) {
                            parent.insertBefore(element.firstChild, element);
                        }
                        parent.removeChild(element);
                    }
                }
            });

            // 2. Handle <span style="mso-spacerun: yes"> tags (existing logic, still relevant)
            const spacerunSpans = body.querySelectorAll('span[style*="mso-spacerun: yes"]');
            spacerunSpans.forEach(span => {
                const parent = span.parentNode;
                if (parent) {
                    // Check if the span's text content contains a normal space
                    if (span.textContent.includes(' ')) {
                        // Replace the span with a single normal space
                        parent.replaceChild(doc.createTextNode(' '), span);
                    } else {
                        // Remove the span entirely if it's not containing a normal space
                        parent.removeChild(span);
                    }
                }
            });

            // Re-serialize and re-parse to handle previous DOM manipulations affecting string content for regex
            let cleanedHtml = body.innerHTML;
            doc = parser.parseFromString(cleanedHtml, 'text/html'); // Re-parse after initial DOM changes
            const currentBody = doc.body; // Use current body reference

            // 3. Condense multiple non-breaking spaces (&#160; or its Unicode char)
            // Replace multiple &#160; sequences (numeric or named entity)
            cleanedHtml = cleanedHtml.replace(/(?:&#160;|\u00A0|&nbsp;){2,}/gi, '&#160;');

            // 4. Clean non-breaking spaces with normal spaces to their left/right
            // Replace sequences like ' &#160;' with '&#160;'
            cleanedHtml = cleanedHtml.replace(/\s+(&#160;|\u00A0|&nbsp;)/gi, '&#160;');
            // Replace sequences like '&#160; ' with '&#160;'
            cleanedHtml = cleanedHtml.replace(/(&#160;|\u00A0|&nbsp;)\s+/gi, '&#160;');


            // 5. Replace sequences of two or more <br> tags (with optional whitespace) with </p><p> (existing logic)
            cleanedHtml = cleanedHtml.replace(/(<br\s*\/?>\s*){2,}/gi, '</p><p>');

            // 6. Completely remove <br clear="all"> and <br clear="ALL">
            cleanedHtml = cleanedHtml.replace(/<br\s+clear=["']?(all|ALL)["']?\s*\/?>/gi, '');


            // Re-parse to work with DOM for empty tag rules and other final cleanups
            doc.body.innerHTML = cleanedHtml;
            const finalBody = doc.body; // Use final body reference after re-parsing

            // 7. Remove/Replace empty tags
            const elementsToCheckForEmptiness = Array.from(finalBody.querySelectorAll('p, li, div, span, strong, em, u, b, i, section'));

            // Process in reverse to avoid issues with DOM changes affecting iteration
            for (let i = elementsToCheckForEmptiness.length - 1; i >= 0; i--) {
                const element = elementsToCheckForEmptiness[i];
                const tagName = element.tagName.toLowerCase();
                const trimmedContent = element.innerHTML.trim();
                const hasChildren = element.children.length > 0;
                const hasTextContent = element.textContent.trim().length > 0; // Check real text content
                const containsOnlyNBSP = (trimmedContent === '&#160;' || trimmedContent === '&nbsp;' || trimmedContent === '\u00A0');
                const containsOnlySpace = (trimmedContent === ' ');

                // Rule for <p> tags: remove only if outside a table
                if (tagName === 'p') {
                    const isInsideTable = element.closest('table');
                    if (!isInsideTable && (trimmedContent === '' || containsOnlyNBSP)) {
                        if (element.parentNode) {
                            element.parentNode.removeChild(element);
                        }
                    } else if (!isInsideTable && containsOnlySpace) {
                        // For <p> with single space, replace with text node of space
                        if (element.parentNode) {
                             element.parentNode.replaceChild(doc.createTextNode(' '), element);
                        }
                    }
                }
                // Rules for other tags: remove if empty or contains only NBSP, replace with space if contains only space
                else {
                    if (trimmedContent === '' || containsOnlyNBSP) {
                        if (element.parentNode) {
                            element.parentNode.removeChild(element);
                        }
                    } else if (containsOnlySpace) {
                        if (element.parentNode) {
                            element.parentNode.replaceChild(doc.createTextNode(' '), element);
                        }
                    }
                }
            }

            // --- New: Trim leading/trailing spaces and non-breaking spaces for <p>, heading, and <li> tags ---
            const elementsToTrim = finalBody.querySelectorAll('p, h1, h2, h3, h4, h5, h6, li');
            elementsToTrim.forEach(element => {
                let currentHtml = element.innerHTML;

                // Regex to match leading/trailing spaces, tabs, newlines, and &nbsp; entities
                // (?:&nbsp;|\s) ensures both &#160; and literal spaces are covered.
                // It's important to use &nbsp; in regex for string manipulation, as innerHTML might return it as such.
                currentHtml = currentHtml.replace(/^(?:&nbsp;|\s|&#160;|\u00A0)+/, ''); // Remove leading
                currentHtml = currentHtml.replace(/(?:&nbsp;|\s|&#160;|\u00A0)+$/, ''); // Remove trailing

                element.innerHTML = currentHtml;
            });
            // --- End of New Trim Logic ---

            return finalBody.innerHTML;
        }

        /**
         * Converts single <br> tags into paragraph breaks (</p><p>) while ignoring <br> tags within tables.
         * This simplified version does not attempt to preserve inline element nesting across the break.
         * @param {string} htmlString - The HTML content to process.
         * @returns {string} The processed HTML content.
         */
        function applyCleanSingleBreaks(htmlString) {
            const parser = new DOMParser();
            const doc = parser.parseFromString(htmlString, 'text/html');
            const brElements = Array.from(doc.querySelectorAll('br')); 

            // Process elements in reverse order to avoid issues with DOM manipulation affecting iteration
            for (let i = brElements.length - 1; i >= 0; i--) {
                const br = brElements[i];

                // Check if br still exists in the DOM and has a parent
                if (!br || !br.parentNode) {
                    continue; 
                }

                let currentParent = br.parentNode;
                let isInsideTable = false;
                // Traverse up the DOM tree to check if the <br> is inside a <table>
                while (currentParent && currentParent !== doc.body) {
                    if (currentParent.tagName && currentParent.tagName.toLowerCase() === 'table') {
                        isInsideTable = true;
                        break;
                    }
                    currentParent = currentParent.parentNode;
                }

                if (isInsideTable) {
                    continue; // Skip this <br> if it's inside a table
                }

                // Create a new paragraph element
                const newParagraph = doc.createElement('p');
                
                // Move all siblings after the <br> into the new paragraph
                while (br.nextSibling) {
                    newParagraph.appendChild(br.nextSibling);
                }

                // Insert the new paragraph after the original parent of the <br>
                // This effectively closes the current paragraph and starts a new one.
                if (br.parentNode.parentNode) {
                    br.parentNode.parentNode.insertBefore(newParagraph, br.parentNode.nextSibling);
                } else {
                    // Fallback for very unusual structures where parentNode.parentNode is null
                    doc.body.appendChild(newParagraph);
                }
                
                // Remove the <br> itself
                br.parentNode.removeChild(br);
            }

            return doc.body.innerHTML;
        }


        /**
         * Removes <p>&nbsp;</p> tags that are not within <table> or <li> tags.
         * @param {string} htmlString - The HTML content to clean.
         * @returns {string} The cleaned HTML content.
         */
        function removeEmptyParagraphsOutsideTablesAndLists(htmlString) {
            const parser = new DOMParser();
            const doc = parser.parseFromString(htmlString, 'text/html');
            const paragraphs = doc.querySelectorAll('p');

            for (let i = paragraphs.length - 1; i >= 0; i--) {
                const p = paragraphs[i];
                // Check if the paragraph contains only &nbsp; or is effectively empty after decoding
                // After decodeHtmlEntities, &nbsp; becomes a non-breaking space character (\u00A0)
                const containsOnlyNBSP = p.innerHTML.trim() === '&nbsp;' || p.innerHTML.trim() === '\u00A0';

                if (containsOnlyNBSP) {
                    let parent = p.parentElement;
                    let isInsideTableOrList = false;
                    while (parent) {
                        if (parent.tagName === 'TABLE' || parent.tagName === 'LI') {
                            isInsideTableOrList = true;
                            break;
                        }
                        parent = parent.parentElement;
                    }

                    if (!isInsideTableOrList) {
                        p.parentNode.removeChild(p);
                    }
                }
            }
            return doc.body.innerHTML;
        }

        /**
         * Removes empty <p> tags and <p> tags that contain only a single non-breaking space,
         * specifically if they have a class starting with "Mso" and are not within a table.
         * @param {string} htmlString - The HTML content to clean.
         * @returns {string} The cleaned HTML content.
         */
        function removeEmptyParagraphs(htmlString) {
            const parser = new DOMParser();
            const doc = parser.parseFromString(htmlString, 'text/html');
            const paragraphs = doc.querySelectorAll('p');

            for (let i = paragraphs.length - 1; i >= 0; i--) {
                const p = paragraphs[i];
                
                // Condition 1: Check if the paragraph is empty or contains only a non-breaking space
                const trimmedContent = p.innerHTML.trim();
                const isEmptyOrNBSP = trimmedContent === '' || trimmedContent === '&nbsp;' || trimmedContent === '\u00A0';

                // Condition 2: Check if the paragraph has a class attribute starting with "Mso"
                const hasMsoClass = p.classList.length > 0 && p.className.startsWith('Mso');

                // Condition 3: Check if the paragraph is NOT within a table
                const isInsideTable = p.closest('table');

                if (isEmptyOrNBSP && hasMsoClass && !isInsideTable) {
                    if (p.parentNode) {
                        p.parentNode.removeChild(p);
                    }
                }
            }
            return doc.body.innerHTML;
        }

        /**
         * Removes inline width and height styles from all elements in the HTML content.
         * @param {string} htmlString - The HTML content to clean.
         * @returns {string} The cleaned HTML content.
         */
        function removeInlineWidthHeightStyles(htmlString) {
            const parser = new DOMParser();
            const doc = parser.parseFromString(htmlString, 'text/html');
            const allElements = doc.querySelectorAll('*');

            allElements.forEach(element => {
                if (element.hasAttribute('style')) {
                    let style = element.getAttribute('style');
                    // Remove width: ...; and height: ...;
                    style = style.replace(/width:\s*[^;]+;?/gi, '');
                    style = style.replace(/height:\s*[^;]+;?/gi, '');
                    // Clean up extra spaces or semicolons
                    style = style.replace(/;{2,}/g, ';').trim();
                    if (style.endsWith(';')) {
                        style = style.slice(0, -1);
                    }

                    if (style) {
                        element.setAttribute('style', style);
                    } else {
                        element.removeAttribute('style');
                    }
                }
            });
            return doc.body.innerHTML;
        }

        /**
         * Converts common character entities and named entities to their numeric HTML entity equivalents.
         * This function operates on an HTML string, parsing it to a temporary DOM, modifying text nodes,
         * and then serializing it back to a string, ensuring numeric entities are preserved.
         * @param {string} htmlString - The HTML string to process.
         * @returns {string} The processed HTML string with numeric entities.
         */
        function convertAllEntitiesToNumeric(htmlString) {
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = htmlString; // This parses entities to characters

            const walker = document.createTreeWalker(
                tempDiv,
                NodeFilter.SHOW_TEXT,
                {
                    acceptNode: function(textNode) {
                        let parent = textNode.parentNode;
                        while (parent) {
                            const tagName = parent.tagName ? parent.tagName.toLowerCase() : '';
                            if (tagName === 'script' || tagName === 'style' || tagName === 'time') {
                                return NodeFilter.FILTER_REJECT;
                            }
                            parent = parent.parentNode;
                        }
                        return NodeFilter.FILTER_ACCEPT;
                    }
                },
                false
            );

            let currentNode;
            const textNodesToProcess = [];
            while (currentNode = walker.nextNode()) {
                textNodesToProcess.push(currentNode);
            }

            textNodesToProcess.forEach(textNode => {
                let text = textNode.nodeValue;
                // Replace specific named entities/characters with their numeric character references
                text = text.replace(/â€™/g, '&#8217;');     // literal â€™
                text = text.replace(/&rsquo;/g, '&#8217;'); // &rsquo;
                text = text.replace(/â€œ/g, '&#8220;');     // literal â€œ
                text = text.replace(/&ldquo;/g, '&#8220;'); // &ldquo;
                text = text.replace(/â€/g, '&#8221;');     // literal â€
                text = text.replace(/&rdquo;/g, '&#8221;'); // &rdquo;
                text = text.replace(/Â«/g, '&#171;');     // literal Â«
                text = text.replace(/&laquo;/g, '&#171;'); // &laquo;
                text = text.replace(/Â»/g, '&#187;');     // literal Â»
                text = text.replace(/&raquo;/g, '&#187;'); // &raquo;
                text = text.replace(/\u00A0/g, '&#160;'); // This converts literal NBSP char to numeric entity
                text = text.replace(/&nbsp;/g, '&#160;'); // This handles named NBSP entity to numeric

                textNode.nodeValue = text;
            });

            let processedHtml = tempDiv.innerHTML; // This re-serializes characters to entities

            // Final string-based replacements to ensure numeric entities are explicitly present
            // This is a safeguard against browser's innerHTML serialization re-converting entities.
            processedHtml = processedHtml.replace(/&nbsp;/g, '&#160;');
            processedHtml = processedHtml.replace(/&rsquo;/g, '&#8217;');
            processedHtml = processedHtml.replace(/&ldquo;/g, '&#8220;');
            processedHtml = processedHtml.replace(/&rdquo;/g, '&#8221;');
            processedHtml = processedHtml.replace(/&laquo;/g, '&#171;');
            processedHtml = processedHtml.replace(/&raquo;/g, '&#187;');

            // Handle double encoding if it occurs (e.g., &amp;#160; -> &#160;)
            processedHtml = processedHtml.replace(/&amp;#(\d+);/g, '&#$1;');

            return processedHtml;
        }

        /**
         * Recursively cleans and preserves only specified HTML content from a source DOM node.
         * Disallowed tags are unwrapped, preserving their allowed children.
         * This function is used for both footnote content and general MSO problematic content.
         * @param {HTMLElement} sourceNode - The DOM node whose children are to be filtered.
         * @param {Document} doc - The document object to create new elements.
         * @returns {string} The HTML string containing only the preserved content.
         */
        function cleanAndPreserveAllowedContent(sourceNode, doc) {
            let tempContainer = doc.createElement('div');

            Array.from(sourceNode.childNodes).forEach(child => {
                if (child.nodeType === Node.TEXT_NODE) {
                    // Always preserve text nodes (including character entities which are parsed into text nodes)
                    tempContainer.appendChild(child.cloneNode(true));
                } else if (child.nodeType === Node.ELEMENT_NODE) {
                    const tagName = child.tagName.toLowerCase();

                    // Function to check if class or id contains disallowed patterns (case-sensitive)
                    const containsDisallowedPattern = (element) => {
                        const elemClassAttr = element.getAttribute('class');
                        if (elemClassAttr) {
                            const classes = elemClassAttr.split(/\s+/);
                            for (const cls of classes) {
                                if (cls.includes('Mso') || cls.includes('Word') || cls.includes('BCX0')) {
                                    return true;
                                }
                            }
                        }
                        const elemIdAttr = element.getAttribute('id');
                        if (elemIdAttr) {
                            if (elemIdAttr.includes('Mso') || elemIdAttr.includes('Word') || elemIdAttr.includes('BCX0')) {
                                return true;
                            }
                        }
                        return false;
                    };

                    const alwaysPreservedTags = [
                        'p', 'section', 'blockquote', 'article', 'ol', 'ul', 'li',
                        'figure', 'caption', 'details', 'summary',
                        'strong', 'u', 'em', 'i', 'b', 'br', 'mark', 'sup', 'sub', 'img',
                        'h1', 'h2', 'h3', 'h4', 'h5', 'h6' // Added heading tags
                    ];

                    const tableTags = ['table', 'thead', 'tbody', 'tfoot', 'tr', 'th', 'td'];

                    if (alwaysPreservedTags.includes(tagName) || tableTags.includes(tagName)) {
                        // These tags are always preserved, recursively clean their content
                        const clonedChild = child.cloneNode(false);
                        clonedChild.innerHTML = cleanAndPreserveAllowedContent(child, doc);
                        tempContainer.appendChild(clonedChild);
                    } else if (tagName === 'a' && child.hasAttribute('href')) {
                        // <a> tags only if they have an href
                        const clonedChild = child.cloneNode(false);
                        clonedChild.innerHTML = cleanAndPreserveAllowedContent(child, doc); // Still clean content inside
                        tempContainer.appendChild(clonedChild);
                    } else if (tagName === 'div') {
                        // <div> ONLY if they have a class or ID that DON'T contain "Mso" or "Word" or "BCX0"
                        if ((child.hasAttribute('class') || child.hasAttribute('id')) && !containsDisallowedPattern(child)) {
                            const clonedChild = child.cloneNode(false);
                            clonedChild.innerHTML = cleanAndPreserveAllowedContent(child, doc);
                            tempContainer.appendChild(clonedChild);
                        } else {
                            // Unwrap if it doesn't meet the criteria
                            const unwrappedContentHtml = cleanAndPreserveAllowedContent(child, doc);
                            const tempUnwrapDiv = doc.createElement('div'); // Temporary div to parse HTML string
                            tempUnwrapDiv.innerHTML = unwrappedContentHtml;
                            while (tempUnwrapDiv.firstChild) {
                                tempContainer.appendChild(tempUnwrapDiv.firstChild);
                            }
                        }
                    } else if (tagName === 'span') {
                        // <span> ONLY if they have a class or ID that DON'T match the ones mentioned (Mso/Word/BCX0)
                        if ((child.hasAttribute('class') || child.hasAttribute('id')) && !containsDisallowedPattern(child)) {
                            const clonedChild = child.cloneNode(false);
                            clonedChild.innerHTML = cleanAndPreserveAllowedContent(child, doc);
                            tempContainer.appendChild(clonedChild);
                        } else {
                            // Unwrap if it doesn't meet the criteria
                            const unwrappedContentHtml = cleanAndPreserveAllowedContent(child, doc);
                            const tempUnwrapDiv = doc.createElement('div'); // Temporary div to parse HTML string
                            tempUnwrapDiv.innerHTML = unwrappedContentHtml;
                            while (tempUnwrapDiv.firstChild) {
                                tempContainer.appendChild(tempUnwrapDiv.firstChild);
                            }
                        }
                    } else {
                        // For any other element not explicitly allowed, unwrap its content
                        const unwrappedContentHtml = cleanAndPreserveAllowedContent(child, doc);
                        const tempUnwrapDiv = doc.createElement('div'); // Temporary div to parse HTML string
                        tempUnwrapDiv.innerHTML = unwrappedContentHtml;
                        while (tempUnwrapDiv.firstChild) {
                            tempContainer.appendChild(tempUnwrapDiv.firstChild);
                        }
                    }
                }
            });
            return tempContainer.innerHTML;
        }

        /**
         * Processes <p> tags with "MsoListParagraph" class, converting them to <ul><li> structures.
         * @param {string} htmlString - The HTML content to clean.
         * @returns {string} The cleaned HTML content.
         */
        function applyCleanLists(htmlString) {
            const parser = new DOMParser();
            const doc = parser.parseFromString(htmlString, 'text/html');
            const body = doc.body;

            // Helper to get the level from style attribute for lists
            function getLevel(styleAttr) {
                if (!styleAttr) return null;
                const match = styleAttr.match(/level(\d+)/);
                return match ? parseInt(match[1], 10) : null;
            }

            // Helper to extract allowed content for lists
            function extractAllowedContentForLists(sourceNode) {
                let contentHtml = '';
                const childrenToProcess = Array.from(sourceNode.childNodes);

                childrenToProcess.forEach(child => {
                    if (child.nodeType === Node.ELEMENT_NODE && child.tagName.toLowerCase() === 'span' && child.hasAttribute('style') && child.getAttribute('style').includes('mso-list: Ignore')) {
                        return;
                    }

                    if (child.nodeType === Node.TEXT_NODE) {
                        contentHtml += child.nodeValue;
                    } else if (child.nodeType === Node.ELEMENT_NODE) {
                        const tagName = child.tagName.toLowerCase();
                        const hasClassOrId = child.hasAttribute('class') || child.hasAttribute('id');

                        // Use the containsDisallowedPattern from cleanAndPreserveAllowedContent for consistent MSO/Word/BCX0 checks
                        const containsDisallowedPattern = (element) => {
                            const elemClassAttr = element.getAttribute('class');
                            if (elemClassAttr) {
                                const classes = elemClassAttr.split(/\s+/);
                                for (const cls of classes) {
                                    if (cls.includes('Mso') || cls.includes('Word') || cls.includes('BCX0')) {
                                        return true;
                                    }
                                }
                            }
                            const elemIdAttr = element.getAttribute('id');
                            if (elemIdAttr) {
                                if (elemIdAttr.includes('Mso') || elemIdAttr.includes('Word') || elemIdAttr.includes('BCX0')) {
                                    return true;
                                }
                            }
                            return false;
                        };

                        if (tagName === 'br' || tagName === 'strong' || tagName === 'a' || tagName === 'em' || tagName === 'u' || tagName === 'sup' || tagName === 'sub' || tagName === 'section') {
                            contentHtml += child.outerHTML;
                        } else if ((tagName === 'span' || tagName === 'div') && hasClassOrId && !containsDisallowedPattern(child)) {
                            const clonedChild = child.cloneNode(false);
                            clonedChild.innerHTML = extractAllowedContentForLists(clonedChild);
                            contentHtml += clonedChild.outerHTML;
                        } else if (tagName === 'a' && child.hasAttribute('href')) { // Explicitly handle <a> with href
                            contentHtml += child.outerHTML;
                        }
                        else {
                            contentHtml += extractAllowedContentForLists(child);
                        }
                    }
                });
                return contentHtml;
            }

            // Helper to determine list type
            function detectListType(pElement) {
                const msoListIgnoreSpan = pElement.querySelector('span[style*="mso-list: Ignore"]');
                if (msoListIgnoreSpan) {
                    const bulletText = msoListIgnoreSpan.textContent.trim();
                    if (/^\d+(\.\d+)+[\.\)]*$/.test(bulletText)) {
                        return 'complex-bullet';
                    }
                    if (/^[A-Za-z](\.\d+)+[\.\)]*$/.test(bulletText)) {
                        return 'complex-bullet';
                    }
                    if (/^\d+[\.\)]$/.test(bulletText)) {
                        return 'ordered-numeric';
                    }
                    if (/^[a-z][\.\)]$/.test(bulletText)) {
                        return 'ordered-alpha';
                    }
                }
                return 'unordered';
            }

            const paragraphs = Array.from(body.querySelectorAll('p'));
            const paragraphsToReplace = new Map();
            const paragraphsToRemove = new Set();

            for (let i = 0; i < paragraphs.length; i++) {
                const p = paragraphs[i];
                const classList = Array.from(p.classList);
                const isMsoListParagraph = classList.some(cls =>
                    cls === 'MsoListParagraphCxSpFirst' ||
                    cls === 'MsoListParagraphCxSpMiddle' ||
                    cls === 'MsoListParagraphCxSpLast' ||
                    cls === 'MsoListParagraph'
                );

                if (paragraphsToRemove.has(p)) {
                    continue;
                }

                if (isMsoListParagraph) {
                    const pStyle = p.getAttribute('style') || '';
                    const level = getLevel(pStyle);

                    if (isMsoListParagraph && level === null) {
                        p.removeAttribute('class');
                        p.classList.add('MsoNormal');
                        continue;
                    }

                    const msoListIgnoreSpan = p.querySelector('span[style*="mso-list: Ignore"]');
                    let bulletTextToPrepend = '';
                    let listType = 'unordered';

                    if (msoListIgnoreSpan) {
                        bulletTextToPrepend = msoListIgnoreSpan.textContent.trim();
                        listType = detectListType(p);
                        msoListIgnoreSpan.parentNode.removeChild(msoListIgnoreSpan);
                    }

                    let newRootListElement;

                    if (listType === 'ordered-numeric') {
                        newRootListElement = doc.createElement('ol');
                    } else if (listType === 'ordered-alpha') {
                        newRootListElement = doc.createElement('ol');
                        newRootListElement.classList.add('lst-lwr-alph');
                    } else {
                        newRootListElement = doc.createElement('ul');
                    }

                    let currentListStack = [newRootListElement];
                    let currentParentList = newRootListElement;

                    const li = doc.createElement('li');
                    let listItemContent = extractAllowedContentForLists(p);

                    if (listType === 'complex-bullet') {
                        li.innerHTML = bulletTextToPrepend + ' ' + listItemContent;
                    } else {
                        li.innerHTML = listItemContent;
                    }
                    currentParentList.appendChild(li);
                    paragraphsToReplace.set(p, newRootListElement);

                    let nextSibling = p.nextElementSibling;
                    let currentSequenceIndex = i + 1;

                    while (nextSibling && nextSibling.nodeType === Node.ELEMENT_NODE && nextSibling.tagName.toLowerCase() === 'p') {
                        const nextP = nextSibling;
                        const nextPClassList = Array.from(nextP.classList);
                        const isNextPListParagraph = nextPClassList.some(cls =>
                            cls === 'MsoListParagraphCxSpFirst' ||
                            cls === 'MsoListParagraphCxSpMiddle' ||
                            cls === 'MsoListParagraphCxSpLast' ||
                            cls === 'MsoListParagraph'
                        );

                        const nextPStyle = nextP.getAttribute('style') || '';
                        const nextLevelCheck = getLevel(nextPStyle);
                        if (isNextPListParagraph && nextLevelCheck === null) {
                            nextP.removeAttribute('class');
                            nextP.classList.add('MsoNormal');
                            break;
                        }

                        if (isNextPListParagraph) {
                            const nextLevel = getLevel(nextP.getAttribute('style') || '');
                            let currentDepth = currentListStack.length;

                            const nextMsoListIgnoreSpan = nextP.querySelector('span[style*="mso-list: Ignore"]');
                            let nextBulletTextToPrepend = '';
                            let nextListType = 'unordered';

                            if (nextMsoListIgnoreSpan) {
                                nextBulletTextToPrepend = nextMsoListIgnoreSpan.textContent.trim();
                                nextListType = detectListType(nextP);
                                nextMsoListIgnoreSpan.parentNode.removeChild(nextMsoListIgnoreSpan);
                            }

                            if (nextLevel > currentDepth) {
                                let nestedListElement;
                                
                                if (nextListType === 'ordered-numeric') {
                                    nestedListElement = doc.createElement('ol');
                                } else if (nextListType === 'ordered-alpha') {
                                    nestedListElement = doc.createElement('ol');
                                    nestedListElement.classList.add('lst-lwr-alph');
                                } else {
                                    nestedListElement = doc.createElement('ul');
                                }

                                for (let k = currentDepth; k > nextLevel; k--) {
                                    currentListStack.pop();
                                    currentParentList = currentListStack[currentListStack.length - 1];
                                }
                                while (currentListStack.length < nextLevel) {
                                     let targetLi = currentParentList.lastElementChild;
                                     if (!targetLi || targetLi.tagName.toLowerCase() !== 'li') {
                                         targetLi = doc.createElement('li');
                                         currentParentList.appendChild(targetLi);
                                     }
                                     let newNestedList;
                                     if (currentListStack.length + 1 === nextLevel) {
                                         if (nextListType === 'ordered-numeric') {
                                             newNestedList = doc.createElement('ol');
                                         } else if (nextListType === 'ordered-alpha') {
                                             newNestedList = doc.createElement('ol');
                                             newNestedList.classList.add('lst-lwr-alph');
                                         } else {
                                             newNestedList = doc.createElement('ul');
                                         }
                                     } else {
                                         newNestedList = doc.createElement('ul');
                                     }
                                     targetLi.appendChild(newNestedList);
                                     currentListStack.push(newNestedList);
                                     currentParentList = newNestedList;
                                 }

                            } else if (nextLevel < currentDepth) {
                                for (let k = currentDepth; k > nextLevel; k--) {
                                    currentListStack.pop();
                                    currentParentList = currentListStack[currentListStack.length - 1];
                                }
                            }

                            const nextLi = doc.createElement('li');
                            let nextListItemContent = extractAllowedContentForLists(nextP);
                            if (nextListType === 'complex-bullet') {
                                nextLi.innerHTML = nextBulletTextToPrepend + ' ' + nextListItemContent;
                            } else {
                                nextLi.innerHTML = nextListItemContent;
                            }
                            currentParentList.appendChild(nextLi);
                            paragraphsToRemove.add(nextP);

                            nextSibling = nextP.nextElementSibling;
                            currentSequenceIndex++;
                        } else {
                            break;
                        }
                    }
                    i = currentSequenceIndex - 1;
                }
            }

            paragraphs.forEach(p => {
                if (paragraphsToReplace.has(p)) {
                    if (p.parentNode) {
                        p.parentNode.replaceChild(paragraphsToReplace.get(p), p);
                    }
                } else if (paragraphsToRemove.has(p)) {
                    if (p.parentNode) {
                        p.parentNode.removeChild(p);
                    }
                }
            });

            return doc.body.innerHTML;
        }

        /**
         * Applies basic cleaning to tables and their elements.
         * This includes removing colgroup/col tags, cleaning table/td/th attributes,
         * and handling paragraphs within table cells.
         * @param {string} htmlString - The HTML content to clean.
         * @returns {string} The cleaned HTML content.
         */
        function applyCleanTablesBasic(htmlString) {
            const parser = new DOMParser();
            const doc = parser.parseFromString(htmlString, 'text/html');
            const body = doc.body;

            // Remove colgroup and col elements
            const colgroupElements = doc.querySelectorAll('colgroup');
            for (let i = colgroupElements.length - 1; i >= 0; i--) {
                if (colgroupElements[i].parentNode) {
                    colgroupElements[i].parentNode.removeChild(colgroupElements[i]);
                }
            }

            const colElements = doc.querySelectorAll('col');
            for (let i = colElements.length - 1; i >= 0; i--) {
                if (colElements[i].parentNode) {
                    colElements[i].parentNode.removeChild(colElements[i]);
                }
            }

            // Clean attributes from table and its structural tags (thead, tbody, tfoot, tr, th, td)
            const tableRelatedTags = doc.querySelectorAll('table, thead, tbody, tfoot, tr, th, td');
            tableRelatedTags.forEach(element => {
                const attributesToKeep = ['rowspan', 'colspan', 'class', 'id', 'headers', 'scope'];
                const attributesToRemove = [];
                for (let j = 0; j < element.attributes.length; j++) {
                    const attr = element.attributes[j];
                    if (!attributesToKeep.includes(attr.name.toLowerCase())) {
                        attributesToRemove.push(attr.name);
                    }
                }
                attributesToRemove.forEach(attrName => {
                    element.removeAttribute(attrName);
                });
            });

            // Remove MsoTable class from tables
            doc.querySelectorAll('table').forEach(table => {
                const classAttr = table.getAttribute('class');
                if (classAttr && classAttr.includes('MsoTable')) {
                    table.removeAttribute('class');
                }
            });

            // Unwrap spans inside td with class^="xl"
            doc.querySelectorAll('table td[class^="xl"] span').forEach(span => {
                if (span.parentNode) {
                    while (span.firstChild) {
                        span.parentNode.insertBefore(span.firstChild, span);
                    }
                    span.parentNode.removeChild(span);
                }
            });

            // Remove class^="xl" from td elements
            doc.querySelectorAll('td').forEach(td => {
                const classAttr = td.getAttribute('class');
                if (classAttr && classAttr.startsWith('xl')) {
                    td.removeAttribute('class');
                }
            });

            // Clean paragraphs within tables: remove Mso/Aligned classes, inline styles, and convert align attribute to Tailwind classes
            doc.querySelectorAll('table p').forEach(p => {
                const parentCell = p.closest('td, th');

                if (parentCell) {
                    const classAttr = p.getAttribute('class');
                    if (classAttr && (classAttr.includes('Mso') || classAttr.includes('Aligned'))) {
                        p.removeAttribute('class');
                    }

                    if (p.hasAttribute('style')) {
                        p.removeAttribute('style');
                    }

                    const alignAttr = p.getAttribute('align');
                    if (alignAttr) {
                        p.removeAttribute('align');
                        let tailwindAlignClass = '';
                        switch (alignAttr.toLowerCase()) {
                            case 'left':
                                tailwindAlignClass = 'text-left';
                                break;
                            case 'center':
                                tailwindAlignClass = 'text-center';
                                break;
                            case 'right':
                                tailwindAlignClass = 'text-right';
                                break;
                        }
                        if (tailwindAlignClass) {
                            parentCell.classList.add(tailwindAlignClass);
                        }
                    }
                }
            });
            return doc.body.innerHTML;
        }

        /**
         * Applies cleaning for Microsoft Office specific code.
         * This function removes tags and their entire content if they have specific MSO-related attributes or hrefs.
         * Attributes targeted for removal: "mso-element: comment-list", "mso-element: endnote-list".
         * Hrefs targeted for removal: containing "#_msocom", "#_edn", or "#_ftn".
         * For "#_ftn" links, converts <a> to <sup><a> with only text content and href attribute.
         * Also transforms elements with "mso-element: footnote-list" style into <aside> with cleaned content.
         * Also removes content from and cleans attributes of elements with 'style' attribute or MSO/Word/BCX0 classes.
         * Additionally handles specific heading class cleanup, and attribute removal for non-table elements,
         * UL/OL tags, and LI tags with 'role' attributes.
         * Also now handles cleaning of file:// or data: img src attributes.
         * @param {string} htmlString - The HTML content to clean.
         * @returns {string} The cleaned HTML content.
         */
        function applyCleanMsoCode(htmlString) {
            const parser = new DOMParser();
            const doc = parser.parseFromString(htmlString, 'text/html');

            // --- Start of Clean IMGs Logic (Moved from applyCleanImgs) ---
            doc.querySelectorAll('img').forEach(img => {
                const src = img.getAttribute('src');
                if (src && (src.startsWith('file://') || src.startsWith('data:'))) {
                    const replacementDiv = doc.createElement('div');
                    replacementDiv.classList.add('clearfix');
                    const replacementMark = doc.createElement('mark');
                    replacementMark.textContent = 'IMAGE NOT IMPORTED';
                    replacementDiv.appendChild(replacementMark);
                    if (img.parentNode) {
                        img.parentNode.replaceChild(replacementDiv, img);
                    }
                }
            });
            // --- End of Clean IMGs Logic ---

            // Select elements with style containing "mso-element: comment-list" or "mso-element: endnote-list"
            const elementsToRemoveByStyle = doc.querySelectorAll('[style*="mso-element: comment-list"], [style*="mso-element: endnote-list"]');
            elementsToRemoveByStyle.forEach(element => {
                if (element.parentNode) {
                    element.parentNode.removeChild(element);
                }
            });

            // Select <a> elements with href containing "#_msocom" or "#_edn" and remove them completely
            const commentEndnoteLinks = doc.querySelectorAll('a[href*="#_msocom"], a[href*="#_edn"]');
            commentEndnoteLinks.forEach(link => {
                if (link.parentNode) {
                    link.parentNode.removeChild(link);
                }
            });

            // Process <a> tags with href containing "#_ftn" to ensure only one <sup> wrapper
            const footnoteLinks = Array.from(doc.querySelectorAll('a[href*="#_ftn"]')); // Convert to array to avoid live NodeList issues
            footnoteLinks.forEach(link => {
                const originalHref = link.getAttribute('href');
                const textContent = link.textContent;

                // Create the ideal new <a> tag, copying only necessary attributes
                const newCleanLink = doc.createElement('a');
                newCleanLink.setAttribute('href', originalHref);
                newCleanLink.textContent = textContent;

                // Create the ideal new <sup> tag
                const idealSupElement = doc.createElement('sup');
                idealSupElement.appendChild(newCleanLink);

                // Find the target element to replace. This could be the link itself
                // or an existing <sup> parent that solely contains the link (or other <sup>s leading to it).
                let elementToReplace = link;
                let currentParent = link.parentNode;

                while (currentParent && currentParent !== doc.body && currentParent.tagName.toLowerCase() === 'sup') {
                    // Check if this <sup> only contains the elementToReplace (which is the link or another sup)
                    // and no other significant content (like additional text nodes or other elements).
                    const children = Array.from(currentParent.childNodes).filter(n => n.nodeType === Node.ELEMENT_NODE || (n.nodeType === Node.TEXT_NODE && n.nodeValue.trim() !== ''));
                    
                    // If the <sup> has only one child and that child is our current elementToReplace (or nested <sup>),
                    // then this <sup> is an exclusive wrapper and we can move up.
                    if (children.length === 1 && children[0] === elementToReplace) {
                        elementToReplace = currentParent; // Move up to replace this <sup>
                        currentParent = elementToReplace.parentNode;
                    } else {
                        break; // This <sup> contains other content, stop here.
                    }
                }
                
                // Perform the replacement:
                // Replace the determined 'elementToReplace' (which could be the original <a>
                // or the outermost exclusively wrapping <sup>) with the 'idealSupElement'.
                if (elementToReplace.parentNode) {
                    elementToReplace.parentNode.replaceChild(idealSupElement, elementToReplace);
                }
            });

            // Process elements with "mso-element: footnote-list" in their style attribute
            const footnoteListElements = doc.querySelectorAll('[style*="mso-element: footnote-list"]');
            footnoteListElements.forEach(element => {
                if (element.parentNode) {
                    // Clean the content of the current element first, based on the preservation rules
                    const cleanedInnerHtml = cleanAndPreserveAllowedContent(element, doc);

                    // Create a new <aside> element
                    const asideElement = doc.createElement('aside');
                    asideElement.innerHTML = cleanedInnerHtml;

                    // Replace the original element with the new <aside>
                    element.parentNode.replaceChild(asideElement, element);
                }
            });

            // Process heading character tags
            // Find all elements that have a class like "Heading#Char" where # is 1-6
            const elementsWithHeadingClass = doc.querySelectorAll('[class*="Heading"]'); // Broad selection then filter

            // Convert to array to avoid issues with live NodeList during modifications
            Array.from(elementsWithHeadingClass).forEach(element => {
                const classAttr = element.getAttribute('class');
                if (!classAttr) return;

                const classes = classAttr.split(/\s+/);
                const headingCharClass = classes.find(cls => /^Heading[1-6]Char$/.test(cls));

                if (headingCharClass) {
                    const headingLevel = parseInt(headingCharClass.match(/\d/)[0], 10);
                    const parent = element.parentNode;

                    if (!parent) return;

                    // Unwrap the current element: move its children to its parent
                    while (element.firstChild) {
                        parent.insertBefore(element.firstChild, element);
                    }
                    element.parentNode.removeChild(element); // Remove the now empty element

                    const currentParent = parent; // This is the original parent after unwrapping

                    // If the original parent is NOT already a heading (h1-h6)
                    if (!/^H[1-6]$/i.test(currentParent.tagName)) {
                        const newHeadingTag = doc.createElement(`h${headingLevel}`);
                        
                        // Move *all* content of the original parent into the new heading tag
                        while (currentParent.firstChild) {
                            newHeadingTag.appendChild(currentParent.firstChild);
                        }

                        // Replace the original parent with the new heading tag
                        if (currentParent.parentNode) {
                            currentParent.parentNode.replaceChild(newHeadingTag, currentParent);
                        }
                    }
                    // If the original parent *was* already a heading, we've already unwrapped the span, so no further action needed.
                }
            });

            // NEW: Remove 'align' attribute from elements *outside* of tables
            doc.querySelectorAll('[align]').forEach(element => {
                if (!element.closest('table')) { // Check if the element is not inside a table
                    element.removeAttribute('align');
                }
            });

            // NEW: Remove 'type' and 'role' attributes from UL and OL tags
            doc.querySelectorAll('ul, ol').forEach(list => {
                list.removeAttribute('type');
                list.removeAttribute('role');
            });

            // NEW: Remove all attributes from LI tags if they have a 'role' attribute
            doc.querySelectorAll('li').forEach(li => {
                if (li.hasAttribute('role')) {
                    // Create an array of attribute names to remove
                    const attributesToRemove = Array.from(li.attributes).map(attr => attr.name);
                    attributesToRemove.forEach(attrName => {
                        li.removeAttribute(attrName);
                    });
                }
            });

            // NEW: Remove span tags with 'lang' attribute unless lang is 'en' or 'fr'
            doc.querySelectorAll('span[lang]').forEach(span => {
                const langAttr = span.getAttribute('lang');
                if (langAttr && langAttr.toLowerCase() !== 'en' && langAttr.toLowerCase() !== 'fr') {
                    // Unwrap the span: move its children to its parent
                    const parent = span.parentNode;
                    if (parent) {
                        while (span.firstChild) {
                            parent.insertBefore(span.firstChild, span);
                        }
                        parent.removeChild(span); // Remove the now empty span
                    }
                }
            });


            // Process all elements that have a style attribute or MSO/Word/BCX0 classes
            // Iterate in reverse to handle nested elements correctly without breaking the loop
            const allElements = Array.from(doc.querySelectorAll('*'));
            for (let i = allElements.length - 1; i >= 0; i--) {
                const element = allElements[i];

                // Skip html, head, body, script, style tags, and the aside tags just created
                const tagName = element.tagName.toLowerCase();
                if (['html', 'head', 'body', 'script', 'style', 'aside'].includes(tagName)) {
                    continue;
                }

                const hasStyle = element.hasAttribute('style');
                const classAttr = element.getAttribute('class') || '';
                const idAttr = element.getAttribute('id') || '';

                // Check if any class contains "Mso", "Word", or "BCX0" (case-sensitive)
                const hasMsoWordBcx0Class = classAttr.split(/\s+/).some(cls =>
                    cls.includes('Mso') || cls.includes('Word') || cls.includes('BCX0')
                );

                // Check if ID contains "Mso", "Word", or "BCX0" (case-sensitive)
                const hasMsoWordBcx0Id = idAttr.includes('Mso') || idAttr.includes('Word') || idAttr.includes('BCX0');

                // NEW: Check for classes that trigger complete unwrapping (eop, eoc, eocx, textrun, or any class containing "mso")
                const shouldUnwrapCompletely = classAttr.split(/\s+/).some(cls =>
                    cls.includes('eop') ||
                    cls.includes('eoc') ||
                    cls.includes('eocx') ||
                    cls.includes('mso') || // Broad check: any class containing "mso"
                    cls.includes('textrun')
                );

                if (shouldUnwrapCompletely) {
                    const parent = element.parentNode;
                    if (parent) {
                        // Move children out of the element
                        while (element.firstChild) {
                            parent.insertBefore(element.firstChild, element);
                        }
                        parent.removeChild(element); // Remove the now empty element
                    }
                    continue; // Continue to the next element in the loop after unwrapping
                }

                // Existing logic for cleaning attributes and content if not completely unwrapped
                if (hasStyle || hasMsoWordBcx0Class || hasMsoWordBcx0Id) {
                    // Get the cleaned innerHTML based on the preservation rules
                    const cleanedInnerHtml = cleanAndPreserveAllowedContent(element, doc);

                    // Replace the original content with the cleaned content
                    element.innerHTML = cleanedInnerHtml;

                    // Remove the style attribute
                    if (hasStyle) {
                        element.removeAttribute('style');
                    }

                    // Clean the class attribute: remove the entire attribute if any class contains "Mso", "Word", or "BCX0"
                    if (classAttr) {
                        const hasDisallowedClass = classAttr.split(/\s+/).some(cls =>
                            cls.includes('Mso') || cls.includes('Word') || cls.includes('BCX0')
                        );
                        if (hasDisallowedClass) {
                            element.removeAttribute('class');
                        }
                        // If no disallowed class, the attribute remains as is.
                    }

                    // Clean the id attribute: remove id if it contains "Mso", "Word", or "BCX0"
                    if (idAttr && (idAttr.includes('Mso') || idAttr.includes('Word') || idAttr.includes('BCX0'))) {
                        element.removeAttribute('id');
                    }
                }
            }

            return doc.body.innerHTML;
        }

        /**
         * Cleans common formatting tags: removes <u>, converts <b> to <strong>, and <i> to <em>.
         * @param {string} htmlString - The HTML content to clean.
         * @returns {string} The cleaned HTML content.
         */
        function applyCleanFormattingTags(htmlString) {
            const parser = new DOMParser();
            const doc = parser.parseFromString(htmlString, 'text/html');

            // 1. Remove <u> tags (unwrap them)
            const uElements = Array.from(doc.querySelectorAll('u'));
            for (let i = uElements.length - 1; i >= 0; i--) {
                const u = uElements[i];
                if (u.parentNode) {
                    while (u.firstChild) {
                        u.parentNode.insertBefore(u.firstChild, u);
                    }
                    u.parentNode.removeChild(u);
                }
            }

            // 2. Convert <b> to <strong>
            const bElements = Array.from(doc.querySelectorAll('b'));
            for (let i = bElements.length - 1; i >= 0; i--) {
                const b = bElements[i];
                if (b.parentNode) {
                    const strong = doc.createElement('strong');
                    while (b.firstChild) {
                        strong.appendChild(b.firstChild);
                    }
                    b.parentNode.replaceChild(strong, b);
                }
            }

            // 3. Convert <i> to <em>
            const iElements = Array.from(doc.querySelectorAll('i'));
            for (let i = iElements.length - 1; i >= 0; i--) {
                const i_tag = iElements[i]; // Renamed to avoid conflict with loop variable
                if (i_tag.parentNode) {
                    const em = doc.createElement('em');
                    while (i_tag.firstChild) {
                        em.appendChild(i_tag.firstChild);
                    }
                    i_tag.parentNode.replaceChild(em, i_tag);
                }
            }

            return doc.body.innerHTML;
        }


        /**
         * Function to set the content of the HugeRTE editor.
         * This is called from the parent window.
         */
        window.setRichEditorContent = function(content) {
            // console.log("Parent: Attempting to set HugeRTE content.");
            if (richTextEditorInstance) {
                richTextEditorInstance.setContent(cleanHtmlForRichTextDisplay(content));
                richTextEditorInstance.focus(); // Re-focus the rich editor after content update
                // console.log('Parent: HugeRTE updated from HTML editor.');
            } else {
                console.warn('Parent: HugeRTE editor not yet initialized. Content will be set once ready.');
            }
        };

        /**
         * Function to get the content from the HugeRTE editor.
         * This is called from the parent window.
         */
        window.getRichEditorContent = function() {
            // console.log("Parent: Attempting to get HugeRTE content.");
            if (richTextEditorInstance) {
                const content = richTextEditorInstance.getContent();
                // console.log("Parent: HugeRTE content requested by parent.");
                return content;
            } else {
                console.warn('Iframe: HugeRTE editor not yet initialized. Cannot get content.');
                return '';
            }
        };

        /**
         * Updates the disabled state of the "Go to Rich-Text" button.
         * It is disabled if any other button that displays a temporary message is active.
         */
        function updateToggleEditorViewBtnCodeState() {
            const anyTempMessageActive = tempMessageButtons.some(btn => btn.getAttribute('data-temp-active') === 'true');
            toggleEditorViewBtnCode.disabled = anyTempMessageActive;
        }

        /**
         * Toggles the active editor view between 'richtext' and 'code'.
         * Includes automatic content synchronization.
         */
        function toggleEditorView() {
            // Prevent toggling if the button is disabled
            if (toggleEditorViewBtnCode.disabled && currentView === 'code') {
                return;
            }
            if (toggleEditorViewBtnRichText.disabled && currentView === 'richtext') {
                return;
            }

            console.log("Toggle Editor View triggered. Current view:", currentView);
            if (currentView === 'richtext') {
                // --- Logic when switching FROM Rich-Text TO Code ---
                // 1. Get content from Rich-Text editor.
                if (default_ifr.contentWindow && default_ifr.contentWindow.getRichEditorContent) {
                    richTextContent = default_ifr.contentWindow.getRichEditorContent();
                    // console.log("Syncing from Rich Text to HTML. Rich Text Content length:", richTextContent.length);
                } else {
                    console.warn("Rich Text Editor not ready for content retrieval on toggle. Using empty string.");
                    richTextContent = '';
                }

                // Apply Auto-Clean MSO in the specified order when switching to HTML editor
                let processedContent = richTextContent;
                if (toggleAutoCleanMsoOnSwitchRichText.checked) {
                    console.log("Auto-Clean MSO applied when switching to HTML editor.");
                    // Apply Clean MSO Lists
                    processedContent = applyCleanLists(processedContent);
                    console.log("Clean MSO Lists applied.");
                    // Apply Clean MSO Tables
                    processedContent = applyCleanTablesBasic(processedContent);
                    console.log("Clean MSO Tables applied.");
                    // Apply Clean MSO Code (includes IMGs now)
                    processedContent = applyCleanMsoCode(processedContent);
                    console.log("Clean MSO Code (including IMGs) applied.");
                    // Apply URL cleaning
                    processedContent = applyUrlCleaning(processedContent);
                    console.log("Clean URLs applied.");
                    // Apply Clean Spaces
                    processedContent = applyAutoSpacing(processedContent);
                    console.log("Clean Spaces applied.");
                } else {
                     // If auto-clean MSO is not checked, still apply URL cleaning on switch.
                     // URL cleaning is always applied when switching to HTML.
                    processedContent = applyUrlCleaning(processedContent);
                    console.log("URL cleaning applied (not part of Auto-Clean MSO, but always on switch).");
                }
                
                // 2. Update HTML output content and Monaco editor.
                htmlOutputContent = processedContent;
                if (monacoEditorInstance) {
                    monacoEditorInstance.setValue(htmlOutputContent);
                    monacoEditorInstance.focus();
                    applyEntityHighlighting();
                    console.log("Monaco editor updated with Rich Text content.");
                } else {
                    console.warn('Monaco editor not yet initialized. Content will be set once ready.');
                }

                // Run Auto-Encode and Auto-Indent when switching to HTML editor
                autoEncodeBtn.click();
                autoFormatBtn.click();
                // console.log("Auto-Encode and Auto-Indent applied on switch to HTML editor.");

                // 3. Switch panel visibility.
                richtextOutputPanel.classList.remove('panel-visible');
                richtextOutputPanel.classList.add('panel-hidden');
                codePanel.classList.remove('panel-hidden');
                codePanel.classList.add('panel-visible');
                
                // 4. Update button styles.
                // "Go to HTML" button (toggleEditorViewBtnRichText) is now inactive/hidden.
                // Remove all color classes and set to default zinc.
                toggleEditorViewBtnRichText.classList.remove('bg-green-600', 'hover:bg-green-700', 'bg-sky-700', 'hover:bg-sky-800');
                toggleEditorViewBtnRichText.classList.add('bg-zinc-700', 'hover:bg-zinc-600');
                
                // "Go to Rich-Text" button (toggleEditorViewBtnCode) is now active/visible.
                // It should be blue.
                toggleEditorViewBtnCode.classList.remove('bg-green-600', 'hover:bg-green-700', 'bg-zinc-700', 'hover:bg-zinc-600');
                toggleEditorViewBtnCode.classList.add('bg-sky-700', 'hover:bg-sky-800');
                
                currentView = 'code';
                console.log("Switched to Code View.");
            } else { // currentView === 'code'
                // --- Logic when switching FROM Code TO Rich-Text ---
                // No auto-clean MSO should happen when switching TO the Rich-Text editor.
                // 1. Get content from Monaco editor.
                if (monacoEditorInstance) {
                    htmlOutputContent = monacoEditorInstance.getValue();
                    console.log("Syncing from HTML to Rich Text. HTML Output Content length:", htmlOutputContent.length);
                } else {
                    console.warn("Monaco editor not ready for content retrieval on toggle. Using empty string.");
                    htmlOutputContent = '';
                }

                // 2. Update Rich Text content and editor.
                richTextContent = htmlOutputContent; // No cleaning applied here
                if (default_ifr.contentWindow && default_ifr.contentWindow.setRichEditorContent) {
                    default_ifr.contentWindow.setRichEditorContent(cleanHtmlForRichTextDisplay(richTextContent));
                    console.log("HugeRTE editor updated with HTML content.");
                } else {
                    console.warn("Rich Text Editor not ready for content setting on toggle.");
                }
                
                // 3. Switch panel visibility.
                codePanel.classList.remove('panel-visible');
                codePanel.classList.add('panel-hidden');
                richtextOutputPanel.classList.remove('panel-hidden');
                richtextOutputPanel.classList.add('panel-visible');

                // 4. Update button styles.
                // "Go to Rich-Text" button (toggleEditorViewBtnCode) is now inactive/hidden.
                // It should be blue.
                toggleEditorViewBtnCode.classList.remove('bg-green-600', 'hover:bg-green-700', 'bg-zinc-700', 'hover:bg-zinc-600');
                toggleEditorViewBtnCode.classList.add('bg-sky-700', 'hover:bg-sky-800');
                
                // "Go to HTML" button (toggleEditorViewBtnRichText) is now active/visible.
                // Its color depends on the MSO toggle.
                updateGoToHtmlButtonColor(); // This function handles its specific coloring.
                
                currentView = 'richtext';
                console.log("Switched to Rich Text View.");
                if (richTextEditorInstance) {
                    richTextEditorInstance.focus();
                }
            }
        }

        // Variable to store Monaco decorations for entities
        let entityDecorations = [];

        /**
         * Applies highlighting to HTML character entities in the Monaco editor.
         */
        function applyEntityHighlighting() {
            if (!monacoEditorInstance) return;

            const model = monacoEditorInstance.getModel();
            if (!model) return;

            const newDecorations = [];
            const text = model.getValue();
            // Regex to find HTML entities like &nbsp; &#160; &amp;
            const regex = /&[a-zA-Z0-9#]+;/g; 

            let match;
            while ((match = regex.exec(text)) !== null) {
                const startPos = model.getPositionAt(match.index);
                const endPos = model.getPositionAt(match.index + match[0].length);

                newDecorations.push({
                    range: new monaco.Range(startPos.lineNumber, startPos.column, endPos.lineNumber, endPos.column),
                    options: {
                        inlineClassName: 'entity-highlight',
                        hoverMessage: { value: 'HTML Character Entity' } // Optional: show tooltip on hover
                    }
                });
            }

            // Apply the new decorations and clear old ones
            entityDecorations = monacoEditorInstance.deltaDecorations(entityDecorations, newDecorations);
        }

        // Function to update the state of the "Run Selected" button
        function updateRunButtonState() {
            const anyToggleChecked = generalCleaningToggles.some(toggle => toggle.checked);
            runSelectedBtn.disabled = !anyToggleChecked;
            if (anyToggleChecked) {
                runSelectedBtn.classList.remove('bg-gray-600', 'cursor-not-allowed', 'opacity-60');
                runSelectedBtn.classList.add('bg-green-600', 'hover:bg-green-700');
            } else {
                runSelectedBtn.classList.add('bg-gray-600', 'cursor-not-allowed', 'opacity-60');
                runSelectedBtn.classList.remove('bg-green-600', 'hover:bg-green-700');
            }
        }

        /**
         * Updates the color of the "Go to HTML" button based on the "Auto-Clean MSO when switching" toggle state.
         * This function is now responsible for setting the correct color for the "Go to HTML" button
         * when the `currentView` is 'richtext' (meaning the "Go to HTML" button is visible and active).
         */
        function updateGoToHtmlButtonColor() {
            // This function is called when the rich text panel is visible and the "Go to HTML" button is active.
            // Its color should reflect the state of toggleAutoCleanMsoOnSwitchRichText.
            if (toggleAutoCleanMsoOnSwitchRichText.checked) {
                toggleEditorViewBtnRichText.classList.remove('bg-sky-700', 'hover:bg-sky-800', 'bg-zinc-700', 'hover:bg-zinc-600');
                toggleEditorViewBtnRichText.classList.add('bg-green-600', 'hover:bg-green-700');
            } else {
                toggleEditorViewBtnRichText.classList.remove('bg-green-600', 'hover:bg-green-700', 'bg-zinc-700', 'hover:bg-zinc-600');
                toggleEditorViewBtnRichText.classList.add('bg-sky-700', 'hover:bg-sky-800');
            }
        }

        /**
         * Simple debounce function.
         * @param {Function} func The function to debounce.
         * @param {number} delay The delay in milliseconds.
         * @returns {Function} The debounced function.
         */
        function debounce(func, delay) {
            let timeout;
            return function(...args) {
                const context = this;
                clearTimeout(timeout);
                timeout = setTimeout(() => func.apply(context, args), delay);
            };
        }

        // Debounced version of monacoEditorInstance.layout() for window resize
        const debouncedMonacoLayout = debounce(() => {
            if (monacoEditorInstance) {
                monacoEditorInstance.layout();
            }
        }, 200); // Debounce for window resize, not internal panel resize


        // Initialize and set up event listeners on window load
        window.onload = function() {
            console.log("Parent window.onload triggered.");
            // Initial setup: Ensure rich text panel is visible and code panel is hidden
            richtextOutputPanel.classList.add('panel-visible');
            codePanel.classList.add('panel-hidden');
            
            // Set initial button styles based on default view (richtext)
            // The "Go to HTML" button is visible initially, so its color depends on the MSO toggle.
            // The "Go to Rich-Text" button is hidden initially, so it should have its default blue color.
            toggleEditorViewBtnCode.classList.add('bg-sky-700', 'hover:bg-sky-800');
            toggleEditorViewBtnCode.classList.remove('bg-sky-700', 'hover:bg-sky-800', 'bg-zinc-700', 'hover:bg-zinc-600');
            updateGoToHtmlButtonColor(); // Call to set initial color for "Go to HTML" button


            // Initialize Monaco Editor
            require.config({ paths: { 'vs': 'https://cdn.jsdelivr.net/npm/monaco-editor@0.49.0/min/vs' } });
            require(['vs/editor/editor.main'], function () {
                monacoEditorInstance = monaco.editor.create(monacoEditorContainer, { // Use monacoEditorContainer here
                    value: htmlOutputContent, // Set initial content
                    language: 'html',
                    theme: 'vs-dark', // Or 'hc-black'
                    automaticLayout: true, // Important for responsiveness
                    minimap: { enabled: false },
                    fontSize: 14,
                    tabSize: 4,
                    insertSpaces: true,
                    // Additional options for better UX
                    scrollBeyondLastLine: false,
                    wordWrap: 'on',
                    wrappingIndent: 'same',
                });
                console.log("Monaco editor initialized.");

                // Update htmlOutputContent on Monaco content change
                monacoEditorInstance.onDidChangeModelContent(() => {
                    htmlOutputContent = monacoEditorInstance.getValue();
                    applyEntityHighlighting(); // Re-apply highlighting on content change
                });

                // Apply initial highlighting after Monaco is created
                applyEntityHighlighting();

                // Ensure Monaco refreshes layout on window resize
                window.addEventListener('resize', debouncedMonacoLayout);

                // Monaco Resizer Logic
                let isResizing = false;
                let initialMonacoWidth; // Keep track of pixel widths for calculations
                let initialSidebarWidth;
                let initialMouseX;

                monacoResizer.addEventListener('mousedown', (e) => {
                    isResizing = true;
                    initialMonacoWidth = monacoEditorContainer.offsetWidth;
                    initialSidebarWidth = sidebar.offsetWidth;
                    initialMouseX = e.clientX;
                    document.addEventListener('mousemove', onMouseMove);
                    document.addEventListener('mouseup', onMouseUp);
                    document.body.style.cursor = 'ew-resize';
                    document.body.style.userSelect = 'none';
                });

                function onMouseMove(e) {
                    if (!isResizing) return;
                    const dx = e.clientX - initialMouseX;

                    let newMonacoWidth = initialMonacoWidth + dx;
                    let newSidebarWidth = initialSidebarWidth - dx;

                    const minWidth = 200; // Minimum size in pixels for each panel

                    // Ensure minimum widths
                    if (newMonacoWidth < minWidth) {
                        newMonacoWidth = minWidth;
                        // Adjust sidebar width to maintain total space if Monaco hits min
                        newSidebarWidth = initialMonacoWidth + initialSidebarWidth - newMonacoWidth;
                    }
                    if (newSidebarWidth < minWidth) {
                        newSidebarWidth = minWidth;
                        // Adjust Monaco width to maintain total space if sidebar hits min
                        newMonacoWidth = initialMonacoWidth + initialSidebarWidth - newSidebarWidth;
                    }

                    // Apply the new widths directly to flex-basis
                    monacoEditorContainer.style.flexBasis = `${newMonacoWidth}px`;
                    sidebar.style.flexBasis = `${newSidebarWidth}px`;
                    
                    // No explicit layout call needed here for Monaco, automaticLayout should handle it.
                }

                function onMouseUp() {
                    isResizing = false;
                    document.removeEventListener('mousemove', onMouseMove);
                    document.removeEventListener('mouseup', onMouseUp);
                    document.body.style.cursor = 'default';
                    document.body.style.userSelect = '';
                    // After resizing stops, call layout once to ensure final state is correct and stable.
                    if (monacoEditorInstance) {
                        monacoEditorInstance.layout();
                    }
                }
            });

            copyCodeBtn.addEventListener('click', async () => {
                const codeContent = monacoEditorInstance ? monacoEditorInstance.getValue() : '';
                try {
                    const tempTextArea = document.createElement('textarea');
                    tempTextArea.value = codeContent;
                    document.body.appendChild(tempTextArea);
                    tempTextArea.select();
                    document.execCommand('copy');
                    document.body.removeChild(tempTextArea);
                    const originalText = copyCodeBtn.textContent;
                    copyCodeBtn.textContent = 'Copied!';
                    copyCodeBtn.classList.add('bg-green-500', 'hover:bg-green-600');
                    copyCodeBtn.classList.remove('bg-zinc-700', 'hover:bg-zinc-600');
                    copyCodeBtn.disabled = true; // Disable the button
                    copyCodeBtn.setAttribute('data-temp-active', 'true'); // Mark as active
                    updateToggleEditorViewBtnCodeState(); // Update Go to Rich-Text button state
                    setTimeout(() => {
                        copyCodeBtn.textContent = originalText;
                        copyCodeBtn.classList.remove('bg-green-500', 'hover:bg-green-600');
                        copyCodeBtn.classList.add('bg-zinc-700', 'hover:bg-zinc-600');
                        copyCodeBtn.disabled = false; // Re-enable the button
                        copyCodeBtn.removeAttribute('data-temp-active'); // Unmark as active
                        updateToggleEditorViewBtnCodeState(); // Update Go to Rich-Text button state
                    }, 1500);
                } catch (err) {
                    console.error('Failed to copy text: ', err);
                }
            });

            autoFormatBtn.addEventListener('click', () => {
                if (monacoEditorInstance) {
                    const currentContent = monacoEditorInstance.getValue();
                    // Use js_beautify to format the HTML content
                    const formattedContent = html_beautify(currentContent, {
                        indent_size: 4, // You can customize indentation size
                        space_in_paren: true // Example option
                    });
                    monacoEditorInstance.setValue(formattedContent);
                    applyEntityHighlighting(); // Re-apply highlighting after formatting

                    const originalText = autoFormatBtn.textContent;
                    autoFormatBtn.textContent = 'Formatted!';
                    autoFormatBtn.classList.add('bg-green-500', 'hover:bg-green-600');
                    autoFormatBtn.classList.remove('bg-red-700', 'hover:bg-red-800');
                    autoFormatBtn.disabled = true; // Disable the button
                    autoFormatBtn.setAttribute('data-temp-active', 'true'); // Mark as active
                    updateToggleEditorViewBtnCodeState(); // Update Go to Rich-Text button state
                    setTimeout(() => {
                        autoFormatBtn.textContent = originalText;
                        autoFormatBtn.classList.remove('bg-green-500', 'hover:bg-green-600');
                        autoFormatBtn.classList.add('bg-red-700', 'hover:bg-red-800');
                        autoFormatBtn.disabled = false; // Re-enable the button
                        autoFormatBtn.removeAttribute('data-temp-active'); // Unmark as active
                        updateToggleEditorViewBtnCodeState(); // Update Go to Rich-Text button state
                    }, 1500);
                }
            });

            // New Auto-Encode button event listener
            autoEncodeBtn.addEventListener('click', () => {
                if (monacoEditorInstance) {
                    const currentContent = monacoEditorInstance.getValue();
                    const encodedContent = convertAllEntitiesToNumeric(currentContent);
                    monacoEditorInstance.setValue(encodedContent);
                    htmlOutputContent = encodedContent; // Keep the main content variable updated
                    applyEntityHighlighting(); // Re-apply highlighting after encoding

                    const originalText = autoEncodeBtn.textContent;
                    autoEncodeBtn.textContent = 'Encoded!';
                    autoEncodeBtn.classList.add('bg-green-500', 'hover:bg-green-600');
                    autoEncodeBtn.classList.remove('bg-red-700', 'hover:bg-red-800');
                    autoEncodeBtn.disabled = true; // Disable the button
                    autoEncodeBtn.setAttribute('data-temp-active', 'true'); // Mark as active
                    updateToggleEditorViewBtnCodeState(); // Update Go to Rich-Text button state
                    setTimeout(() => {
                        autoEncodeBtn.textContent = originalText;
                        autoEncodeBtn.classList.remove('bg-green-500', 'hover:bg-green-600');
                        autoEncodeBtn.classList.add('bg-red-700', 'hover:bg-red-800');
                        autoEncodeBtn.disabled = false; // Re-enable the button
                        autoEncodeBtn.removeAttribute('data-temp-active'); // Unmark as active
                        updateToggleEditorViewBtnCodeState(); // Update Go to Rich-Text button state
                    }, 1500);
                }
            });

            exportHtmlBtn.addEventListener('click', () => {
                const htmlContent = monacoEditorInstance ? monacoEditorInstance.getValue() : '';
                const blob = new Blob([htmlContent], { type: 'text/html' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'index.html';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                const originalText = exportHtmlBtn.textContent;
                exportHtmlBtn.textContent = 'Exported!';
                exportHtmlBtn.classList.add('bg-green-500', 'hover:bg-green-600');
                exportHtmlBtn.classList.remove('bg-red-700', 'hover:bg-red-800');
                exportHtmlBtn.disabled = true; // Disable the button
                exportHtmlBtn.setAttribute('data-temp-active', 'true'); // Mark as active
                updateToggleEditorViewBtnCodeState(); // Update Go to Rich-Text button state
                setTimeout(() => {
                    exportHtmlBtn.textContent = originalText;
                    exportHtmlBtn.classList.remove('bg-green-500', 'hover:bg-green-600');
                    exportHtmlBtn.classList.add('bg-red-700', 'hover:bg-red-800');
                    exportHtmlBtn.disabled = false; // Re-enable the button
                    exportHtmlBtn.removeAttribute('data-temp-active'); // Unmark as active
                    updateToggleEditorViewBtnCodeState(); // Update Go to Rich-Text button state
                }, 1500);
            });

            importHtmlBtn.addEventListener('click', () => htmlFileInput.click());
            htmlFileInput.addEventListener('change', (event) => {
                const file = event.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        const importedContent = e.target.result;
                        if (monacoEditorInstance) {
                            monacoEditorInstance.setValue(importedContent);
                            htmlOutputContent = importedContent; // Update stored content
                            applyEntityHighlighting(); // Re-apply highlighting after import
                        }
                        const originalText = importHtmlBtn.textContent;
                        importHtmlBtn.textContent = 'Imported!';
                        importHtmlBtn.classList.add('bg-green-500', 'hover:bg-green-600');
                        importHtmlBtn.classList.remove('bg-purple-700', 'hover:bg-purple-800');
                        importHtmlBtn.disabled = true; // Disable the button
                        importHtmlBtn.setAttribute('data-temp-active', 'true'); // Mark as active
                        updateToggleEditorViewBtnCodeState(); // Update Go to Rich-Text button state
                        setTimeout(() => {
                            importHtmlBtn.textContent = originalText;
                            importHtmlBtn.classList.remove('bg-green-500', 'hover:bg-green-600');
                            importHtmlBtn.classList.add('bg-purple-700', 'hover:bg-purple-800');
                            importHtmlBtn.disabled = false; // Re-enable the button
                            importHtmlBtn.removeAttribute('data-temp-active'); // Unmark as active
                            updateToggleEditorViewBtnCodeState(); // Update Go to Rich-Text button state
                        }, 1500);
                    };
                    reader.onerror = () => {
                        // Error handling for file read removed.
                    };
                    reader.readAsText(file);
                }
            });

            // Event listeners for the new individual toggle buttons
            toggleEditorViewBtnRichText.addEventListener('click', toggleEditorView);
            toggleEditorViewBtnCode.addEventListener('click', toggleEditorView);

            // Clear All button event listener
            clearAllBtn.addEventListener('click', () => {
                if (monacoEditorInstance) {
                    monacoEditorInstance.setValue(''); // Clear Monaco content
                    htmlOutputContent = ''; // Clear stored content
                    applyEntityHighlighting(); // Re-apply highlighting after clearing
                }
                const originalText = clearAllBtn.textContent;
                clearAllBtn.textContent = 'Cleared!';
                clearAllBtn.classList.add('bg-green-500', 'hover:bg-green-600');
                clearAllBtn.classList.remove('bg-zinc-700', 'hover:bg-zinc-600');
                clearAllBtn.disabled = true; // Disable the button
                clearAllBtn.setAttribute('data-temp-active', 'true'); // Mark as active
                updateToggleEditorViewBtnCodeState(); // Update Go to Rich-Text button state
                setTimeout(() => {
                    clearAllBtn.textContent = originalText;
                    clearAllBtn.classList.remove('bg-green-500', 'hover:bg-green-600');
                    clearAllBtn.classList.add('bg-zinc-700', 'hover:bg-zinc-600');
                    clearAllBtn.disabled = false; // Re-enable the button
                    clearAllBtn.removeAttribute('data-temp-active'); // Unmark as active
                    updateToggleEditorViewBtnCodeState(); // Update Go to Rich-Text button state
                }, 1500);
            });

            // Initial content for the iframe
            const iframeDocument = default_ifr.contentDocument || default_ifr.contentWindow.document;
            iframeDocument.open();
            iframeDocument.write(`
                <!DOCTYPE html>
                <html lang="en">
                <head>
                    <meta charset="UTF-8">
                    <meta name="viewport" content="width=device-width, initial-scale=1.0">
                    <title>Rich Editor</title>
                    <script src="https://cdn.jsdelivr.net/npm/hugerte@1/hugerte.min.js"><\/script>
                    <script src="https://cdn.tailwindcss.com"><\/script>
                    <style>
                        html, body {
                            height: 100%; /* Ensure html and body take full height */
                            margin: 0;
                            /* Removed padding from html, body to avoid height calculation issues */
                            box-sizing: border-box; /* Include padding in height calculations for all elements */
                        }
                        body {
                            font-family: sans-serif;
                            background-color: #ffffff; /* White background for iframe body */
                            color: #333;
                            display: flex; /* Use flexbox for body to make form fill height */
                            flex-direction: column;
                            padding: 1rem; /* Add padding to the body of the iframe */
                        }
                        form {
                            height: 100%;
                            display: flex;
                            flex-direction: column;
                        }
                        textarea {
                            width: 100%;
                            flex-grow: 1;
                            border: 1px solid #ccc;
                            border-radius: 0.5rem;
                            padding: 0.75rem;
                            font-size: 1rem;
                            resize: none; /* Prevent manual resizing */
                            box-sizing: border-box; /* Include padding in width/height */
                        }
                        /* Style for HugeRTE container */
                        .tox.tox-tinymce { /* Use .tox.tox-tinymce as HugeRTE uses TinyMCE classes */
                            height: 100% !important; /* Force full height */
                            display: flex; /* Make it a flex container */
                            flex-direction: column; /* Stack its children vertically */
                        }
                        .tox-editor-container {
                            flex-grow: 1; /* Allow the editor area to grow */
                            display: flex;
                            flex-direction: column;
                        }
                        .tox-edit-area {
                            flex-grow: 1; /* Allow the editing area to grow */
                            display: flex;
                            flex-direction: column;
                        }
                        .tox-edit-area__iframe {
                            flex-grow: 1; /* Make the actual iframe within TinyMCE fill space */
                        }
                    </style>
                </head>
                <body>
                    <form method="post">
                        <textarea id="richEditor"></textarea>
                    </form>
                    <script type="text/javascript">
                        console.log("Iframe script started executing.");
                        // Global variable to hold the HugeRTE editor instance
                        let richTextEditorInstance;
                        // Flag to prevent infinite loop when updating HugeRTE from CodeMirror
                        let isUpdatingFromCodeMirror = false;

                        /**
                         * Function to set the content of the HugeRTE editor.
                         * This is called from the parent window.
                         */
                        window.setRichEditorContent = function(content) {
                            // console.log("Iframe: setRichEditorContent called by parent.");
                            if (richTextEditorInstance && !isUpdatingFromCodeMirror) {
                                isUpdatingFromCodeMirror = true;
                                richTextEditorInstance.setContent(content);
                                richTextEditorInstance.focus(); // Re-focus the rich editor after content update
                                // console.log('Iframe: HugeRTE updated from parent.');
                                isUpdatingFromCodeMirror = false;
                            } else {
                                console.warn('Iframe: HugeRTE editor not yet initialized or isUpdatingFromCodeMirror is true. Content will be set once ready.');
                            }
                        };

                        /**
                         * Function to get the content from the HugeRTE editor.
                         * This is called from the parent window.
                         */
                        window.getRichEditorContent = function() {
                            // console.log("Iframe: getRichEditorContent called by parent.");
                            if (richTextEditorInstance) {
                                const content = richTextEditorInstance.getContent();
                                // console.log("Iframe: HugeRTE content requested by parent.");
                                return content;
                            } else {
                                console.warn('Iframe: HugeRTE editor not yet initialized. Cannot get content.');
                                return '';
                            }
                        };

                        /**
                         * HugeRTE init
                         */
                        if (typeof hugerte === 'undefined') {
                            console.error("Iframe: HugeRTE library not loaded!");
                        } else {
                            console.log("Iframe: HugeRTE library loaded. Initializing editor.");
                            hugerte.init({
                                selector: '#richEditor',
                                toolbar: 'undo redo styles bold italic alignleft aligncenter alignright numlist bullist table',
                                plugins: [ 'table', 'lists' ],
                                height: '100%', // Explicitly set height for TinyMCE
                                tab_focus: false, // Allow tab to indent instead of changing focus
                                formats: { // Define custom formats for alignment to use classes
                                    alignleft: { selector: 'p,h1,h2,h3,h4,h5,h6,td,th,div,ul,ol,li,table,img', classes: 'text-left', exact: true },
                                    aligncenter: { selector: 'p,h1,h2,h3,h4,h5,h6,td,th,div,ul,ol,li,table,img', classes: 'text-center', exact: true },
                                    alignright: { selector: 'p,h1,h2,h3,h4,h5,h6,td,th,div,ul,ol,li,table,img', classes: 'text-right', exact: true },
                                },
                                init_instance_callback: function(editorInstance) {
                                    console.log('Iframe: HugeRTE editor initialized inside iframe.');
                                    richTextEditorInstance = editorInstance; // Store the instance globally
                                    // Expose the instance to the parent window
                                    if (window.parent) {
                                        window.parent.richTextEditorInstanceFromIframe = editorInstance;
                                        console.log("Iframe: HugeRTE instance exposed to parent.");
                                    }

                                    // Handle Tab key for indentation and outdentation, especially for lists
                                    editorInstance.on('keydown', (event) => {
                                        if (event.key === 'Tab') {
                                            event.preventDefault(); // Prevent default tab behavior (focus change)
                                            // No content modification (no spaces, no styles)
                                            editorInstance.focus(); // Explicitly refocus the editor after command
                                        }
                                    });

                                    // Initial content sync when editor loads
                                    console.log('Iframe: HugeRTE editor ready.');
                                    // Set initial content if parent already has some
                                    if (window.parent.richTextContent) {
                                        editorInstance.setContent(window.parent.richTextContent);
                                        console.log("Iframe: Initial HugeRTE content set from parent.");
                                    }
                                }
                            });
                        }
                    <\/script>
                </body>
                </html>
            `);
            iframeDocument.close();

            // After the iframe content is loaded and the editor is initialized within it,
            // the iframe's script will assign its editor instance to window.parent.richTextEditorInstanceFromIframe
            // We can then pick it up here.
            default_ifr.onload = () => {
                console.log("Parent: Iframe finished loading.");
                if (default_ifr.contentWindow && default_ifr.contentWindow.richTextEditorInstanceFromIframe) {
                    richTextEditorInstanceFromIframe = default_ifr.contentWindow.richTextEditorInstanceFromIframe;
                    console.log("Parent: HugeRTE instance captured by parent.");
                } else {
                    console.warn("Parent: Could not capture HugeRTE instance from iframe. Is HugeRTE initializing correctly inside?");
                }
            };
            

            // Toggle switch logic for general cleaning toggles
            generalCleaningToggles.forEach(switchElement => {
                // Set initial state based on checked attribute
                if (switchElement.checked) {
                    switchElement.closest('.toggle-switch').classList.add('is-checked');
                }

                switchElement.addEventListener('change', (event) => {
                    const switchId = event.target.id;
                    const isChecked = event.target.checked;
                    const parentLabel = event.target.closest('.toggle-switch');

                    if (isChecked) {
                        parentLabel.classList.add('is-checked');
                    } else {
                        parentLabel.classList.remove('is-checked');
                    }
                    console.log(`Toggle switch '${switchId}' is now: ${isChecked ? 'ON' : 'OFF'}`);
                    updateRunButtonState(); // Update button state on toggle change
                });
            });

            // Event listeners for Auto-Clean MSO when switching toggles
            toggleAutoCleanMsoOnSwitchRichText.addEventListener('change', (event) => {
                const isChecked = event.target.checked;
                const parentLabel = event.target.closest('.toggle-switch');
                if (isChecked) {
                    parentLabel.classList.add('is-checked');
                } else {
                    parentLabel.classList.remove('is-checked');
                }
                toggleAutoCleanMsoOnSwitchCode.checked = isChecked; // Sync state
                toggleAutoCleanMsoOnSwitchCode.closest('.toggle-switch').classList.toggle('is-checked', isChecked);
                console.log(`Auto-Clean MSO on RichText switch is now: ${isChecked ? 'ON' : 'OFF'}`);
                updateGoToHtmlButtonColor(); // Update button color
            });

            toggleAutoCleanMsoOnSwitchCode.addEventListener('change', (event) => {
                const isChecked = event.target.checked;
                const parentLabel = event.target.closest('.toggle-switch');
                if (isChecked) {
                    parentLabel.classList.add('is-checked');
                } else {
                    parentLabel.classList.remove('is-checked');
                }
                toggleAutoCleanMsoOnSwitchRichText.checked = isChecked; // Sync state
                toggleAutoCleanMsoOnSwitchRichText.closest('.toggle-switch').classList.toggle('is-checked', isChecked);
                console.log(`Auto-Clean MSO on Code switch is now: ${isChecked ? 'ON' : 'OFF'}`);
                // No button color update needed here as it's the "Go to Rich-Text" button
            });


            // Call updateRunButtonState initially to set the correct state on load
            updateRunButtonState();
            // Removed updateRunTableButtonState() as it is no longer needed
            // updateGoToHtmlButtonColor(); // Initial call is now handled directly in window.onload for better control

            // Functionality for "Run Selected" button for General Cleaning
            runSelectedBtn.addEventListener('click', () => {
                // Prevent execution if button is disabled
                if (runSelectedBtn.disabled) {
                    return;
                }
                console.log("Run Selected button clicked.");

                let contentToClean;
                if (currentView === 'richtext') {
                    contentToClean = window.getRichEditorContent();
                    // When running from rich text, entities are already decoded
                    // and empty paragraphs outside tables/lists are removed by toggleEditorView
                } else { // currentView === 'code'
                    contentToClean = monacoEditorInstance.getValue();
                    // If running from code view, ensure entities are decoded before cleaning functions
                    // This is important because cleaning functions operate on a DOM, and decoded entities
                    // ensure they are treated as actual characters.
                    contentToClean = decodeHtmlEntities(contentToClean); 
                }
                
                let cleanedContent = contentToClean; // Start with current content

                // Apply cleaning in the specified order for Run Selected
                if (toggleCleanLists.checked) {
                    cleanedContent = applyCleanLists(cleanedContent);
                    console.log("Clean MSO Lists applied.");
                }

                if (toggleCleanTablesBasic.checked) {
                    cleanedContent = applyCleanTablesBasic(cleanedContent);
                    console.log("Clean MSO Tables applied.");
                }

                if (toggleCleanMsoCode.checked) { // This now includes Clean IMGs
                    cleanedContent = applyCleanMsoCode(cleanedContent);
                    console.log("Clean MSO Code (including IMGs) applied.");
                }

                if (toggleUrlCleaning.checked) {
                    cleanedContent = applyUrlCleaning(cleanedContent);
                    console.log("Clean URLs applied.");
                }

                if (toggleAutoSpacing.checked) {
                    cleanedContent = applyAutoSpacing(cleanedContent);
                    console.log("Clean Spaces applied.");
                }

                // Remaining toggles (order doesn't matter for these)
                if (toggleCleanSingleBreaks.checked) {
                    cleanedContent = applyCleanSingleBreaks(cleanedContent);
                    console.log("Clean Single Breaks applied.");
                }

                if (toggleCleanFormattingTags.checked) {
                    cleanedContent = applyCleanFormattingTags(cleanedContent);
                    console.log("Clean <u> | <b> | <i> applied.");
                }

                // After all cleaning operations, if in code view, re-encode entities to numeric HTML entities
                // before setting the value back to Monaco.
                if (currentView === 'code') {
                    cleanedContent = convertAllEntitiesToNumeric(cleanedContent);
                    console.log("Entities re-encoded to numeric after cleaning for code view.");
                }

                // Update the active editor with the final cleaned content
                if (currentView === 'richtext') {
                    window.setRichEditorContent(cleanedContent);
                } else { // currentView === 'code'
                    monacoEditorInstance.setValue(cleanedContent);
                    htmlOutputContent = cleanedContent; // Keep the main content variable updated
                    applyEntityHighlighting(); // Re-apply highlighting after cleaning
                }

                // Always run Auto-Indent after any cleaning operation
                autoFormatBtn.click();
                console.log("Auto-Indent applied after cleaning.");

                // Turn off all general cleaning toggles after running
                generalCleaningToggles.forEach(toggle => {
                    if (toggle.checked) {
                        toggle.checked = false;
                        toggle.closest('.toggle-switch').classList.remove('is-checked');
                    }
                });
                console.log("All general cleaning toggles turned off.");
                updateRunButtonState(); // Update button state after toggles are turned off


                // Provide visual feedback
                const originalText = runSelectedBtn.textContent;
                runSelectedBtn.textContent = 'Cleaned!';
                runSelectedBtn.classList.add('bg-sky-500', 'hover:bg-sky-600');
                runSelectedBtn.classList.remove('bg-green-600', 'hover:bg-green-700');
                runSelectedBtn.disabled = true; // Disable the button
                runSelectedBtn.setAttribute('data-temp-active', 'true'); // Mark as active
                updateToggleEditorViewBtnCodeState(); // Update Go to Rich-Text button state
                setTimeout(() => {
                    runSelectedBtn.textContent = originalText;
                    runSelectedBtn.classList.remove('bg-sky-500', 'hover:bg-sky-600');
                    runSelectedBtn.classList.add('bg-green-600', 'hover:bg-green-700');
                    runSelectedBtn.disabled = false; // Re-enable the button
                    runSelectedBtn.removeAttribute('data-temp-active'); // Unmark as active
                    updateToggleEditorViewBtnCodeState(); // Update Go to Rich-Text button state
                }, 1500);
            });
        };
    </script>
</body>
</html>
