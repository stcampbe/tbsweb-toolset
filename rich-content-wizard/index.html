<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WordToCode™ - Rich Content Wizard</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/js-beautify/1.14.0/beautify-html.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/monaco-editor@0.49.0/min/vs/loader.js"></script>
    <style>
        /* Custom styles for the editor */
        html, body {
            height: 100%; /* Ensure html and body take full viewport height */
            margin: 0;
            padding: 0;
            overflow: hidden; /* Prevent body from scrolling; all scrolling should be within panels */
        }

        body {
            font-family: 'Inter', sans-serif; /* Using Inter font */
            display: flex;
            flex-direction: column;
            background-color: #0F172A; /* Dark slate */
        }
        /* New header for the QA Wizard title */
        .content-wizard-header {
            padding: 1rem;
            display: flex; /* Use flexbox for alignment */
            align-items: center; /* Vertically align items */
            gap: 1rem; /* Space between title and buttons */
            flex-wrap: wrap; /* Allow wrapping on smaller screens */
        }

        .content-wizard-header h1 {
            font-size: 1.25rem; /* text-4xl */
            font-weight: bold;
            color: #ffffff;
            margin-right: auto; /* Push buttons to the right */
        }
        .editor-container {
            display: flex;
            flex-grow: 1; /* Allow container to grow and fill available space */
            padding: 0 1rem 1rem 1rem;
            gap: 1rem; /* Space between editor and richtext-output */
            margin: 0;
            width: 100%; /* Full width */
            height: 100%; /* Explicitly make editor-container take full height of flex parent (body) */
            box-sizing: border-box; /* Include padding in total height */
            overflow-y: hidden; /* Prevent editor container from scrolling its children */
            overflow-x: hidden; /* Prevent horizontal scrolling */
        }
        
        /* New container for the Monaco editor and the sidebar */
        .main-editor-area {
            display: flex;
            flex-grow: 1; /* Allow this area to take up remaining horizontal space */
            gap: 1rem; /* Space between code-panel and sidebar-panel */
            height: 100%; /* Take full height of editor-container */
            box-sizing: border-box;
            overflow: hidden; /* Prevent horizontal scroll in this container */
        }

        .code-panel, .richtext-output-panel, .sidebar-panel {
            background-color: #1E293B; /* Darker slate */
            border-radius: 0.75rem; /* rounded-xl */
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3); /* Darker shadow */
            padding: 1rem;
            display: flex;
            flex-direction: column; /* Keep column for header, content area, and footer */
            flex-grow: 1; /* Allow panels to grow and shrink horizontally */
            flex-shrink: 1;
            flex-basis: 0; /* Important for equal distribution in flex row */
            height: 100%; /* Take full height of container */
            box-sizing: border-box; /* Include padding and border in element's total width/height */
            overflow-y: hidden; /* Prevent main panels from scrolling; internal elements will manage their own scroll */
            overflow-x: hidden; /* Prevent horizontal scrollbar on panels unless explicitly needed */
        }

        /* Monaco Editor specific styling */
        #monacoEditorContainer {
            min-height: 200px; /* Ensure it has a minimum height */
            flex-grow: 1;   /* Monaco will fill its parent (code-panel) */
            flex-shrink: 1;
            height: 100%; /* Make Monaco take full height of its flex parent */
            /* Monaco editor will handle its own internal scrolling due to automaticLayout: true */
        }

        /* Rich-Text Iframe styling */
        iframe {
            width: 100%;
            height: 100%; /* Make iframe fill its parent's height */
            flex-grow: 1; /* Allow iframe to take all available vertical space */
            border: 1px solid #475569; /* Medium slate border */
            border-radius: 0.5rem; /* rounded-lg */
            background-color: #ffffff; /* Rich-Text Output window background remains white */
            overflow: auto; /* Ensure iframe itself can scroll if its content overflows */
        }

        /* Sidebar styling */
        .sidebar-panel { /* Changed from #sidebar to .sidebar-panel */
            flex-basis: 300px; /* Fixed width for sidebar */
            flex-grow: 0;   /* Prevent sidebar from growing */
            flex-shrink: 0; /* Prevent sidebar from shrinking */
            overflow-y: auto; /* Enable vertical scrolling for sidebar content */
            overflow-x: hidden; /* Prevent horizontal scrolling on sidebar */
            min-height: 0; /* Crucial for flex items to scroll correctly if content overflows */
            background-color: #1E293B; /* Darker slate */
            border-radius: 0.75rem; /* rounded-xl */
            padding: 1rem;
            display: flex;
            flex-direction: column; /* Keep column for header, content area, and footer */
            box-sizing: border-box; /* Include padding and border in element's total width/height */
        }

        h1 {
            color: #ffffff; /* White text for H1 in editor panel */
            margin-bottom: 1rem;
            text-align: center;
        }
        h2 {
            color: #ffffff; /* White text for H2 in panel headers */
        }
        h3 {
            color: #ffffff; /* White text for H3 in panel headers */
            font-size: 1.125rem; /* text-lg */
            font-weight: 600; /* semi-bold */
            margin-bottom: 1rem;
        }
        label {
            color: #CBD5E1; /* Light slate for labels */
        }
        input[type="text"] {
            background-color: #334155; /* Darker slate for input */
            color: #ffffff; /* White text for input */
            border-color: #475569; /* Medium slate border for input */
        }
        input[type="text"]::placeholder {
            color: #94A3B8; /* Medium slate for placeholder text */
        }
        input[type="number"] { /* New style for number input */
            background-color: #334155; /* Darker slate for input */
            color: #ffffff; /* White text for input */
            border-color: #475569; /* Medium slate border for input */
        }
        input[type="number"]::placeholder { /* New style for number input placeholder */
            color: #94A3B8; /* Medium slate for placeholder text */
        }

        /* Add flex-shrink: 0 to the button containers at the top and bottom of panels */
        /* For Richtext panel header */
        #richtextOutputPanel > div.flex.items-center.mb-4 {
            flex-shrink: 0;
        }
        /* For Code panel header */
        #codePanel > div.flex.items-center.mb-4.flex-wrap {
            flex-shrink: 0;
        }
        /* For Code panel footer */
        #codePanel > div.mt-auto.pt-4.flex.justify-center.space-x-2 {
            flex-shrink: 0;
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .editor-container {
                flex-direction: column; /* Stack vertically on small screens */
                height: 100%; /* Ensure it occupies full height */
            }
            .main-editor-area {
                flex-direction: column; /* Stack code-panel and sidebar-panel vertically */
                height: auto; /* Allow content to dictate height */
                flex-grow: 1; /* Allow it to grow vertically */
            }
            .code-panel, .richtext-output-panel, .sidebar-panel {
                height: auto; /* Allow content to dictate height, but flex-grow will ensure it fills space */
                flex-basis: auto; /* Reset flex-basis set by JS for horizontal layout */
                flex-grow: 1; /* Each panel should grow to fill vertical space */
                overflow-y: hidden; /* Main panel should not scroll, its children will */
            }

            #monacoEditorContainer {
                width: 100%; /* Full width on small screens */
                flex-grow: 1; /* Allow Monaco to grow vertically */
                flex-shrink: 1; /* Allow Monaco to shrink */
                min-height: 250px; /* Minimum height for editor usability */
            }
            .sidebar-panel { /* Changed from #sidebar */
                width: 100%; /* Full width on small screens */
                flex-grow: 1; /* Allow sidebar to grow vertically */
                flex-shrink: 1; /* Allow sidebar to shrink */
                min-height: 250px; /* Minimum height for sidebar usability */
                overflow-y: auto; /* This is crucial for scrolling sidebar content */
                overflow-x: hidden;
            }
        }

        /* Styles for button group (GENERAL STYLES - for JOINED buttons by default) */
        .button-group {
            display: flex;
            width: 100%;
            border-radius: 0.5rem;
            box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
            border: 1px solid #475569;
            flex-wrap: wrap;
        }

        .button-group button {
            flex: 1; /* Makes buttons take up equal space */
            border-radius: 0; /* Removes individual button rounded corners */
            border: none; /* Removes individual button borders */
            margin: 0;
            padding: 0.5rem 0.75rem;
            font-size: 0.875rem;
            line-height: 1.25rem;
            position: relative;
            color: #ffffff;
            font-weight: bold;
        }

        /* Specific styles for the Sections and Headings buttons - NO FLEX */
        #toggleSectionsBtn,
        #toggleHeadingsBtn {
            flex: none; /* Override flex: 1; for these specific buttons */
            width: auto; /* Allow buttons to size based on content */
            border: 1px solid #475569; /* Add border back for individual buttons */
            border-radius: 0.5rem; /* Add rounded corners back for individual buttons */
            margin-left: 0.5rem; /* Add spacing between them and other buttons */
        }

        /* Adjust border between buttons in the main button groups (JOINED) */
        .button-group:not(.no-border-buttons):not(.individual-rounded-buttons) button:not(:last-child) {
            border-right: 1px solid rgba(71, 85, 105, 0.5); /* Separator for JOINED buttons */
        }

        /* Apply rounded corners only if NOT individual-rounded-buttons */
        .button-group:not(.individual-rounded-buttons) button:first-child {
            border-top-left-radius: 0.5rem;
            border-bottom-left-radius: 0.5rem;
        }

        .button-group:not(.individual-rounded-buttons) button:last-child {
            border-top-right-radius: 0.5rem;
            border-bottom-right-radius: 0.5rem;
        }

        .button-group button:hover {
            z-index: 1; /* Bring hovered button to front to show full border/shadow */
        }

        /* Visibility classes for toggle view */
        .panel-hidden {
            display: none;
        }
        .panel-visible {
            display: flex; /* Or 'block' for iframe if it's not a flex container */
        }


        /* Customize section styles (removed, but keeping styles for reference if needed) */
        .customize-section {
            background-color: #334155; /* Same as input background */
            border-radius: 0.5rem;
            padding: 1rem; /* Re-added padding */
            margin-bottom: 1rem; /* Re-added margin-bottom */
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .customize-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            /* Removed padding-bottom, margin-bottom, border-bottom */
        }

        .customize-content {
            /* Now uses max-height instead of height */
            max-height: 0; /* Changed from height: 0; */
            overflow: hidden;
            /* Unified transition for smoother effect */
            transition: max-height 0.5s ease-in-out, padding 0.5s ease-in-out; /* Transition max-height and padding */
            padding: 0 1rem; /* Padding for content area, default to 0 for collapsed */
            background-color: #475569; /* Match header background */
            border-radius: 0 0 0.5rem 0.5rem; /* Rounded bottom corners */
        }

        .collapsible-content.expanded {
            /* max-height will be set by JS dynamically to scrollHeight or a large value */
            padding-top: 0.75rem; /* Add padding to content when expanded */
            padding-bottom: 0.75rem; /* Add padding to content when expanded */
        }

        .customize-header svg {
            transition: transform 0.3s ease;
        }

        .customize-header.expanded svg {
            transform: rotate(180deg);
        }

        /* Adjustments for button spacing */
        .code-panel h2 .inline-flex.mr-auto button,
        .richtext-output-panel h2 .inline-flex.mr-auto button {
            margin-right: 0.5rem; /* Default margin for buttons within the group */
        }

        /* When in fullscreen editor mode, remove margin from the first button group */
        .editor-container.fullscreen-editor .code-panel h2 .inline-flex.mr-auto {
            margin-left: 0 !important; /* Remove any left margin on the button container */
        }

        /* When in fullscreen richtext-output mode, remove margin from the first button group */
        .editor-container.fullscreen-richtext .richtext-output-panel h2 .inline-flex.mr-auto {
            margin-left: 0 !important; /* Remove any left margin on the button */
        }

        /* Ensure the button itself doesn't have an undesired left margin when its parent is adjusted */
        .editor-container.fullscreen-editor .code-panel h2 .inline-flex.mr-auto #fullScreenBtn,
        .editor-container.fullscreen-editor .code-panel h2 .inline-flex.mr-auto #exitFullScreenBtn,
        .editor-container.fullscreen-richtext .richtext-output-panel h2 .inline-flex.mr-auto #fullScreenRichTextBtn,
        .editor-container.fullscreen-richtext .richtext-output-panel h2 .inline-flex.mr-auto #exitFullScreenRichTextBtn {
            margin-left: 0; /* Explicitly remove any left margin on the button */
        }

        /* Modal styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .modal-content {
            background-color: #1E293B; /* Darker slate */
            padding: 2rem;
            border-radius: 0.75rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            color: #ffffff;
            text-align: left; /* Left align content */
            max-width: 90%;
            width: 400px;
        }

        .modal-content h3 {
            font-size: 1.5rem;
            font-weight: bold;
            margin-bottom: 1rem;
            text-align: left; /* Ensure title is left aligned */
        }

        .modal-content p {
            margin-bottom: 1.5rem;
        }

        .modal-content button {
            background-color: #64748B; /* Lighter slate */
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            font-weight: bold;
            transition: background-color 0.2s ease;
        }

        .modal-content button:hover {
            background-color: #475569; /* Medium slate */
        }

        .modal-content .button-group {
            border: none; /* Remove border for button groups inside modal */
            box-shadow: none; /* Remove shadow for button groups inside modal */
            width: auto; /* Allow buttons to size naturally */
        }

        .modal-content .button-group button {
            flex: none; /* Prevent buttons from taking equal space */
            margin: 0.25rem; /* Add some margin between buttons */
            border: 1px solid #475569; /* Add border back for individual buttons */
            border-radius: 0.5rem; /* Add rounded corners back for individual buttons */
            padding: 0.3rem 0.6rem; /* Reduced padding for smaller buttons */
            font-size: 0.8rem; /* Reduced font size for smaller buttons */
        }

        .modal-content .button-group button.active {
            background-color: #4338CA; /* Active color for internal modal buttons - Indigo 600 */
            color: white;
            border-color: #4338CA;
        }

        /* Styles for collapsible sections */
        .collapsible-section {
            background-color: #475569; /* Medium slate for section background */
            border-radius: 0.5rem;
            margin-bottom: 0.75rem; /* Space between sections */
            overflow: hidden; /* Hide overflowing content during collapse */
        }

        .collapsible-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem 1rem;
            cursor: pointer;
            background-color: #475569; /* Medium slate for header background */
            border-bottom: 1px solid #64748B; /* Lighter slate border */
            border-radius: 0.5rem 0.5rem 0 0; /* Rounded top corners */
        }

        .collapsible-header.collapsed {
            border-bottom: none; /* No border when collapsed */
            border-radius: 0.5rem; /* Fully rounded when collapsed */
        }

        .collapsible-header h4 {
            font-size: 1rem;
            font-weight: bold;
            color: #ffffff;
        }

        .collapsible-header svg {
            transition: transform 0.3s ease;
        }

        .collapsible-header.expanded svg {
            transform: rotate(180deg);
        }

        .collapsible-content {
            /* Now uses max-height instead of height */
            max-height: 0; /* Changed from height: 0; */
            overflow: hidden;
            /* Unified transition for smoother effect */
            transition: max-height 0.5s ease-in-out, padding 0.5s ease-in-out; /* Transition max-height and padding */
            padding: 0 1rem; /* Padding for content area, default to 0 for collapsed */
            background-color: #475569; /* Match header background */
            border-radius: 0 0 0.5rem 0.5rem; /* Rounded bottom corners */
        }

        .collapsible-content.expanded {
            /* max-height will be set by JS dynamically to scrollHeight or a large value */
            padding-top: 0.75rem; /* Add padding to content when expanded */
            padding-bottom: 0.75rem; /* Add padding to content when expanded */
        }

        /* Toggle Switch Styles */
        .toggle-switch-container {
            display: flex;
            align-items: center;
            margin-bottom: 0.25rem; /* Reduced spacing */
            padding: 0.25rem 0; /* Reduced vertical padding */
            gap: 0.5rem; /* Space between toggle and label */
            justify-content: flex-start; /* Align contents to the start */
        }

        .toggle-switch-label {
            color: #CBD5E1; /* Light slate for label text */
            font-size: 0.9rem;
            flex-shrink: 1; /* Allow label to shrink */
            min-width: 0; /* Allow text to wrap within the label */
        }

        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 44px; /* Width of the pill */
            height: 24px; /* Height of the pill */
            border-radius: 12px; /* Half of height for pill shape */
            background-color: #64748B; /* Grayish slate for off state */
            cursor: pointer;
            transition: background-color 0.3s ease;
            flex-shrink: 0; /* Prevent the switch from shrinking */
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-switch-slider {
            position: absolute;
            content: "";
            height: 20px; /* Height of the inner circle */
            width: 20px; /* Width of the inner circle */
            left: 2px; /* Initial position for off state */
            bottom: 2px;
            background-color: #ffffff; /* Circle color */
            border-radius: 50%;
            transition: transform 0.3s ease;
        }

        /* Checked state styles (applied to the .toggle-switch label itself) */
        .toggle-switch.is-checked {
            background-color: #22c55e; /* Green for on state */
        }

        .toggle-switch.is-checked .toggle-switch-slider {
            transform: translateX(20px); /* Move circle to the right */
        }

        /* Custom style for HTML character entities in Monaco Editor */
        .entity-highlight {
            color: gold !important; /* Use !important to ensure override */
        }

        /* Styling for disabled button */
        .button-list button:disabled,
        .flex.justify-center.space-x-2 button:disabled,
        .flex.items-center.mb-4 button:disabled,
        .modal-content button:disabled { /* Apply to all buttons within these containers and modal buttons */
            background-color: #4a4a4a !important; /* Darker gray for disabled state, use !important to override other styles */
            cursor: not-allowed !important;
            opacity: 0.6 !important;
        }

        /* New styles for the button list */
        .button-list {
            display: flex;
            flex-direction: column; /* Stack buttons vertically */
            width: 100%;
            /* Removed border and border-radius from button-list container */
        }

        .button-list button {
            width: 100%; /* Full width within the list */
            border-radius: 0.5rem; /* Apply rounded corners */
            margin-bottom: 0.5rem; /* Add margin between buttons */
            border: 1px solid rgba(71, 85, 105, 0.5); /* Re-add individual border */
            padding: 0.5rem 0.75rem; /* Consistent padding */
            text-align: center; /* Center text */
            font-weight: 600; /* semi-bold */
            background-color: #475569; /* Darker slate for internal buttons */
            color: #ffffff;
        }

        .button-list button:hover {
            background-color: #64748B; /* Lighter slate on hover */
        }


        /* The two-button group in modals uses a different style, which is fine */
        .modal-content .button-group.inline-flex {
            border: none;
            box-shadow: none;
            gap: 0.5rem; /* Spacing between the buttons in the modal group */
        }

        .modal-content .button-group.inline-flex button {
            flex: none; /* Important for modal buttons to not stretch */
            border-radius: 0.5rem; /* Individual rounded corners for modal buttons */
            margin: 0; /* No external margins, gap handles spacing */
            border: 1px solid #475569; /* Ensure border for individual modal buttons */
            padding: 0.3rem 0.6rem; /* Smaller padding for modal buttons */
            font-size: 0.8rem; /* Smaller font size for modal buttons */
        }
    </style>
</head>
<body>
    <header class="content-wizard-header">
        <h1 class="text-left">WordToCode™ - Rich Content Wizard</h1>
       <a href="/tbsweb-toolset/rich-content-wizard/" class="px-3 py-1 text-sm text-white rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50 font-bold bg-gray-400 cursor-not-allowed opacity-60" disabled="">Content Wizard</a>
        <a href="/tbsweb-toolset/table-wizard/" class="px-3 py-1 text-sm bg-blue-600 text-white rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50 font-bold">Table Wizard</a>
        <a href="/tbsweb-toolset/qa-wizard/" class="px-3 py-1 text-sm bg-blue-600 text-white rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50 font-bold">QA Wizard</a>
    </header>
    <div class="editor-container">
        <div id="richtextOutputPanel" class="richtext-output-panel panel-visible">
            <div class="flex items-center mb-4">
                <button id="toggleEditorViewBtnRichText" class="px-4 py-2 text-base font-semibold bg-cyan-700 text-white rounded-md hover:bg-cyan-800 focus:outline-none focus:ring-2 focus:ring-cyan-600 focus:ring-opacity-50 font-bold">
                    Go to HTML
                </button>
                <!-- Auto-Clean MSO toggle for Rich-Text Editor -->
                <div class="ml-4 p-2 bg-slate-700 rounded-lg flex items-center gap-2">
                    <label class="toggle-switch">
                        <input type="checkbox" id="toggleAutoCleanMsoOnSwitchRichText">
                        <span class="toggle-switch-slider"></span>
                    </label>
                    <span class="toggle-switch-label text-white text-sm">Auto-Clean MSO</span>
                </div>
            </div>
            <iframe id="default_ifr"></iframe>
        </div>

        <!-- Main Editor Area: Contains Code Panel and Sidebar Panel -->
        <div id="mainEditorArea" class="main-editor-area panel-hidden">
            <div id="codePanel" class="code-panel">
                <div class="flex items-center mb-4 flex-wrap">
                    <button id="toggleEditorViewBtnCode" class="px-4 py-2 text-base font-semibold bg-cyan-700 text-white rounded-md hover:bg-cyan-800 focus:outline-none focus:ring-2 focus:ring-cyan-600 focus:ring-opacity-50 font-bold">
                        Go to Rich-Text
                    </button>
                    <!-- Auto-Clean MSO toggle for HTML Editor -->
                    <div class="ml-4 p-2 bg-slate-700 rounded-lg flex items-center gap-2">
                        <label class="toggle-switch">
                            <input type="checkbox" id="toggleAutoCleanMsoOnSwitchCode">
                            <span class="toggle-switch-slider"></span>
                        </label>
                        <span class="toggle-switch-label text-white text-sm">Auto-Clean MSO</span>
                    </div>
                    <!-- New Clean Mso Button -->
                    <button id="cleanMsoBtn" class="ml-4 px-4 py-2 text-base bg-blue-700 text-white rounded-md hover:bg-blue-800 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50 font-bold">
                        Clean MSO
                    </button>
                </div>
                <!-- New row for Copy, Clear, Import, Export buttons -->
                <div class="flex items-center mb-4 flex-wrap">
                    <div class="inline-flex rounded-md shadow-sm" role="group">
                        <button id="copyCodeBtn" class="px-4 py-1 text-sm bg-gray-700 text-white rounded-l-md hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-opacity-50 font-semibold">
                            Copy Code
                        </button>
                        <button id="clearAllBtn" class="px-4 py-1 text-sm bg-gray-700 text-white rounded-r-md hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-opacity-50 font-bold">
                            Clear All
                        </button>
                    </div>
                    <div class="inline-flex space-x-2 ml-4">
                        <button id="importHtmlBtn" class="px-3 py-1 text-sm bg-purple-700 text-white rounded-md hover:bg-purple-800 focus:outline-none focus:ring-2 focus:ring-purple-600 focus:ring-opacity-50 font-bold">Import HTML</button>
                        <button id="exportHtmlBtn" class="px-3 py-1 text-sm bg-red-700 text-white rounded-md hover:bg-red-800 focus:outline-none focus:ring-2 focus:ring-red-600 focus:ring-opacity-50 font-bold">Export HTML</button>
                        <input type="file" id="htmlFileInput" accept=".html" style="display: none;">
                    </div>
                </div>

                <div id="monacoEditorContainer" class="flex-grow border border-slate-700 rounded-lg overflow-hidden"></div>
            </div>

            <div id="sidebarPanel" class="sidebar-panel">
                <h3 class="text-lg font-semibold text-white mb-4">Quick Formatting</h3>

                <div class="button-list">
                    <!-- Clean Spaces Toggle -->
                    <div class="toggle-switch-container">
                        <label class="toggle-switch is-checked" for="toggleCleanSpaces">
                            <input type="checkbox" id="toggleCleanSpaces" checked>
                            <span class="toggle-switch-slider"></span>
                        </label>
                        <span class="toggle-switch-label text-white text-sm">Clean Spaces</span>
                    </div>

                    <!-- Clean URLs Toggle -->
                    <div class="toggle-switch-container">
                        <label class="toggle-switch is-checked" for="toggleCleanUrls">
                            <input type="checkbox" id="toggleCleanUrls" checked>
                            <span class="toggle-switch-slider"></span>
                        </label>
                        <span class="toggle-switch-label text-white text-sm">Clean URLs</span>
                    </div>
                    
                    <!-- Set Time Tags Toggle -->
                    <div class="toggle-switch-container">
                        <label class="toggle-switch is-checked" for="toggleTimeTags">
                            <input type="checkbox" id="toggleTimeTags" checked>
                            <span class="toggle-switch-slider"></span>
                        </label>
                        <span class="toggle-switch-label text-white text-sm">Set Time Tags</span>
                    </div>

                    <!-- Fix FN ID's Toggle -->
                    <div class="toggle-switch-container">
                        <label class="toggle-switch is-checked" for="toggleFixFnIds">
                            <input type="checkbox" id="toggleFixFnIds" checked>
                            <span class="toggle-switch-slider"></span>
                        </label>
                        <span class="toggle-switch-label text-white text-sm">Fix FN ID's</span>
                    </div>

                    <!-- Auto-Level Headings Toggle -->
                    <div class="toggle-switch-container">
                        <label class="toggle-switch is-checked" for="toggleAutoLevelHeadings">
                            <input type="checkbox" id="toggleAutoLevelHeadings" checked>
                            <span class="toggle-switch-slider"></span>
                        </label>
                        <span class="toggle-switch-label text-white text-sm">Auto-Level Headings</span>
                    </div>

                    <!-- Auto-Section Toggle -->
                    <div class="toggle-switch-container">
                        <label class="toggle-switch is-checked" for="toggleAutoSection">
                            <input type="checkbox" id="toggleAutoSection" checked>
                            <span class="toggle-switch-slider"></span>
                        </label>
                        <span class="toggle-switch-label text-white text-sm">Auto-Section</span>
                    </div>
                    
                    <!-- Clean Single Breaks Toggle -->
                    <div class="toggle-switch-container">
                        <label class="toggle-switch" for="toggleCleanSingleBreaks">
                            <input type="checkbox" id="toggleCleanSingleBreaks">
                            <span class="toggle-switch-slider"></span>
                        </label>
                        <span class="toggle-switch-label text-white text-sm">Clean Single Breaks</span>
                    </div>

                    <!-- NEW: Clean <p> in Tables Toggle -->
                    <div class="toggle-switch-container">
                        <label class="toggle-switch" for="toggleCleanPTables">
                            <input type="checkbox" id="toggleCleanPTables">
                            <span class="toggle-switch-slider"></span>
                        </label>
                        <span class="toggle-switch-label text-white text-sm">Clean &lt;p&gt; in Tables</span>
                    </div>

                    <!-- Clean <u> | <b> | <i> Toggle -->
                    <div class="toggle-switch-container">
                        <label class="toggle-switch" for="toggleCleanFormattingTags">
                            <input type="checkbox" id="toggleCleanFormattingTags">
                            <span class="toggle-switch-slider"></span>
                        </label>
                        <span class="toggle-switch-label text-white text-sm">Clean &lt;u&gt; | &lt;b&gt; | &lt;i&gt;</span>
                    </div>
                </div>
                <!-- New Format Button for Quick Formatting Toggles -->
                <button id="formatSelectedBtn" class="px-4 py-2 text-sm bg-blue-600 text-white rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50 font-bold mb-2 mt-2" disabled>
                    Format
                </button>
                <button id="autoEncodeBtn" class="px-4 py-2 text-sm bg-red-700 text-white rounded-md hover:bg-red-800 focus:outline-none focus:ring-2 focus:ring-red-600 focus:ring-opacity-50  font-bold mb-2">
                    Auto-Encode
                </button>
                <button id="autoFormatBtn" class="px-4 py-2 text-sm bg-red-700 text-white rounded-md hover:bg-red-800 focus:outline-none focus:ring-2 focus:ring-red-600 focus:ring-opacity-50  font-bold mb-2">
                    Auto-Indent
                </button>

                <h3 class="text-lg font-semibold text-white mb-4 mt-4">Quick Insert</h3>
                <div class="button-list mb-2">
                    <!-- Auto-ID Button -->
                    <button id="autoIdBtn" class="px-4 py-2 text-sm bg-slate-600 text-white hover:bg-slate-500 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50 rounded-md">
                        Element ID's
                    </button>
				
                    <!-- Footnote List Button -->
                    <button id="footnoteListBtn" class="px-4 py-2 text-sm bg-slate-600 text-white hover:bg-slate-500 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50 rounded-md">
                        Footnote List
                    </button>
                    <!-- Colophon Button -->
                    <button id="colophonBtn" class="px-4 py-2 text-sm bg-slate-600 text-white hover:bg-slate-500 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50 rounded-md">
                        Colophon
                    </button>
                </div>
				<h4 class="text-md text-white mb-2">Page ToC ("On this page")</h3>
				<div class="button-list">
				  <div class="flex space-x-2 mb-2">
					<button
					  id="enPageToCBtn"
					  class="flex-1 px-4 py-2 text-sm bg-slate-600 text-white hover:bg-slate-500 rounded-md mb-1"
					>English
					</button>
					<button
					  id="frPageToCBtn"
					  class="flex-1 px-4 py-2 text-sm bg-slate-600 text-white hover:bg-slate-500 rounded-md mb-1"
					>French
					</button>
				  </div>
				</div>
				<h4 class="text-md text-white mb-2">Section ToC ("In this section")</h4>
				<div class="button-list">
					<div class="flex space-x-2">
						<button id="enSecToCBtn" class="flex-1 px-4 py-2 text-sm bg-slate-600 text-white hover:bg-slate-500 rounded-md mb-1">ENG</button>
						<button id="enSecToCH4Btn" class="flex-1 px-4 py-2 text-sm bg-slate-600 text-white hover:bg-slate-500 rounded-md mb-1">+H4</button>
						<button id="enSecToCH5Btn" class="flex-1 px-4 py-2 text-sm bg-slate-600 text-white hover:bg-slate-500 rounded-md mb-1">+H5</button>
						<button id="enSecToCH6Btn" class="flex-1 px-4 py-2 text-sm bg-slate-600 text-white hover:bg-slate-500 rounded-md mb-1">+H6</button>
					</div>
				</div>
				<div class="button-list">
					<div class="flex space-x-2">
						<button id="frSecToCBtn" class="flex-1 px-4 py-2 text-sm bg-slate-600 text-white hover:bg-slate-500 rounded-md mb-1">FRA</button>
						<button id="frSecToCH4Btn" class="flex-1 px-4 py-2 text-sm bg-slate-600 text-white hover:bg-slate-500 rounded-md mb-1">+H4</button>
						<button id="frSecToCH5Btn" class="flex-1 px-4 py-2 text-sm bg-slate-600 text-white hover:bg-slate-500 rounded-md mb-1">+H5</button>
						<button id="frSecToCH6Btn" class="flex-1 px-4 py-2 text-sm bg-slate-600 text-white hover:bg-slate-500 rounded-md mb-1">+H6</button>
					</div>
				</div>
        </div>
    </div>

    <script>
        // Get references to the elements
        const default_ifr = document.getElementById('default_ifr');
        const codePanel = document.getElementById('codePanel');
        const richtextOutputPanel = document.getElementById('richtextOutputPanel');
        const mainEditorArea = document.getElementById('mainEditorArea'); // New: Reference to the main editor area
        const toggleEditorViewBtnRichText = document.getElementById('toggleEditorViewBtnRichText');
        const toggleEditorViewBtnCode = document.getElementById('toggleEditorViewBtnCode');
        const copyCodeBtn = document.getElementById('copyCodeBtn');
        const autoFormatBtn = document.getElementById('autoFormatBtn');
        const autoEncodeBtn = document.getElementById('autoEncodeBtn'); // New button reference
        const exportHtmlBtn = document.getElementById('exportHtmlBtn');
        const importHtmlBtn = document.getElementById('importHtmlBtn');
        const htmlFileInput = document.getElementById('htmlFileInput');
        const clearAllBtn = document.getElementById('clearAllBtn');
        const cleanMsoBtn = document.getElementById('cleanMsoBtn'); // Ensure cleanMsoBtn is defined

        // References for new Quick Formatting Toggles
        const toggleCleanSpaces = document.getElementById('toggleCleanSpaces');
        const toggleCleanUrls = document.getElementById('toggleCleanUrls');
        const toggleTimeTags = document.getElementById('toggleTimeTags');
        const toggleFixFnIds = document.getElementById('toggleFixFnIds');
        const toggleCleanSingleBreaks = document.getElementById('toggleCleanSingleBreaks');
        const toggleCleanFormattingTags = document.getElementById('toggleCleanFormattingTags');
        const toggleAutoLevelHeadings = document.getElementById('toggleAutoLevelHeadings');
        const toggleAutoSection = document.getElementById('toggleAutoSection');
        const toggleCleanPTables = document.getElementById('toggleCleanPTables'); // NEW: Clean <p> in Tables toggle
        const formatSelectedBtn = document.getElementById('formatSelectedBtn'); // New Format button

        const autoIdBtn = document.getElementById('autoIdBtn'); // New: Auto-ID button
        const colophonBtn = document.getElementById('colophonBtn'); // New: Colophon button
        const footnoteListBtn = document.getElementById('footnoteListBtn'); // New: Footnote List button
		const enPageToCBtn = document.getElementById('enPageToCBtn');
		const frPageToCBtn = document.getElementById('frPageToCBtn');

		
        // Monaco Resizer elements - now applies to panels
        const monacoEditorContainer = document.getElementById('monacoEditorContainer');
        // const panelResizer = document.getElementById('panelResizer'); // Removed: Resizer element
        const sidebarPanel = document.getElementById('sidebarPanel'); // Changed from sidebar

        // Auto-Clean MSO when switching toggles
        const toggleAutoCleanMsoOnSwitchRichText = document.getElementById('toggleAutoCleanMsoOnSwitchRichText');
        const toggleAutoCleanMsoOnSwitchCode = document.getElementById('toggleAutoCleanMsoOnSwitchCode');

        // NEW: Array of all interactive buttons to control their disabled state
        const allInteractiveButtons = [
            toggleEditorViewBtnRichText,
            toggleEditorViewBtnCode,
            cleanMsoBtn,
            importHtmlBtn,
            exportHtmlBtn,
            formatSelectedBtn, // Add the new Format button
            autoIdBtn,
            // REMOVED: pageTocBtn, sectionTocBtn
            footnoteListBtn,
            colophonBtn,
            clearAllBtn,
            autoEncodeBtn,
            autoFormatBtn,
            copyCodeBtn,
        ];

        // Add the toggle inputs themselves to the list if their parent elements need to be disabled
        // No, these are inputs, not buttons. The disabled state of the *toggles* is not controlled by `data-temp-active`
        // on other buttons. Only actual buttons.

        let richTextEditorInstance; // HugeRTE editor instance
        let monacoEditorInstance; // Monaco editor instance
        let currentView = 'richtext'; // 'richtext' or 'code'

        // Separate content storage for each editor
        let richTextContent = '';
        let htmlOutputContent = ''; // This will now hold the content for Monaco

        // Variable to hold the HugeRTE editor instance from the iframe
        let richTextEditorInstanceFromIframe;

        // NEW: Simplified NBSP Placeholder
        const NBSP_PLACEHOLDER = '__NBSP_PLACEHOLDER__'; // A unique string that won't conflict with content

        /**
         * Replaces all forms of non-breaking spaces with a single, unique placeholder.
         * @param {string} htmlString - The HTML string to process.
         * @returns {string} The HTML string with NBSP replaced by placeholders.
         */
        function applyNBSPPlaceholders(htmlString) {
            let processedString = htmlString;
            processedString = processedString.replace(/&nbsp;|&#160;|\u00A0/g, NBSP_PLACEHOLDER);
            return processedString;
        }

        /**
         * Reverts the unique placeholder back to the numeric HTML entity for non-breaking space.
         * @param {string} htmlString - The HTML string with NBSP placeholders.
         * @returns {string} The HTML string with original NBSP entities restored.
         */
        function revertNBSPPlaceholders(htmlString) {
            let processedString = htmlString;
            processedString = processedString.replace(new RegExp(NBSP_PLACEHOLDER, 'g'), '&#160;');
            return processedString;
        }

        /**
         * Encodes a string to Base64.
         * @param {string} str The string to encode.
         * @returns {string} The Base64 encoded string.
         */
        function encodeBase64(str) {
            return btoa(unescape(encodeURIComponent(str)));
        }

        /**
         * Decodes a Base64 string.
         * @param {string} str The Base64 string to decode.
         * @returns {string} The decoded string.
         */
        function decodeBase64(str) {
            return decodeURIComponent(escape(atob(str)));
        }

        /**
         * Protects all data- attributes by Base64 encoding their values and replacing them with a temporary attribute.
         * This function operates purely on the HTML string using regex to avoid DOM parsing issues with complex attribute values.
         * @param {string} htmlString - The HTML content to process.
         * @returns {string} The HTML with protected data- attributes.
         */
        function protectDataAttributes(htmlString) {
            // Regex to find any data- attribute.
            // Captures the full attribute name (e.g., "data-toggle") in group 1, and the value in group 2.
            const regex = /(data-[a-zA-Z0-9-]+)="([^"]*)"/g;
            return htmlString.replace(regex, (match, attrName, value) => {
                const encodedValue = encodeBase64(value);
                // Return a temporary attribute that stores the original attribute name and the encoded value.
                // We use a distinct prefix and include the original attribute name for later restoration.
                return `data-temp-protected-${attrName}="${encodedValue}"`;
            });
        }

        /**
         * Restores protected data- attributes by Base64 decoding their values and replacing them back.
         * The decoded value's internal double quotes are explicitly re-escaped as &quot; to prevent corruption during later DOM operations.
         * This function operates purely on the HTML string using regex.
         * @param {string} htmlString - The HTML content to process.
         * @returns {string} The HTML with original data- attributes restored.
         */
        function restoreDataAttributes(htmlString) {
            // Regex to find the temporary protected data- attributes.
            // Captures the original attribute name (e.g., "data-toggle") in group 1, and the encoded value in group 2.
            const regex = /data-temp-protected-(data-[a-zA-Z0-9-]+)="([^"]*)"/g;
            return htmlString.replace(regex, (match, originalAttrName, encodedValue) => {
                try {
                    let decodedValue = decodeBase64(encodedValue);
                    // Ensure literal double quotes and numeric double quote entities are converted to &quot;
                    // This is crucial to prevent re-escaping of the ampersand in &quot;
                    let safeValue = decodedValue.replace(/"/g, '&quot;');
                    safeValue = safeValue.replace(/&#34;/g, '&quot;');

                    // Restore the original data attribute with the safely escaped value.
                    return `${originalAttrName}="${safeValue}"`;
                } catch (e) {
                    console.error("Error decoding or re-escaping Base64 data-attribute:", e);
                    // If decoding/re-escaping fails, remove the attribute to prevent malformed HTML.
                    return '';
                }
            });
        }


        /**
         * Decodes HTML entities within a string to their actual Unicode characters.
         * Uses a temporary textarea element for reliable decoding.
         * @param {string} html - The HTML string containing entities.
         * @returns {string} The HTML string with entities decoded.
         */
        function decodeHtmlEntities(html) {
            const textarea = document.createElement('textarea');
            textarea.innerHTML = html; // Browser decodes entities when setting innerHTML
            return textarea.value; // Retrieving value gives the decoded string
        }

        /**
         * Cleans HTML content for display in HugeRTE.
         * This function is specifically for preparing content *before* setting it to the rich text editor.
         * It decodes HTML entities to ensure they render correctly in the visual editor.
         * @param {string} content - The HTML content to clean.
         * @returns {string} The cleaned HTML content.
         */
        function cleanHtmlForRichTextDisplay(content) {
            // Ensure content passed to rich text editor is also decoded
            return decodeHtmlEntities(content);
        }

        /**
         * Applies URL cleaning to HTML content.
         * Converts specific absolute URLs to relative paths and removes target/rel attributes from <a> tags.
         * Also removes <a> tags that ONLY contain a name attribute (i.e., no href).
         * @param {string} htmlString - The HTML content to clean.
         * @returns {string} The cleaned HTML content.
         */
        function applyUrlCleaning(htmlString) {
            const parser = new DOMParser(); // Create a new parser instance
            const tempDiv = parser.parseFromString(htmlString, 'text/html').body; // Parse string into a temporary DOM body

            const urlMappings = [
                { old: 'https://canada-preview.adobecqms.net/en/treasury-board-secretariat', new: '/content/canadasite/en/treasury-board-secretariat' },
                { old: 'https://canada-preview.adobecqms.net/fr/secretariat-conseil-tresor', new: '/content/canadasite/fr/secretariat-conseil-tresor' },
                { old: 'https://canada-preview.adobecqms.net/en/government', new: '/content/canadasite/en/government' },
                { old: 'https://canada-preview.adobecqms.net/fr/gouvernement', new: '/content/canadasite/fr/gouvernement' },
                { old: 'https://www.canada.ca/en/treasury-board-secretariat', new: '/content/canadasite/en/treasury-board-secretariat' },
                { old: 'https://www.canada.ca/fr/secretariat-conseil-tresor', new: '/content/canadasite/fr/secretaria-conseil-tresor' },
                { old: 'https://www.canada.ca/en/government', new: '/content/canadasite/en/government' },
                { old: 'https://www.canada.ca/fr/gouvernement', new: '/content/canadasite/fr/gouvernement' }
            ];

            const prependPatterns = [
                '/en/treasury-board-secretariat', 'en/treasury-board-secretariat',
                '/fr/secretariat-conseil-tresor', 'fr/secretariat-conseil-tresor',
                '/en/government', 'en/government',
                '/fr/gouvernement', 'fr/gouvernement'
            ];

            const aElements = tempDiv.querySelectorAll('a');
            aElements.forEach(a => {
                let href = a.getAttribute('href');
                const name = a.getAttribute('name');

                // Case 1: Remove <a> tags that ONLY contain a name attribute (no href)
                if (name && !href) {
                    const parent = a.parentNode;
                    if (parent) {
                        while (a.firstChild) {
                            parent.insertBefore(a.firstChild, a);
                        }
                        parent.removeChild(a);
                    }
                    return; // Skip further processing for this <a> tag
                }

                // Case 2: Process <a> tags with href
                if (href) {
                    // Handle Outlook Safelinks
                    if (href.startsWith('https://can01.safelinks.protection.outlook.com')) {
                        try {
                            const urlObj = new URL(href);
                            const actualUrlParam = urlObj.searchParams.get('url');
                            if (actualUrlParam) {
                                // Decode the actual URL parameter to get the clean link
                                href = decodeURIComponent(actualUrlParam);
                                a.setAttribute('href', href);
                            }
                        } catch (e) {
                            console.error("Error parsing Outlook Safelink URL:", e);
                            // Fallback: If parsing fails, keep the original safelink or remove it
                            // For now, we'll just keep the original href if parsing fails.
                        }
                    }

                    // Rule: Prepend /content/canadasite to specific relative links
                    let prepended = false;
                    for (const pattern of prependPatterns) {
                        if (href.startsWith(pattern)) {
                            if (href.startsWith('/')) {
                                href = '/content/canadasite' + href;
                            } else {
                                href = '/content/canadasite/' + href;
                            }
                            a.setAttribute('href', href);
                            prepended = true;
                            break; // Stop after the first match
                        }
                    }

                    // If already prepended, skip other URL conversions for this link
                    if (prepended) {
                        // Remove target attribute
                        if (a.hasAttribute('target')) {
                            a.removeAttribute('target');
                        }

                        // Remove rel attribute
                        if (a.hasAttribute('rel')) {
                            a.removeAttribute('rel');
                        }
                        return;
                    }

                    // Specific handling for "/content/canadasite" or "/content/dam" links
                    if (href.includes('/content/canadasite') || href.includes('/content/dam')) {
                        const contentPath = href.includes('/content/canadasite') ? '/content/canadasite' : '/content/dam';
                        const contentIndex = href.indexOf(contentPath);
                        if (contentIndex !== 0) {
                            href = href.substring(contentIndex);
                        }
                        a.setAttribute('href', href);
                    } else {
                        // Convert other URLs using existing mappings
                        for (const mapping of urlMappings) {
                            if (href.startsWith(mapping.old)) {
                                href = href.replace(mapping.old, mapping.new);
                                a.setAttribute('href', href);
                                break; // Stop after the first match
                            }
                        }
                    }
                }

                // Remove target attribute
                if (a.hasAttribute('target')) {
                    a.removeAttribute('target');
                }

                // Remove rel attribute
                if (a.hasAttribute('rel')) {
                    a.removeAttribute('rel');
                }
            });

            // NEW: Handle <img> tags with src attributes containing "/content/dam"
            const imgElements = tempDiv.querySelectorAll('img');
            imgElements.forEach(img => {
                let src = img.getAttribute('src');
                if (src && src.includes('/content/dam')) {
                    const contentDamIndex = src.indexOf('/content/dam');
                    if (contentDamIndex !== 0) { // If it doesn't start with /content/dam
                        src = src.substring(contentDamIndex); // Adjust to start from /content/dam
                        img.setAttribute('src', src);
                    }
                }
                // Also remove target and rel attributes from img tags for consistency, though less common
                if (img.hasAttribute('target')) {
                    img.removeAttribute('target');
                }
                if (img.hasAttribute('rel')) {
                    img.removeAttribute('rel');
                }
            });

            return tempDiv.innerHTML;
        }

        /**
         * Applies auto-spacing and cleans multiple <br> tags in HTML content.
         * Includes new rules for non-breaking spaces and empty tag removal/replacement.
         * Also trims leading/trailing spaces and non-breaking spaces within <p>, heading, and <li> tags.
         * @param {string} htmlString - The HTML content to clean.
         * @returns {string} The cleaned HTML content.
         */
        function applyAutoSpacing(htmlString) {
            const parser = new DOMParser();
            let doc = parser.parseFromString(htmlString, 'text/html');
            const body = doc.body;

            // 1. Unwrap <div> and <span> elements if they have no attributes.
            // Note: Section elements are now explicitly NOT unwrapped here.
            const elementsToUnwrap = Array.from(body.querySelectorAll('div, span'));
            elementsToUnwrap.forEach(element => {
                // Only unwrap if element has NO attributes AT ALL
                if (element.attributes.length === 0) {
                    const parent = element.parentNode;
                    if (parent) {
                        while (element.firstChild) {
                            parent.insertBefore(element.firstChild, element);
                        }
                        parent.removeChild(element);
                    }
                }
            });

            // 2. Handle <span style="mso-spacerun: yes"> tags (existing logic, still relevant)
            const spacerunSpans = body.querySelectorAll('span[style*="mso-spacerun: yes"]');
            spacerunSpans.forEach(span => {
                const parent = span.parentNode;
                if (parent) {
                    // Check if the span's text content contains a normal space
                    if (span.textContent.includes(' ')) {
                        // Replace the span with a single normal space
                        parent.replaceChild(doc.createTextNode(' '), span);
                    } else {
                        // Remove the span entirely if it's not containing a normal space
                        parent.removeChild(span);
                    }
                }
            });

            // NEW: Remove empty text nodes (representing empty lines/excess whitespace)
            const walker = doc.createTreeWalker(
                body,
				  NodeFilter.SHOW_TEXT,
				  {
					acceptNode: function(node) {
					  const txt = node.nodeValue;
					  // Only remove if it’s pure whitespace AND more than a single space (or contains newline/tab)
					  if (txt.trim() === '' && (txt.length > 1 || /[\r\n\t]/.test(txt))) {
						return NodeFilter.FILTER_ACCEPT;
					  }
					  return NodeFilter.FILTER_REJECT;
					}
				  },
				  false
            );

            const nodesToRemove = [];
            let currentNode;
            while (currentNode = walker.nextNode()) {
                nodesToRemove.push(currentNode);
            }

            nodesToRemove.forEach(node => {
                if (node.parentNode) {
                    node.parentNode.removeChild(node);
                }
            });

            // Re-serialize to string to apply regex-based cleaning
            let cleanedHtml = body.innerHTML;

            // 3. Condense multiple non-breaking spaces (&#160; or its Unicode char)
            // Replace multiple &#160; sequences (numeric or named entity)
            cleanedHtml = cleanedHtml.replace(/(?:&#160;|\u00A0|&nbsp;){2,}/gi, '&#160;');

            // 4. Clean non-breaking spaces with normal spaces to their left/right
            // Replace sequences like ' &#160;' with '&#160;'
            cleanedHtml = cleanedHtml.replace(/\s+(&#160;|\u00A0|&nbsp;)/gi, '&#160;');
            // Replace sequences like '&#160; ' with '&#160;'
            cleanedHtml = cleanedHtml.replace(/(&#160;|\u00A0|&nbsp;)\s+/gi, '&#160;');


            // 5. Replace sequences of two or more <br> tags (with optional whitespace) with </p><p> (existing logic)
            cleanedHtml = cleanedHtml.replace(/(<br\s*\/?>\s*){2,}/gi, '</p><p>');

            // 6. Completely remove <br clear="all"> and <br clear="ALL">
            cleanedHtml = cleanedHtml.replace(/<br\s+clear=["']?(all|ALL)["']?\s*\/?>/gi, '');


            // Re-parse to work with DOM for empty tag rules and other final cleanups
            doc.body.innerHTML = cleanedHtml;
            const finalBody = doc.body; // Use final body reference after re-parsing

            // 7. Remove/Replace empty tags
            // Include <section> in elements to check for emptiness now as well
            const elementsToCheckForEmptiness = Array.from(finalBody.querySelectorAll('p, li, div, span, strong, em, u, b, i, section'));

            // Process in reverse to avoid issues with DOM changes affecting iteration
            for (let i = elementsToCheckForEmptiness.length - 1; i >= 0; i--) {
                const element = elementsToCheckForEmptiness[i];
                const tagName = element.tagName.toLowerCase();
                const trimmedContent = element.innerHTML.trim();
                const containsOnlyNBSP = (trimmedContent === '&#160;' || trimmedContent === '&nbsp;' || trimmedContent === '\u00A0');
                const containsOnlySpace = (trimmedContent === ' ');

                // Rule for <p> tags: remove only if outside a table
                if (tagName === 'p') {
                    const isInsideTable = element.closest('table');
                    if (!isInsideTable && (trimmedContent === '' || containsOnlyNBSP)) {
                        if (element.parentNode) {
                            element.parentNode.removeChild(element);
                        }
                    } else if (!isInsideTable && containsOnlySpace) {
                        // For <p> with single space, replace with text node of space
                        if (element.parentNode) {
                             element.parentNode.replaceChild(doc.createTextNode(' '), element);
                        }
                    }
                }
                // Rules for other tags: remove if empty or contains only NBSP, replace with space if contains only space
                else {
                    // IMPORTANT CHANGE: Exclude div, span, and section elements with *any* attributes
                    // from being removed/replaced by emptiness logic.
                    // This means `div`, `span`, and `section` tags with attributes are preserved.
                    if (['div', 'span', 'section'].includes(tagName) && element.attributes.length > 0) {
                        continue; // Skip this element, keep it intact
                    }
					if (element.textContent === ' ' &&
						  ['strong','em','u','b','i'].includes(tagName)
					  ) {
						element.parentNode.replaceChild(
						  doc.createTextNode(' '),
						  element
						);
						continue;
					  }
                    if (trimmedContent === '' || containsOnlyNBSP) {
                        if (element.parentNode) {
                            element.parentNode.removeChild(element);
                        }
                    } else if (containsOnlySpace) {
                        if (element.parentNode) {
                            element.parentNode.replaceChild(doc.createTextNode(' '), element);
                        }
                    }
                }
            }

            // --- New: Trim leading/trailing spaces and non-breaking spaces for <p>, heading, and <li> tags ---
            const elementsToTrim = finalBody.querySelectorAll('p, h1, h2, h3, h4, h5, h6, li');
            elementsToTrim.forEach(element => {
                let currentHtml = element.innerHTML;

                // Regex to match leading/trailing spaces, tabs, newlines, and &nbsp; entities
                // (?:&nbsp;|\s) ensures both &#160; and literal spaces are covered.
                // It's important to use &nbsp; in regex for string manipulation, as innerHTML might return it as such.
                currentHtml = currentHtml.replace(/^(?:&nbsp;|\s|&#160;|\u00A0)+/, ''); // Remove leading
                currentHtml = currentHtml.replace(/(?:&nbsp;|\s|&#160;|\u00A0)+$/, ''); // Remove trailing

                element.innerHTML = currentHtml;
            });
            // --- End of New Trim Logic ---

            return finalBody.innerHTML;
        }

        /**
         * Converts single <br> tags into paragraph breaks (</p><p>) while ignoring <br> tags within tables.
         * This simplified version does not attempt to preserve inline element nesting across the break.
         * @param {string} htmlString - The HTML content to process.
         * @returns {string} The processed HTML content.
         */
        function applyCleanSingleBreaks(htmlString) {
            const parser = new DOMParser();
            const doc = parser.parseFromString(htmlString, 'text/html');
            const brElements = Array.from(doc.querySelectorAll('br'));

            // Process elements in reverse order to avoid issues with DOM manipulation affecting iteration
            for (let i = brElements.length - 1; i >= 0; i--) {
                const br = brElements[i];

                // Check if br still exists in the DOM and has a parent
                if (!br || !br.parentNode) {
                    continue;
                }

                let currentParent = br.parentNode;
                let isInsideTable = false;
                // Traverse up the DOM tree to check if the <br> is inside a <table>
                while (currentParent && currentParent !== doc.body) {
                    if (currentParent.tagName && currentParent.tagName.toLowerCase() === 'table') {
                        isInsideTable = true;
                        break;
                    }
                    currentParent = currentParent.parentNode;
                }

                if (isInsideTable) {
                    continue; // Skip this <br> if it's inside a table
                }

                // Create a new paragraph element
                const newParagraph = doc.createElement('p');

                // Move all siblings after the <br> into the new paragraph
                while (br.nextSibling) {
                    newParagraph.appendChild(br.nextSibling);
                }

                // Insert the new paragraph after the original parent of the <br>
                // This effectively closes the current paragraph and starts a new one.
                if (br.parentNode.parentNode) {
                    br.parentNode.parentNode.insertBefore(newParagraph, br.parentNode.nextSibling);
                } else {
                    // Fallback for very unusual structures where parentNode.parentNode is null
                    doc.body.appendChild(newParagraph);
                }

                // Remove the <br> itself
                br.parentNode.removeChild(br);
            }

            return doc.body.innerHTML;
        }

        /**
         * Unwraps <p> tags within <td> or <th> elements, moving their content directly into the cell.
         * @param {string} htmlString - The HTML content to clean.
         * @returns {string} The cleaned HTML content.
         */
        function applyCleanPTagsInTables(htmlString) {
            const parser = new DOMParser();
            const doc = parser.parseFromString(htmlString, 'text/html');

            // Select all <p> tags that are direct or indirect children of <td> or <th>
            const pElementsInCells = doc.querySelectorAll('td p, th p');

            // Iterate in reverse to avoid issues when modifying the DOM while looping
            for (let i = pElementsInCells.length - 1; i >= 0; i--) {
                const pTag = pElementsInCells[i];
                const parentCell = pTag.parentNode; // This should be a td or th (or an element within them)

                // Ensure the direct parent is indeed a td or th, or that it's nested within one.
                // We want to unwrap <p> tags only if they are logically "inside" a cell.
                const closestCell = pTag.closest('td, th');

                if (closestCell) {
                    // Move all children of the <p> tag to its immediate parent
                    while (pTag.firstChild) {
                        parentCell.insertBefore(pTag.firstChild, pTag);
                    }
                    // Remove the now empty <p> tag
                    parentCell.removeChild(pTag);
                }
            }
            return doc.body.innerHTML;
        }


        /**
         * Removes <p>&nbsp;</p> tags that are not within <table> or <li> tags.
         * @param {string} htmlString - The HTML content to clean.
         * @returns {string} The cleaned HTML content.
         */
        function removeEmptyParagraphsOutsideTablesAndLists(htmlString) {
            const parser = new DOMParser();
            const doc = doc.parseFromString(htmlString, 'text/html');
            const paragraphs = doc.querySelectorAll('p');

            for (let i = paragraphs.length - 1; i >= 0; i--) {
                const p = paragraphs[i];
                // Check if the paragraph contains only &nbsp; or is effectively empty after decoding
                // After decodeHtmlEntities, &nbsp; becomes a non-breaking space character (\u00A0)
                const containsOnlyNBSP = p.innerHTML.trim() === '&nbsp;' || p.innerHTML.trim() === '\u00A0';

                if (containsOnlyNBSP) {
                    let parent = p.parentElement;
                    let isInsideTableOrList = false;
                    while (parent) {
                        if (parent.tagName === 'TABLE' || parent.tagName === 'LI') {
                            isInsideTableOrList = true;
                            break;
                        }
                        parent = parent.parentElement;
                    }

                    if (!isInsideTableOrList) {
                        p.parentNode.removeChild(p);
                    }
                }
            }
            return doc.body.innerHTML;
        }

        /**
         * Removes empty <p> tags and <p> tags that contain only a single non-breaking space,
         * specifically if they have a class starting with "Mso" and are not within a table.
         * @param {string} htmlString - The HTML content to clean.
         * @returns {string} The cleaned HTML content.
         */
        function removeEmptyParagraphs(htmlString) {
            const parser = new DOMParser();
            const doc = parser.parseFromString(htmlString, 'text/html');
            const paragraphs = doc.querySelectorAll('p');

            for (let i = paragraphs.length - 1; i >= 0; i--) {
                const p = paragraphs[i];

                // Condition 1: Check if the paragraph is empty or contains only a non-breaking space
                const trimmedContent = p.innerHTML.trim();
                const isEmptyOrNBSP = trimmedContent === '' || trimmedContent === '&nbsp;' || trimmedContent === '\u00A0';

                // Condition 2: Check if the paragraph has a class attribute starting with "Mso"
                const hasMsoClass = p.classList.length > 0 && p.className.startsWith('Mso');

                // Condition 3: Check if the paragraph is NOT within a table
                const isInsideTable = p.closest('table');

                if (isEmptyOrNBSP && hasMsoClass && !isInsideTable) {
                    if (p.parentNode) {
                        p.parentNode.removeChild(p);
                    }
                }
            }
            return doc.body.innerHTML;
        }

        /**
         * Removes inline width and height styles from all elements in the HTML content.
         * @param {string} htmlString - The HTML content to clean.
         * @returns {string} The cleaned HTML content.
         */
        function removeInlineWidthHeightStyles(htmlString) {
            const parser = new DOMParser();
            const doc = parser.parseFromString(htmlString, 'text/html');
            const allElements = doc.querySelectorAll('*');

            allElements.forEach(element => {
                if (element.hasAttribute('style')) {
                    let style = element.getAttribute('style');
                    // Remove width: ...; and height: ...;
                    style = style.replace(/width:\s*[^;]+;?/gi, '');
                    style = style.replace(/height:\s*[^;]+;?/gi, '');
                    // Clean up extra spaces or semicolons
                    style = style.replace(/;{2,}/g, ';').trim();
                    if (style.endsWith(';')) {
                        style = style.slice(0, -1);
                    }

                    if (style) {
                        element.setAttribute('style', style);
                    } else {
                        element.removeAttribute('style');
                    }
                }
            });
            return doc.body.innerHTML;
        }

        /**
         * Converts common character entities and named entities to their numeric HTML entity equivalents.
         * This function operates on an HTML string, parsing it to a temporary DOM, modifying text nodes,
         * and then serializing it back to a string, ensuring numeric entities are preserved.
         * @param {string} htmlString - The HTML content to process.
         * @returns {string} The processed HTML string with numeric entities.
         */
        function convertAllEntitiesToNumeric(htmlString) {
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = htmlString; // This parses entities to characters

            const walker = document.createTreeWalker(
                tempDiv,
                NodeFilter.SHOW_TEXT,
                {
                    acceptNode: function(textNode) {
                        let parent = textNode.parentNode;
                        while (parent) {
                            const tagName = parent.tagName ? parent.tagName.toLowerCase() : '';
                            if (tagName === 'script' || tagName === 'style' || tagName === 'time') {
                                return NodeFilter.FILTER_REJECT;
                            }
                            parent = parent.parentNode;
                        }
                        return NodeFilter.FILTER_ACCEPT;
                    }
                },
                false

            );

            let currentNode;
            const textNodesToProcess = [];
            while (currentNode = walker.nextNode()) {
                textNodesToProcess.push(currentNode);
            }

            textNodesToProcess.forEach(textNode => {
                let text = textNode.nodeValue;
                // Replace specific named entities/characters with their numeric character references
                text = text.replace(/’/g, '&#8217;');     // literal ’
                text = text.replace(/&rsquo;/g, '&#8217;'); // &rsquo;
                text = text.replace(/“/g, '&#8220;');     // literal “
                text = text.replace(/&ldquo;/g, '&#8220;'); // &ldquo;
                text = text.replace(/”/g, '&#8221;');     // literal ”
                text = text.replace(/&rdquo;/g, '&#8221;'); // &rdquo;
                text = text.replace(/«/g, '&#171;');     // literal «
                text = text.replace(/&laquo;/g, '&#171;'); // &laquo;
                text = text.replace(/»/g, '&#187;');     // literal »
                text = text.replace(/&raquo;/g, '&#187;'); // &raquo;
                text = text.replace(/\u00A0/g, '&#160;'); // This converts literal NBSP char to numeric entity
                text = text.replace(/&nbsp;/g, '&#160;'); // This handles named NBSP entity to numeric

                textNode.nodeValue = text;
            });

            let processedHtml = tempDiv.innerHTML; // This re-serializes characters to entities

            // Final string-based replacements to ensure numeric entities are explicitly present
            // This is a safeguard against browser's innerHTML serialization re-converting entities.
            processedHtml = processedHtml.replace(/&nbsp;/g, '&#160;');
            processedHtml = processedHtml.replace(/&rsquo;/g, '&#8217;');
            processedHtml = processedHtml.replace(/&ldquo;/g, '&#8220;');
            processedHtml = processedHtml.replace(/&rdquo;/g, '&#8221;');
            processedHtml = processedHtml.replace(/&laquo;/g, '&#171;');
            processedHtml = processedHtml.replace(/&raquo;/g, '&#187;');

            // Handle double encoding if it occurs (e.g., &amp;#160; -> &#160;)
            processedHtml = processedHtml.replace(/&amp;#(\d+);/g, '&#$1;');

            return processedHtml;
        }

        /**
         * Recursively cleans and preserves only specified HTML content from a source DOM node.
         * Disallowed tags are unwrapped, preserving their allowed children.
         * This function is used for both footnote content and general MSO problematic content.
         * @param {HTMLElement} sourceNode - The DOM node whose children are to be filtered.
         * @param {Document} doc - The document object to create new elements.
         * @returns {string} The HTML string containing only the preserved content.
         */
        function cleanAndPreserveAllowedContent(sourceNode, doc) {
            let tempContainer = doc.createElement('div');

            Array.from(sourceNode.childNodes).forEach(child => {
                if (child.nodeType === Node.TEXT_NODE) {
                    // Always preserve text nodes (including character entities which are parsed into text nodes)
                    tempContainer.appendChild(child.cloneNode(true));
                } else if (child.nodeType === Node.ELEMENT_NODE) {
                    const tagName = child.tagName.toLowerCase();

                    // Function to check if class or id contains disallowed patterns (case-sensitive)
                    const containsDisallowedPattern = (element) => {
                        const elemClassAttr = element.getAttribute('class');
                        if (elemClassAttr) {
                            const classes = elemClassAttr.split(/\s+/);
                            for (const cls of classes) {
                                if (cls.includes('Mso') || cls.includes('Word') || cls.includes('BCX0')) {
                                    return true;
                                }
                            }
                        }
                        const elemIdAttr = element.getAttribute('id');
                        if (elemIdAttr) {
                            if (elemIdAttr.includes('Mso') || elemIdAttr.includes('Word') || elemIdAttr.includes('BCX0')) {
                                return true;
                            }
                        }
                        return false;
                    };

                    const alwaysPreservedTags = [
                        'p', 'section', 'blockquote', 'article', 'ol', 'ul', 'li',
                        'figure', 'caption', 'details', 'summary',
                        'strong', 'u', 'em', 'i', 'b', 'br', 'mark', 'sup', 'sub', 'img',
                        'h1', 'h2', 'h3', 'h4', 'h5', 'h6' // Added heading tags
                    ];

                    const tableTags = ['table', 'thead', 'tbody', 'tfoot', 'tr', 'th', 'td'];

                    if (alwaysPreservedTags.includes(tagName) || tableTags.includes(tagName)) {
                        // These tags are always preserved, recursively clean their content
                        const clonedChild = child.cloneNode(false);
                        clonedChild.innerHTML = cleanAndPreserveAllowedContent(child, doc);
                        tempContainer.appendChild(clonedChild);
                    } else if (tagName === 'a' && child.hasAttribute('href')) {
                        // <a> tags only if they have an href
                        const clonedChild = child.cloneNode(false);
                        clonedChild.innerHTML = cleanAndPreserveAllowedContent(child, doc); // Still clean content inside
                        tempContainer.appendChild(clonedChild);
                    } else if (tagName === 'div' || tagName === 'span') {
                        // <div>, <span>, <ins> ONLY if they have a class or ID that DON'T contain "Mso" or "Word" or "BCX0"
                        if ((child.hasAttribute('class') || child.hasAttribute('id')) && !containsDisallowedPattern(child)) {
                            const clonedChild = child.cloneNode(false);
                            clonedChild.innerHTML = cleanAndPreserveAllowedContent(child, doc);
                            tempContainer.appendChild(clonedChild);
                        } else {
                            // Unwrap if it doesn't meet the criteria
                            const unwrappedContentHtml = cleanAndPreserveAllowedContent(child, doc);
                            const tempUnwrapDiv = doc.createElement('div'); // Temporary div to parse HTML string
                            tempUnwrapDiv.innerHTML = unwrappedContentHtml;
                            while (tempUnwrapDiv.firstChild) {
                                tempContainer.appendChild(tempUnwrapDiv.firstChild);
                            }
                        }
                    } else {
                        // For any other element not explicitly allowed, unwrap its content
                        const unwrappedContentHtml = cleanAndPreserveAllowedContent(child, doc);
                        const tempUnwrapDiv = doc.createElement('div'); // Temporary div to parse HTML string
                        tempUnwrapDiv.innerHTML = unwrappedContentHtml;
                        while (tempUnwrapDiv.firstChild) {
                            tempContainer.appendChild(tempUnwrapDiv.firstChild);
                        }
                    }
                }
            });
            return tempContainer.innerHTML;
        }

        /**
         * Processes <p> or heading tags with "MsoListParagraph" class or specific style attributes,
         * converting them to <ul><li> structures.
         * @param {string} htmlString - The HTML content to clean.
         * @returns {string} The cleaned HTML content.
         */
        function applyCleanLists(htmlString) {
            const parser = new DOMParser();
            const doc = parser.parseFromString(htmlString, 'text/html');
            const body = doc.body;
			
			  // ——— SPECIAL-CASE HEADINGS WITH MSO-LIST ———
			  // Turn them back into plain headings with only their text
			  doc.querySelectorAll(
				'h1[style*="mso-list"],h2[style*="mso-list"],h3[style*="mso-list"],' +
				'h4[style*="mso-list"],h5[style*="mso-list"],h6[style*="mso-list"]'
			  ).forEach(h => {
				const tag = h.tagName.toLowerCase();
				// collapse whitespace so you don’t get accidental newlines/tabs
				const text = h.textContent.trim().replace(/\s+/g, ' ');
				const cleanH = doc.createElement(tag);
				cleanH.textContent = text;
				h.replaceWith(cleanH);
			  });

            // Helper to get the level from style attribute for lists
            function getLevel(styleAttr) {
                if (!styleAttr) return null;
                const match = styleAttr.match(/level(\d+)/);
                return match ? parseInt(match[1], 10) : null;
            }

            // Helper to extract allowed content for lists
            function extractAllowedContentForLists(sourceNode) {
                let contentHtml = '';
                const childrenToProcess = Array.from(sourceNode.childNodes);

                childrenToProcess.forEach(child => {
                    if (child.nodeType === Node.ELEMENT_NODE && child.tagName.toLowerCase() === 'span' && child.hasAttribute('style') && child.getAttribute('style').includes('mso-list: Ignore')) {
                        return;
                    }

                    if (child.nodeType === Node.TEXT_NODE) {
                        contentHtml += child.nodeValue;
                    } else if (child.nodeType === Node.ELEMENT_NODE) {
                        const tagName = child.tagName.toLowerCase();
                        const hasClassOrId = child.hasAttribute('class') || child.hasAttribute('id');

                        // Use the containsDisallowedPattern from cleanAndPreserveAllowedContent for consistent MSO/Word/BCX0 checks
                        const containsDisallowedPattern = (element) => {
                            const elemClassAttr = element.getAttribute('class');
                            if (elemClassAttr) {
                                const classes = elemClassAttr.split(/\s+/);
                                for (const cls of classes) {
                                    if (cls.includes('Mso') || cls.includes('Word') || cls.includes('BCX0')) {
                                        return true;
                                    }
                                }
                            }
                            const elemIdAttr = element.getAttribute('id');
                            if (elemIdAttr) {
                                if (elemIdAttr.includes('Mso') || elemIdAttr.includes('Word') || elemIdAttr.includes('BCX0')) {
                                    return true;
                                }
                            }
                            return false;
                        };

                        if (tagName === 'br' || tagName === 'strong' || tagName === 'a' || tagName === 'em' || tagName === 'u' || tagName === 'sup' || tagName === 'sub' || tagName === 'section' || tagName === 'ins') {
                            contentHtml += child.outerHTML;
                        } else if ((tagName === 'span' || tagName === 'div') && !containsDisallowedPattern(child)) {
    const clonedChild = child.cloneNode(false);
    // PASS THE ORIGINAL NODE INTO THE RECURSION, NOT THE EMPTY CLONE:
    clonedChild.innerHTML = extractAllowedContentForLists(child);
    contentHtml += clonedChild.outerHTML;
} else if (tagName === 'a' && child.hasAttribute('href')) { // Explicitly handle <a> with href
                            contentHtml += child.outerHTML;
                        }
                        else {
                            contentHtml += extractAllowedContentForLists(child);
                        }
                    }
                });
                return contentHtml;
            }

            // Helper to determine list type
            function detectListType(element) {
                const msoListIgnoreSpan = element.querySelector('span[style*="mso-list: Ignore"]');
                if (msoListIgnoreSpan) {
                    const bulletText = msoListIgnoreSpan.textContent.trim();
                    if (/^\d+(\.\d+)+[\.\)]*$/.test(bulletText)) {
                        return 'complex-bullet';
                    }
                    if (/^[A-Za-z](\.\d+)+[\.\)]*$/.test(bulletText)) {
                        return 'complex-bullet';
                    }
                    if (/^\d+[\.\)]$/.test(bulletText)) {
                        return 'ordered-numeric';
                    }
                    if (/^[a-z][\.\)]$/.test(bulletText)) {
                        return 'ordered-alpha';
                    }
                }
                return 'unordered';
            }

            // Query for p AND heading tags
            const targetElements = Array.from(body.querySelectorAll('p, h1, h2, h3, h4, h5, h6'));
            const elementsToReplace = new Map(); // Maps old element to new list element
            const elementsToRemove = new Set(); // Elements that have been integrated into a list

            for (let i = 0; i < targetElements.length; i++) {
                const element = targetElements[i];

                if (elementsToRemove.has(element)) {
                    continue; // Skip if already processed and marked for removal
                }

                const tagName = element.tagName.toLowerCase();
                const classList = Array.from(element.classList);
                const styleAttr = element.getAttribute('style') || '';

                // Condition 1: Check for existing MsoListParagraph classes
                const isMsoListParagraphClass = classList.some(cls =>
                    cls === 'MsoListParagraphCxSpFirst' ||
                    cls === 'MsoListParagraphCxSpSpMiddle' ||
                    cls === 'MsoListParagraphCxSpLast' ||
                    cls === 'MsoListParagraph'
                );

                // Condition 2: Check for new rule: p or heading with no class OR class that DOES NOT contain "MsoList", AND style contains "mso-list"
                const matchesNewRule =
                    (['p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6'].includes(tagName)) &&
                    (!element.hasAttribute('class') || !element.className.includes('MsoList')) &&
                    (styleAttr.includes('mso-list'));

                // Combined condition for a list item
                if (isMsoListParagraphClass || matchesNewRule) {
                    const level = getLevel(styleAttr);

                    // If it's identified as a list paragraph but no level is found,
                    // assume it's not a proper MSO list item and convert to MsoNormal or remove styling.
                    if (level === null) {
                        element.removeAttribute('class');
                        element.removeAttribute('style'); // Also remove style
                        element.classList.add('MsoNormal');
                        continue; // Skip further list processing for this element
                    }

                    const msoListIgnoreSpan = element.querySelector('span[style*="mso-list: Ignore"]');
                    let bulletTextToPrepend = '';
                    let listType = 'unordered';

                    if (msoListIgnoreSpan) {
                        bulletTextToPrepend = msoListIgnoreSpan.textContent.trim();
                        listType = detectListType(element);
                        msoListIgnoreSpan.parentNode.removeChild(msoListIgnoreSpan);
                    }

                    let newRootListElement;
                    if (listType === 'ordered-numeric') {
                        newRootListElement = doc.createElement('ol');
                    } else if (listType === 'ordered-alpha') {
                        newRootListElement = doc.createElement('ol');
                        newRootListElement.classList.add('lst-lwr-alph');
                    } else {
                        newRootListElement = doc.createElement('ul');
                    }

                    let currentListStack = [{ domElement: newRootListElement, level: level }];
                    let currentParentList = newRootListElement;

                    const li = doc.createElement('li');
                    let listItemContent = extractAllowedContentForLists(element);

                    if (listType === 'complex-bullet') {
                        li.innerHTML = bulletTextToPrepend + ' ' + listItemContent;
                    } else {
                        li.innerHTML = listItemContent;
                    }
                    currentParentList.appendChild(li);
                    elementsToReplace.set(element, newRootListElement); // Mark the first element of the sequence for replacement

                    // Remove class and style attributes from the processed element
                    element.removeAttribute('class');
                    element.removeAttribute('style');


                    // Process subsequent sibling elements that are part of the same list sequence
                    let nextSibling = element.nextElementSibling;
                    let currentSequenceIndex = i + 1; // Track index in original targetElements array

                    while (nextSibling && currentSequenceIndex < targetElements.length) {
                        const nextElement = targetElements[currentSequenceIndex]; // Get from original array
                        if (nextElement !== nextSibling) { // Ensure we are still processing actual next siblings
                            break;
                        }

                        const nextTagName = nextElement.tagName.toLowerCase();
                        const nextClassList = Array.from(nextElement.classList);
                        const nextStyleAttr = nextElement.getAttribute('style') || '';

                        const isNextMsoListParagraphClass = nextClassList.some(cls =>
                            cls === 'MsoListParagraphCxSpFirst' ||
                            cls === 'MsoListParagraphCxSpMiddle' ||
                            cls === 'MsoListParagraphCxSpLast' ||
                            cls === 'MsoListParagraph'
                        );
                        const nextMatchesNewRule =
                            (['p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6'].includes(nextTagName)) &&
                            (!nextElement.hasAttribute('class') || !nextElement.className.includes('MsoList')) &&
                            (nextStyleAttr.includes('mso-list'));

                        if (isNextMsoListParagraphClass || nextMatchesNewRule) {
                            const nextLevel = getLevel(nextStyleAttr);

                            // If next element is identified as list but has no level, break the sequence
                            if (nextLevel === null) {
                                nextElement.removeAttribute('class');
                                nextElement.removeAttribute('style');
                                nextElement.classList.add('MsoNormal');
                                break;
                            }

                            const nextMsoListIgnoreSpan = nextElement.querySelector('span[style*="mso-list: Ignore"]');
                            let nextBulletTextToPrepend = '';
                            let nextListType = 'unordered';

                            if (nextMsoListIgnoreSpan) {
                                nextBulletTextToPrepend = nextMsoListIgnoreSpan.textContent.trim();
                                nextListType = detectListType(nextElement);
                                nextMsoListIgnoreSpan.parentNode.removeChild(nextMsoListIgnoreSpan);
                            }

                            // Adjust list nesting based on level
                            let currentDepth = currentListStack[currentListStack.length - 1].level;

                            if (nextLevel > currentDepth) {
                                // Deeper level, create nested list
                                let nestedListElement;
                                if (nextListType === 'ordered-numeric') {
                                    nestedListElement = doc.createElement('ol');
                                } else if (nextListType === 'ordered-alpha') {
                                    nestedListElement = doc.createElement('ol');
                                    nestedListElement.classList.add('lst-lwr-alph');
                                } else {
                                    nestedListElement = doc.createElement('ul');
                                }

                                // Append to the last <li> of the current parent list
                                let targetLi = currentParentList.lastElementChild;
                                if (!targetLi || targetLi.tagName.toLowerCase() !== 'li') {
                                    // Should ideally not happen if structure is well-formed, but a fallback
                                    targetLi = doc.createElement('li');
                                    currentParentList.appendChild(targetLi);
                                }
                                targetLi.appendChild(nestedListElement);
                                currentListStack.push({ domElement: nestedListElement, level: nextLevel });
                                currentParentList = nestedListElement;

                            } else if (nextLevel < currentDepth) {
                                // Higher level, pop from stack until appropriate parent is found
                                while (currentListStack.length > 1 && nextLevel <= currentListStack[currentListStack.length - 1].level) {
                                    currentListStack.pop();
                                }
                                currentParentList = currentListStack[currentListStack.length - 1].domElement;

                                // If after popping, the next level is still greater than current parent's level,
                                // it means an intermediate level was skipped, so create missing intermediate list(s).
                                // This logic might need further refinement for complex cases but aims to prevent too-deep jumps.
                                while (currentListStack.length < nextLevel) {
                                    let targetLi = currentParentList.lastElementChild;
                                    if (!targetLi || targetLi.tagName.toLowerCase() !== 'li') {
                                        targetLi = doc.createElement('li');
                                        currentParentList.appendChild(targetLi);
                                    }
                                    let newNestedList;
                                    if (currentListStack.length + 1 === nextLevel) { // Only create the *correct* type if this is the target level
                                        if (nextListType === 'ordered-numeric') {
                                            newNestedList = doc.createElement('ol');
                                        } else if (nextListType === 'ordered-alpha') {
                                            newNestedList = doc.createElement('ol');
                                            newNestedList.classList.add('lst-lwr-alph');
                                        } else {
                                            newNestedList = doc.createElement('ul');
                                        }
                                    } else { // Intermediate levels are always <ul>
                                        newNestedList = doc.createElement('ul');
                                    }
                                    targetLi.appendChild(newNestedList);
                                    currentListStack.push({ domElement: newNestedList, level: currentListStack.length + 1 });
                                    currentParentList = newNestedList;
                                }

                            }
                            // If nextLevel === currentDepth, simply append to currentParentList


                            const nextLi = doc.createElement('li');
                            let nextListItemContent = extractAllowedContentForLists(nextElement);
                            if (nextListType === 'complex-bullet') {
                                nextLi.innerHTML = nextBulletTextToPrepend + ' ' + nextListItemContent;
                            } else {
                                nextLi.innerHTML = nextListItemContent;
                            }
                            currentParentList.appendChild(nextLi);
                            elementsToRemove.add(nextElement); // Mark subsequent elements for removal

                            // Remove class and style attributes from the processed element
                            nextElement.removeAttribute('class');
                            nextElement.removeAttribute('style');

                            nextSibling = nextElement.nextElementSibling;
                            currentSequenceIndex++;
                        } else {
                            break; // End of list sequence
                        }
                    }
                    i = currentSequenceIndex - 1; // Adjust outer loop index
                }
            }

            // Perform DOM modifications based on maps
            targetElements.forEach(element => {
                if (elementsToReplace.has(element)) {
                    if (element.parentNode) {
                        element.parentNode.replaceChild(elementsToReplace.get(element), element);
                    }
                } else if (elementsToRemove.has(element)) {
                    if (element.parentNode) {
                        element.parentNode.removeChild(element);
                    }
                }
            });

            return doc.body.innerHTML;
        }

        /**
         * Applies basic cleaning to tables and their elements.
         * This includes removing colgroup/col tags, cleaning table/td/th attributes,
         * and handling paragraphs within table cells.
         * @param {string} htmlString - The HTML content to clean.
         * @returns {string} The cleaned HTML content.
         */
        function applyCleanTablesBasic(htmlString) {
            const parser = new DOMParser();
            const doc = parser.parseFromString(htmlString, 'text/html');
            const body = doc.body;

            // Remove colgroup and col elements
            const colgroupElements = doc.querySelectorAll('colgroup');
            for (let i = colgroupElements.length - 1; i >= 0; i--) {
                if (colgroupElements[i].parentNode) {
                    colgroupElements[i].parentNode.removeChild(colgroupElements[i]);
                }
            }

            const colElements = doc.querySelectorAll('col');
            for (let i = colElements.length - 1; i >= 0; i--) {
                if (colElements[i].parentNode) {
                    colElements[i].parentNode.removeChild(colElements[i]);
                }
            }

            // Clean attributes from table and its structural tags (thead, tbody, tfoot, tr, th, td)
            const tableRelatedTags = doc.querySelectorAll('table, thead, tbody, tfoot, tr, th, td');
            tableRelatedTags.forEach(element => {
                const attributesToKeep = ['rowspan', 'colspan', 'class', 'id', 'headers', 'scope'];
                const attributesToRemove = [];
                for (let j = 0; j < element.attributes.length; j++) {
                    const attr = element.attributes[j];
                    if (!attributesToKeep.includes(attr.name.toLowerCase())) {
                        attributesToRemove.push(attr.name);
                    }
                }
                attributesToRemove.forEach(attrName => {
                    element.removeAttribute(attrName);
                });
            });

            // Remove MsoTable class from tables
            doc.querySelectorAll('table').forEach(table => {
                const classAttr = table.getAttribute('class');
                if (classAttr && classAttr.includes('MsoTable')) {
                    table.removeAttribute('class');
                }
            });

            // Unwrap spans inside td with class^="xl"
            doc.querySelectorAll('table td[class^="xl"] span').forEach(span => {
                if (span.parentNode) {
                    while (span.firstChild) {
                        span.parentNode.insertBefore(span.firstChild, span);
                    }
                    span.parentNode.removeChild(span);
                }
            });

            // Remove class^="xl" from td elements
            doc.querySelectorAll('td').forEach(td => {
                const classAttr = td.getAttribute('class');
                if (classAttr && classAttr.startsWith('xl')) {
                    td.removeAttribute('class');
                }
            });

            // Clean paragraphs within tables: remove Mso/Aligned classes, inline styles, and convert align attribute to Tailwind classes
            doc.querySelectorAll('table p').forEach(p => {
                const parentCell = p.closest('td, th');

                if (parentCell) {
                    const classAttr = p.getAttribute('class');
                    if (classAttr && (classAttr.includes('Mso') || classAttr.includes('Aligned'))) {
                        p.removeAttribute('class');
                    }

                    if (p.hasAttribute('style')) {
                        p.removeAttribute('style');
                    }

                    const alignAttr = p.getAttribute('align');
                    if (alignAttr) {
                        p.removeAttribute('align');
                        let tailwindAlignClass = ''; // Fixed typo from tailwclassName
                        switch (alignAttr.toLowerCase()) {
                            case 'left':
                                tailwindAlignClass = 'text-left';
                                break;
                            case 'center':
                                tailwindAlignClass = 'text-center';
                                break;
                            case 'right':
                                tailwindAlignClass = 'text-right';
                                break;
                        }
                        if (tailwindAlignClass) {
                            parentCell.classList.add(tailwindAlignClass);
                        }
                    }
                }
            });
            return doc.body.innerHTML;
        }

        /**
         * Applies cleaning for Microsoft Office specific code.
         * This function removes tags and their entire content if they have specific MSO-related attributes or hrefs.
         * Attributes targeted for removal: "mso-element: comment-list", "mso-element: endnote-list".
         * Hrefs targeted for removal: containing "#_msocom", "#_edn", or "#_ftn".
         * For "#_ftn" links, converts <a> to <sup><a> with only text content and href attribute.
         * Also transforms elements with "mso-element: footnote-list" style into <aside> with cleaned content.
         * Also removes content from and cleans attributes of elements with 'style' attribute or MSO/Word/BCX0 classes.
         * Additionally handles specific heading class cleanup, and attribute removal for non-table elements,
         * UL/OL tags, and LI tags with 'role' attributes.
         * Also now handles cleaning of file:// or data: img src attributes.
         * @param {string} htmlString - The HTML content to clean.
         * @returns {string} The cleaned HTML content.
         */
        function applyCleanMsoCode(htmlString) {
            const parser = new DOMParser();
            const doc = parser.parseFromString(htmlString, 'text/html');
			
			doc.querySelectorAll('span[style*="mso-"]').forEach(span => {
				const p = span.parentNode;
				while (span.firstChild) p.insertBefore(span.firstChild, span);
				p.removeChild(span);
				
			});
			doc.querySelectorAll('del, span.msoDel').forEach(node => {
				node.remove();
			});
			doc.querySelectorAll('span.msoIns').forEach(ins => {
				const parent = ins.parentNode;
				while (ins.firstChild) parent.insertBefore(ins.firstChild, ins);
				parent.removeChild(ins);
			});
			doc.querySelectorAll('ins').forEach(ins => {
				const parent = ins.parentNode;
				while (ins.firstChild) parent.insertBefore(ins.firstChild, ins);
				parent.removeChild(ins);
			});
			  
            // --- Start of Clean IMGs Logic (Moved from applyCleanImgs) ---
            doc.querySelectorAll('img').forEach(img => {
                const src = img.getAttribute('src');
                if (src && (src.startsWith('file://') || src.startsWith('data:'))) {
                    const replacementDiv = doc.createElement('div');
                    replacementDiv.classList.add('clearfix');
                    const replacementMark = doc.createElement('mark');
                    replacementMark.textContent = 'IMAGE NOT IMPORTED';
                    replacementDiv.appendChild(replacementMark);
                    if (img.parentNode) {
                        img.parentNode.replaceChild(replacementDiv, img);
                    }
                }
            });
            // --- End of Clean IMGs Logic ---

            // Select elements with style containing "mso-element: comment-list" or "mso-element: endnote-list"
            const elementsToRemoveByStyle = doc.querySelectorAll('[style*="mso-element: comment-list"], [style*="mso-element: endnote-list"]');
            elementsToRemoveByStyle.forEach(element => {
                if (element.parentNode) {
                    element.parentNode.removeChild(element);
                }
            });

            // Select <a> elements with href containing "#_msocom" or "#_edn" and remove them completely
            const commentEndnoteLinks = doc.querySelectorAll('a[href*="#_msocom"], a[href*="#_edn"]');
            commentEndnoteLinks.forEach(link => {
                if (link.parentNode) {
                    link.parentNode.removeChild(link);
                }
            });

            // Process <a> tags with href containing "#_ftn" to ensure only one <sup> wrapper
            const footnoteLinks = Array.from(doc.querySelectorAll('a[href*="#_ftn"]')); // Convert to array to avoid live NodeList issues
            footnoteLinks.forEach(link => {
                const originalHref = link.getAttribute('href');
                const textContent = link.textContent;

                // Create the ideal new <a> tag, copying only necessary attributes
                const newCleanLink = doc.createElement('a');
                newCleanLink.setAttribute('href', originalHref);
                newCleanLink.textContent = textContent;

                // Create the ideal new <sup> tag
                const idealSupElement = doc.createElement('sup');
                idealSupElement.appendChild(newCleanLink);

                // Find the target element to replace. This could be the link itself
                // or an existing <sup> parent that solely contains the link (or other <sup>s leading to it).
                let elementToReplace = link; // This `link` is the current <a> element being processed
                let currentParent = link.parentNode; // Start the the immediate parent of the link

                // Traverse up the DOM tree as long as the parent is <sup> and solely contains `elementToReplace`
                while (currentParent && currentParent !== doc.body && currentParent.tagName.toLowerCase() === 'sup') {
                    // Check if this <sup> only contains the elementToReplace (which is the link or another sup)
                    // and no other significant content (like additional text nodes or other elements).
                    const children = Array.from(currentParent.childNodes).filter(n => n.nodeType === Node.ELEMENT_NODE || (n.nodeType === Node.TEXT_NODE && n.nodeValue.trim() !== ''));

                    // If the <sup> has only one child and that child is our current elementToReplace (or nested <sup>),
                    // then this <sup> is an exclusive wrapper and we can move up.
                    if (children.length === 1 && children[0] === elementToReplace) {
                        elementToReplace = currentParent; // Move up: now `elementToReplace` is this <sup>
                        currentParent = currentParent.parentNode; // Move `currentParent` further up
                    } else {
                        break; // This <sup> contains other content, stop unwrapping here.
                    }
                }

                // Perform the replacement:
                // Replace the determined 'elementToReplace' (which could be the original <a>
                // or the outermost exclusively wrapping <sup>) with the 'idealSupElement'.
                if (elementToReplace.parentNode) {
                    elementToReplace.parentNode.replaceChild(idealSupElement, elementToReplace);
                }
            });

            // Process elements with "mso-element: footnote-list" in their style attribute
            const footnoteListElements = doc.querySelectorAll('[style*="mso-element: footnote-list"]');
            footnoteListElements.forEach(element => {
                if (element.parentNode) {
                    // Clean the content of the current element first, based on the preservation rules
                    const cleanedInnerHtml = cleanAndPreserveAllowedContent(element, doc);

                    // Create a new <aside> element
                    const asideElement = doc.createElement('aside');
                    asideElement.innerHTML = cleanedInnerHtml;

                    // Replace the original element with the new <aside>
                    if (element.parentNode) {
                        element.parentNode.replaceChild(asideElement, element);
                    }
                }
            });

            // Process heading character tags
            // Find all elements that have a class like "Heading#Char" where # is 1-6
            const elementsWithHeadingClass = doc.querySelectorAll('[class*="Heading"]'); // Broad selection then filter

            // Convert to array to avoid issues with live NodeList during modifications
            Array.from(elementsWithHeadingClass).forEach(element => {
                const classAttr = element.getAttribute('class');
                if (!classAttr) return;

                const classes = classAttr.split(/\s+/);
                const headingCharClass = classes.find(cls => /^Heading[1-6]Char$/.test(cls));

                if (headingCharClass) {
                    const headingLevel = parseInt(headingCharClass.match(/\d/)[0], 10);
                    const parent = element.parentNode;

                    if (!parent) return;

                    // Unwrap the current element: move its children to its parent
                    while (element.firstChild) {
                        parent.insertBefore(element.firstChild, element);
                    }
                    parent.removeChild(element); // Remove the now empty element

                    const currentParent = parent; // This is the original parent after unwrapping

                    // If the original parent is NOT already a heading (h1-h6)
                    if (!/^H[1-6]$/i.test(currentParent.tagName)) {
                        const newHeadingTag = doc.createElement(`h${headingLevel}`);

                        // Move *all* content of the original parent into the new headingTag
                        while (currentParent.firstChild) {
                            newHeadingTag.appendChild(currentParent.firstChild);
                        }

                        // Replace the original parent with the new heading tag
                        if (currentParent.parentNode) {
                            currentParent.parentNode.replaceChild(newHeadingTag, currentParent);
                        }
                    }
                    // If the original parent *was* already a heading, we've already unwrapped the span, so no further action needed.
                }
            });

            // NEW: Remove 'align' attribute from elements *outside* of tables
            doc.querySelectorAll('[align]').forEach(element => {
                if (!element.closest('table')) { // Check if the element is not inside a table
                    element.removeAttribute('align');
                }
            });

            // NEW: Remove 'type' and 'role' attributes from UL and OL tags
            doc.querySelectorAll('ul, ol').forEach(list => {
                list.removeAttribute('type');
                list.removeAttribute('role');
            });

            // NEW: Remove all attributes from LI tags if they have a 'role' attribute
            doc.querySelectorAll('li').forEach(li => {
                if (li.hasAttribute('role')) {
                    // Create an array of attribute names to remove
                    const attributesToRemove = Array.from(li.attributes).map(attr => attr.name);
                    attributesToRemove.forEach(attrName => {
                        li.removeAttribute(attrName);
                    });
                }
            });

            // NEW: Remove span tags with 'lang' attribute unless lang is 'en' or 'fr'
            doc.querySelectorAll('span[lang]').forEach(span => {
                const langAttr = span.getAttribute('lang');
                if (langAttr && langAttr.toLowerCase() !== 'en' && langAttr.toLowerCase() !== 'fr') {
                    // Unwrap the span: move its children to its parent
                    const parent = span.parentNode;
                    if (parent) {
                        while (span.firstChild) {
                            parent.insertBefore(span.firstChild, span);
                        }
                        parent.removeChild(span); // Remove the now empty span
                    }
                }
            });


            // Process all elements that have a style attribute or MSO/Word/BCX0 classes
            // Iterate in reverse to handle nested elements correctly without breaking the loop
            const allElements = Array.from(doc.querySelectorAll('*'));
            for (let i = allElements.length - 1; i >= 0; i--) {
                const element = allElements[i];

                // Skip html, head, body, script, style tags, and the aside tags just created
                const tagName = element.tagName.toLowerCase();
                if (['html', 'head', 'body', 'script', 'style', 'aside'].includes(tagName)) {
                    continue;
                }

                const hasStyle = element.hasAttribute('style');
                const classAttr = element.getAttribute('class') || '';
                const idAttr = element.getAttribute('id') || '';

                // Check if any class contains "Mso", "Word", or "BCX0" (case-sensitive)
                const hasMsoWordBcx0Class = classAttr.split(/\s+/).some(cls =>
                    cls.includes('Mso') || cls.includes('Word') || cls.includes('BCX0')
                );

                // Check if ID contains "Mso", "Word", or "BCX0" (case-sensitive)
                const hasMsoWordBcx0Id = idAttr.includes('Mso') || idAttr.includes('Word') || idAttr.includes('BCX0');

                // NEW: Check for classes that trigger complete unwrapping
                const shouldUnwrapCompletely = classAttr.split(/\s+/).some(cls =>
                    cls.includes('eop') ||
                    cls.includes('eoc') ||
                    cls.includes('eocx') ||
                    cls.includes('textrun')
                );

                if (shouldUnwrapCompletely) {
                    const parent = element.parentNode;
                    if (parent) {
                        // Move children out of the element
                        while (element.firstChild) {
                            parent.insertBefore(element.firstChild, element);
                        }
                        parent.removeChild(element); // Remove the now empty element
                    }
                    continue; // Continue to the next element in the loop after unwrapping
                }

                // Existing logic for cleaning attributes and content if not completely unwrapped
                if (hasStyle || hasMsoWordBcx0Class || hasMsoWordBcx0Id) {
                    // Get the cleaned innerHTML based on the preservation rules
                    const cleanedInnerHtml = cleanAndPreserveAllowedContent(element, doc);

                    // Replace the original content with the cleaned content
                    element.innerHTML = cleanedInnerHtml;

                    // Remove the style attribute
                    if (hasStyle) {
                        element.removeAttribute('style');
                    }

                    // Clean the class attribute: remove the entire attribute if any class contains "Mso", "Word", or "BCX0"
                    if (classAttr) {
                        const hasDisallowedClass = classAttr.split(/\s+/).some(cls =>
                            cls.includes('Mso') || cls.includes('Word') || cls.includes('BCX0')
                        );
                        if (hasDisallowedClass) {
                            element.removeAttribute('class');
                        }
                        // If no disallowed class, the attribute remains as is.
                    }

                    // Clean the id attribute: remove id if it contains "Mso", "Word", or "BCX0"
                    if (idAttr && (idAttr.includes('Mso') || idAttr.includes('Word') || idAttr.includes('BCX0'))) {
                        element.removeAttribute('id');
                    }
                }
            }

            return doc.body.innerHTML;
        }

        /**
         * Converts common formatting tags: removes <u>, converts <b> to <strong>, and <i> to <em>.
         * @param {string} htmlString - The HTML content to clean.
         * @returns {string} The cleaned HTML content.
         */
        function applyCleanFormattingTags(htmlString) {
            const parser = new DOMParser();
            const doc = parser.parseFromString(htmlString, 'text/html');

            // 1. Remove <u> tags (unwrap them)
            const uElements = Array.from(doc.querySelectorAll('u'));
            for (let i = uElements.length - 1; i >= 0; i--) {
                const u = uElements[i];
                if (u.parentNode) {
                    while (u.firstChild) {
                        u.parentNode.insertBefore(u.firstChild, u);
                    }
                    u.parentNode.removeChild(u);
                }
            }

            // 2. Convert <b> to <strong>
            const bElements = Array.from(doc.querySelectorAll('b'));
            for (let i = bElements.length - 1; i >= 0; i--) {
                const b = bElements[i];
                if (b.parentNode) {
                    const strong = doc.createElement('strong');
                    while (b.firstChild) {
                        strong.appendChild(b.firstChild);
                    }
                    b.parentNode.replaceChild(strong, b);
                }
            }

            // 3. Convert <i> to <em>
            const iElements = Array.from(doc.querySelectorAll('i'));
            for (let i = iElements.length - 1; i >= 0; i--) {
                const i_tag = iElements[i]; // Renamed to avoid conflict with loop variable
                if (i_tag.parentNode) {
                    const em = doc.createElement('em');
                    while (i_tag.firstChild) {
                        em.appendChild(i_tag.firstChild);
                    }
                    i_tag.parentNode.replaceChild(em, i_tag);
                }
            }

            return doc.body.innerHTML;
        }

        /**
         * Adjusts heading levels (h1-h6) to ensure a correct hierarchical structure.
         *
         * Rules:
         * - If an H1 exists with `property="name"` and `id="wb-cont"`, it is preserved as H1.
         * - Otherwise, the very first encountered heading in the document (regardless of its initial level)
         * is converted to H2.
         * - All subsequent headings are adjusted relative to this H2 (or the preserved H1).
         * Specifically, if the document starts with H1 (which becomes H2), all subsequent headings shift down one level.
         * If the document starts with H3 (which becomes H2), all subsequent headings shift down one level.
         * If an H2 follows an H2, it remains H2. If an H2 follows an H1 (now H2), it becomes H3.
         * No more than one level skip down is allowed (e.g., H2 followed by H4 becomes H3).
         * All headings are guaranteed to be at least H2 (except the special H1).
         *
         * @param {string} htmlString - The HTML content to process.
         * @returns {string} The HTML content with adjusted heading levels.
         */
        function applyAutoLevelHeadings(htmlString) {
            const parser = new DOMParser();
            const doc = parser.parseFromString(htmlString, 'text/html');
            const body = doc.body;

            const headings = Array.from(body.querySelectorAll('h1, h2, h3, h4, h5, h6'));

            // Find the special H1, if it exists, which should be preserved.
            const specialH1 = headings.find(h =>
                h.tagName.toLowerCase() === 'h1' &&
                h.getAttribute('property') === 'name' &&
                h.id === 'wb-cont'
            );

            let levelAdjustmentForGlobalShift = 0; // The numerical shift to apply to all relevant headings (+1 for H1->H2, -1 for H3->H2 etc.)
            let firstRelevantHeadingFound = false;

            // First pass: Determine the overall level adjustment based on the first non-special heading
            for (const h of headings) {
                if (h === specialH1) {
                    continue; // Skip the special H1 in this calculation
                }
                if (!firstRelevantHeadingFound) {
                    const actualLevel = parseInt(h.tagName.substring(1), 10);
                    // Calculate the adjustment needed for this first heading to become an H2.
                    // If actualLevel is 1 (H1), adjust by +1 (1 + 1 = 2). So adjustment = 1.
                    // If actualLevel is 3 (H3), adjust by -1 (3 - 1 = 2). So adjustment = -1.
                    // General formula: levelAdjustment = (Target Level for First) - (Actual Level for First)
                    // Here, Target Level for First is always 2.
                    levelAdjustmentForGlobalShift = 2 - actualLevel;
                    firstRelevantHeadingFound = true;
                    break; // Only need to consider the very first one
                }
            }

            // Second pass: Apply the adjustments and enforce hierarchical rules
            let effectivePreviousLevel = 0; // Tracks the *resulting* level of the previously processed heading

            for (let i = 0; i < headings.length; i++) {
                let currentHeading = headings[i]; // Get the element reference

                // If it's the special H1, skip modification and set effectivePreviousLevel as H1 (level 1)
                if (currentHeading === specialH1) {
                    effectivePreviousLevel = 1;
                    continue;
                }

                const currentActualLevel = parseInt(currentHeading.tagName.substring(1), 10);
                let newLevel;

                // Calculate the 'globally adjusted' level based on the initial shift
                // (e.g., if first H1 became H2, all subsequent headings effectively shift up by 1 level number)
                let globallyAdjustedLevel = currentActualLevel + levelAdjustmentForGlobalShift;
                globallyAdjustedLevel = Math.max(2, globallyAdjustedLevel); // Ensure it's at least H2


                if (effectivePreviousLevel === 0) {
                    // This is the very first non-special heading we're processing. It must be H2.
                    newLevel = 2;
                } else {
                    // For subsequent headings, ensure two rules are met:
                    // 1. It maintains the overall global shift (`globallyAdjustedLevel`).
                    // 2. It doesn't jump more than one level down from the `effectivePreviousLevel`.
                    newLevel = Math.min(globallyAdjustedLevel, effectivePreviousLevel + 1);
                    // Also, ensure the new level is never below H2
                    newLevel = Math.max(2, newLevel);
                }

                // Only replace the element if its level needs to be changed
                if (newLevel !== currentActualLevel) {
                    const newHeadingTag = doc.createElement(`h${newLevel}`);
                    // Copy all attributes from the original heading to the new one
                    Array.from(currentHeading.attributes).forEach(attr => {
                        newHeadingTag.setAttribute(attr.name, attr.value);
                    });
                    // Move all children (content) from the original heading to the new one
                    while (currentHeading.firstChild) {
                        newHeadingTag.appendChild(currentHeading.firstChild);
                    }
                    // Replace the original heading element with the newly created one in the DOM.
                    // This is crucial if subsequent iterations might re-evaluate elements that were
                    // later in the original 'headings' array but whose parent or context might have changed.
                    // Although not strictly necessary with the current loop, it's safer for DOM manipulations.
                    if (currentHeading.parentNode) {
                        currentHeading.parentNode.replaceChild(newHeadingTag, currentHeading);
                    }
                    headings[i] = newHeadingTag; // Update the reference in the 'headings' array
                }
                
                // Update effectivePreviousLevel with the level that the current heading *actually* became
                effectivePreviousLevel = newLevel;
            }

            return body.innerHTML;
        }

        /**
         * Wraps <section> tags around heading tags and their content, nesting based on heading level.
         * Treats <aside> tags as H2 for sectioning purposes but does not wrap them.
         * Ignores sections with 'colophon' in their ID or containing a paragraph with '©' for auto-sectioning.
         * @param {string} htmlString - The HTML content to section.
         * @returns {string} The sectioned HTML content.
         */
        function applyAutoSectioning(htmlString) {
            const parser = new DOMParser();
            const doc = parser.parseFromString(htmlString, 'text/html');
            const originalBody = doc.body;

            const newBody = doc.createElement('body');
            // Stack stores { domElement: Node, level: number }
            let currentSectionStack = [{ domElement: newBody, level: 0 }]; // Level 0 for body (root container)

            // Iterate over the live childNodes of the originalBody
            while (originalBody.firstChild) {
                const node = originalBody.firstChild;
                // Temporarily remove the node from originalBody to process it
                originalBody.removeChild(node);

                if (node.nodeType === Node.ELEMENT_NODE) {
                    const tagName = node.tagName.toLowerCase();
                    let nodeLevel = null; // Conceptual level of the current node (e.g., 1 for h1, 2 for h2 or aside)
                    let shouldCreateNewSectionForNode = true; // Does this specific node warrant a new <section>?
                    let isProtectedSection = false; // Flag for sections to ignore

                    if (tagName === 'section') {
                        // Check if this section should be ignored (colophon ID, has any class, or p with ©)
                        // IMPORTANT CHANGE: Added condition to ignore sections that have a class attribute
                        if (node.id.includes('colophon') || node.querySelector('p')?.textContent?.includes('©') || node.hasAttribute('class') || (node.id && !/^sec\d+(-\d+)*$/.test(node.id))) {
                            isProtectedSection = true;
                            shouldCreateNewSectionForNode = false; // Do not wrap or re-section this
                        } else {
                            // For non-protected existing sections (those without class, not colophon/copyright, and follow 'sec' ID pattern),
                            // unwrap their content. This allows re-sectioning to properly build hierarchy.
                            const fragment = doc.createDocumentFragment();
                            while (node.firstChild) {
                                fragment.appendChild(node.firstChild);
                            }
                            // Temporarily append the fragment's children back to the originalBody
                            // so they are picked up in the next iteration of the while loop.
                            // Insert at the beginning so they are processed immediately.
                            originalBody.insertBefore(fragment, originalBody.firstChild);
                            // The original section 'node' is now empty. It will be implicitly removed
                            // when originalBody.removeChild(node) is called at the beginning of the next loop iteration.
                            // We use 'continue' to skip the rest of the current loop iteration, ensuring
                            // the unwrapped children are processed next.
                            continue;
                        }
                    }

                    const headingLevelMatch = tagName.match(/^h([1-6])$/);
                    if (headingLevelMatch) {
                        nodeLevel = parseInt(headingLevelMatch[1], 10);
                    } else if (tagName === 'aside') {
                        nodeLevel = 2; // Treat <aside> as H2 for sectioning logic
                        shouldCreateNewSectionForNode = false; // Do NOT wrap <aside> in its own section
                    }

                    if (isProtectedSection) {
                        // For protected sections, append them directly to the current effective parent
                        // and *don't* modify the currentSectionStack.
                        let parentToAppendTo = currentSectionStack[currentSectionStack.length - 1].domElement;
                        parentToAppendTo.appendChild(node);
                    }
                    else if (nodeLevel !== null) { // It's either a heading (h1-h6) or an <aside> and not a protected section
                        // Pop sections from stack if current node's level is less than or equal to the top section's level.
                        while (currentSectionStack.length > 1 && nodeLevel <= currentSectionStack[currentSectionStack.length - 1].level) {
                            currentSectionStack.pop();
                        }

                        let currentParentDomElement = currentSectionStack[currentSectionStack.length - 1].domElement;

                        if (shouldCreateNewSectionForNode) { // It's a heading, create a new section
                            const newSection = doc.createElement('section');
                            currentParentDomElement.appendChild(newSection);
                            // Push the new section onto the stack, updating the current parent for next elements
                            currentSectionStack.push({ domElement: newSection, level: nodeLevel });
                            // Append the original heading node to the newly created section
                            currentSectionStack[currentSectionStack.length - 1].domElement.appendChild(node);
                        } else { // It's an <aside>, append it directly to the current effective parent
                            currentParentDomElement.appendChild(node);
                            // IMPORTANT: <aside> does NOT create a new section for itself and is not pushed onto the stack.
                            // This means subsequent content will be appended relative to the section that *contains* the <aside>.
                        }
                    } else { // Not a heading, aside, or protected section; append to the current open section
                        currentSectionStack[currentSectionStack.length - 1].domElement.appendChild(node);
                    }
                } else { // Text node or comment node, append to the current open section
                    currentSectionStack[currentSectionStack.length - 1].domElement.appendChild(node);
                }
            }

            return newBody.innerHTML;
        }

        /**
         * Inserts IDs to all heading tags (h1-h6), section, and table tags based on specified rules.
         * This function ensures full re-numbering on each run, allowing for dynamic updates
         * after elements are added, deleted, or reordered.
         *
         * Rules:
         * - H1s: Not ID'd.
         * - H2s:
         * - If text starts with a number (e.g., "1. Introduction"): ID is "toc<number>" (e.g., "toc1").
         * - If text starts with "Appendix", "Annex", or "Annexe": ID is "app<letter>" (e.g., "appA", "appB"),
         * where the letter is derived from the text if present, otherwise sequentially generated.
         * - Otherwise (general H2): ID is "toc<sequential_letter>" (e.g., "tocA", "tocB").
         * - H3-H6: Nested IDs.
         * - If text starts with "Appendix", "Annex", or "Annexe": ID is "<parentID>-app<letter>",
         * where the letter is derived from the text if present, otherwise sequentially generated within that parent's scope.
         * - Otherwise (general H3-H6): ID is "<parentID>-<sequential_number>".
         *
         * - Sections:
         * - Top-level sections (direct children of body or not nested within other sections) get "sec#" (e.g., "sec1").
         * - Nested sections get "sec#-#", "sec#-#-#", etc., based on their parent section's ID.
         * - Sections that already have an ID are not modified if their ID does not follow the "sec" pattern.
         *
         * - Tables:
         * - Tables outside of a <figure> element get "tbl#" (e.g., "tbl1").
         * - Tables within a <figure> element get "ftbl#" (e.g., "ftbl1").
         * - "ftbl" IDs are numbered separately from "tbl" IDs.
         * - Tables that already have an ID are not modified (similar to sections).
         *
         * - Figures:
         * - Figure elements get "fig#" (e.g., "fig1").
         * - Figures that already have an ID are not modified if their ID does not follow the "fig" pattern.
         *
         * @param {string} htmlString - The HTML content to process.
         * @param {object} options - An object specifying which elements to ID.
         * @param {boolean} options.idSections - Whether to ID sections.
         * @param {boolean} options.idHeadings - Whether to ID headings.
         * @param {boolean} options.occursOutsideIgnoredParent - Determines if heading is within ignored parent (used to skip ID).
         * @param {boolean} options.idFigures - Whether to ID figures.
         * @param {boolean} options.idTables - Whether to ID general tables.
         * @param {boolean} options.idFigureTables - Whether to ID tables within figure elements.
         * @returns {string} The HTML content with IDs inserted.
         */
        function applyAutoId(htmlString, options = {}) {
            // Default options to true if not provided
            const defaultOptions = {
                idSections: true,
                idHeadings: true,
                idFigures: true, // NEW default for figures
                idTables: true,
                idFigureTables: true
            };
            const currentOptions = { ...defaultOptions, ...options };

            const parser = new DOMParser();
            const doc = parser.parseFromString(htmlString, 'text/html');
            const body = doc.body;

            // Map to store oldId: newId pairs for updating anchor links
            const idChangeMap = {};

            // Helper function to convert a number to an uppercase alphabetical string (A, B, C, ..., Z, AA, AB, ...)
            function toAlpha(num) {
                let s = '';
                let t;
                while (num > 0) {
                    t = (num - 1) % 26;
                    s = String.fromCharCode(65 + t) + s;
                    num = Math.floor((num - t) / 26);
                }
                return s || 'A';
            }

            // Helper function to extract an alphabetical character from an appendix/annex text
            // e.g., "Appendix A" -> "A", "Annex B" -> "B"
            function getLetterFromAppendixText(text) {
                const match = text.match(/^(?:Appendix|Annex|Annexe)\s*([A-Z])?/i);
                if (match && match[1]) {
                    return match[1].toUpperCase();
                }
                return null;
            }

            // Store existing IDs to avoid re-assigning if they match the desired pattern and are already present,
            // though for full re-numbering, we will overwrite. This set helps track uniqueness.
            const existingIds = new Set();
            // Collect existing IDs before processing to ensure no duplicate IDs are generated
            // even if the user had some manually set.
            doc.querySelectorAll('[id]').forEach(el => existingIds.add(el.id));

            // Headings counters - these should be persistent and not reset each other
            let h2_num_counter = 0; // For H2s starting with numbers (toc1, toc2)
            let h2_general_alpha_counter = 0; // For general H2s (tocA, tocB)
            let h2_appendix_alpha_counter = 0; // For H2s explicitly "Appendix" (appA, appB)

            // Sub-level counters (H3-H6)
            // Maps parent ID path string (e.g., "toc1" or "tocA-1") to its child counters
            let sub_num_counters = new Map(); // Stores { "parent_id": next_numeric_count }
            let sub_appendix_alpha_counters = new Map(); // Stores { "parent_id": next_alpha_count_for_appendices }

            // This array will hold segments of the current heading's ID path
            // e.g., ["toc1"], ["toc1", "1"], ["tocA", "appA"]
            let currentHeadingIdPathSegments = [];

            // Table counters
            let tableCounter = 0; // For 'tbl#'
            let figureTableCounter = 0; // For 'ftbl#'
            let figureCounter = 0; // NEW: For 'fig#'

            // Section specific counters: Maps parent section ID to its next child number
            // 'root' key is used for top-level sections (children of body)
            let sectionChildCounters = { 'root': 0 };

            if (currentOptions.idHeadings) {
                // --- Pre-scan: Determine if any H2 is numerically prefaced and global level adjustment ---
                let hasAnyNumberedH2 = false; // Flag to track if *any* regular H2 starts with a number (influences other regular H2s)
                let levelAdjustmentForGlobalShift = 0; // The numerical shift to apply to all relevant headings (+1 for H1->H2, -1 for H3->H2 etc.)
                let foundFirstRegularH2ForAdjustment = false; // Flag to ensure global shift is based on the *very first* regular H2

                const allHeadingsForPreScan = Array.from(body.querySelectorAll('h1, h2, h3, h4, h5, h6'));
                const specialH1ForPreScan = allHeadingsForPreScan.find(h =>
                    h.tagName.toLowerCase() === 'h1' &&
                    h.getAttribute('property') === 'name' &&
                    h.id === 'wb-cont'
                );

                for (const h of allHeadingsForPreScan) {
                    // Skip the special H1 in this pre-scan
                    if (h === specialH1ForPreScan) continue;

                    // Skip if inside an ignored parent
                    const ignoredParentsPreScan = ['aside', 'caption', 'figure', 'figcaption', 'table'];
                    let isInsideIgnoredParentPreScan = false;
                    let currentParentPreScan = h.parentNode;
                    while (currentParentPreScan && currentParentPreScan !== body) {
                        if (ignoredParentsPreScan.includes(currentParentPreScan.tagName.toLowerCase())) {
                            isInsideIgnoredParentPreScan = true;
                            break;
                        }
                        currentParentPreScan = currentParentPreScan.parentNode;
                    }
                    if (isInsideIgnoredParentPreScan) continue;

                    // Check if this is a potential "special first H2" (content-based or existing ID)
                    const textContentLower = h.textContent.trim().toLowerCase();
                    const isPotentialSpecialFirstH2 = (h.tagName.toLowerCase() === 'h2' && (h.hasAttribute('id') ||
                        textContentLower.includes('on this page') ||
                        textContentLower.includes('sur cette page') ||
                        textContentLower.includes('in this section') ||
                        textContentLower.includes('dans cette section') ||
                        textContentLower.includes('table of contents') ||
                        textContentLower.includes('table des matières') ||
                        textContentLower.replace(/:/g, '').trim() === 'on this page' ||
                        textContentLower.replace(/:/g, '').trim() === 'sur cette page' ||
                        textContentLower.replace(/:/g, '').trim() === 'in this section' ||
                        textContentLower.replace(/:/g, '').trim() === 'dans cette section' ||
                        textContentLower.replace(/:/g, '').trim() === 'table of contents' ||
                        textContentLower.replace(/:/g, '').trim() === 'table des matières'
                    ));

                    if (!foundFirstRegularH2ForAdjustment && isPotentialSpecialFirstH2) {
                        // If the very first *relevant* H2 is special, we don't base the global shift on it.
                        // We'll wait for the next *regular* H2.
                        continue;
                    }

                    const currentActualLevel = parseInt(h.tagName.substring(1), 10);
                    if (!foundFirstRegularH2ForAdjustment) {
                        // This is the first *actual* regular heading that will receive a numbered/lettered ID.
                        levelAdjustmentForGlobalShift = 2 - currentActualLevel;
                        foundFirstRegularH2ForAdjustment = true; // Mark as found
                    }

                    // Check if this heading is numerically prefaced (for `hasAnyNumberedH2`)
                    const text = h.textContent.trim();
                    if (h.tagName.toLowerCase() === 'h2' && text.match(/^\s*(\d+)(?:\.|\s|\)|\-)?/)) {
                        hasAnyNumberedH2 = true;
                    }
                }
                // --- End Pre-scan ---

                let initialH2ProcessedInLoop = false; // Flag to ensure the special 'toc' H2 logic runs only once for the first qualifying H2.

                // Process all headings (H1, H2, H3, H4, H5, H6)
                doc.querySelectorAll('h1, h2, h3, h4, h5, h6').forEach(heading => {
                    const level = parseInt(heading.tagName.substring(1), 10);
                    const text = heading.textContent.trim();
                    const oldId = heading.id;
                    let newId = oldId; // Initialize newId with oldId, only change if logic dictates

                    // 1. Handle special H1 (wb-cont)
                    if (level === 1 && heading.getAttribute('property') === 'name' && heading.id === 'wb-cont') {
                        currentHeadingIdPathSegments = [];
                        sub_num_counters.clear();
                        sub_appendix_alpha_counters.clear();
                        effectivePreviousLevel = 1;
                        // Since this is an H1, it doesn't affect the `initialH2ProcessedInLoop` flag specifically for H2s.
                        return;
                    }

                    // 2. Handle ignored parent
                    const ignoredParents = ['aside', 'caption', 'figure', 'figcaption', 'table'];
                    let isInsideIgnoredParent = false;
                    let currentParent = heading.parentNode;
                    while (currentParent && currentParent !== body) {
                        if (ignoredParents.includes(currentParent.tagName.toLowerCase())) {
                            isInsideIgnoredParent = true;
                            break;
                        }
                        currentParent = currentParent.parentNode;
                    }
                    if (isInsideIgnoredParent) {
                        return;
                    }

                    // 3. Special handling for the very first H2 that is not a special H1 and not in an ignored parent
                    // This logic only applies to the *first* H2 encountered that passes the above checks.
                    if (level === 2 && !initialH2ProcessedInLoop) {
                        const textContentLower = heading.textContent.trim().toLowerCase();
                        const textMatchesCriteria =
                            textContentLower.includes('on this page') ||
                            textContentLower.includes('sur cette page') ||
                            textContentLower.includes('in this section') ||
                            textContentLower.includes('dans cette section') ||
                            textContentLower.includes('table of contents') ||
                            textContentLower.includes('table des matières');

                        // Check for optional colon variants
                        const textWithoutColon = textContentLower.replace(/:/g, '').trim();
                        const textMatchesCriteriaWithoutColon =
                            textWithoutColon === 'on this page' ||
                            textWithoutColon === 'sur cette page' ||
                            textWithoutColon === 'in this section' ||
                            textWithoutColon === 'dans cette section' ||
                            textWithoutColon === 'table of contents' ||
                            textWithoutColon === 'table des matières';

                        if (heading.hasAttribute('id') || textMatchesCriteria || textMatchesCriteriaWithoutColon) {
                            // If it has an existing ID, keep it. Otherwise, set to "toc".
                            if (!heading.hasAttribute('id')) {
                                newId = 'toc';
                            } else {
                                newId = oldId; // Keep existing ID
                            }
                            // Only set ID if different or if it was empty
                            if (oldId !== newId || !oldId) {
                                heading.setAttribute('id', newId);
                                idChangeMap[oldId] = newId; // Track the change
                                existingIds.add(newId);
                            }

                            currentHeadingIdPathSegments = [newId]; // This sets the path for subsequent headings
                            sub_num_counters.clear(); // Reset sub-counters as this is a new "root" for them
                            sub_appendix_alpha_counters.clear();
                            effectivePreviousLevel = 2; // Treat this as an H2 for subsequent level calculation
                            initialH2ProcessedInLoop = true; // Mark as handled, so this block won't run again for another H2
                            return; // Done with this heading, move to the next in the loop
                        }
                    }

                    // This block runs for all headings (H2, H3, H4, H5, H6) that are NOT the special 'toc' H2.
                    // This is where regular numerical/alphabetical ID assignment occurs.

                    let id_segment = '';
                    const isNumericHeading = text.match(/^\s*(\d+)(?:\.|\s|\)|\-)?/);
                    const isAppendixHeading = text.match(/^(?:Appendix|Annex|Annexe)\s*(?:([A-Z]))?/i);

                    if (level === 2) {
                        // This is a regular H2 (not the special 'toc' type).
                        // If it's the very first *regular* H2, ensure counters are reset for its sequence.
                        if (!initialH2ProcessedInLoop) { // This means it's the very first *actual* numbered/lettered H2.
                            h2_num_counter = 0;
                            h2_general_alpha_counter = 0;
                            h2_appendix_alpha_counter = 0;
                            initialH2ProcessedInLoop = true; // Mark that a *regular* H2 has now been processed
                        }

                        if (isAppendixHeading) {
                            const letterFromText = getLetterFromAppendixText(text);
                            if (letterFromText) {
                                id_segment = `app${letterFromText}`;
                            } else {
                                h2_appendix_alpha_counter++;
                                id_segment = `app${toAlpha(h2_appendix_alpha_counter)}`;
                            }
                        } else if (hasAnyNumberedH2) { // Global check from pre-scan
                            if (isNumericHeading) {
                                h2_num_counter++;
                                id_segment = `toc${h2_num_counter}`;
                            } else {
                                h2_general_alpha_counter++;
                                id_segment = `toc${toAlpha(h2_general_alpha_counter)}`;
                            }
                        } else { // No numbered H2s in the document, all H2s get numeric IDs
                            h2_num_counter++;
                            id_segment = `toc${h2_num_counter}`;
                        }
                        currentHeadingIdPathSegments = [id_segment];
                        sub_num_counters.clear();
                        sub_appendix_alpha_counters.clear();

                    } else { // For H3, H4, H5, H6
                        currentHeadingIdPathSegments.length = level - 2; // Trim path to parent's level
                        const parent_id_path_string = currentHeadingIdPathSegments.join('-');

                        if (isAppendixHeading) {
                            const letterFromText = getLetterFromAppendixText(text);
                            if (letterFromText) {
                                id_segment = `app${letterFromText}`;
                            } else {
                                const currentAppCount = (sub_appendix_alpha_counters.get(parent_id_path_string) || 0) + 1;
                                sub_appendix_alpha_counters.set(parent_id_path_string, currentAppCount);
                                id_segment = `app${toAlpha(currentAppCount)}`;
                            }
                            sub_num_counters.delete(parent_id_path_string);
                        } else {
                            const currentNumCount = (sub_num_counters.get(parent_id_path_string) || 0) + 1;
                            sub_num_counters.set(parent_id_path_string, currentNumCount);
                            id_segment = String(currentNumCount);
                            sub_appendix_alpha_counters.delete(parent_id_path_string);
                        }
                        currentHeadingIdPathSegments.push(id_segment);
                    }

                    newId = currentHeadingIdPathSegments.join('-');
                    if (oldId && oldId !== newId) {
                        idChangeMap[oldId] = newId;
                    }
                    heading.setAttribute('id', newId);
                    existingIds.add(newId);
                    effectivePreviousLevel = level;
                });
            }


            if (currentOptions.idSections) {
                // Process Sections
                // The approach for sections already rebuilds IDs based on hierarchy on each run.
                doc.querySelectorAll('section').forEach(section => {
                    const existingId = section.getAttribute('id');
                    const oldId = section.id; // Capture old ID

                    // IMPORTANT CHANGE: If section already has an ID AND it does NOT match the "sec" pattern OR has a class, skip it.
                    // This allows manual section IDs to persist.
                    if (existingId && (!/^sec\d+(-\d+)*$/.test(existingId) || section.hasAttribute('class'))) {
                        return; // Do not overwrite non-standard section IDs or sections with classes
                    }

                    let parentSectionId = 'root'; // Default for top-level sections
                    let tempParent = section.parentNode;

                    // Traverse up to find the closest parent section with an ID that follows the "sec" pattern
                    while (tempParent && tempParent !== body) {
                        if (tempParent.tagName.toLowerCase() === 'section' && tempParent.id && /^sec\d+(-\d+)*$/.test(tempParent.id)) {
                            parentSectionId = tempParent.id;
                            break;
                        }
                        tempParent = tempParent.parentNode;
                    }

                    // Increment the counter for the current parent's children
                    sectionChildCounters[parentSectionId] = (sectionChildCounters[parentSectionId] || 0) + 1;
                    const newSectionNum = sectionChildCounters[parentSectionId];

                    let newId;
                    if (parentSectionId === 'root') {
                        newId = `sec${newSectionNum}`;
                    } else {
                        newId = `${parentSectionId}-${newSectionNum}`;
                    }

                    if (oldId && oldId !== newId) {
                        idChangeMap[oldId] = newId; // Store the ID change
                    }
                    section.setAttribute('id', newId);
                    existingIds.add(newId); // Add newly assigned ID to set
                });
            }

            // NEW: Process Figures
            if (currentOptions.idFigures) {
                doc.querySelectorAll('figure').forEach(figure => {
                    const existingId = figure.getAttribute('id');
                    const oldId = figure.id; // Capture old ID
                    // Only assign a new ID if it doesn't already have one or if it's not a standard fig# ID.
                    if (!existingId || !/^fig\d+$/.test(existingId)) {
                        figureCounter++;
                        const newId = `fig${figureCounter}`;
                        if (oldId && oldId !== newId) {
                            idChangeMap[oldId] = newId; // Store the ID change
                        }
                        figure.setAttribute('id', newId);
                        existingIds.add(newId);
                    }
                });
            }

            if (currentOptions.idTables || currentOptions.idFigureTables) {
                // Process Tables
                // Similar to sections, table IDing also rebuilds on each run.
                doc.querySelectorAll('table').forEach(table => {
                    const oldId = table.id; // Capture old ID
                    // For full re-numbering, we will re-assign table IDs.
                    const parentFigure = table.closest('figure');
                    let newId = null;

                    if (parentFigure && currentOptions.idFigureTables) {
                        // It's inside a figure, assign ftbl#
                        figureTableCounter++;
                        newId = `ftbl${figureTableCounter}`;
                    } else if (!parentFigure && currentOptions.idTables) {
                        // It's not inside a figure, assign tbl#
                        tableCounter++;
                        newId = `tbl${tableCounter}`;
                    }

                    if (newId) {
                        if (oldId && oldId !== newId) {
                            idChangeMap[oldId] = newId; // Store the ID change
                        }
                        table.setAttribute('id', newId);
                        existingIds.add(newId);
                    } else {
                        // If neither option is selected for this table type, ensure it has no ID.
                        // If oldId existed and is now removed, it should be noted, but for simplicity
                        // we focus on changed IDs as per request.
                        if (oldId) {
                             table.removeAttribute('id'); // Explicitly remove ID if it was there and no new one assigned
                        }
                    }
                });
            }

            // --- NEW: Update anchor links based on idChangeMap ---
            const allLinks = doc.querySelectorAll('a[href^="#"]');
            allLinks.forEach(link => {
                const currentAnchor = link.getAttribute('href').substring(1); // Get the ID part without '#'
                if (idChangeMap[currentAnchor]) {
                    link.setAttribute('href', `#${idChangeMap[currentAnchor]}`);
                }
            });
            // --- END NEW ANCHOR UPDATE ---

            return body.innerHTML;
        }

        // REMOVED: generateToc function
        // REMOVED: showTocModal function


        /**
         * Function to set the content of the HugeRTE editor.
         * This is called from the parent window.
         */
        window.setRichEditorContent = function(content) {
            // console.log("Parent: Attempting to set HugeRTE content.");
            if (richTextEditorInstance) {
                richTextEditorInstance.setContent(cleanHtmlForRichTextDisplay(content));
                richTextEditorInstance.focus(); // Re-focus the rich editor after content update
                // console.log('Parent: HugeRTE updated from HTML editor.');
            } else {
                console.warn('Parent: HugeRTE editor not yet initialized. Content will be set once ready.');
            }
        };

        /**
         * Function to get the content from the HugeRTE editor.
         * This is called from the parent window.
         */
        window.getRichEditorContent = function() {
            // console.log("Parent: Attempting to get HugeRTE content.");
            if (richTextEditorInstance) {
                const content = richTextEditorInstance.getContent();
                // console.log("Parent: HugeRTE content requested by parent.");
                return content;
            } else {
                console.warn('Iframe: HugeRTE editor not yet initialized. Cannot get content.');
                return '';
            }
        };

        /**
         * Updates the disabled state of all interactive buttons.
         * Buttons are disabled if any button has 'data-temp-active' set to 'true'.
         */
        function updateAllInteractiveButtonStates() {
            const anyTempMessageActive = allInteractiveButtons.some(btn => btn.getAttribute('data-temp-active') === 'true');

            allInteractiveButtons.forEach(btn => {
                // If a button itself has 'data-temp-active', it means its modal is open, so it should be disabled.
                // Otherwise, it's disabled if ANY other button has 'data-temp-active'.
                btn.disabled = btn.getAttribute('data-temp-active') === 'true' || anyTempMessageActive;
            });
        }


        /**
         * Toggles the active editor view between 'richtext' and 'code'.
         * Includes automatic content synchronization.
         */
        function toggleEditorView() {
            // Prevent toggling if any button is disabled (implicitly means a temp message is active)
            const anyTempMessageActive = allInteractiveButtons.some(btn => btn.getAttribute('data-temp-active') === 'true');
            if (anyTempMessageActive) {
                console.log("Toggle prevented: another button is active.");
                return;
            }

            console.log("Toggle Editor View triggered. Current view:", currentView);
            if (currentView === 'richtext') {
                // --- Logic when switching FROM Rich-Text TO Code ---
                // 1. Get content from Rich-Text editor.
                if (default_ifr.contentWindow && default_ifr.contentWindow.getRichEditorContent) {
                    richTextContent = default_ifr.contentWindow.getRichEditorContent();
                    console.log("Syncing from Rich Text to HTML. Rich Text Content length:", richTextContent.length);
                } else {
                    console.warn("Rich Text Editor not ready for content retrieval on toggle. Using empty string.");
                    richTextContent = '';
                }

                // Restore protected data attributes FIRST, as other cleaning might remove elements
                let processedContent = restoreDataAttributes(richTextContent);
                console.log("Data attributes restored after Rich Text editor roundtrip.");

                // Apply Auto-Clean MSO in the specified order when switching to HTML editor
                if (toggleAutoCleanMsoOnSwitchRichText.checked) {
                    console.log("Auto-Clean MSO applied when switching to HTML editor.");
                    // Apply Clean Mso Lists
                    processedContent = applyCleanLists(processedContent);
                    console.log("Clean MSO Lists applied.");
                    // Apply Clean Mso Tables
                    processedContent = applyCleanTablesBasic(processedContent);
                    console.log("Clean MSO Tables applied.");
                    // Apply Clean Mso Code (includes IMGs now)
                    processedContent = applyCleanMsoCode(processedContent);
                    console.log("Clean MSO Code (including IMGs) applied.");
                    // Apply URL cleaning
                    processedContent = applyUrlCleaning(processedContent);
                    console.log("Clean URLs applied.");
                    // Apply Clean Spaces
                    processedContent = applyAutoSpacing(processedContent);
                    console.log("Clean Spaces applied.");
                } else {
                     // If auto-clean MSO is not checked, still apply URL cleaning on switch.
                     // URL cleaning is always applied when switching to HTML.
                    processedContent = applyUrlCleaning(processedContent);
                    console.log("URL cleaning applied (not part of Auto-Clean MSO, but always on switch).");
                }

                // 2. Update HTML output content and Monaco editor.
                htmlOutputContent = processedContent;
                if (monacoEditorInstance) {
                    monacoEditorInstance.setValue(htmlOutputContent);
                    monacoEditorInstance.focus();
                    applyEntityHighlighting();
                    console.log("Monaco editor updated with Rich Text content.");
                } else {
                    console.warn('Monaco editor not yet initialized. Content will be set once ready.');
                }

                // Run Auto-Encode and Auto-Indent when switching to HTML editor
                autoEncodeBtn.click();

                // 3. Switch panel visibility.
                richtextOutputPanel.classList.remove('panel-visible');
                richtextOutputPanel.classList.add('panel-hidden');
                mainEditorArea.classList.remove('panel-hidden'); // Show main editor area
                mainEditorArea.classList.add('panel-visible');

                // 4. Update button styles.
                // "Go to HTML" button (toggleEditorViewBtnRichText) is now inactive/hidden.
                // Remove all color classes and set to default slate.
                toggleEditorViewBtnRichText.classList.remove('bg-green-600', 'hover:bg-green-700', 'bg-cyan-700', 'hover:bg-cyan-800');
                toggleEditorViewBtnRichText.classList.add('bg-slate-800', 'hover:bg-slate-700');

                // "Go to Rich-Text" button (toggleEditorViewBtnCode) is now active/visible.
                // It should be cyan.
                toggleEditorViewBtnCode.classList.remove('bg-green-600', 'hover:bg-green-700', 'bg-slate-800', 'hover:bg-slate-700');
                toggleEditorViewBtnCode.classList.add('bg-cyan-700', 'hover:bg-cyan-800');

                currentView = 'code';
                console.log("Switched to Code View.");
                updateCleanMsoButtonState(); // Ensure Clean Mso button state is correct after view switch
            } else { // currentView === 'code'
                // --- Logic when switching FROM Code TO Rich-Text ---
                // No auto-clean MSO should happen when switching TO the Rich-Text editor.
                // 1. Get content from Monaco editor.
                if (monacoEditorInstance) {
                    htmlOutputContent = monacoEditorInstance.getValue();
                    console.log("Syncing from HTML to Rich Text. HTML Output Content length:", htmlOutputContent.length);
                } else {
                    console.warn("Monaco editor not ready for content retrieval on toggle. Using empty string.");
                    htmlOutputContent = '';
                }

                // Protect data attributes BEFORE sending to TinyMCE
                let contentToSendToRichText = protectDataAttributes(htmlOutputContent);
                console.log("Data attributes protected before sending to Rich Text editor.");

                // 2. Update Rich Text content and editor.
                richTextContent = contentToSendToRichText; // Use the protected content
                if (default_ifr.contentWindow && default_ifr.contentWindow.setRichEditorContent) {
                    default_ifr.contentWindow.setRichEditorContent(cleanHtmlForRichTextDisplay(richTextContent));
                    console.log("HugeRTE editor updated with HTML content.");
                } else {
                    console.warn("Rich Text Editor not ready for content setting on toggle.");
                }

                // 3. Switch panel visibility.
                mainEditorArea.classList.remove('panel-visible'); // Hide main editor area
                mainEditorArea.classList.add('panel-hidden');
                richtextOutputPanel.classList.remove('panel-hidden');
                richtextOutputPanel.classList.add('panel-visible');

                // 4. Update button styles.
                // "Go to Rich-Text" button (toggleEditorViewBtnCode) is now inactive/hidden.
                // It should be cyan.
                toggleEditorViewBtnCode.classList.remove('bg-green-600', 'hover:bg-green-700', 'bg-slate-800', 'hover:bg-slate-700');
                toggleEditorViewBtnCode.classList.add('bg-cyan-700', 'hover:bg-cyan-800');

                // "Go to HTML" button (toggleEditorViewBtnRichText) is now active/visible.
                // Its color depends on the MSO toggle.
                updateGoToHtmlButtonColor(); // This function handles its specific coloring.

                currentView = 'richtext';
                console.log("Switched to Rich Text View.");
                updateCleanMsoButtonState(); // Ensure Clean Mso button state is correct after view switch
            }
        }

        // Variable to store Monaco decorations for entities
        let entityDecorations = [];

        /**
         * Applies highlighting to HTML character entities in the Monaco editor.
         */
        function applyEntityHighlighting() {
            if (!monacoEditorInstance) return;

            const model = monacoEditorInstance.getModel();
            if (!model) return;

            const newDecorations = [];
            const text = model.getValue();
            // Regex to find HTML entities like &nbsp; &#160; &amp;
            const regex = /&[a-zA-Z0-9#]+;/g;

            let match;
            while ((match = regex.exec(text)) !== null) {
                const startPos = model.getPositionAt(match.index);
                const endPos = model.getPositionAt(match.index + match[0].length);

                newDecorations.push({
                    range: new monaco.Range(startPos.lineNumber, startPos.column, endPos.lineNumber, endPos.column),
                    options: {
                        inlineClassName: 'entity-highlight',
                        hoverMessage: { value: 'HTML Character Entity' } // Optional: show tooltip on hover
                    }
                });
            }

            // Apply the new decorations and clear old ones
            entityDecorations = monacoEditorInstance.deltaDecorations(entityDecorations, newDecorations);
        }

        /**
         * Updates the color of the "Go to HTML" button based on the "Auto-Clean MSO when switching" toggle state.
         * This function is now responsible for setting the correct color for the "Go to HTML" button
         * when the `currentView` is 'richtext' (meaning the "Go to HTML" button is visible and active).
         */
        function updateGoToHtmlButtonColor() {
            // This function is called when the rich text panel is visible and the "Go to HTML" button is active.
            // Its color should reflect the state of toggleAutoCleanMsoOnSwitchRichText.
            if (toggleAutoCleanMsoOnSwitchRichText.checked) {
                toggleEditorViewBtnRichText.classList.remove('bg-cyan-700', 'hover:bg-cyan-800', 'bg-slate-800', 'hover:bg-slate-700');
                toggleEditorViewBtnRichText.classList.add('bg-green-600', 'hover:bg-green-700');
            } else {
                toggleEditorViewBtnRichText.classList.remove('bg-green-600', 'hover:bg-green-700', 'bg-slate-800', 'hover:bg-slate-700');
                toggleEditorViewBtnRichText.classList.add('bg-cyan-700', 'hover:bg-cyan-800');
            }
        }

        /**
         * Updates the state of the "Clean Mso" button based on the "Auto-Clean MSO" toggle.
         */
        function updateCleanMsoButtonState() {
            const isAutoCleanEnabled = toggleAutoCleanMsoOnSwitchRichText.checked; // Check any of the synced toggles
            if (isAutoCleanEnabled) {
                cleanMsoBtn.disabled = true;
                cleanMsoBtn.classList.remove('bg-blue-700', 'hover:bg-blue-800');
                cleanMsoBtn.classList.add('bg-gray-400', 'cursor-not-allowed', 'opacity-60');
            } else {
                cleanMsoBtn.disabled = false;
                cleanMsoBtn.classList.remove('bg-gray-400', 'cursor-not-allowed', 'opacity-60');
                cleanMsoBtn.classList.add('bg-blue-700', 'hover:bg-blue-800');
            }
        }

        /**
         * Simple debounce function.
         * @param {Function} func The function to debounce.
         * @param {number} delay The delay in milliseconds.
         * @returns {Function} The debounced function.
         */
        function debounce(func, delay) {
            let timeout;
            return function(...args) {
                const context = this;
                clearTimeout(timeout);
                timeout = setTimeout(() => func.apply(context, args), delay);
            };
        }

        // Debounced version of monacoEditorInstance.layout() for window resize
        const debouncedMonacoLayout = debounce(() => {
            if (monacoEditorInstance) {
                monacoEditorInstance.layout();
            }
        }, 200); // Debounce for window resize, not internal panel resize

        /**
         * Displays a modal dialog with a given title and HTML content.
         * Note: This `showModal` function is specifically for the Colophon, and is distinct from `showFootnoteModal`.
         * @param {string} title - The title of the modal.
         * @param {string} contentHtml - The HTML content for the modal body.
         * @param {HTMLElement} triggeringButton - The button that opened this modal.
         * @param {string} originalButtonText - The original text of the triggering button before "Opening...".
         */
        function showModal(title, contentHtml, triggeringButton, originalButtonText) {
            const modalOverlay = document.createElement('div');
            modalOverlay.className = 'modal-overlay';
            modalOverlay.innerHTML = `
                <div class="modal-content">
                    <h3>${title}</h3>
                    <div id="modalBody">${contentHtml}</div>
                    <div class="flex justify-end mt-4 space-x-2">
                        <button id="modalCancelBtn" class="px-4 py-2 bg-gray-500 text-white rounded-md hover:bg-gray-600">Cancel</button>
                        <button id="modalInsertBtn" class="px-4 py-2 bg-green-600 text-white rounded-md hover:bg-green-700">Insert</button>
                    </div>
                </div>
            `;
            document.body.appendChild(modalOverlay);

            // Function to clean up and re-enable buttons
            function closeModalAndReEnableButtons() {
                modalOverlay.remove();
                triggeringButton.removeAttribute('data-temp-active'); // Crucial: Remove flag
                // Directly revert the button text and color here
                triggeringButton.textContent = originalButtonText;
                triggeringButton.classList.remove('bg-green-500', 'hover:bg-green-600');
                triggeringButton.classList.add('bg-slate-600', 'hover:bg-slate-500');
                updateAllInteractiveButtonStates(); // Re-enable all buttons
            }


            document.getElementById('modalCancelBtn').addEventListener('click', closeModalAndReEnableButtons);

            // Get references to elements within the newly created modal
            const langEnglishBtn = document.getElementById('langEnglishBtn');
            const langFrenchBtn = document.getElementById('langFrenchBtn');
            const monarchKingBtn = document.getElementById('monarchKingBtn');
            const monarchQueenBtn = document.getElementById('monarchQueenBtn');
            const idISBNBtn = document.getElementById('idISBNBtn');
            const idISSNBtn = document.getElementById('idISSNBtn');
            const colophonYearInput = document.getElementById('colophonYear');
            const colophonNumberInput = document.getElementById('colophonNumber'); // Reference for the number input
            const modalInsertBtn = document.getElementById('modalInsertBtn');

            let selectedLanguage = 'English'; // Default to English
            let selectedMonarch = 'King'; // Default
            let selectedIdentifier = 'ISBN'; // Default

            // Function to update button active state
            function updateButtonActiveState(buttons, activeBtn) {
                buttons.forEach(btn => {
                    btn.classList.remove('active', 'bg-indigo-600'); /* Changed */
                    btn.classList.add('bg-gray-600', 'hover:bg-gray-500'); /* Changed */
                });
                activeBtn.classList.add('active', 'bg-indigo-600'); /* Changed */
                activeBtn.classList.remove('bg-gray-600', 'hover:bg-gray-500'); /* Changed */
            }

            // Initial active states
            updateButtonActiveState([langEnglishBtn, langFrenchBtn], langEnglishBtn);
            updateButtonActiveState([monarchKingBtn, monarchQueenBtn], monarchKingBtn);
            updateButtonActiveState([idISBNBtn, idISSNBtn], idISBNBtn);

            // Event listeners for language buttons
            langEnglishBtn.addEventListener('click', () => {
                selectedLanguage = 'English';
                updateButtonActiveState([langEnglishBtn, langFrenchBtn], langEnglishBtn);
            });

            langFrenchBtn.addEventListener('click', () => {
                selectedLanguage = 'French';
                updateButtonActiveState([langEnglishBtn, langFrenchBtn], langFrenchBtn);
            });

            // Event listeners for Monarch toggle
            monarchKingBtn.addEventListener('click', () => {
                selectedMonarch = 'King';
                updateButtonActiveState([monarchKingBtn, monarchQueenBtn], monarchKingBtn);
            });

            monarchQueenBtn.addEventListener('click', () => {
                selectedMonarch = 'Queen';
                updateButtonActiveState([monarchKingBtn, monarchQueenBtn], monarchQueenBtn);
            });

            // Event listeners for ISBN/ISSN toggle
            idISBNBtn.addEventListener('click', () => {
                selectedIdentifier = 'ISBN';
                updateButtonActiveState([idISBNBtn, idISSNBtn], idISBNBtn);
            });

            idISSNBtn.addEventListener('click', () => {
                selectedIdentifier = 'ISSN';
                updateButtonActiveState([idISBNBtn, idISSNBtn], idISSNBtn);
            });

            // Year input validation
            colophonYearInput.addEventListener('input', (event) => {
                const input = event.target;
                // Remove any non-digit characters
                input.value = input.value.replace(/\D/g, '');
                // Truncate to 4 digits if longer
                if (input.value.length > 4) {
                    input.value = input.value.substring(0, 4);
                }
            });

            // Insert button logic
            modalInsertBtn.addEventListener('click', () => {
                const currentYear = new Date().getFullYear();
                const year = colophonYearInput.value || currentYear;
                const number = colophonNumberInput.value || '###';
                let colophonHtmlContent = `<section id="colophon">\n<p class="mrgn-tp-lg text-center small">© `;

                if (selectedLanguage === 'English') {
                    if (selectedMonarch === 'King') {
                        colophonHtmlContent += `His Majesty the King in Right of Canada, represented by the President of the Treasury Board, ${year},<br>${selectedIdentifier}:&#160;${number}</p>\n</section>`;
                    } else { // Queen
                        colophonHtmlContent += `Her Majesty the Queen in Right of Canada, represented by the President of the Treasury Board, ${year},<br>${selectedIdentifier}:&#160;${number}</p>\n</section>`;
                    }
                } else { // French
                    if (selectedMonarch === 'King') {
                        colophonHtmlContent += `Sa Majesté le Roi du chef du Canada, représenté par le président du Conseil du Trésor, ${year},<br>${selectedIdentifier}&#160;:&#160;${number}</p>\n</section>`;
                    } else { // Queen
                        colophonHtmlContent += `Sa Majesté la Reine du chef du Canada, représentée par le président du Conseil du Conseil du Trésor, ${year},<br>${selectedIdentifier}&#160;:&#160;${number}</p>\n</section>`;
                    }
                }

                // Insert the generated HTML into the Monaco editor
                if (monacoEditorInstance) {
                    let currentContent = monacoEditorInstance.getValue();
                    currentContent = protectDataAttributes(currentContent); // Protect attributes before string manipulation

                    // Append the new colophon HTML
                    currentContent += colophonHtmlContent;

                    currentContent = restoreDataAttributes(currentContent); // Restore attributes
                    currentContent = convertAllEntitiesToNumeric(currentContent); // Ensure entities are correct after all operations

                    monacoEditorInstance.setValue(currentContent);
                    htmlOutputContent = currentContent; // Update main content variable
                    applyEntityHighlighting(); // Re-apply highlighting
                }

                closeModalAndReEnableButtons(); // Cleanup and re-enable immediately

                // Capture originalButtonText in a local constant for the setTimeout closure
                const capturedOriginalText = originalButtonText;

                // Provide visual feedback for the triggering button only after successful insert
                triggeringButton.textContent = 'Inserted!';
                triggeringButton.classList.add('bg-green-500', 'hover:bg-green-600');
                triggeringButton.classList.remove('bg-slate-600', 'hover:bg-slate-500');
                // The disabled state is managed by updateAllInteractiveButtonStates()
                setTimeout(() => {
                    triggeringButton.textContent = capturedOriginalText; // Revert to initial text
                    triggeringButton.classList.remove('bg-green-500', 'hover:bg-green-600');
                    triggeringButton.classList.add('bg-slate-600', 'hover:bg-slate-500');
                }, 1500);
            });
        }

        /**
         * Displays a modal dialog for configuring and inserting footnote lists.
         * @param {HTMLElement} triggeringButton - The button that opened this modal.
         * @param {string} originalButtonText - The original text of the triggering button.
         */
        function showFootnoteModal(triggeringButton, originalButtonText) {
            const footnoteContentHtml = `
                <div class="flex flex-col space-y-4">
				<div>
				<p>NOTE: This only creates an empty list of footnotes, you must populate it on your own. It also does not add/change anchors. 
				</div>
                    <div>
                        <span class="text-sm font-medium text-gray-200 mr-2">Language:</span>
                        <div class="button-group inline-flex">
                            <button id="fnLangEnglishBtn" class="px-3 py-1 text-sm bg-gray-600 text-white rounded-md hover:bg-gray-500 focus:outline-none focus:ring-2 focus:ring-slate-500 focus:ring-opacity-50 font-bold">English</button>
                            <button id="fnLangFrenchBtn" class="px-3 py-1 text-sm bg-gray-600 text-white rounded-md hover:bg-gray-500 focus:outline-none focus:ring-2 focus:ring-slate-500 focus:ring-opacity-50 font-bold">French</button>
                        </div>
                    </div>
                    
                    <div>
                        <label for="fnCount" class="block text-sm font-medium text-gray-200">How many?</label>
                        <input type="number" id="fnCount" class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500" placeholder="1" min="1" value="1">
                    </div>
					<div>
                        <label for="fnIdPrefix" class="block text-sm font-medium text-gray-200">ID Prefix (optional):</label>
                        <input type="text" id="fnIdPrefix" class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500" placeholder="e.g., mydoc-">
					</div>
                </div>
            `;

            const modalOverlay = document.createElement('div');
            modalOverlay.className = 'modal-overlay';
            modalOverlay.innerHTML = `
                <div class="modal-content">
                    <h3>Insert Footnote List</h3>
                    <div id="modalBody">${footnoteContentHtml}</div>
                    <div class="flex justify-end mt-4 space-x-2">
                        <button id="modalCancelFnBtn" class="px-4 py-2 bg-gray-500 text-white rounded-md hover:bg-gray-600">Cancel</button>
                        <button id="modalInsertFnBtn" class="px-4 py-2 bg-green-600 text-white rounded-md hover:bg-green-700">Insert</button>
                    </div>
                </div>
            `;
            document.body.appendChild(modalOverlay);

            // Function to clean up and re-enable buttons
            function closeModalAndReEnableButtons() {
                modalOverlay.remove();
                triggeringButton.removeAttribute('data-temp-active'); // Crucial: Remove flag
                triggeringButton.textContent = originalButtonText; // Revert immediately
                triggeringButton.classList.remove('bg-green-500', 'hover:bg-green-600');
                triggeringButton.classList.add('bg-slate-600', 'hover:bg-slate-500');
                updateAllInteractiveButtonStates(); // Re-enable all buttons
            }

            document.getElementById('modalCancelFnBtn').addEventListener('click', closeModalAndReEnableButtons);

            const fnLangEnglishBtn = document.getElementById('fnLangEnglishBtn');
            const fnLangFrenchBtn = document.getElementById('fnLangFrenchBtn');
            const fnIdPrefixInput = document.getElementById('fnIdPrefix');
            const fnCountInput = document.getElementById('fnCount');
            const modalInsertFnBtn = document.getElementById('modalInsertFnBtn');

            let selectedFnLanguage = 'English';

            // Helper for button active state in modal
            function updateFnButtonActiveState(buttons, activeBtn) {
                buttons.forEach(btn => {
                    btn.classList.remove('active', 'bg-indigo-600'); /* Changed */
                    btn.classList.add('bg-gray-600', 'hover:bg-gray-500'); /* Changed */
                });
                activeBtn.classList.add('active', 'bg-indigo-600'); /* Changed */
                activeBtn.classList.remove('bg-gray-600', 'hover:bg-gray-500'); /* Changed */
            }

            updateFnButtonActiveState([fnLangEnglishBtn, fnLangFrenchBtn], fnLangEnglishBtn);

            fnLangEnglishBtn.addEventListener('click', () => {
                selectedFnLanguage = 'English';
                updateFnButtonActiveState([fnLangEnglishBtn, fnLangFrenchBtn], fnLangEnglishBtn);
            });

            fnLangFrenchBtn.addEventListener('click', () => {
                selectedFnLanguage = 'French';
                updateFnButtonActiveState([fnLangEnglishBtn, fnLangFrenchBtn], fnLangFrenchBtn);
            });

            // Ensure number input only accepts digits
            fnCountInput.addEventListener('input', (event) => {
                const input = event.target;
                input.value = input.value.replace(/\D/g, ''); // Remove non-digits
                if (input.value === '') {
                    input.value = '1'; // Default to 1 if cleared
                }
            });

            modalInsertFnBtn.addEventListener('click', () => {
                const idPrefix = fnIdPrefixInput.value.trim();
                const footnoteCount = parseInt(fnCountInput.value) || 1; // Default to 1

                // Capture originalButtonText in a local constant for the setTimeout closure
                const capturedOriginalText = originalButtonText;

                let footnoteHtmlContent = `<aside class="wb-fnote" role="note">\n`;
                footnoteHtmlContent += `\t<h2 id="${idPrefix}fn">${selectedFnLanguage === 'English' ? 'Footnotes' : 'Notes en bas de page'}</h2>\n`;
                footnoteHtmlContent += `\t<dl>\n`;

                for (let i = 1; i <= footnoteCount; i++) {
                    const dtText = selectedFnLanguage === 'English' ? `Footnote ${i}` : `Note en bas de page ${i}`;
                    const ddContent = selectedFnLanguage === 'English' ? `ENG footnote ${i} content.` : `FRA footnote ${i} content.`;
                    const returnTextInv = selectedFnLanguage === 'English' ? `Return to footnote ` : `Retour à la référence de la note en bas de page `;
                    const returnTextRef = selectedFnLanguage === 'English' ? ` referrer` : ``;

                    footnoteHtmlContent += `\t\t<dt>${dtText}</dt>\n`;
                    footnoteHtmlContent += `\t\t<dd id="${idPrefix}fn${i}">\n`;
                    footnoteHtmlContent += `\t\t\t<p>${ddContent}</p>\n`;
                    footnoteHtmlContent += `\t\t\t<p class="fn-rtn"> <a href="#${idPrefix}fn${i}-rf"><span class="wb-inv">${returnTextInv}</span>${i}<span class="wb-inv">${returnTextRef}</span></a> </p>\n`;
                    footnoteHtmlContent += `\t\t</dd>\n`;
                }

                footnoteHtmlContent += `\t</dl>\n`;
                footnoteHtmlContent += `</aside>\n`;

                if (monacoEditorInstance) {
                    let currentContent = monacoEditorInstance.getValue();
                    currentContent = protectDataAttributes(currentContent); // Protect attributes

                    // Find the insertion point: before any section with 'colophon' in its ID
                    const colophonSectionMatch = currentContent.match(/<section[^>]*id=["'][^"']*colophon[^"']*["'][^>]*>/i);
                    let insertionIndex = -1;

                    if (colophonSectionMatch) {
                        insertionIndex = currentContent.indexOf(colophonSectionMatch[0]);
                    }

                    if (insertionIndex !== -1) {
                        // Insert the footnote HTML before the colophon section
                        currentContent = currentContent.substring(0, insertionIndex) + footnoteHtmlContent + currentContent.substring(insertionIndex);
                    } else {
                        // If no colophon section, append to the end of the body just before </body>
                        const bodyEndTagIndex = currentContent.lastIndexOf('</body>');
                        if (bodyEndTagIndex !== -1) {
                            currentContent = currentContent.substring(0, bodyEndTagIndex) + footnoteHtmlContent + '\n' + currentContent.substring(bodyEndTagIndex);
                        } else {
                            currentContent += footnoteHtmlContent; // Fallback to simply appending
                        }
                    }

                    currentContent = restoreDataAttributes(currentContent); // Restore attributes
                    currentContent = convertAllEntitiesToNumeric(currentContent); // Ensure entities are correct after all operations

                    monacoEditorInstance.setValue(currentContent);
                    htmlOutputContent = currentContent;
                    applyEntityHighlighting();
                }

                closeModalAndReEnableButtons(); // Cleanup and re-enable immediately

                // Provide visual feedback for the button after successful insert
                triggeringButton.textContent = 'Inserted!';
                triggeringButton.classList.add('bg-green-500', 'hover:bg-green-600');
                triggeringButton.classList.remove('bg-slate-600', 'hover:bg-slate-500'); /* Changed */
                // The disabled state is managed by updateAllInteractiveButtonStates()
                setTimeout(() => {
                    triggeringButton.textContent = capturedOriginalText; // Use the captured variable
                    triggeringButton.classList.remove('bg-green-500', 'hover:bg-green-600');
                    triggeringButton.classList.add('bg-slate-600', 'hover:bg-slate-500');
                }, 1500);
            });
        }

        /**
         * Displays a modal dialog for Auto-ID options.
         * @param {HTMLElement} triggeringButton - The button that opened this modal.
         * @param {string} originalButtonText - The original text of the triggering button.
         */
        function showAutoIdModal(triggeringButton, originalButtonText) {
            const autoIdContentHtml = `
                <div class="flex flex-col space-y-4">
                    <div>
                        <span class="text-sm font-medium text-CBD5E1 mr-2">Choose elements to ID:</span> <!-- Changed text color -->
                        <div class="space-y-2 mt-2">
                            <!-- Section Toggle -->
                            <div class="toggle-switch-container">
                                <label class="toggle-switch is-checked" for="toggleSectionsId">
                                    <input type="checkbox" id="toggleSectionsId" checked>
                                    <span class="toggle-switch-slider"></span>
                                </label>
                                <span class="toggle-switch-label text-white text-sm">Sections (sec#)</span>
                            </div>
                            <!-- Headings Toggle -->
                            <div class="toggle-switch-container">
                                <label class="toggle-switch is-checked" for="toggleHeadingsId">
                                    <input type="checkbox" id="toggleHeadingsId" checked>
                                    <span class="toggle-switch-slider"></span>
                                </label>
                                <span class="toggle-switch-label text-white text-sm">Headings (toc#)</span>
                            </div>
                            <!-- NEW: Figures Toggle -->
                            <div class="toggle-switch-container">
                                <label class="toggle-switch is-checked" for="toggleFiguresId">
                                    <input type="checkbox" id="toggleFiguresId" checked>
                                    <span class="toggle-switch-slider"></span>
                                </label>
                                <span class="toggle-switch-label text-white text-sm">Figures (fig#)</span>
                            </div>
                            <!-- Tables Toggle (OFF by default) -->
                            <div class="toggle-switch-container">
                                <label class="toggle-switch" for="toggleTablesId">
                                    <input type="checkbox" id="toggleTablesId">
                                    <span class="toggle-switch-slider"></span>
                                </label>
                                <span class="toggle-switch-label text-white text-sm">Tables (tbl#)</span>
                            </div>
                            <!-- Figure Tables Toggle (OFF by default) -->
                            <div class="toggle-switch-container">
                                <label class="toggle-switch" for="toggleFigureTablesId">
                                    <input type="checkbox" id="toggleFigureTablesId">
                                    <span class="toggle-switch-slider"></span>
                                </label>
                                <span class="toggle-switch-label text-white text-sm">Figure Tables (ftbl#)</span>
                            </div>
                        </div>
                    </div>
                </div>
            `;

            const modalOverlay = document.createElement('div');
            modalOverlay.className = 'modal-overlay';
            modalOverlay.innerHTML = `
                <div class="modal-content">
                    <h3>Element ID's Options</h3> <!-- Changed title -->
                    <div id="modalBody">${autoIdContentHtml}</div>
                    <div class="flex justify-end mt-4 space-x-2">
                        <button id="modalCancelAutoIdBtn" class="px-4 py-2 bg-gray-500 text-white rounded-md hover:bg-gray-600">Cancel</button> <!-- Changed bg -->
                        <button id="modalApplyAutoIdBtn" class="px-4 py-2 bg-green-600 text-white rounded-md hover:bg-green-700">Apply IDs</button> <!-- Changed bg -->
                    </div>
                </div>
            `;
            document.body.appendChild(modalOverlay);

            // Function to clean up and re-enable buttons
            function closeModalAndReEnableButtons() {
                modalOverlay.remove();
                triggeringButton.removeAttribute('data-temp-active'); // Crucial: Remove flag
                triggeringButton.textContent = originalButtonText; // Revert immediately
                triggeringButton.classList.remove('bg-green-500', 'hover:bg-green-600');
                triggeringButton.classList.add('bg-slate-600', 'hover:bg-slate-500'); /* Changed */
                updateAllInteractiveButtonStates(); // Re-enable all buttons
            }

            document.getElementById('modalCancelAutoIdBtn').addEventListener('click', closeModalAndReEnableButtons);

            // Get references to elements within the newly created modal
            const toggleSectionsId = document.getElementById('toggleSectionsId');
            const toggleHeadingsId = document.getElementById('toggleHeadingsId');
            const toggleFiguresId = document.getElementById('toggleFiguresId'); // NEW: Figures toggle
            const toggleTablesId = document.getElementById('toggleTablesId');
            const toggleFigureTablesId = document.getElementById('toggleFigureTablesId');
            const modalApplyAutoIdBtn = document.getElementById('modalApplyAutoIdBtn');

            // Event listeners for pill switches
            [toggleSectionsId, toggleHeadingsId, toggleFiguresId, toggleTablesId, toggleFigureTablesId].forEach(toggle => { // Added toggleFiguresId
                toggle.addEventListener('change', (event) => {
                    const parentLabel = event.target.closest('.toggle-switch');
                    if (event.target.checked) {
                        parentLabel.classList.add('is-checked');
                    } else {
                        parentLabel.classList.remove('is-checked');
                    }
                });
            });

            modalApplyAutoIdBtn.addEventListener('click', () => {
                const options = {
                    idSections: toggleSectionsId.checked,
                    idHeadings: toggleHeadingsId.checked,
                    idFigures: toggleFiguresId.checked, // NEW: Pass figures option
                    idTables: toggleTablesId.checked,
                    idFigureTables: toggleFigureTablesId.checked
                };

                if (monacoEditorInstance) {
                    let currentContent = monacoEditorInstance.getValue();
                    currentContent = protectDataAttributes(currentContent);
                    currentContent = applyAutoId(currentContent, options); // Pass options to applyAutoId
                    currentContent = restoreDataAttributes(currentContent);
                    currentContent = convertAllEntitiesToNumeric(currentContent);
                    monacoEditorInstance.setValue(currentContent);
                    htmlOutputContent = currentContent;
                    applyEntityHighlighting();

                    closeModalAndReEnableButtons(); // Cleanup and re-enable immediately

                    // Capture originalButtonText in a local constant for the setTimeout closure
                    const capturedOriginalText = originalButtonText;

                    // Provide visual feedback for the main Auto-ID button
                    triggeringButton.textContent = 'ID\'d!';
                    triggeringButton.classList.add('bg-green-500', 'hover:bg-green-600');
                    triggeringButton.classList.remove('bg-slate-600', 'hover:bg-slate-500'); /* Changed */
                    // The disabled state is managed by updateAllInteractiveButtonStates()
                    setTimeout(() => {
                        triggeringButton.textContent = capturedOriginalText; // Revert to initial text
                        triggeringButton.classList.remove('bg-green-500', 'hover:bg-green-600');
                        triggeringButton.classList.add('bg-slate-600', 'hover:bg-slate-500'); /* Changed */
                    }, 1500);
                }
            });
        }

        // Array of Quick Formatting toggle inputs
        const quickFormattingToggles = [
            toggleCleanSpaces, toggleCleanUrls, toggleTimeTags, toggleFixFnIds,
            toggleCleanSingleBreaks, toggleCleanPTables, toggleCleanFormattingTags, // Added toggleCleanPTables
            toggleAutoLevelHeadings, toggleAutoSection
        ];

        /**
         * Updates the disabled state of the Format button based on selected quick formatting options.
         */
        function updateFormatButtonState() {
            const anySelected = quickFormattingToggles.some(toggle => toggle.checked);
            if (anySelected) {
                formatSelectedBtn.disabled = false;
                formatSelectedBtn.classList.remove('bg-gray-400', 'cursor-not-allowed', 'opacity-60');
                formatSelectedBtn.classList.add('bg-blue-600', 'hover:bg-blue-700');
            } else {
                formatSelectedBtn.disabled = true;
                formatSelectedBtn.classList.remove('bg-blue-600', 'hover:bg-blue-700');
                formatSelectedBtn.classList.add('bg-gray-400', 'cursor-not-allowed', 'opacity-60');
            }
        }

        /**
         * Performs auto-encoding of HTML entities to numeric entities.
         * This function is now reusable by both the "Auto-Encode" button and the "Format" button.
         * @param {string} htmlContent - The HTML content to encode.
         * @returns {string} The encoded HTML content.
         */
        function doAutoEncode(htmlContent) {
            let processedContent = protectDataAttributes(htmlContent);
            processedContent = convertAllEntitiesToNumeric(processedContent);
            processedContent = restoreDataAttributes(processedContent);
            return processedContent;
        }

        // Initialize and set up event listeners on window load
        window.onload = function() {
            console.log("Parent window.onload triggered.");
            // Initial setup: Ensure rich text panel is visible and code panel is hidden
            richtextOutputPanel.classList.add('panel-visible');
            mainEditorArea.classList.add('panel-hidden'); // Hide main editor area initially

            // Set initial button styles based on default view (richtext)
            // The "Go to HTML" button is visible initially, so its color depends on the Mso toggle.
            // The "Go to Rich-Text" button is hidden initially, so it should have its default cyan color.
            toggleEditorViewBtnCode.classList.add('bg-cyan-700', 'hover:bg-cyan-800');
            toggleEditorViewBtnCode.classList.remove('bg-cyan-700', 'hover:bg-cyan-800', 'bg-slate-800', 'hover:bg-slate-700'); /* Changed */
            updateGoToHtmlButtonColor(); // Call to set initial color for "Go to HTML" button
			
            // Initialize Monaco Editor
            require.config({ paths: { 'vs': 'https://cdn.jsdelivr.net/npm/monaco-editor@0.49.0/min/vs' } });
            require(['vs/editor/editor.main'], function () {
                monacoEditorInstance = monaco.editor.create(monacoEditorContainer, { // Use monacoEditorContainer here
                    value: htmlOutputContent, // Set initial content
                    language: 'html',
                    theme: 'vs-dark', // Or 'hc-black'
                    automaticLayout: true, // Important for responsiveness
                    minimap: { enabled: false },
                    fontSize: 14,
                    tabSize: 4,
                    insertSpaces: true,
                    // Additional options for better UX
                    scrollBeyondLastLine: false,
                    wordWrap: 'on',
                    wrappingIndent: 'same',
                });
                console.log("Monaco editor initialized.");

                // Update htmlOutputContent on Monaco content change
                monacoEditorInstance.onDidChangeModelContent(() => {
                    htmlOutputContent = monacoEditorInstance.getValue();
                    applyEntityHighlighting(); // Re-apply highlighting on content change
                });

                // Apply initial highlighting after Monaco is created
                applyEntityHighlighting();

                // Ensure Monaco refreshes layout on window resize
                window.addEventListener('resize', debouncedMonacoLayout);
            });

            copyCodeBtn.addEventListener('click', async () => {
                const codeContent = monacoEditorInstance ? monacoEditorInstance.getValue() : '';
                try {
                    const tempTextArea = document.createElement('textarea');
                    tempTextArea.value = codeContent;
                    document.body.appendChild(tempTextArea);
                    tempTextArea.select();
                    document.execCommand('copy');
                    const originalText = copyCodeBtn.textContent;
                    copyCodeBtn.textContent = 'Copied!';
                    copyCodeBtn.classList.add('bg-green-500', 'hover:bg-green-600');
                    copyCodeBtn.classList.remove('bg-slate-600', 'hover:bg-slate-500'); // Changed
                    copyCodeBtn.disabled = true; // Disable the button
                    copyCodeBtn.setAttribute('data-temp-active', 'true'); // Mark as active
                    updateAllInteractiveButtonStates(); // Update all buttons
                    setTimeout(() => {
                        copyCodeBtn.textContent = originalText;
                        copyCodeBtn.classList.remove('bg-green-500', 'hover:bg-green-600');
                        copyCodeBtn.classList.add('bg-slate-600', 'hover:bg-slate-500'); // Changed
                        copyCodeBtn.disabled = false; // Re-enable the button
                        copyCodeBtn.removeAttribute('data-temp-active'); // Unmark as active
                        updateAllInteractiveButtonStates(); // Update all buttons
                    }, 1500);
                } catch (err) {
                    console.error('Failed to copy text: ', err);
                }
            });

            autoFormatBtn.addEventListener('click', () => {
                if (monacoEditorInstance) {
                    let currentContent = monacoEditorInstance.getValue();
                    // Do NOT decodeHtmlEntities here. Protect attributes directly from Monaco's value.
                    currentContent = protectDataAttributes(currentContent); // Protect attributes (string replacement)

                    // Use js_beautify to format the HTML content
                    let formattedContent = html_beautify(currentContent, {
                        indent_size: 4, // You can customize indentation size
                        space_in_paren: true // Example option
                    });

                    formattedContent = restoreDataAttributes(formattedContent); // Restore attributes
                    formattedContent = convertAllEntitiesToNumeric(formattedContent); // Re-encode after formatting

                    monacoEditorInstance.setValue(formattedContent);
                    applyEntityHighlighting(); // Re-apply highlighting after formatting

                    const originalText = autoFormatBtn.textContent;
                    autoFormatBtn.textContent = 'Formatted!';
                    autoFormatBtn.classList.add('bg-green-500', 'hover:bg-green-600');
                    autoFormatBtn.classList.remove('bg-red-700', 'hover:bg-red-800'); /* Changed */
                    autoFormatBtn.disabled = true; // Disable the button
                    autoFormatBtn.setAttribute('data-temp-active', 'true'); // Mark as active
                    updateAllInteractiveButtonStates(); // Update all buttons
                    setTimeout(() => {
                        autoFormatBtn.textContent = originalText;
                        autoFormatBtn.classList.remove('bg-green-500', 'hover:bg-green-600');
                        autoFormatBtn.classList.add('bg-red-700', 'hover:bg-red-800'); /* Changed */
                        autoFormatBtn.disabled = false; // Re-enable the button
                        autoFormatBtn.removeAttribute('data-temp-active'); // Unmark as active
                        updateAllInteractiveButtonStates(); // Update all buttons
                    }, 1500);
                }
            });

            // New Auto-Encode button event listener
            autoEncodeBtn.addEventListener('click', () => {
                if (monacoEditorInstance) {
                    let currentContent = monacoEditorInstance.getValue();
                    let encodedContent = doAutoEncode(currentContent); // Call the new auto-encode function

                    monacoEditorInstance.setValue(encodedContent);
                    htmlOutputContent = encodedContent; // Keep the main content variable updated
                    applyEntityHighlighting(); // Re-apply highlighting after encoding

                    const originalText = autoEncodeBtn.textContent;
                    autoEncodeBtn.textContent = 'Encoded!';
                    autoEncodeBtn.classList.add('bg-green-500', 'hover:bg-green-600');
                    autoEncodeBtn.classList.remove('bg-red-700', 'hover:bg-red-800'); /* Changed */
                    autoEncodeBtn.disabled = true; // Disable the button
                    autoEncodeBtn.setAttribute('data-temp-active', 'true'); // Mark as active
                    updateAllInteractiveButtonStates(); // Update all buttons
                    setTimeout(() => {
                        autoEncodeBtn.textContent = originalText;
                        autoEncodeBtn.classList.remove('bg-green-500', 'hover:bg-green-600');
                        autoEncodeBtn.classList.add('bg-red-700', 'hover:bg-red-800'); /* Changed */
                        autoEncodeBtn.disabled = false; // Re-enable the button
                        autoEncodeBtn.removeAttribute('data-temp-active'); // Unmark as active
                        updateAllInteractiveButtonStates(); // Update all buttons
                    }, 1500);
                }
            });

            exportHtmlBtn.addEventListener('click', () => {
                const htmlContent = monacoEditorInstance ? monacoEditorInstance.getValue() : '';
                const blob = new Blob([htmlContent], { type: 'text/html' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'index.html';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                const originalText = exportHtmlBtn.textContent;
                exportHtmlBtn.textContent = 'Exported!';
                exportHtmlBtn.classList.add('bg-green-500', 'hover:bg-green-600');
                exportHtmlBtn.classList.remove('bg-red-700', 'hover:bg-red-800'); /* Changed */
                exportHtmlBtn.disabled = true; // Disable the button
                exportHtmlBtn.setAttribute('data-temp-active', 'true'); // Mark as active
                updateAllInteractiveButtonStates(); // Update all buttons
                setTimeout(() => {
                        exportHtmlBtn.textContent = originalText;
                        exportHtmlBtn.classList.remove('bg-green-500', 'hover:bg-green-600');
                        exportHtmlBtn.classList.add('bg-red-700', 'hover:bg-red-800'); /* Changed */
                        exportHtmlBtn.disabled = false; // Re-enable the button
                        exportHtmlBtn.removeAttribute('data-temp-active'); // Unmark as active
                        updateAllInteractiveButtonStates(); // Update all buttons
                    }, 1500);
            });

            importHtmlBtn.addEventListener('click', () => htmlFileInput.click());
            htmlFileInput.addEventListener('change', (event) => {
                const file = event.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        const importedContent = e.target.result;
                        if (monacoEditorInstance) {
                            monacoEditorInstance.setValue(importedContent);
                            htmlOutputContent = importedContent; // Update stored content
                            applyEntityHighlighting(); // Re-apply highlighting after import
                        }
                        const originalText = importHtmlBtn.textContent;
                        importHtmlBtn.textContent = 'Imported!';
                        importHtmlBtn.classList.add('bg-green-500', 'hover:bg-green-600');
                        importHtmlBtn.classList.remove('bg-purple-700', 'hover:bg-purple-800'); /* Changed */
                        importHtmlBtn.disabled = true; // Disable the button
                        importHtmlBtn.setAttribute('data-temp-active', 'true'); // Mark as active
                        updateAllInteractiveButtonStates(); // Update all buttons
                        setTimeout(() => {
                            importHtmlBtn.textContent = originalText;
                            importHtmlBtn.classList.remove('bg-green-500', 'hover:bg-green-600');
                            importHtmlBtn.classList.add('bg-purple-700', 'hover:bg-purple-800'); /* Changed */
                            htmlFileInput.value = null; // Clear the input so same file can be imported again
                            importHtmlBtn.removeAttribute('data-temp-active');
                            updateAllInteractiveButtonStates();
                        }, 1500);
                    };
                    reader.onerror = () => {
                        // Error handling for file read removed.
                    };
                    reader.readAsText(file);
                }
            });

            // Event listeners for the new individual toggle buttons
            toggleEditorViewBtnRichText.addEventListener('click', toggleEditorView);
            toggleEditorViewBtnCode.addEventListener('click', toggleEditorView);

            // Clean Mso button event listener
            cleanMsoBtn.addEventListener('click', () => {
                if (monacoEditorInstance) {
                    let currentContent = monacoEditorInstance.getValue();
                    currentContent = protectDataAttributes(currentContent);

                    // Apply all MSO cleaning functions in the specified order
                    currentContent = applyCleanLists(currentContent);
                    console.log("Clean MSO Lists applied by Clean MSO button.");
                    currentContent = applyCleanTablesBasic(currentContent);
                    console.log("Clean MSO Tables applied by Clean MSO button.");
                    currentContent = applyCleanMsoCode(currentContent);
                    console.log("Clean MSO Code (including IMGs) applied by Clean MSO button.");
                    currentContent = applyUrlCleaning(currentContent);
                    console.log("Clean URLs applied by Clean Mso button.");
                    currentContent = applyAutoSpacing(currentContent);
                    console.log("Clean Spaces applied by Clean MSO button.");

                    currentContent = restoreDataAttributes(currentContent);
                    currentContent = convertAllEntitiesToNumeric(currentContent);

                    monacoEditorInstance.setValue(currentContent);
                    htmlOutputContent = currentContent;
                    applyEntityHighlighting();
                    autoEncodeBtn.click();

                    const originalText = cleanMsoBtn.textContent;
                    cleanMsoBtn.textContent = 'Cleaned!';
                    cleanMsoBtn.classList.add('bg-green-500', 'hover:bg-green-600');
                    cleanMsoBtn.classList.remove('bg-blue-700', 'hover:bg-blue-800');
                    cleanMsoBtn.disabled = true; // Disable until timeout or next user action
                    cleanMsoBtn.setAttribute('data-temp-active', 'true');
                    updateAllInteractiveButtonStates();
                    setTimeout(() => {
                        cleanMsoBtn.textContent = originalText;
                        cleanMsoBtn.classList.remove('bg-green-500', 'hover:bg-green-600');
                        cleanMsoBtn.classList.add('bg-blue-700', 'hover:bg-blue-800');
                        cleanMsoBtn.disabled = false;
                        cleanMsoBtn.removeAttribute('data-temp-active');
                        updateAllInteractiveButtonStates();
                        // Re-evaluate clean Mso button state based on auto-clean toggle
                        updateCleanMsoButtonState();
                    }, 1500);
                }
            });

            // Clear All button event listener
            clearAllBtn.addEventListener('click', () => {
                if (monacoEditorInstance) {
                    monacoEditorInstance.setValue(''); // Clear Monaco content
                    htmlOutputContent = ''; // Clear stored content
                    applyEntityHighlighting(); // Re-apply highlighting after clearing
                }
                const originalText = clearAllBtn.textContent;
                clearAllBtn.textContent = 'Cleared!';
                clearAllBtn.classList.add('bg-green-500', 'hover:bg-green-600');
                clearAllBtn.classList.remove('bg-slate-600', 'hover:bg-slate-500'); // Changed
                clearAllBtn.disabled = true; // Disable the button
                clearAllBtn.setAttribute('data-temp-active', 'true'); // Mark as active
                updateAllInteractiveButtonStates(); // Update all buttons
                setTimeout(() => {
                    clearAllBtn.textContent = originalText;
                    clearAllBtn.classList.remove('bg-green-500', 'hover:bg-green-600');
                    clearAllBtn.classList.add('bg-slate-600', 'hover:bg-slate-500'); // Changed
                    clearAllBtn.disabled = false; // Re-enable the button
                    clearAllBtn.removeAttribute('data-temp-active'); // Unmark as active
                    updateAllInteractiveButtonStates();
                }, 1500);
            });

            // Initial content for the iframe
            const iframeDocument = default_ifr.contentDocument || default_ifr.contentWindow.document;
            iframeDocument.open();
            iframeDocument.write(`
                <!DOCTYPE html>
                <html lang="en">
                <head>
                    <meta charset="UTF-8">
                    <meta name="viewport" content="width=device-width, initial-scale=1.0">
                    <title>Rich Editor</title>
                    <script src="https://cdn.jsdelivr.net/npm/hugerte@1/hugerte.min.js"><\/script>
                    <script src="https://cdn.tailwindcss.com"><\/script>
                    <style>
                        html, body {
                            height: 100%; /* Ensure html and body take full height */
                            margin: 0;
                            /* Removed padding from html, body to avoid height calculation issues */
                            box-sizing: border-box; /* Include padding in height calculations for all elements */
                        }
                        body {
                            font-family: sans-serif;
                            background-color: #ffffff; /* White background for iframe body */
                            color: #333;
                            display: flex; /* Use flexbox for body to make form fill height */
                            flex-direction: column;
                            padding: 1rem; /* Add padding to the body of the iframe */
                        }
                        form {
                            height: 100%;
                            display: flex;
                            flex-direction: column;
                        }
                        textarea {
                            width: 100%;
                            flex-grow: 1;
                            border: 1px solid #ccc;
                            border-radius: 0.5rem;
                            padding: 0.75rem;
                            font-size: 1rem;
                            resize: none; /* Prevent manual resizing */
                            box-sizing: border-box; /* Include padding in width/height */
                        }
                        /* Style for HugeRTE container */
                        .tox.tox-tinymce { /* Use .tox.tox-tinymce as HugeRTE uses TinyMCE classes */
                            height: 100% !important; /* Force full height */
                            display: flex; /* Make it a flex container */
                            flex-direction: column; /* Stack its children vertically */
                        }
                        .tox-editor-container {
                            flex-grow: 1; /* Allow the editor area to grow */
                            display: flex;
                            flex-direction: column;
                        }
                        .tox-edit-area {
                            flex-grow: 1; /* Allow the editing area to grow */
                            display: flex;
                            flex-direction: column;
                        }
                        .tox-edit-area__iframe {
                            flex-grow: 1; /* Make the actual iframe within TinyMCE fill space */
                        }
                        /* Class for time tags to prevent wrapping */
                        .nowrap {
                            white-space: nowrap;
                        }
                    </style>
                </head>
                <body>
                    <form method="post">
                        <textarea id="richEditor"></textarea>
                    </form>
                    <script type="text/javascript">
                        console.log("Iframe script started executing.");
                        // Global variable to hold the HugeRTE editor instance
                        let richTextEditorInstance;
                        // Flag to prevent infinite loop when updating HugeRTE from CodeMirror
                        let isUpdatingFromCodeMirror = false;

                        /**
                         * Function to set the content of the HugeRTE editor.
                         * This is called from the parent window.
                         */
                        window.setRichEditorContent = function(content) {
                            // console.log("Iframe: setRichEditorContent called by parent.");
                            if (richTextEditorInstance && !isUpdatingFromCodeMirror) {
                                isUpdatingFromCodeMirror = true;
                                richTextEditorInstance.setContent(content);
                                richTextEditorInstance.focus(); // Re-focus the rich editor after content update
                                // console.log('Iframe: HugeRTE updated from parent.');
                                isUpdatingFromCodeMirror = false;
                            } else {
                                console.warn('Iframe: HugeRTE editor not yet initialized or isUpdatingFromCodeMirror is true. Content will be set once ready.');
                            }
                        };

                        /**
                         * Function to get the content from the HugeRTE editor.
                         * This is called from the parent window.
                         */
                        window.getRichEditorContent = function() {
                            // console.log("Iframe: getRichEditorContent called by parent.");
                            if (richTextEditorInstance) {
                                const content = richTextEditorInstance.getContent();
                                // console.log("Iframe: HugeRTE content requested by parent.");
                                return content;
                            } else {
                                console.warn('Iframe: HugeRTE editor not yet initialized. Cannot get content.');
                                return '';
                            }
                        };

                        /**
                         * HugeRTE init
                         */
                        if (typeof hugerte === 'undefined') {
                            console.error("Iframe: HugeRTE library not loaded!");
                        }
                        else {
                            console.log("Iframe: HugeRTE library loaded. Initializing editor.");
                            hugerte.init({
                                selector: '#richEditor',
                                toolbar: 'undo redo styles bold italic alignleft aligncenter alignright numlist bullist link table',
                                plugins: [ 'table', 'lists', 'link' ],
                                height: '100%', // Explicitly set height for TinyMCE
                                tab_focus: false, // Allow tab to indent instead of changing focus
                                formats: { // Define custom formats for alignment to use classes
                                    alignleft: { selector: 'p,h1,h2,h3,h4,h5,h6,td,th,div,ul,ol,li,table,img', classes: 'text-left', exact: true },
                                    aligncenter: { selector: 'p,h1,h2,h3,h4,h5,h6,td,th,div,ul,ol,li,table,img', classes: 'text-center', exact: true },
                                    alignright: { selector: 'p,h1,h2,h3,h4,h5,h6,td,th,div,ul,ol,li,table,img', classes: 'text-right', exact: true },
                                },
                                init_instance_callback: function(editorInstance) {
                                    console.log('Iframe: HugeRTE editor initialized inside iframe.');
                                    richTextEditorInstance = editorInstance; // Store the instance globally
                                    // Expose the instance to the parent window
                                    if (window.parent) {
                                        window.parent.richTextEditorInstanceFromIframe = editorInstance;
                                        console.log("Iframe: HugeRTE instance exposed to parent.");
                                    }

                                    // Handle Tab key for indentation and outdentation, especially for lists
                                    editorInstance.on('keydown', (event) => {
                                        if (event.key === 'Tab') {
                                            event.preventDefault(); // Prevent default tab behavior (focus change)
                                            // No content modification (no spaces, no styles)
                                            editorInstance.focus(); // Explicitly refocus the editor after command
                                        }
                                    });

                                    // Initial content sync when editor loads
                                    console.log('Iframe: HugeRTE editor ready.');
                                    // Set initial content if parent already has some
                                    if (window.parent.richTextContent) {
                                        editorInstance.setContent(window.parent.richTextContent);
                                        console.log("Iframe: Initial HugeRTE content set from parent.");
                                    }
                                }
                            });
                        }
                    <\/script>
                </body>
                </html>
            `);
            iframeDocument.close();

            // After the iframe content is loaded and the editor is initialized within it,
            // the iframe's script will assign its editor instance to window.parent.richTextEditorInstanceFromIframe
            // We can then pick it up here.
            default_ifr.onload = () => {
                console.log("Parent: Iframe finished loading.");
                if (default_ifr.contentWindow && default_ifr.contentWindow.richTextEditorInstanceFromIframe) {
                    richTextEditorInstanceFromIframe = default_ifr.contentWindow.richTextEditorInstanceFromIframe;
                    console.log("Parent: HugeRTE instance captured by parent.");
                } else {
                    console.warn("Parent: Could not capture HugeRTE instance from iframe. Is HugeRTE initializing correctly inside?");
                }
            };

            // Event listeners for Auto-Clean MSO when switching toggles
            toggleAutoCleanMsoOnSwitchRichText.addEventListener('change', (event) => {
                const isChecked = event.target.checked;
                const parentLabel = event.target.closest('.toggle-switch');
                if (isChecked) {
                    parentLabel.classList.add('is-checked');
                } else {
                    parentLabel.classList.remove('is-checked');
                }
                toggleAutoCleanMsoOnSwitchCode.checked = isChecked; // Sync state
                toggleAutoCleanMsoOnSwitchCode.closest('.toggle-switch').classList.toggle('is-checked', isChecked);
                console.log(`Auto-Clean MSO on RichText switch is now: ${isChecked ? 'ON' : 'OFF'}`);
                updateGoToHtmlButtonColor(); // Update button color
                updateCleanMsoButtonState(); // Update Clean Mso button state
            });

            toggleAutoCleanMsoOnSwitchCode.addEventListener('change', (event) => {
                const isChecked = event.target.checked;
                const parentLabel = event.target.closest('.toggle-switch');
                if (isChecked) {
                    parentLabel.classList.add('is-checked');
                    toggleAutoCleanMsoOnSwitchCode.checked = true;
                } else {
                    parentLabel.classList.remove('is-checked');
                    toggleAutoCleanMsoOnSwitchCode.checked = false;
                }
                toggleAutoCleanMsoOnSwitchRichText.checked = isChecked; // Sync state
                toggleAutoCleanMsoOnSwitchRichText.closest('.toggle-switch').classList.toggle('is-checked', isChecked);
                console.log(`Auto-Clean MSO on Code switch is now: ${isChecked ? 'ON' : 'OFF'}`);
                // No button color update needed here as it's the "Go to Rich-Text" button
                updateCleanMsoButtonState(); // Update Clean Mso button state
            });

            // Set initial checked states and add event listeners for new pill toggles in "Quick Formatting"
            quickFormattingToggles.forEach(toggle => {
                // Set initial checked state based on requirements
                if (toggle.id === 'toggleCleanSingleBreaks' || toggle.id === 'toggleCleanFormattingTags' || toggle.id === 'toggleCleanPTables') {
                    toggle.checked = false;
                    toggle.closest('.toggle-switch').classList.remove('is-checked');
                } else {
                    toggle.checked = true;
                    toggle.closest('.toggle-switch').classList.add('is-checked');
                }

                toggle.addEventListener('change', (event) => {
                    const parentLabel = event.target.closest('.toggle-switch');
                    if (event.target.checked) {
                        parentLabel.classList.add('is-checked');
                    } else {
                        parentLabel.classList.remove('is-checked');
                    }
                    updateFormatButtonState(); // Update format button state on change
                });
            });

            // Set initial state of the Format button
            updateFormatButtonState();


            // New "Format" button event listener for Quick Formatting toggles
            formatSelectedBtn.addEventListener('click', async () => {
                console.log("Format button clicked.");
                if (monacoEditorInstance) {
                    console.log("Monaco instance is valid.");
                    let currentContent = monacoEditorInstance.getValue();
                    console.log("Content before processing (length):", currentContent.length);

                    currentContent = protectDataAttributes(currentContent);

                    // Apply NBSP placeholders early for spacing and time tagging
                    currentContent = applyNBSPPlaceholders(currentContent);

                    if (toggleCleanSingleBreaks.checked) {
                        currentContent = applyCleanSingleBreaks(currentContent);
                        console.log("Clean Single Breaks applied. Content length:", currentContent.length);
                    }
                    if (toggleCleanPTables.checked) {
                        currentContent = applyCleanPTagsInTables(currentContent);
                        console.log("Clean <p> in Tables applied. Content length:", currentContent.length);
                    }
                    if (toggleCleanSpaces.checked) {
                        currentContent = applyAutoSpacing(currentContent);
                        console.log("Clean Spaces applied. Content length:", currentContent.length);
                    }
                    if (toggleCleanUrls.checked) {
                        currentContent = applyUrlCleaning(currentContent);
                        console.log("Clean URLs applied. Content length:", currentContent.length);
                    }
                    if (toggleCleanFormattingTags.checked) {
                        currentContent = applyCleanFormattingTags(currentContent);
                        console.log("Clean <U> | <B> | <I> applied. Content length:", currentContent.length);
                    }
                    if (toggleAutoLevelHeadings.checked) {
                        currentContent = applyAutoLevelHeadings(currentContent);
                        console.log("Auto-Level Headings applied. Content length:", currentContent.length);
                    }
                    if (toggleAutoSection.checked) {
                        currentContent = applyAutoSectioning(currentContent);
                        console.log("Auto-Section applied. Content length:", currentContent.length);
                    }
                    if (toggleTimeTags.checked) {
                        // Time tags functionality - copied from original timeTagsBtn.click()
                        const parser = new DOMParser();
                        const doc = parser.parseFromString(currentContent, 'text/html');
                        const body = doc.body;

                        // Step 1: Remove existing <time> tags and extract their text content
                        const existingTimeElements = doc.querySelectorAll('time');
                        existingTimeElements.forEach(timeEl => {
                            // Replace the <time> element with its text content
                            const textNode = doc.createTextNode(timeEl.textContent);
                            if (timeEl.parentNode) {
                                timeEl.parentNode.replaceChild(textNode, timeEl);
                            }
                        });

                        let contentToProcessForTimeTags = body.innerHTML;

                        const monthMap = {
                            'january': '01', 'jan': '01', 'janvier': '01',
                            'february': '02', 'feb': '02', 'février': '02',
                            'march': '03', 'mar': '03', 'mars': '03',
                            'april': '04', 'apr': '04', 'avril': '04',
                            'may': '05', 'mai': '05',
                            'june': '06', 'jun': '06', 'juin': '06',
                            'july': '07', 'jul': '07', 'juillet': '07',
                            'august': '08', 'aug': '08', 'août': '08',
                            'september': '09', 'sep': '09', 'septembre': '09',
                            'october': '10', 'oct': '10', 'octobre': '10',
                            'november': '11', 'nov': '11', 'novembre': '11',
                            'december': '12', 'dec': '12', 'décembre': '12'
                        };

                        function getMonthNumber(monthName) {
                            return monthMap[monthName.toLowerCase()] || null;
                        }

                        // Sort month keys by length descending to match longer names first (e.g., 'september' before 'sep')
                        const sortedMonthKeys = Object.keys(monthMap).sort((a, b) => b.length - a.length);
                        // Escape special characters in month names for regex
                        const monthPattern = sortedMonthKeys.map(m => m.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&')).join('|');
                        const spaceOrNBSPChar = `(?:\\s|${NBSP_PLACEHOLDER})+`;

                        // Add word boundaries (\b) to month patterns to prevent partial word matches (e.g., 'mai' in 'maintaining')
                        // And robustly check for non-digits before/after the full match
                        const regexIsoDateFull = /(?<!\d)(\d{4}-(?:0[1-9]|1[0-2])-(?:0[1-9]|[12]\d|3[01]))(?!\d)/g;
                        const regexMonthDayYear = new RegExp(`(?<!\\d)\\b(${monthPattern})\\b${spaceOrNBSPChar}(\\d{1,2}),?${spaceOrNBSPChar}(\\d{4})(?!\\d)`, 'i');
                        const regexDayMonthYear = new RegExp(`(?<!\\d)(?:(?:le|the)${spaceOrNBSPChar})?(\\d{1,2})${spaceOrNBSPChar}\\b(${monthPattern})\\b,?${spaceOrNBSPChar}(\\d{4})(?!\\d)`, 'i');
                        const regexMonthYear = new RegExp(`(?<!\\d)\\b(${monthPattern})\\b${spaceOrNBSPChar}(\\d{4})(?!\\d|${spaceOrNBSPChar}\\d{1,2})`, 'i');
                        const regexMonthDayNoYear = new RegExp(`(?<!\\d)\\b(${monthPattern})\\b${spaceOrNBSPChar}(\\d{1,2})(?!\\d|${spaceOrNBSPChar}\\d{4})(?!-)`, 'i');
                        const regexDayMonthNoYear = new RegExp(`(?<!\\d)(?:(?:le|the)${spaceOrNBSPChar})?(\\d{1,2})${spaceOrNBSPChar}\\b(${monthPattern})\\b(?!\d|${spaceOrNBSPChar}\\d{4})(?!-)`, 'i');

                        const reParsedDocForTimeTags = parser.parseFromString(contentToProcessForTimeTags, 'text/html');
                        const reParsedBodyForTimeTags = reParsedDocForTimeTags.body;

                        const textNodesToModifyForTimeTags = [];
                        const walkerForTimeTags = reParsedDocForTimeTags.createTreeWalker(
                            reParsedBodyForTimeTags,
                            NodeFilter.SHOW_TEXT,
                            {
                                acceptNode: function(node) {
                                    let parent = node.parentNode;
                                    while (parent) {
                                        const tagName = parent.tagName ? parent.tagName.toLowerCase() : '';
                                        if (tagName === 'script' || tagName === 'style' || tagName === 'time') {
                                            return NodeFilter.FILTER_REJECT;
                                        }
                                        parent = parent.parentNode;
                                    }
                                    return NodeFilter.FILTER_ACCEPT;
                                }
                            },
                            false
                        );

                        let currentNodeForTimeTags;
                        while (currentNodeForTimeTags = walkerForTimeTags.nextNode()) {
                            textNodesToModifyForTimeTags.push(currentNodeForTimeTags);
                        }

                        textNodesToModifyForTimeTags.forEach(textNode => {
                            let text = textNode.nodeValue;
                            let currentText = text;

                            let allMatches = [];
                            const patternsToTest = [
                                { name: 'IsoDateFull', regex: regexIsoDateFull, handler: (match) => {
                                    const [fullMatch, yearMonthDay] = match;
                                    return yearMonthDay;
                                }, priority: 3 },
                                { name: 'MonthDayYear', regex: regexMonthDayYear, handler: (match) => {
                                    const [, month, day, year] = match;
                                    const monthNum = getMonthNumber(month);
                                    const parsedDay = parseInt(day);
                                    if (!monthNum || isNaN(parsedDay) || parsedDay < 1 || parsedDay > 31) return null;
                                    return `${year}-${monthNum}-${String(parsedDay).padStart(2, '0')}`;
                                }, priority: 2 },
                                { name: 'DayMonthYear', regex: regexDayMonthYear, handler: (match) => {
                                    const [, day, month, year] = match;
                                    const monthNum = getMonthNumber(month);
                                    const parsedDay = parseInt(day);
                                    if (!monthNum || isNaN(parsedDay) || parsedDay > 31) return null;
                                    return `${year}-${monthNum}-${String(parsedDay).padStart(2, '0')}`;
                                }, priority: 2 },
                                { name: 'MonthYear', regex: regexMonthYear, handler: (match) => {
                                    const [, month, year] = match;
                                    const monthNum = getMonthNumber(month);
                                    if (!monthNum) return null;
                                    return `${year}-${monthNum}`;
                                }, priority: 2 },
                                { name: 'MonthDayNoYear', regex: regexMonthDayNoYear, handler: (match) => {
                                    const [, month, day] = match;
                                    const monthNum = getMonthNumber(month);
                                    const parsedDay = parseInt(day);
                                    if (!monthNum || isNaN(parsedDay) || parsedDay < 1 || parsedDay > 31) return null;
                                    return `${monthNum}-${String(parsedDay).padStart(2, '0')}`;
                                }, priority: 1 },
                                { name: 'DayMonthNoYear', regex: regexDayMonthNoYear, handler: (match) => {
                                    const [, day, month] = match;
                                    const monthNum = getMonthNumber(month);
                                    const parsedDay = parseInt(day);
                                    if (!monthNum || isNaN(parsedDay) || parsedDay < 1 || parsedDay > 31) return null;
                                    return `${monthNum}-${String(parsedDay).padStart(2, '0')}`;
                                }, priority: 1 }
                            ];

                            patternsToTest.forEach(pattern => {
                                let localRegex = new RegExp(pattern.regex.source, pattern.regex.flags);
                                if (!localRegex.flags.includes('g')) {
                                    localRegex = new RegExp(localRegex.source, localRegex.flags + 'g');
                                }

                                let match;
                                while ((match = localRegex.exec(currentText)) !== null) {
                                    const datetimeValue = pattern.handler(match);
                                    if (datetimeValue) {
                                        allMatches.push({
                                            start: match.index,
                                            end: match.index + match[0].length,
                                            original: match[0],
                                            datetime: datetimeValue,
                                            priority: pattern.priority
                                        });
                                    }
                                }
                            });

                            allMatches.sort((a, b) => {
                                if (a.start !== b.start) {
                                    return a.start - b.start;
                                }
                                if (a.priority !== b.priority) {
                                    return b.priority - a.priority;
                                }
                                return b.original.length - a.original.length;
                            });

                            let nonOverlappingMatches = [];
                            if (allMatches.length > 0) {
                                nonOverlappingMatches.push(allMatches[0]);
                                for (let i = 1; i < allMatches.length; i++) {
                                    const currentMatch = allMatches[i];
                                    const lastAddedMatch = nonOverlappingMatches[nonOverlappingMatches.length - 1];

                                    if (currentMatch.start >= lastAddedMatch.end) {
                                        nonOverlappingMatches.push(currentMatch);
                                    }
                                }
                            }

                            if (nonOverlappingMatches.length > 0) {
                                let resultParts = [];
                                let currentIndex = 0;
                                nonOverlappingMatches.forEach(match => {
                                    resultParts.push(currentText.substring(currentIndex, match.start));
                                    resultParts.push(`<time class="nowrap" datetime="${match.datetime}">${match.original}</time>`);
                                    currentIndex = match.end;
                                });
                                resultParts.push(currentText.substring(currentIndex));
                                const newHtmlContent = resultParts.join('');

                                const fragment = reParsedDocForTimeTags.createRange().createContextualFragment(newHtmlContent);
                                if (textNode.parentNode) {
                                    textNode.parentNode.replaceChild(fragment, textNode);
                                }
                            }
                        });
                        currentContent = reParsedBodyForTimeTags.innerHTML; // Update currentContent after time tag processing
                        console.log("Time Tags applied. Content length:", currentContent.length);
                    }
                    if (toggleFixFnIds.checked) {
                        // Fix FN ID's functionality - copied from original fixFnIdsBtn.click()
                        const parser = new DOMParser();
                        const doc = parser.parseFromString(currentContent, 'text/html');

                        const baseIdToSupElements = new Map();
                        const supElements = doc.querySelectorAll('sup[id$="-rf"]');
                        supElements.forEach(sup => {
                            const originalId = sup.id;
                            const baseId = originalId.replace(/-rf$/, '');

                            if (!baseIdToSupElements.has(baseId)) {
                                baseIdToSupElements.set(baseId, []);
                            }
                            baseIdToSupElements.get(baseId).push(sup);
                        });

                        const idMapping = {};

                        for (const [baseId, supList] of baseIdToSupElements.entries()) {
                            let canonicalTargetId = supList[0].id;

                            if (supList.length > 1) {
                                canonicalTargetId = `${baseId}-rf-0`;
                                supList.forEach((sup, index) => {
                                    const newSupId = `${baseId}-rf-${index}`;
                                    sup.id = newSupId;
                                });
                            }
                            supList.forEach(sup => {
                                idMapping[sup.id] = canonicalTargetId;
                            });
                            if (supList.length > 1) {
                                idMapping[`${baseId}-rf`] = canonicalTargetId;
                            }
                        }

                        const links = doc.querySelectorAll('a[href^="#"]');
                        links.forEach(link => {
                            let href = link.getAttribute('href');
                            const anchor = href.substring(1);

                            if (idMapping.hasOwnProperty(anchor)) {
                                link.setAttribute('href', `#${idMapping[anchor]}`);
                            }
                        });
                        currentContent = doc.body.innerHTML; // Update currentContent after FN ID processing
                        console.log("Fix FN ID's applied. Content length:", currentContent.length);
                    }


                    currentContent = revertNBSPPlaceholders(currentContent); // Revert placeholders after all spacing/time tagging
                    currentContent = restoreDataAttributes(currentContent);
                    currentContent = doAutoEncode(currentContent); // Call the new auto-encode function
                    console.log("Auto-Encode applied. Content length:", currentContent.length);


                    monacoEditorInstance.setValue(currentContent);
                    htmlOutputContent = currentContent;
                    applyEntityHighlighting();

                    const originalText = formatSelectedBtn.textContent;
                    formatSelectedBtn.textContent = 'Formatted!';
                    formatSelectedBtn.classList.add('bg-green-500', 'hover:bg-green-600');
                    formatSelectedBtn.classList.remove('bg-blue-600', 'hover:bg-blue-700'); /* Changed */
                    formatSelectedBtn.disabled = true;
                    formatSelectedBtn.setAttribute('data-temp-active', 'true');
                    updateAllInteractiveButtonStates();
                    setTimeout(() => {
                        formatSelectedBtn.textContent = originalText;
                        formatSelectedBtn.classList.remove('bg-green-500', 'hover:bg-green-600');
                        formatSelectedBtn.classList.add('bg-blue-600', 'hover:bg-blue-700'); /* Changed */
                        formatSelectedBtn.disabled = false;
                        formatSelectedBtn.removeAttribute('data-temp-active');
                        updateAllInteractiveButtonStates();
                    }, 1500);
                } else {
                    console.error("Monaco editor instance is not available.");
                }
            });

            // Auto-ID button event listener
            autoIdBtn.addEventListener('click', () => {
                const originalText = autoIdBtn.textContent;
                autoIdBtn.textContent = 'Opening...';
                autoIdBtn.classList.add('bg-green-500', 'hover:bg-green-600');
                autoIdBtn.classList.remove('bg-slate-600', 'hover:bg-slate-500');
                autoIdBtn.setAttribute('data-temp-active', 'true'); // Set the flag
                updateAllInteractiveButtonStates(); // Disable all buttons
                showAutoIdModal(autoIdBtn, originalText); // Pass original text to the modal
            });

            // Colophon button event listener
            colophonBtn.addEventListener('click', () => {
                const originalText = colophonBtn.textContent;
                colophonBtn.textContent = 'Opening...';
                colophonBtn.classList.add('bg-green-500', 'hover:bg-green-600');
                colophonBtn.classList.remove('bg-slate-600', 'hover:bg-slate-500');
                colophonBtn.setAttribute('data-temp-active', 'true'); // Set the flag
                updateAllInteractiveButtonStates(); // Disable all buttons

                const colophonHtmlContent = `
                    <div class="flex flex-col space-y-4">
                        <div>
                            <span class="text-sm font-medium text-CBD5E1 mr-2">Language:</span> <!-- Changed text color -->
                            <div class="button-group inline-flex">
                                <button id="langEnglishBtn" class="px-3 py-1 text-sm bg-gray-600 text-white rounded-md hover:bg-gray-500 focus:outline-none focus:ring-2 focus:ring-slate-500 focus:ring-opacity-50 font-bold">English</button>
                                <button id="langFrenchBtn" class="px-3 py-1 text-sm bg-gray-600 text-white rounded-md hover:bg-gray-500 focus:outline-none focus:ring-2 focus:ring-slate-500 focus:ring-opacity-50 font-bold">French</button>
                            </div>
                        </div>
                        <div>
                            <span class="text-sm font-medium text-CBD5E1 mr-2">Monarch:</span>
                            <div class="button-group inline-flex">
                                <button id="monarchKingBtn" class="px-3 py-1 text-sm bg-gray-600 text-white rounded-md hover:bg-gray-500 focus:outline-none focus:ring-2 focus:ring-slate-500 focus:ring-opacity-50 font-bold">King</button>
                                <button id="monarchQueenBtn" class="px-3 py-1 text-sm bg-gray-600 text-white rounded-md hover:bg-gray-500 focus:outline-none focus:ring-2 focus:ring-slate-500 focus:ring-opacity-50 font-bold">Queen</button>
                            </div>
                        </div>
                        <div>
                            <span class="text-sm font-medium text-CBD5E1 mr-2">Identifier Type:</span>
                            <div class="button-group inline-flex">
                                <button id="idISBNBtn" class="px-3 py-1 text-sm bg-gray-600 text-white rounded-md hover:bg-gray-500 focus:outline-none focus:ring-2 focus:ring-slate-500 focus:ring-opacity-50 font-bold">ISBN</button>
                                <button id="idISSNBtn" class="px-3 py-1 text-sm bg-gray-600 text-white rounded-md hover:bg-gray-500 focus:outline-none focus:ring-2 focus:ring-slate-500 focus:ring-opacity-50 font-bold">ISSN</button>
                            </div>
                        </div>
                        <div>
                            <label for="colophonYear" class="block text-sm font-medium text-gray-200">Year (optional, defaults to current year):</label>
                            <input type="number" id="colophonYear" class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500" placeholder="e.g., 2024" min="1900" max="2100">
                        </div>
                        <div>
                            <label for="colophonNumber" class="block text-sm font-medium text-gray-200">Identifier Number (optional, defaults to ###):</label>
                            <input type="text" id="colophonNumber" class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500" placeholder="e.g., 123-456-789-X">
                        </div>
                    </div>
                `;
                showModal('Insert Colophon', colophonHtmlContent, colophonBtn, originalText); // Pass original text
            });

            // Footnote List button event listener
            footnoteListBtn.addEventListener('click', () => {
                const originalText = footnoteListBtn.textContent;
                footnoteListBtn.textContent = 'Opening...';
                footnoteListBtn.classList.add('bg-green-500', 'hover:bg-green-600');
                footnoteListBtn.classList.remove('bg-slate-600', 'hover:bg-slate-500');
                footnoteListBtn.setAttribute('data-temp-active', 'true');
                updateAllInteractiveButtonStates();
                showFootnoteModal(footnoteListBtn, originalText); // Pass original text
            });
			// EN Page ToC — insert/update above the first <section>
			enPageToCBtn.addEventListener('click', () => {
			  // parse current editor HTML
			  const html = monacoEditorInstance.getValue();
			  const doc  = new DOMParser().parseFromString(html, 'text/html');

			  // 1) remove any existing ToC
			  const oldToc = doc.getElementById('page-nav');
			  if (oldToc) oldToc.remove();

			  // 2) collect all <h2>
			  const h2s = Array.from(doc.querySelectorAll('h2'));
			  if (!h2s.length) return;

			  // 3) build list items
			  const items = h2s.map(h2 => {
				const txt = h2.textContent.trim();
				const id  = h2.id || '';
				return `<li><a href="#${id}">${txt}</a></li>`;
			  }).join('\n        ');

			  // 4) assemble new ToC with an ID
			  const toc = `
			<section id="page-nav">
			  <h2 id="toc">On this page</h2>
			  <ul>
				${items}
			  </ul>
			</section>`;

			  // 5) find first <section> or fallback to top of body
			  const firstSection = doc.querySelector('section');
			  if (firstSection) {
				firstSection.insertAdjacentHTML('beforebegin', toc);
			  } else {
				doc.body.insertAdjacentHTML('afterbegin', toc);
			  }

			  // 6) write back updated HTML
			  monacoEditorInstance.setValue(doc.body.innerHTML);
			});

			// FR Page ToC — same logic, French heading
			frPageToCBtn.addEventListener('click', () => {
			  const html = monacoEditorInstance.getValue();
			  const doc  = new DOMParser().parseFromString(html, 'text/html');

			  const oldToc = doc.getElementById('page-nav');
			  if (oldToc) oldToc.remove();

			  const h2s = Array.from(doc.querySelectorAll('h2'));
			  if (!h2s.length) return;

			  const items = h2s.map(h2 => {
				const txt = h2.textContent.trim();
				const id  = h2.id || '';
				return `<li><a href="#${id}">${txt}</a></li>`;
			  }).join('\n        ');

			  const toc = `
			<section id="page-nav">
			  <h2 id="toc">Sur cette page</h2>
			  <ul>
				${items}
			  </ul>
			</section>`;

			  const firstSection = doc.querySelector('section');
			  if (firstSection) {
				firstSection.insertAdjacentHTML('beforebegin', toc);
			  } else {
				doc.body.insertAdjacentHTML('afterbegin', toc);
			  }

			  monacoEditorInstance.setValue(doc.body.innerHTML);
			});
			// Helper function to generate a valid, unique ID for HTML elements.
// It sanitizes baseText, and ensures the generated ID is not already present in the document.
function generateUniqueId(baseText, existingIds) {
    let id = baseText.toLowerCase()
                     .replace(/[^a-z0-9\s-]/g, '') // Remove characters not allowed in IDs (keep letters, numbers, spaces, hyphens)
                     .replace(/\s+/g, '-')       // Replace spaces with single hyphens
                     .replace(/^-+|-+$/g, '');   // Trim hyphens from start/end

    if (!id) { // If the baseText was empty or only special characters, use a generic fallback
        id = 'auto-id';
    }

    let counter = 1;
    let uniqueId = id;
    // Check if the generated ID already exists. If so, append a counter until unique.
    while (existingIds.has(uniqueId)) {
        uniqueId = `${id}-${counter}`;
        counter++;
    }
    existingIds.add(uniqueId); // Add the newly generated unique ID to our set of existing IDs
    return uniqueId;
}

function insertSectionToc(maxLevel, lang) {
  // 1) parse the editor’s current HTML
  const html = monacoEditorInstance.getValue();
  const doc = new DOMParser().parseFromString(html, 'text/html');

  // Step 1: Collect all existing IDs in the document.
  // This set will be used by generateUniqueId to ensure all new IDs are truly unique.
  const existingIds = new Set();
  doc.querySelectorAll('[id]').forEach(el => existingIds.add(el.id));

  // Step 2: Ensure all H-level elements (H2, H3, H4, H5, H6) have unique IDs.
  // This is crucial for:
  // - Creating a unique ID for the 'details' block (based on H2 ID).
  // - Creating valid 'a' (anchor) links inside the ToC.
  doc.querySelectorAll('h2, h3, h4, h5, h6').forEach(heading => {
      if (!heading.id) {
          // If a heading doesn't have an ID, generate one based on its text content.
          heading.id = generateUniqueId(heading.textContent || `heading-${heading.tagName.toLowerCase()}`, existingIds);
      }
  });

  // Step 3: Remove any existing Section ToCs.
  // We identify them by their ID starting with "sec-nav-".
  doc.querySelectorAll('details[id^="sec-nav-"]').forEach(oldDetails => {
    oldDetails.remove();
  });

  // Step 4: Process each H2 to build and insert its new TOC
  Array.from(doc.querySelectorAll('h2')).forEach(h2 => {
    const items = [];
    let currentElement = h2.nextElementSibling; // Start with the sibling immediately after the H2

    // Traverse siblings of the H2 until an H1 or another H2 is encountered
    while (currentElement && !['h1', 'h2'].includes(currentElement.tagName.toLowerCase())) {
      // Find all relevant headings (H3, H4, H5, H6) that are descendants within this current scope
      Array.from(currentElement.querySelectorAll('h3, h4, h5, h6')).forEach(subHeading => {
        const subLevel = parseInt(subHeading.tagName.substring(1), 10);
        if (subLevel <= maxLevel) { // subHeading.id is guaranteed to exist now
          items.push(subHeading);
        }
      });
      currentElement = currentElement.nextElementSibling; // Move to the next sibling of the H2
    }

    if (!items.length) return; // skip H2s with no matching headings up to maxLevel

    // Sort items by their position in the document to ensure correct order
    items.sort((a, b) => a.compareDocumentPosition(b) & Node.DOCUMENT_POSITION_FOLLOWING ? -1 : 1);

    // Build the new details block
    const details = doc.createElement('details');
    // Assign a unique ID to the details tag, prefixed by 'sec-nav-'
    details.id = 'sec-nav-' + h2.id;
    
    const summary = doc.createElement('summary');
    summary.className = 'wb-toggle';
    summary.setAttribute('data-toggle', '{"print":"on"}');
    summary.textContent = lang === 'en'
      ? 'In this section'
      : 'Dans cette section';
    details.appendChild(summary);

    const ul = doc.createElement('ul');
    // FIX: Initialize stack with the correct level for the UL's direct children.
    // The root 'ul' will contain H3s (level 3), so its associated level should be 3.
    let currentListStack = [{ domElement: ul, level: 3 }]; 

    items.forEach(el => {
      const elLevel = parseInt(el.tagName.substring(1), 10);
      const li = doc.createElement('li');
      const a = doc.createElement('a');
      a.href = `#${el.id}`; // el.id is guaranteed to exist from Step 2.
      a.textContent = el.textContent.trim();
      li.appendChild(a);

      let currentParentListContainer = currentListStack[currentListStack.length - 1];
      let currentParentList = currentParentListContainer.domElement;
      let currentParentLevel = currentParentListContainer.level;

      if (elLevel > currentParentLevel) {
        // Descend: Create new nested lists until the correct level is reached
        // The new UL should be appended to the *last LI* of the current parent list.
        // This ensures the nesting is always LI > UL > LI.
        while (elLevel > currentParentLevel) {
          const newUl = doc.createElement('ul');
          // It's critical that the new UL is appended to the *last LI* of the current UL.
          // This ensures the nesting hierarchy (LI > UL > LI).
          if (currentParentList.lastElementChild && currentParentList.lastElementChild.tagName.toLowerCase() === 'li') {
            currentParentList.lastElementChild.appendChild(newUl);
          } else {
             // This case should ideally not happen if the list is constructed correctly,
             // as an LI should always precede a nested UL in this context.
             // If it does, it might indicate a level jump (e.g., H2 followed by H4 directly),
             // which would flatten the structure slightly.
             console.warn(`Unexpected structure: Attempted to append a new UL to a UL without a preceding LI for heading ${el.id}.`);
             currentParentList.appendChild(newUl);
          }
          currentListStack.push({ domElement: newUl, level: currentParentLevel + 1 });
          currentParentList = newUl;
          currentParentLevel++;
        }
        currentParentList.appendChild(li); // Append the li to the newly established list at the correct level
      } else if (elLevel < currentParentLevel) {
        // Ascend: Pop from stack until appropriate parent is found or root ul is reached
        while (currentListStack.length > 1 && elLevel < currentListStack[currentListStack.length - 1].level) { // Changed <= to <
          currentListStack.pop();
        }
        // After popping, if we are at the same level as the new element, we should use that parent.
        // If we popped too far (e.g., trying to put H3 under H2's root UL, but we popped the root), re-add it.
        // This check ensures we land on the correct parent UL's level.
        if (currentListStack[currentListStack.length - 1].level > elLevel) {
             // This can happen if, for example, we're at level 5, pop to level 3, and next element is level 4.
             // We need to ensure we land on the correct parent.
             // For simplicity, for now, we'll assume a direct pop works and rely on the next push.
             // The main issue here is if the target list isn't the root `ul` and we jumped over its level.
             // Let's refine the stack checking. The target must be currentParentListContainer.level <= elLevel
             // We stop when the current parent list is either at the target level, or one level above it.
             while (currentListStack.length > 1 && currentListStack[currentListStack.length - 1].level > elLevel) {
                 currentListStack.pop();
             }
        }
        currentParentListContainer = currentListStack[currentListStack.length - 1];
        currentParentList = currentParentListContainer.domElement;
        currentParentList.appendChild(li); // Append the li to the appropriate parent list
      } else {
        // Same level: Append to current parent list
        currentParentList.appendChild(li);
      }
    });
    details.appendChild(ul); // The root ul is appended to the details element

    // Insert the new details block right after the H2
    h2.parentNode.insertBefore(details, h2.nextSibling);
  });

  // Step 5: Write the modified HTML back to the editor
  // IMPORTANT: This function only *adds* new `details` elements.
  // It does NOT modify classes or other attributes on existing `ul` elements in your original HTML.
  monacoEditorInstance.setValue(doc.body.innerHTML);
  monacoEditorInstance.trigger('insertSectionToc', 'editor.action.formatDocument', null);
}

			// now wire your buttons (you may already have these listeners; just point them at our new function)
			enSecToCBtn.addEventListener('click', () => insertSectionToc(3, 'en'));
			frSecToCBtn.addEventListener('click', () => insertSectionToc(3, 'fr'));
			enSecToCH4Btn.addEventListener('click', () => insertSectionToc(4, 'en'));
			frSecToCH4Btn.addEventListener('click', () => insertSectionToc(4, 'fr'));
			enSecToCH5Btn.addEventListener('click', () => insertSectionToc(5, 'en'));
			frSecToCH5Btn.addEventListener('click', () => insertSectionToc(5, 'fr'));
			enSecToCH6Btn.addEventListener('click', () => insertSectionToc(6, 'en'));
			frSecToCH6Btn.addEventListener('click', () => insertSectionToc(6, 'fr'));

            // Initial call to set the state of the Clean Mso button on load
            updateCleanMsoButtonState();

            // Add browser warning for unsaved changes
            window.onbeforeunload = function() {
                // You can add a condition here if you only want to warn if the editor content is not empty
                if (monacoEditorInstance && monacoEditorInstance.getValue().trim() !== '') {
                    return "You have unsaved changes. Are you sure you want to leave?";
                }
                // If you return nothing or undefined, the browser will not show a warning.
            };
        };
    </script>
</body>
</html>
