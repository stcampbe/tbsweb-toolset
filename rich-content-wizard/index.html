<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WordToCode™ - Rich Content Wizard</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/js-beautify/1.15.4/beautify-html.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/monaco-editor@0.52.2/min/vs/loader.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <style>
        /* Custom styles for the editor */
        html,
        body {
            height: 100%;
            /* Ensure html and body take full viewport height */
            margin: 0;
            padding: 0;
            overflow: hidden;
            /* Prevent body from scrolling; all scrolling should be within panels */
        }

        body {
            font-family: 'Inter', sans-serif;
            /* Using Inter font */
            display: flex;
            flex-direction: column;
            background-color: #0F172A;
            /* Dark slate */
        }

        /* Highlight styles for headings */
        .highlight-h1 {
            background-color: #FFD700;
            /* Gold */
            padding: 2px 5px;
            border-radius: 3px;
        }

        .highlight-h2 {
            background-color: #ADD8E6;
            /* Light Blue */
            padding: 2px 5px;
            border-radius: 3px;
        }

        .highlight-h3 {
            background-color: #90EE90;
            /* Light Green */
            padding: 2px 5px;
            border-radius: 3px;
        }

        .highlight-h4 {
            background-color: #FFB6C1;
            /* Light Pink */
            padding: 2px 5px;
            border-radius: 3px;
        }

        .highlight-h5 {
            background-color: #FF7F50;
            /* Coral */
            padding: 2px 5px;
            border-radius: 3px;
        }

        .highlight-h6 {
            background-color: #DA70D6;
            /* Orchid */
            padding: 2px 5px;
            border-radius: 3px;
        }

        /* New header for the QA Wizard title */
        .content-wizard-header {
            padding: 1rem;
            display: flex;
            /* Use flexbox for alignment */
            align-items: center;
            /* Vertically align items */
            gap: 1rem;
            /* Space between title and buttons */
            flex-wrap: wrap;
            /* Allow wrapping on smaller screens */
        }

        .content-wizard-header h1 {
            font-size: 1.25rem;
            /* text-4xl */
            font-weight: bold;
            color: #ffffff;
            margin-right: auto;
            /* Push buttons to the right */
        }

        .editor-container {
            display: flex;
            flex-grow: 1;
            /* Allow container to grow and fill available space */
            padding: 0 1rem 1rem 1rem;
            gap: 1rem;
            /* Space between editor and richtext-output */
            margin: 0;
            width: 100%;
            /* Full width */
            height: 100%;
            /* Explicitly make editor-container take full height of flex parent (body) */
            box-sizing: border-box;
            /* Include padding in total height */
            overflow-y: hidden;
            /* Prevent editor container from scrolling its children */
            overflow-x: hidden;
            /* Prevent horizontal scrolling */
        }

        /* New container for the Monaco editor and the sidebar */
        .main-editor-area {
            display: flex;
            flex-grow: 1;
            /* Allow this area to take up remaining horizontal space */
            gap: 1rem;
            /* Space between code-panel and sidebar-panel */
            height: 100%;
            /* Take full height of editor-container */
            box-sizing: border-box;
            overflow: hidden;
            /* Prevent horizontal scroll in this container */
        }

        .code-panel,
        .richtext-output-panel,
        .sidebar-panel {
            background-color: #1E293B;
            /* Darker slate */
            border-radius: 0.75rem;
            /* rounded-xl */
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            /* Darker shadow */
            padding: 1rem;
            display: flex;
            flex-direction: column;
            /* Keep column for header, content area, and footer */
            flex-grow: 1;
            /* Allow panels to grow and shrink horizontally */
            flex-shrink: 1;
            flex-basis: 0;
            /* Important for equal distribution in flex row */
            height: 100%;
            /* Take full height of container */
            box-sizing: border-box;
            /* Include padding and border in element's total width/height */
            overflow-y: hidden;
            /* Prevent main panels from scrolling; internal elements will manage their own scroll */
            overflow-x: hidden;
            /* Prevent horizontal scrollbar on panels unless explicitly needed */
        }

        /* Monaco Editor specific styling */
        #monacoEditorContainer {
            min-height: 200px;
            /* Ensure it has a minimum height */
            flex-grow: 1;
            /* Monaco will fill its parent (code-panel) */
            flex-shrink: 1;
            height: 100%;
            /* Make Monaco take full height of its flex parent */
            /* Monaco editor will handle its own internal scrolling due to automaticLayout: true */
        }

        /* Rich-Text Iframe styling */
        iframe {
            width: 100%;
            height: 100%;
            /* Make iframe fill its parent's height */
            flex-grow: 1;
            /* Allow iframe to take all available vertical space */
            border: 1px solid #475569;
            /* Medium slate border */
            border-radius: 0.5rem;
            /* rounded-lg */
            background-color: #ffffff;
            /* Rich-Text Output window background remains white */
            overflow: auto;
            /* Ensure iframe itself can scroll if its content overflows */
        }

        /* Sidebar styling */
        .sidebar-panel {
            /* Changed from #sidebar to .sidebar-panel */
            flex-basis: 300px;
            /* Fixed width for sidebar */
            flex-grow: 0;
            /* Prevent sidebar from growing */
            flex-shrink: 0;
            /* Prevent sidebar from shrinking */
            overflow-y: auto;
            /* Enable vertical scrolling for sidebar content */
            overflow-x: hidden;
            /* Prevent horizontal scrolling on sidebar */
            min-height: 0;
            /* Crucial for flex items to scroll correctly if content overflows */
            background-color: #1E293B;
            /* Darker slate */
            border-radius: 0.75rem;
            /* rounded-xl */
            padding: 1rem;
            display: flex;
            flex-direction: column;
            /* Keep column for header, content area, and footer */
            box-sizing: border-box;
            /* Include padding and border in element's total width/height */
        }

        h1 {
            color: #ffffff;
            /* White text for H1 in editor panel */
            margin-bottom: 1rem;
            text-align: center;
        }

        h2 {
            color: #ffffff;
            /* White text for H2 in panel headers */
        }

        h3 {
            color: #ffffff;
            /* White text for H3 in panel headers */
            font-size: 1.125rem;
            /* text-lg */
            font-weight: 600;
            /* semi-bold */
            margin-bottom: 1rem;
        }

        label {
            color: #CBD5E1;
            /* Light slate for labels */
        }

        input[type="text"] {
            background-color: #334155;
            /* Darker slate for input */
            color: #ffffff;
            /* White text for input */
            border-color: #475569;
            /* Medium slate border for input */
        }

        input[type="text"]::placeholder {
            color: #94A3B8;
            /* Medium slate for placeholder text */
        }

        input[type="number"] {
            /* New style for number input */
            background-color: #334155;
            /* Darker slate for input */
            color: #ffffff;
            /* White text for input */
            border-color: #475569;
            /* Medium slate border for input */
        }

        input[type="number"]::placeholder {
            /* New style for number input placeholder */
            color: #94A3B8;
            /* Medium slate for placeholder text */
        }

        /* Add flex-shrink: 0 to the button containers at the top and bottom of panels */
        /* For Richtext panel header */
        #richtextOutputPanel>div.flex.items-center.mb-4 {
            flex-shrink: 0;
        }

        /* For Code panel header */
        #codePanel>div.flex.items-center.mb-4.flex-wrap {
            flex-shrink: 0;
        }

        /* For Code panel footer */
        #codePanel>div.mt-auto.pt-4.flex.justify-center.space-x-2 {
            flex-shrink: 0;
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .editor-container {
                flex-direction: column;
                /* Stack vertically on small screens */
                height: 100%;
                /* Ensure it occupies full height */
            }

            .main-editor-area {
                flex-direction: column;
                /* Stack code-panel and sidebar-panel vertically */
                height: auto;
                /* Allow content to dictate height */
                flex-grow: 1;
                /* Allow it to grow vertically */
            }

            .code-panel,
            .richtext-output-panel,
            .sidebar-panel {
                height: auto;
                /* Allow content to dictate height, but flex-grow will ensure it fills space */
                flex-basis: auto;
                /* Reset flex-basis set by JS for horizontal layout */
                flex-grow: 1;
                /* Each panel should grow to fill vertical space */
                overflow-y: hidden;
                /* Main panel should not scroll, its children will */
            }

            #monacoEditorContainer {
                width: 100%;
                /* Full width on small screens */
                flex-grow: 1;
                /* Allow Monaco to grow vertically */
                flex-shrink: 1;
                /* Allow Monaco to shrink */
                min-height: 250px;
                /* Minimum height for editor usability */
            }

            .sidebar-panel {
                /* Changed from #sidebar */
                width: 100%;
                /* Full width on small screens */
                flex-grow: 1;
                /* Allow sidebar to grow vertically */
                flex-shrink: 1;
                /* Allow sidebar to shrink */
                min-height: 250px;
                /* Minimum height for sidebar usability */
                overflow-y: auto;
                /* This is crucial for scrolling sidebar content */
                overflow-x: hidden;
            }
        }

        /* Styles for button group (GENERAL STYLES - for JOINED buttons by default) */
        .button-group {
            display: flex;
            width: 100%;
            border-radius: 0.5rem;
            box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
            border: 1px solid #475569;
            flex-wrap: wrap;
        }

        .button-group button {
            flex: 1;
            /* Makes buttons take up equal space */
            border-radius: 0;
            /* Removes individual button rounded corners */
            border: none;
            /* Removes individual button borders */
            margin: 0;
            padding: 0.5rem 0.75rem;
            font-size: 0.875rem;
            line-height: 1.25rem;
            position: relative;
            color: #ffffff;
            font-weight: bold;
        }

        /* Specific styles for the Sections and Headings buttons - NO FLEX */
        #toggleSectionsBtn,
        #toggleHeadingsBtn {
            flex: none;
            /* Override flex: 1; for these specific buttons */
            width: auto;
            /* Allow buttons to size based on content */
            border: 1px solid #475569;
            /* Add border back for individual buttons */
            border-radius: 0.5rem;
            /* Add rounded corners back for individual buttons */
            margin-left: 0.5rem;
            /* Add spacing between them and other buttons */
        }

        /* Adjust border between buttons in the main button groups (JOINED) */
        .button-group:not(.no-border-buttons):not(.individual-rounded-buttons) button:not(:last-child) {
            border-right: 1px solid rgba(71, 85, 105, 0.5);
            /* Separator for JOINED buttons */
        }

        /* Apply rounded corners only if NOT individual-rounded-buttons */
        .button-group:not(.individual-rounded-buttons) button:first-child {
            border-top-left-radius: 0.5rem;
            border-bottom-left-radius: 0.5rem;
        }

        .button-group:not(.individual-rounded-buttons) button:last-child {
            border-top-right-radius: 0.5rem;
            border-bottom-right-radius: 0.5rem;
        }

        .button-group button:hover {
            z-index: 1;
            /* Bring hovered button to front to show full border/shadow */
        }

        /* Visibility classes for toggle view */
        .panel-hidden {
            display: none;
        }

        .panel-visible {
            display: flex;
            /* Or 'block' for iframe if it's not a flex container */
        }


        /* Customize section styles (removed, but keeping styles for reference if needed) */
        .customize-section {
            background-color: #334155;
            /* Same as input background */
            border-radius: 0.5rem;
            padding: 1rem;
            /* Re-added padding */
            margin-bottom: 1rem;
            /* Re-added margin-bottom */
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .customize-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            /* Removed padding-bottom, margin-bottom, border-bottom */
        }

        .customize-content {
            /* Now uses max-height instead of height */
            max-height: 0;
            /* Changed from height: 0; */
            overflow: hidden;
            /* Unified transition for smoother effect */
            transition: max-height 0.5s ease-in-out, padding 0.5s ease-in-out;
            /* Transition max-height and padding */
            padding: 0 1rem;
            /* Padding for content area, default to 0 for collapsed */
            background-color: #475569;
            /* Match header background */
            border-radius: 0 0 0.5rem 0.5rem;
            /* Rounded bottom corners */
        }

        .collapsible-content.expanded {
            /* max-height will be set by JS dynamically to scrollHeight or a large value */
            padding-top: 0.75rem;
            /* Add padding to content when expanded */
            padding-bottom: 0.75rem;
            /* Add padding to content when expanded */
        }

        .customize-header svg {
            transition: transform 0.3s ease;
        }

        .customize-header.expanded svg {
            transform: rotate(180deg);
        }

        /* Adjustments for button spacing */
        .code-panel h2 .inline-flex.mr-auto button,
        .richtext-output-panel h2 .inline-flex.mr-auto button {
            margin-right: 0.5rem;
            /* Default margin for buttons within the group */
        }

        /* When in fullscreen editor mode, remove margin from the first button group */
        .editor-container.fullscreen-editor .code-panel h2 .inline-flex.mr-auto {
            margin-left: 0 !important;
            /* Remove any left margin on the button container */
        }

        /* When in fullscreen richtext-output mode, remove margin from the first button group */
        .editor-container.fullscreen-richtext .richtext-output-panel h2 .inline-flex.mr-auto {
            margin-left: 0 !important;
            /* Remove any left margin on the button */
        }

        /* Ensure the button itself doesn't have an undesired left margin when its parent is adjusted */
        .editor-container.fullscreen-editor .code-panel h2 .inline-flex.mr-auto #fullScreenBtn,
        .editor-container.fullscreen-editor .code-panel h2 .inline-flex.mr-auto #exitFullScreenBtn,
        .editor-container.fullscreen-richtext .richtext-output-panel h2 .inline-flex.mr-auto #fullScreenRichTextBtn,
        .editor-container.fullscreen-richtext .richtext-output-panel h2 .inline-flex.mr-auto #exitFullScreenRichTextBtn {
            margin-left: 0;
            /* Explicitly remove any left margin on the button */
        }

        /* Modal styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        /* Specific styles for the Regex Guide Modal content */
        .regex-guide-modal-content {
            /* Override or set specific width for the Regex Guide */
            width: 90%;
            max-width: 700px;
            /* Adjust as desired for the regex guide */
            min-width: 300px;
            /* Adjust as desired */

            /* Override or set specific height for the Regex Guide */
            height: auto;
            max-height: 90vh;
            /* Adjust as desired for the regex guide */
            overflow-y: auto;
        }

        /* Specific styling for list items and code within the Regex Guide Modal */
        .regex-guide-modal-content ul {
            margin-left: 1.5rem;
        }

        .regex-guide-modal-content li {
            margin-bottom: 0.5rem;
        }

        .regex-guide-modal-content code {
            display: inline-block;
            background-color: #334155;
            padding: 0.2em 0.4em;
            border-radius: 3px;
            font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, Courier, monospace;
            font-size: 0.9em;
            color: #e0f2f7;
            white-space: nowrap;
        }

        .modal-content {
            background-color: #1E293B;
            /* Darker slate */
            padding: 2rem;
            border-radius: 0.75rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            color: #ffffff;
            text-align: left;
            /* Left align content */
            max-width: 90%;
            width: 400px;
        }

        .modal-content h3 {
            font-size: 1.5rem;
            font-weight: bold;
            margin-bottom: 1rem;
            text-align: left;
            /* Ensure title is left aligned */
        }

        .modal-content p {
            margin-bottom: 1.5rem;
        }

        .modal-content button {
            background-color: #64748B;
            /* Lighter slate */
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            font-weight: bold;
            transition: background-color 0.2s ease;
        }

        .modal-content button:hover {
            background-color: #475569;
            /* Medium slate */
        }

        .modal-content .button-group {
            border: none;
            /* Remove border for button groups inside modal */
            box-shadow: none;
            /* Remove shadow for button groups inside modal */
            width: auto;
            /* Allow buttons to size naturally */
        }

        .modal-content .button-group button {
            flex: none;
            /* Prevent buttons from taking equal space */
            margin: 0.25rem;
            /* Add some margin between buttons */
            border: 1px solid #475569;
            /* Add border back for individual buttons */
            border-radius: 0.5rem;
            /* Add rounded corners back for individual buttons */
            padding: 0.3rem 0.6rem;
            /* Reduced padding for smaller buttons */
            font-size: 0.8rem;
            /* Reduced font size for smaller buttons */
        }

        .modal-content .button-group button.active {
            background-color: #4338CA;
            /* Active color for internal modal buttons - Indigo 600 */
            color: white;
            border-color: #4338CA;
        }
		
		/* Preview Modal Specific Styles */
        #previewModal .modal-content {
            width: 98%; /* Wider for better preview */
            max-width: 1500px; /* Max width for large screens */
            height: 95%; /* Taller for better preview */
            display: flex;
            flex-direction: column;
            overflow: hidden; /* Prevent modal content from scrolling, iframe handles it */
            padding: 1.5rem; /* Reduced padding for modal content */
        }

        #previewModal .modal-content .modal-header-controls {
            display: flex;
            align-items: center; /* Vertically align items */
            /* Removed justify-content: space-between; to allow title and buttons to be close */
            margin-bottom: 0.75rem; /* Reduced space below header */
            flex-wrap: wrap;
        }

        #previewModal .modal-content h3 {
            font-size: 1.25rem; /* Slightly smaller title */
            text-align: left; /* Keep title left-aligned */
            margin-bottom: 0; /* Adjusted for inline elements */
            /* Removed flex-grow: 1; to prevent it from pushing buttons too far */
            margin-right: 0.75rem; /* Space between title and buttons */
        }

        #previewModal iframe {
            width: 100%;
            height: 100%;
            border: 1px solid #4a5568;
            border-radius: 0.5rem;
            background-color: #ffffff;
            flex-grow: 1; /* Allow iframe to take available space */
        }

        /* Customize section styles for modal */
        #previewModal .customize-section {
            background-color: #3b455a;
            border-radius: 0.5rem;
            padding: 0.75rem; /* Reduced padding */
            margin-bottom: 0.75rem; /* Reduced margin */
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        #previewModal .customize-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
        }

        #previewModal .customize-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out;
        }

        #previewModal .customize-content.expanded {
            max-height: 500px; /* Adjust as needed to fit content */
            transition: max-height 0.5s ease-in;
            padding-top: 0.5rem;
        }

        #previewModal .customize-header svg {
            transition: transform 0.3s ease;
        }

        #previewModal .customize-header.expanded svg {
            transform: rotate(180deg);
        }

        /* Button group styles for modal customize section (from index.html) */
        #previewModal .button-group {
            display: flex;
            width: 100%; /* Make it span full width */
            border-radius: 0.5rem; /* rounded-md */
            box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05); /* shadow-sm */
            border: 1px solid #4a5568; /* Darker border for button group */
            flex-wrap: wrap; /* Keep for responsiveness on smaller screens */
        }

        #previewModal .button-group button {
            flex: 1; /* Make buttons take up equal space */
            border-radius: 0; /* Remove individual button rounded corners */
            border: none; /* Remove individual button borders */
            margin: 0; /* Remove individual button margins */
            padding: 0.5rem 0.75rem; /* Consistent padding */
            font-size: 0.875rem; /* text-sm */
            line-height: 1.25rem; /* leading-5 */
            position: relative; /* For z-index if needed */
            color: #ffffff; /* White text for all buttons */
            font-weight: bold; /* Make buttons bold */
        }

        #previewModal .button-group button:hover {
            background-color: #3182ce; /* Blue-600 */
        }

        /* Adjust border between buttons in the main button groups */
        #previewModal .button-group:not(.no-border-buttons) button:not(:last-child) {
            border-right: 1px solid rgba(74, 85, 104, 0.5); /* Darker separator between buttons */
        }
        #previewModal .button-group.no-border-buttons button:not(:last-child) {
            border-right: none; /* Remove border for this specific group */
        }

        /* Specific styling for the byline and URL/Image source button groups */
        #previewModal .button-group.individual-rounded-buttons {
            border: none; /* Remove group border */
            box-shadow: none; /* Remove group shadow */
            width: auto; /* Allow the group to size to content */
            gap: 0.5rem; /* Add gap between individual buttons */
        }

        #previewModal .button-group.individual-rounded-buttons button {
            flex: none; /* Do not make buttons take equal space */
            border-radius: 0.5rem; /* Ensure rounded corners */
            border: 1px solid #4a5568; /* Add individual button border */
            padding: 0.5rem 0.75rem; /* Consistent padding */
        }
        /* Remove right border for individual rounded buttons */
        #previewModal .button-group.individual-rounded-buttons button:not(:last-child) {
            border-right: 1px solid #4a5568; /* Keep individual border */
        }

        #previewModal .button-group button:first-child {
            border-top-left-radius: 0.5rem;
            border-bottom-left-radius: 0.5rem;
        }

        #previewModal .button-group button:last-child {
            border-top-right-radius: 0.5rem;
            border-bottom-right-radius: 0.5rem;
        }

        #previewModal .button-group button.active:hover {
            z-index: 1; /* Bring hovered button to front to show full border/shadow */
			background-color: #3182ce !important;
        }
		#previewModal .button-group button.active:hover {
            z-index: 1; /* Bring hovered button to front to show full border/shadow */
			background-color: #3182ce !important;
        }

        /* Active states for buttons in modal, matching QA Wizard */
        #previewModal .button-group button.active {
			color: white !important;
			background-color: #4a5568 !important;
		}
        /* Specific active state for WET4 button */
        #previewModal #modalWetGcdsToggleBtn.active {
            background-color: #2563eb !important; /* Blue-600 for WET4 active */
            border-color: #2563eb !important;
        }
        #previewModal #modalWetGcdsToggleBtn.hover {
            background-color: #2563eb !important; /* Blue-600 for WET4 active */
            border-color: #2563eb !important;
        }
        /* Specific active state for GCDS/WET+ button */
        #previewModal #modalWetGcdsToggleBtn[class*="indigo-600"].active {
            background-color: #4f46e5 !important; /* Indigo-600 for GCDS/WET+ active */
            border-color: #4f46e5 !important;
        }

        /* Specific styling for the Sections and Headings buttons in modal */
        #previewModal #modalToggleSectionsBtn,
        #previewModal #modalToggleHeadingsBtn {
            flex: none; /* Override flex: 1; for these specific buttons */
            width: auto; /* Allow buttons to size based on content */
            border: 1px solid #4a5568; /* Add border back for individual buttons */
            border-radius: 0.5rem; /* Add rounded corners back for individual buttons */
            padding: 0.3rem 0.6rem; /* Reduced padding */
            font-size: 0.75rem; /* Smaller font size */
        }
        #previewModal #modalToggleSectionsBtn.active,
        #previewModal #modalToggleHeadingsBtn.active {
            background-color: #facc15 !important; /* Tailwind yellow-400 */
            color: #1f2937 !important; /* Dark gray for text */
            border-color: #facc15 !important;
        }
        /* Default state for Sections/Headings buttons */
        #previewModal #modalToggleSectionsBtn,
        #previewModal #modalToggleHeadingsBtn {
            background-color: #374151; /* Tailwind gray-700 */
            color: #ffffff;
        }
        #previewModal #modalToggleSectionsBtn:hover,
        #previewModal #modalToggleHeadingsBtn:hover {
            background-color: #4b5563; /* Tailwind gray-600 */
        }

        /* Input and Label styles for modal */
        #previewModal input[type="text"] {
            background-color: #4a5568; /* Darker background for input */
            color: #ffffff; /* White text for input */
            border-color: #4a5568; /* Darker border for input */
            border-radius: 0.5rem; /* rounded-md */
            padding: 0.5rem 0.75rem; /* Consistent padding */
            font-size: 0.875rem; /* text-sm */
            line-height: 1.25rem; /* leading-5 */
        }
        #previewModal input[type="text"]::placeholder {
            color: #a0aec0; /* Lighter placeholder text */
        }
        #previewModal label {
            color: #cbd5e0; /* Lighter gray for labels */
        }

        /* Styles for Prev/Next buttons in modal */
        #modalPreviewFindPrevBtn,
        #modalPreviewFindNextBtn {
            padding: 0.25rem 0.5rem !important; /* px-2 py-1 */
            font-size: 0.75rem !important; /* text-xs */
            background-color: #2563eb !important;
            color: #ffffff !important; /* White text */
            border-radius: 0.375rem !important; /* rounded-md */
            transition: background-color 0.2s ease;
        }
        #modalPreviewFindPrevBtn:hover,
        #modalPreviewFindNextBtn:hover {
            background-color: #3182ce !important; /* Blue-600 */
        }

        /* Styles for WET4, EN, FR buttons in modal header */
        #modalWetGcdsToggleBtn,
        #modalLangEnBtn, /* Apply to both EN and FR buttons */
        #modalLangFrBtn {
            padding: 0.3rem 0.6rem; /* Reduced padding */
            font-size: 0.75rem; /* Smaller font size */
        }
        /* EN/FR active state */
        #modalLangEnBtn.active,
        #modalLangFrBtn.active {
            background-color: #2563eb !important; /* Indigo-600 for active state */
            color: white !important;
            border-color: #2563eb !important;
        }

        /* EN/FR hover state */
        #modalLangEnBtn:hover,
        #modalLangFrBtn:hover {
            background-color: #3182ce !important; /* Blue-600 */
        }

        /* "X" Close Button styling */
        #closePreviewModalBtn {
            background-color: transparent; /* Make it transparent by default */
            color: #cbd5e0; /* Lighter gray for the X symbol */
            border: none;
            transition: background-color 0.2s ease, color 0.2s ease;
            cursor: pointer;
            border-radius: 50%; /* Make it round */
            display: flex;
            align-items: center;
            justify-content: center;
            width: 2rem; /* w-8 */
            height: 2rem; /* h-8 */
            font-size: 1.5rem; /* text-2xl */
            font-weight: bold;
            line-height: none; /* Remove extra line height */
            padding: 0; /* Remove padding */
        }
        #closePreviewModalBtn:hover {
            background-color: rgba(255, 255, 255, 0.1); /* Subtle background on hover */
            color: #ffffff; /* White on hover */
        }

        .message-box {
            /* This is probably not needed if you have your own system */
            position: fixed;
            top: 1rem;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            padding: 1rem 2rem;
            font-weight: bold;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            animation: fadeInOut 4s ease-in-out forwards;
            color: white;
            background-color: #38a169;
            /* Default to green for success */
        }

        .message-box.error {
            /* This is probably not needed if you have your own system */
            background-color: #f56565;
            /* Red for errors */
        }

        @keyframes fadeInOut {

            /* This is probably not needed if you have your own system */
            0% {
                opacity: 0;
                transform: translateX(-50%) scale(0.9);
            }

            10% {
                opacity: 1;
                transform: translateX(-50%) scale(1);
            }

            90% {
                opacity: 1;
                transform: translateX(-50%) scale(1);
            }

            100% {
                opacity: 0;
                transform: translateX(-50%) scale(0.9);
            }
        }

        /* Custom class for highlighting a single match when "Highlight all" is off */
        .find-highlight {
            background-color: rgba(255, 255, 0, 0.6);
            color: #000000 !important;
        }

        /* Custom class for highlighting all matches in magenta */
        .highlight-all-magenta {
            background-color: rgba(255, 0, 255, 0.5);
            color: #ffffff !important;
        }

        /* Custom class for highlighting the CURRENT match when "Highlight all" is ON */
        .find-current-match-highlight {
            box-shadow: 0 0 0 2px #f97316;
            /* Bright orange outline */
            background-color: rgba(255, 165, 0, 0.8);
            /* More opaque orange background */
            z-index: 10;
        }

        /* Custom class for highlighting the entire ID tag block with a subtle border */
        .id-highlight {
            border-bottom: 1px solid rgba(0, 255, 255, 1);
            z-index: 1;
        }

        .tag-highlight {
            border-bottom: 2px solid rgba(255, 0, 255, 1);
        }

        /* New CSS for Regex active border */
        .regex-active-border {
            border: 2px solid #3498db !important;
            /* A distinct blue color */
        }

        /* Styles for collapsible sections */
        .collapsible-section {
            background-color: #475569;
            /* Medium slate for section background */
            border-radius: 0.5rem;
            margin-bottom: 0.75rem;
            /* Space between sections */
            overflow: hidden;
            /* Hide overflowing content during collapse */
        }

        .collapsible-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem 1rem;
            cursor: pointer;
            background-color: #475569;
            /* Medium slate for header background */
            border-bottom: 1px solid #64748B;
            /* Lighter slate border */
            border-radius: 0.5rem 0.5rem 0 0;
            /* Rounded top corners */
        }

        .collapsible-header.collapsed {
            border-bottom: none;
            /* No border when collapsed */
            border-radius: 0.5rem;
            /* Fully rounded when collapsed */
        }

        .collapsible-header h4 {
            font-size: 1rem;
            font-weight: bold;
            color: #ffffff;
        }

        .collapsible-header svg {
            transition: transform 0.3s ease;
        }

        .collapsible-header.expanded svg {
            transform: rotate(180deg);
        }

        .collapsible-content {
            /* Now uses max-height instead of height */
            max-height: 0;
            /* Changed from height: 0; */
            overflow: hidden;
            /* Unified transition for smoother effect */
            transition: max-height 0.5s ease-in-out, padding 0.5s ease-in-out;
            /* Transition max-height and padding */
            padding: 0 1rem;
            /* Padding for content area, default to 0 for collapsed */
            background-color: #475569;
            /* Match header background */
            border-radius: 0 0 0.5rem 0.5rem;
            /* Rounded bottom corners */
        }

        .collapsible-content.expanded {
            /* max-height will be set by JS dynamically to scrollHeight or a large value */
            padding-top: 0.75rem;
            /* Add padding to content when expanded */
            padding-bottom: 0.75rem;
            /* Add padding to content when expanded */
        }

        /* Toggle Switch Styles */
        .toggle-switch-container {
            display: flex;
            align-items: center;
            margin-bottom: 0.25rem;
            /* Reduced spacing */
            padding: 0.25rem 0;
            /* Reduced vertical padding */
            gap: 0.5rem;
            /* Space between toggle and label */
            justify-content: flex-start;
            /* Align contents to the start */
        }

        .toggle-switch-label {
            color: #CBD5E1;
            /* Light slate for label text */
            font-size: 0.9rem;
            flex-shrink: 1;
            /* Allow label to shrink */
            min-width: 0;
            /* Allow text to wrap within the label */
        }

        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 44px;
            /* Width of the pill */
            height: 24px;
            /* Height of the pill */
            border-radius: 12px;
            /* Half of height for pill shape */
            background-color: #64748B;
            /* Grayish slate for off state */
            cursor: pointer;
            transition: background-color 0.3s ease;
            flex-shrink: 0;
            /* Prevent the switch from shrinking */
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-switch-slider {
            position: absolute;
            content: "";
            height: 20px;
            /* Height of the inner circle */
            width: 20px;
            /* Width of the inner circle */
            left: 2px;
            /* Initial position for off state */
            bottom: 2px;
            background-color: #ffffff;
            /* Circle color */
            border-radius: 50%;
            transition: transform 0.3s ease;
        }

        /* Checked state styles (applied to the .toggle-switch label itself) */
        .toggle-switch.is-checked {
            background-color: #22c55e;
            /* Green for on state */
        }

        .toggle-switch.is-checked .toggle-switch-slider {
            transform: translateX(20px);
            /* Move circle to the right */
        }

        /* Custom style for HTML character entities in Monaco Editor */
        .entity-highlight {
            color: gold !important;
            /* Use !important to ensure override */
        }

        /* Styling for disabled button */
        .button-list button:disabled,
        .flex.justify-center.space-x-2 button:disabled,
        .flex.items-center.mb-4 button:disabled,
        .modal-content button:disabled {
            /* Apply to all buttons within these containers and modal buttons */
            background-color: #4a4a4a !important;
            /* Darker gray for disabled state, use !important to override other styles */
            cursor: not-allowed !important;
            opacity: 0.6 !important;
        }

        /* New styles for the button list */
        .button-list {
            display: flex;
            flex-direction: column;
            /* Stack buttons vertically */
            width: 100%;
            /* Removed border and border-radius from button-list container */
        }

        .button-list button {
            width: 100%;
            /* Full width within the list */
            border-radius: 0.5rem;
            /* Apply rounded corners */
            margin-bottom: 0.5rem;
            /* Add margin between buttons */
            border: 1px solid rgba(71, 85, 105, 0.5);
            /* Re-add individual border */
            padding: 0.5rem 0.75rem;
            /* Consistent padding */
            text-align: center;
            /* Center text */
            font-weight: 600;
            /* semi-bold */
            background-color: #475569;
            /* Darker slate for internal buttons */
            color: #ffffff;
        }

        .button-list button:hover {
            background-color: #64748B;
            /* Lighter slate on hover */
        }


        /* The two-button group in modals uses a different style, which is fine */
        .modal-content .button-group.inline-flex {
            border: none;
            box-shadow: none;
            gap: 0.5rem;
            /* Spacing between the buttons in the modal group */
        }

        .modal-content .button-group.inline-flex button {
            flex: none;
            /* Important for modal buttons to not stretch */
            border-radius: 0.5rem;
            /* Individual rounded corners for modal buttons */
            margin: 0;
            /* No external margins, gap handles spacing */
            border: 1px solid #475569;
            /* Ensure border for individual modal buttons */
            padding: 0.3rem 0.6rem;
            /* Smaller padding for modal buttons */
            font-size: 0.8rem;
            /* Smaller font size for modal buttons */
        }

        /* Apply these classes to the new #searchRegex div */
        .search-controls-hidden {
            max-height: 0;
            opacity: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out, opacity 0.3s ease-out;
            pointer-events: none;
            /* Disable interaction when hidden */
            padding-top: 0 !important;
            /* Remove any top/bottom padding when hidden */
            padding-bottom: 0 !important;
        }

        .search-controls-visible {
            max-height: 500px;
            /* A value large enough to contain all controls */
            opacity: 1;
            transition: max-height 0.3s ease-in, opacity 0.3s ease-in;
            pointer-events: auto;
        }
		 /* Validation Results Section */
#validationResults {
    padding: 0.5rem;
    border-radius: 0.5rem;
    font-size: 0.875rem;
    line-height: 1.5;
    flex-grow: 1; /* Allow results to take up remaining space */
    height: 150px; /* Fixed height for results area */
    overflow-y: auto; /* Enable scrolling for results */
    /* Default background for validation results */
    background-color: #f9fafb; /* bg-gray-50 */
    color: #4a5568; /* text-gray-700 */
    border: 1px solid #e2e8f0; /* border-gray-200 */
}

/* Specific styles for validation results based on success/error */
#validationResults.bg-green-100 {
    background-color: #d1fae5;
    color: #065f46;
    border: 1px solid #34d399;
}
#validationResults.bg-red-100 {
    background-color: #fee2e2;
    color: #991b1b;
    border: 1px solid #f87171;
}

/* Styling for clickable error list items */
#validationResults ul li {
    cursor: pointer;
    padding: 4px 0;
    transition: background-color 0.2s ease;
}

#validationResults ul li:hover {
    background-color: rgba(255, 255, 255, 0.1);
    text-decoration: underline;
}

/* Monaco Editor custom highlight style for clicked line */
#monacoEditorContainer .highlighted-line {
    background-color: rgba(255,99,71, 0.2); /* Muted cornflower blue, more subtle */
	border-left: solid 3px red;
}
		/* Add this to your existing styles */
.bottom-panel-content-hidden {
    display: none;
}

#searchValidateToggle button.active {
    background-color: #3b82f6; /* A brighter blue to indicate active state */
    color: white;
    font-weight: bold;
}
.view-hidden {
    display: none !important;
}
    </style>
</head>

<body>
    <header class="content-wizard-header">
        <h1 class="text-left"><i class="fa-solid fa-pen-to-square"></i> WordToCode™ - Rich Content Wizard</h1>
        <a href="/tbsweb-toolset/rich-content-wizard/" class="px-3 py-1 text-sm text-white rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50 font-bold bg-gray-400 cursor-not-allowed opacity-60" disabled="">Content Wizard</a>
        <a href="/tbsweb-toolset/table-wizard/" class="px-3 py-1 text-sm bg-blue-600 text-white rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50 font-bold">Table Wizard</a>
        <a href="/tbsweb-toolset/qa-wizard/" class="px-3 py-1 text-sm bg-blue-600 text-white rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50 font-bold">QA Wizard</a>
    </header>
    <div class="editor-container">
        <div id="richtextOutputPanel" class="richtext-output-panel panel-visible">
            <div class="flex items-center mb-4">
                <button id="toggleEditorViewBtnRichText" class="px-4 py-2 text-base font-semibold bg-cyan-700 text-white rounded-md hover:bg-cyan-800 focus:outline-none focus:ring-2 focus:ring-cyan-600 focus:ring-opacity-50 font-bold">
                    Go to HTML
                </button>
                <!-- Auto-Clean MSO toggle for Rich-Text Editor -->
                <div class="ml-4 p-2 bg-slate-700 rounded-lg flex items-center gap-2">
                    <label class="toggle-switch">
                        <input type="checkbox" id="toggleAutoCleanMsoOnSwitchRichText">
                        <span class="toggle-switch-slider"></span>
                    </label>
                    <span class="toggle-switch-label text-white text-sm">Auto-Clean MSO</span>
                </div>
            </div>
            <iframe id="default_ifr"></iframe>
        </div>

        <!-- Main Editor Area: Contains Code Panel and Sidebar Panel -->
        <div id="mainEditorArea" class="main-editor-area panel-hidden">
            <div id="codePanel" class="code-panel">
                <div class="flex items-center mb-4 flex-wrap">
                    <button id="toggleEditorViewBtnCode" class="px-4 py-2 text-base font-semibold bg-cyan-700 text-white rounded-md hover:bg-cyan-800 focus:outline-none focus:ring-2 focus:ring-cyan-600 focus:ring-opacity-50 font-bold">
                        Go to Rich-Text
                    </button>
                    <!-- Auto-Clean MSO toggle for HTML Editor -->
                    <div class="ml-4 p-2 bg-slate-700 rounded-lg flex items-center gap-2">
                        <label class="toggle-switch">
                            <input type="checkbox" id="toggleAutoCleanMsoOnSwitchCode">
                            <span class="toggle-switch-slider"></span>
                        </label>
                        <span class="toggle-switch-label text-white text-sm">Auto-Clean MSO</span>
                    </div>
                    <!-- New Clean Mso Button -->
                    <button id="cleanMsoBtn" class="ml-4 px-4 py-2 text-base bg-blue-700 text-white rounded-md hover:bg-blue-800 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50 font-bold">
                        Clean MSO
                    </button>
					<button id="validateNowBtn" class="ml-4 px-4 py-2 text-base bg-blue-700 text-white rounded-md hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50 font-bold">
					   <i class="fa-solid fa-check-double"></i> Validate
					</button>
                </div>
                <!-- New row for Copy, Clear, Import, Export buttons -->
                <div class="flex items-center mb-4 flex-wrap">
                    <div class="inline-flex rounded-md shadow-sm" role="group">
                        <button id="copyCodeBtn" class="px-4 py-1 text-sm bg-zinc-700 text-white rounded-l-md hover:bg-zinc-600 focus:outline-none focus:ring-2 focus:ring-zinc-500 focus:ring-opacity-50 font-semibold">
                            Copy Code <i class="fa-solid fa-copy"></i>
                        </button>
                        <button id="clearAllBtn" class="px-4 py-1 text-sm bg-zinc-700 text-white rounded-r-md hover:bg-zinc-600 focus:outline-none focus:ring-2 focus:ring-zinc-500 focus:ring-opacity-50 font-semibold">
                            Clear All <i class="fa-solid fa-trash"></i>
                        </button>
                    </div>
                    <div class="inline-flex rounded-md shadow-sm ml-4" role="group">
                        <button id="undoBtn" class="px-4 py-1 text-sm bg-zinc-700 text-white rounded-l-md hover:bg-zinc-600 focus:outline-none focus:ring-2 focus:ring-zinc-500 focus:ring-opacity-50 font-semibold disabled:opacity-50 disabled:cursor-not-allowed" title="Undo">
                            <i class="fas fa-undo"></i>
                        </button>
                        <button id="redoBtn" class="px-4 py-1 text-sm bg-zinc-700 text-white rounded-r-md hover:bg-zinc-600 focus:outline-none focus:ring-2 focus:ring-zinc-500 focus:ring-opacity-50 font-semibold disabled:opacity-50 disabled:cursor-not-allowed" title="Redo">
                            <i class="fas fa-redo"></i>
                        </button>
                    </div>
                    <div class="inline-flex rounded-md shadow-sm ml-4" role="group">
                        <button id="importHtmlBtn" class="px-3 py-1 text-sm bg-purple-700 text-white rounded-l-md hover:bg-purple-800 focus:outline-none focus:ring-2 focus:ring-purple-600 focus:ring-opacity-50 font-bold">Import HTML <i class="fa-solid fa-file-import"></i></button>
                        <button id="exportHtmlBtn" class="px-3 py-1 text-sm bg-red-700 text-white rounded-r-md hover:bg-red-800 focus:outline-none focus:ring-2 focus:ring-red-600 focus:ring-opacity-50 font-bold">Export HTML <i class="fa-solid fa-file-export"></i></button>
                        <input type="file" id="htmlFileInput" accept=".html" style="display: none;">
                    </div>

                </div>

                <div id="monacoEditorContainer" class="flex-grow border border-slate-700 rounded-lg overflow-hidden"></div>
				<div class="w-full text-left mb-2 mt-2 flex items-center justify-between">
					<button id="toggleBottomPanel" class="px-3 py-1 text-xs bg-gray-600 text-white rounded-md hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-opacity-50 font-bold">
						Hide Panel
					</button>
					<div id="searchValidateToggle" class="inline-flex rounded-md shadow-sm" role="group">
					<button id="openSearchControlsBtn" class="px-3 py-1 text-xs bg-gray-600 text-white rounded-l-md hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-opacity-50 font-bold">
						Search
					</button>
					<button id="openValidationBtn" class="px-3 py-1 text-xs bg-gray-600 text-white rounded-r-md hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-opacity-50 font-bold">
						Validation Results
					</button>
					</div>
				</div>
                <div id="searchAndValidatePanel" class="w-full">
    <div id="searchRegex">
        <!-- All your existing search controls (<select>, <input>, <button>, etc.) go here -->
        <!-- ... (content remains the same) ... -->
        <div class="flex flex-wrap items-center space-x-4 mb-2">
            <select id="target-id-dropdown" class="w-32 p-3 rounded-md bg-gray-900 text-white font-mono focus:outline-none focus:ring-2 focus:ring-blue-500 transition duration-200">
                <option value="all">All ID's</option>
            </select>
            <select id="target-tag-dropdown" class="w-32 p-3 rounded-md bg-gray-900 text-white font-mono focus:outline-none focus:ring-2 focus:ring-blue-500 transition duration-200">
                <option value="all">All Tags</option>
            </select>
            <div class="flex items-center space-x-4 text-white ml-auto">
                <label for="match-case" class="flex items-center space-x-2">
                    <input type="checkbox" id="match-case" class="form-checkbox h-5 w-5 text-blue-600 rounded">
                    <span>Match case</span>
                </label>
                <label for="highlight-all" class="flex items-center space-x-2">
                    <input type="checkbox" id="highlight-all" class="form-checkbox h-5 w-5 text-blue-600 rounded">
                    <span>Highlight all</span>
                </label>
                <label for="enable-regex" class="flex items-center space-x-2">
                    <input type="checkbox" id="enable-regex" class="form-checkbox h-5 w-5 text-blue-600 rounded">
                    <span>REGEX</span>
                </label>
            </div>
        </div>
        <div id="sequence-container" class="flex flex-wrap items-center space-x-4 text-white overflow-hidden max-h-40 opacity-100 transition-all duration-300 ease-in-out mb-1 mt-1">
            <label for="sequence" class="flex items-center space-x-2">
                <input type="checkbox" id="sequence" class="form-checkbox h-5 w-5 text-blue-600 rounded">
                <span>Sequence <span class="text-gray-300 text-sm">(To use: Insert <strong><code>{$#+}</code></strong> OR <strong><code>{$#-}</code></strong> in replace field)</span></span>
            </label>
            <div id="sequence-range-container" class="flex items-center space-x-2 flex-grow justify-end opacity-0 pointer-events-none transition-opacity duration-300 ease-in-out">
                <label for="start-index">Start:</label>
                <input type="number" id="start-index" value="1" class="w-20 p-2 rounded-md bg-gray-900 text-white font-mono focus:outline-none focus:ring-2 focus:ring-blue-500">
                <label for="end-index">End:</label>
                <input type="number" id="end-index" placeholder="all" class="w-20 p-2 rounded-md bg-gray-900 text-white font-mono placeholder-gray-500 focus:outline-none focus:ring-2 focus:ring-blue-500">
            </div>
        </div>
        <div class="flex flex-col space-y-4 mt-1">
            <div class="flex flex-col md:flex-row items-center space-y-4 md:space-y-0 md:space-x-4">
                <input id="find-input" type="text" placeholder="Find" class="w-full flex-1 p-3 rounded-md bg-gray-900 text-white font-mono placeholder-gray-500 focus:outline-none focus:ring-2 focus:ring-blue-500 transition duration-200">
                <input id="replace-input" type="text" placeholder="Replace" class="w-full flex-1 p-3 rounded-md bg-gray-900 text-white font-mono placeholder-gray-500 focus:outline-none focus:ring-2 focus:ring-blue-500 transition duration-200">
            </div>
            <div class="flex flex-wrap justify-between items-center space-x-2">
                <div class="flex items-center space-x-2">
                    <button id="find-previous-button" class="px-3 py-1 text-sm bg-blue-600 text-white rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50 font-bold">
                        &#x2191;
                    </button>
                    <button id="find-next-button" class="px-3 py-1 text-sm bg-blue-600 text-white rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50 font-bold">
                        Next &#x2193;
                    </button>
                    <button id="regex-guide-button" class="px-3 py-1 text-sm bg-gray-600 text-white rounded-md hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-opacity-50 font-bold">
                        Regex Guide
                    </button>
                </div>
                <div class="flex items-center space-x-2">
                    <button id="replace-one-button" class="px-3 py-1 text-sm bg-blue-600 text-white rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50 font-bold">
                        Replace
                    </button>
                    <button id="replace-all-button" class="px-3 py-1 text-sm bg-blue-600 text-white rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50 font-bold">
                        Replace All
                    </button>
                </div>
            </div>
        </div>
        <span id="match-count" class="text-white text-sm mt-2"></span>
    </div>
    
    <!-- IMPORTANT: Add the 'bottom-panel-content-hidden' class here initially -->
    <div id="validationResultsContainer" class="view-hidden">
        <div id="validationResults" class="bg-gray-50 p-4 border border-gray-200 rounded-lg min-h-[50px] text-gray-700 text-sm leading-relaxed">
            <p class="text-gray-500 text-center">Click <strong>"Validate"</strong> at the top to view results.</p>
        </div>
    </div>
</div>
				
            </div>

            <div id="sidebarPanel" class="sidebar-panel">
                <h3 class="text-lg font-semibold text-white mb-4">Quick Formatting</h3>

                <div class="button-list">
                    <!-- Clean Spaces Toggle -->
                    <div class="toggle-switch-container">
                        <label class="toggle-switch is-checked" for="toggleCleanSpaces">
                            <input type="checkbox" id="toggleCleanSpaces" checked>
                            <span class="toggle-switch-slider"></span>
                        </label>
                        <span class="toggle-switch-label text-white text-sm">Clean Spaces</span>
                    </div>

                    <!-- Clean URLs Toggle -->
                    <div class="toggle-switch-container">
                        <label class="toggle-switch is-checked" for="toggleCleanUrls">
                            <input type="checkbox" id="toggleCleanUrls" checked>
                            <span class="toggle-switch-slider"></span>
                        </label>
                        <span class="toggle-switch-label text-white text-sm">Clean URLs</span>
                    </div>

                    <!-- Set Time Tags Toggle -->
                    <div class="toggle-switch-container">
                        <label class="toggle-switch is-checked" for="toggleTimeTags">
                            <input type="checkbox" id="toggleTimeTags" checked>
                            <span class="toggle-switch-slider"></span>
                        </label>
                        <span class="toggle-switch-label text-white text-sm">Set Time Tags</span>
                    </div>

                    <!-- Fix FN ID's Toggle -->
                    <div class="toggle-switch-container">
                        <label class="toggle-switch is-checked" for="toggleFixFnIds">
                            <input type="checkbox" id="toggleFixFnIds" checked>
                            <span class="toggle-switch-slider"></span>
                        </label>
                        <span class="toggle-switch-label text-white text-sm">Fix FN ID's</span>
                    </div>

                    <!-- Auto-Level Headings Toggle -->
                    <div class="toggle-switch-container">
                        <label class="toggle-switch is-checked" for="toggleAutoLevelHeadings">
                            <input type="checkbox" id="toggleAutoLevelHeadings" checked>
                            <span class="toggle-switch-slider"></span>
                        </label>
                        <span class="toggle-switch-label text-white text-sm">Auto-Level Headings</span>
                    </div>

                    <!-- Auto-Section Toggle -->
                    <div class="toggle-switch-container">
                        <label class="toggle-switch is-checked" for="toggleAutoSection">
                            <input type="checkbox" id="toggleAutoSection" checked>
                            <span class="toggle-switch-slider"></span>
                        </label>
                        <span class="toggle-switch-label text-white text-sm">Auto-Section</span>
                    </div>

                    <!-- Clean Single Breaks Toggle -->
                    <div class="toggle-switch-container">
                        <label class="toggle-switch" for="toggleCleanSingleBreaks">
                            <input type="checkbox" id="toggleCleanSingleBreaks">
                            <span class="toggle-switch-slider"></span>
                        </label>
                        <span class="toggle-switch-label text-white text-sm">Clean Single Breaks</span>
                    </div>

                    <!-- NEW: Clean <p> in Tables Toggle -->
                    <div class="toggle-switch-container">
                        <label class="toggle-switch" for="toggleCleanPTables">
                            <input type="checkbox" id="toggleCleanPTables">
                            <span class="toggle-switch-slider"></span>
                        </label>
                        <span class="toggle-switch-label text-white text-sm">Clean &lt;p&gt; in Tables</span>
                    </div>

                    <!-- Clean <u> | <b> | <i> Toggle -->
                    <div class="toggle-switch-container">
                        <label class="toggle-switch" for="toggleCleanFormattingTags">
                            <input type="checkbox" id="toggleCleanFormattingTags">
                            <span class="toggle-switch-slider"></span>
                        </label>
                        <span class="toggle-switch-label text-white text-sm">Clean &lt;u&gt; | &lt;b&gt; | &lt;i&gt;</span>
                    </div>
                </div>
                <!-- New Format Button for Quick Formatting Toggles -->
                <button id="formatSelectedBtn" class="px-4 py-2 text-sm bg-blue-600 text-white rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50 font-bold mb-2 mt-2" disabled>
                    Format
                </button>
                <button id="autoEncodeBtn" class="px-4 py-2 text-sm bg-red-700 text-white rounded-md hover:bg-red-800 focus:outline-none focus:ring-2 focus:ring-red-600 focus:ring-opacity-50  font-bold mb-2">
                    Auto-Encode
                </button>
                <button id="autoFormatBtn" class="px-4 py-2 text-sm bg-red-700 text-white rounded-md hover:bg-red-800 focus:outline-none focus:ring-2 focus:ring-red-600 focus:ring-opacity-50  font-bold mb-2">
                    Auto-Indent
                </button>

                <h3 class="text-lg font-semibold text-white mb-4 mt-4">Quick Insert</h3>
                <div class="button-list mb-2">
                    <!-- Auto-ID Button -->
                    <button id="autoIdBtn" class="px-4 py-2 text-sm bg-slate-600 text-white hover:bg-slate-500 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50 rounded-md">
                        Element ID's
                    </button>

                    <!-- Footnote List Button -->
                    <button id="footnoteListBtn" class="px-4 py-2 text-sm bg-slate-600 text-white hover:bg-slate-500 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50 rounded-md">
                        Footnote List
                    </button>
                    <!-- Colophon Button -->
                    <button id="colophonBtn" class="px-4 py-2 text-sm bg-slate-600 text-white hover:bg-slate-500 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50 rounded-md">
                        Colophon
                    </button>
                </div>
                <h4 class="text-md text-white mb-2">Page ToC ("On this page")</h4>
                <div class="button-list">
                    <div class="flex space-x-2">
                        <button id="enPageToCBtn" class="flex-1 px-4 py-2 text-sm bg-slate-600 text-white hover:bg-slate-500 rounded-md mb-1">English
                        </button>
                        <button id="enPageToCH3Btn" class="flex-1 px-4 py-2 text-sm bg-slate-600 text-white hover:bg-slate-500 rounded-md mb-1">+H3
                        </button>
                    </div>
                    <div class="flex space-x-2 mb-2">
                        <button id="frPageToCBtn" class="flex-1 px-4 py-2 text-sm bg-slate-600 text-white hover:bg-slate-500 rounded-md mb-1">French
                        </button>
                        <button id="frPageToCH3Btn" class="flex-1 px-4 py-2 text-sm bg-slate-600 text-white hover:bg-slate-500 rounded-md mb-1">+H3
                        </button>
                    </div>
                </div>
                <h4 class="text-md text-white mb-2">Section ToC ("In this section")</h4>
                <div class="button-list">
                    <div class="flex space-x-2">
                        <button id="enSecToCBtn" class="flex-1 px-4 py-2 text-sm bg-slate-600 text-white hover:bg-slate-500 rounded-md mb-1">ENG</button>
                        <button id="enSecToCH4Btn" class="flex-1 px-4 py-2 text-sm bg-slate-600 text-white hover:bg-slate-500 rounded-md mb-1">+H4</button>
                        <button id="enSecToCH5Btn" class="flex-1 px-4 py-2 text-sm bg-slate-600 text-white hover:bg-slate-500 rounded-md mb-1">+H5</button>
                        <button id="enSecToCH6Btn" class="flex-1 px-4 py-2 text-sm bg-slate-600 text-white hover:bg-slate-500 rounded-md mb-1">+H6</button>
                    </div>
                </div>
                <div class="button-list">
                    <div class="flex space-x-2">
                        <button id="frSecToCBtn" class="flex-1 px-4 py-2 text-sm bg-slate-600 text-white hover:bg-slate-500 rounded-md mb-1">FRA</button>
                        <button id="frSecToCH4Btn" class="flex-1 px-4 py-2 text-sm bg-slate-600 text-white hover:bg-slate-500 rounded-md mb-1">+H4</button>
                        <button id="frSecToCH5Btn" class="flex-1 px-4 py-2 text-sm bg-slate-600 text-white hover:bg-slate-500 rounded-md mb-1">+H5</button>
                        <button id="frSecToCH6Btn" class="flex-1 px-4 py-2 text-sm bg-slate-600 text-white hover:bg-slate-500 rounded-md mb-1">+H6</button>
                    </div>
                </div>
            </div>
        </div>

        <script>
            // Get references to the elements
            const default_ifr = document.getElementById('default_ifr');
            const codePanel = document.getElementById('codePanel');
            const richtextOutputPanel = document.getElementById('richtextOutputPanel');
            const mainEditorArea = document.getElementById('mainEditorArea'); // New: Reference to the main editor area
            const toggleEditorViewBtnRichText = document.getElementById('toggleEditorViewBtnRichText');
            const toggleEditorViewBtnCode = document.getElementById('toggleEditorViewBtnCode');
            const copyCodeBtn = document.getElementById('copyCodeBtn');
            const autoFormatBtn = document.getElementById('autoFormatBtn');
            const autoEncodeBtn = document.getElementById('autoEncodeBtn'); // New button reference
            const exportHtmlBtn = document.getElementById('exportHtmlBtn');
            const importHtmlBtn = document.getElementById('importHtmlBtn');
            const htmlFileInput = document.getElementById('htmlFileInput');
            const clearAllBtn = document.getElementById('clearAllBtn');
            const cleanMsoBtn = document.getElementById('cleanMsoBtn'); // Ensure cleanMsoBtn is defined

            // References for new Quick Formatting Toggles
            const toggleCleanSpaces = document.getElementById('toggleCleanSpaces');
            const toggleCleanUrls = document.getElementById('toggleCleanUrls');
            const toggleTimeTags = document.getElementById('toggleTimeTags');
            const toggleFixFnIds = document.getElementById('toggleFixFnIds');
            const toggleCleanSingleBreaks = document.getElementById('toggleCleanSingleBreaks');
            const toggleCleanFormattingTags = document.getElementById('toggleCleanFormattingTags');
            const toggleAutoLevelHeadings = document.getElementById('toggleAutoLevelHeadings');
            const toggleAutoSection = document.getElementById('toggleAutoSection');
            const toggleCleanPTables = document.getElementById('toggleCleanPTables'); // NEW: Clean <p> in Tables toggle
            const formatSelectedBtn = document.getElementById('formatSelectedBtn'); // New Format button

            const autoIdBtn = document.getElementById('autoIdBtn'); // New: Auto-ID button
            const colophonBtn = document.getElementById('colophonBtn'); // New: Colophon button
            const footnoteListBtn = document.getElementById('footnoteListBtn'); // New: Footnote List button


            // Monaco Resizer elements - now applies to panels
            const monacoEditorContainer = document.getElementById('monacoEditorContainer');
            // const panelResizer = document.getElementById('panelResizer'); // Removed: Resizer element
            const sidebarPanel = document.getElementById('sidebarPanel'); // Changed from sidebar

            // Auto-Clean MSO when switching toggles
            const toggleAutoCleanMsoOnSwitchRichText = document.getElementById('toggleAutoCleanMsoOnSwitchRichText');
            const toggleAutoCleanMsoOnSwitchCode = document.getElementById('toggleAutoCleanMsoOnSwitchCode');

            // NEW: Array of all interactive buttons to control their disabled state
            const allInteractiveButtons = [
                toggleEditorViewBtnRichText,
                toggleEditorViewBtnCode,
                cleanMsoBtn,
                importHtmlBtn,
                exportHtmlBtn,
                formatSelectedBtn,
                autoIdBtn,
                footnoteListBtn,
                colophonBtn,
                clearAllBtn,
                autoEncodeBtn,
                autoFormatBtn,
                copyCodeBtn,
                undoBtn,
                redoBtn,
                enPageToCBtn,
                enPageToCH3Btn,
                frPageToCBtn,
                frPageToCH3Btn,
                enSecToCBtn,
                enSecToCH4Btn,
                enSecToCH5Btn,
                enSecToCH6Btn,
                frSecToCBtn,
                frSecToCH4Btn,
                frSecToCH5Btn,
                frSecToCH6Btn,
            ];

            // --- Undo/Redo Manager ---
            const undoStack = [];
            const redoStack = [];
            let isUndoingOrRedoing = false;
            const UNDO_LIMIT = 50; // To prevent memory issues

            // Add the toggle inputs themselves to the list if their parent elements need to be disabled
            // No, these are inputs, not buttons. The disabled state of the *toggles* is not controlled by `data-temp-active`
            // on other buttons. Only actual buttons.

            let richTextEditorInstance; // HugeRTE editor instance
            let monacoEditorInstance; // Monaco editor instance
            let currentView = 'richtext'; // 'richtext' or 'code'

            // Separate content storage for each editor
            let richTextContent = '';
            let htmlOutputContent = ''; // This will now hold the content for Monaco

            // Variable to hold the HugeRTE editor instance from the iframe
            let richTextEditorInstanceFromIframe;

            // NEW: Simplified NBSP Placeholder
            const NBSP_PLACEHOLDER = '&#160;'; // A unique string that won't conflict with content
			
			let currentLineDecorations = []; // To manage Monaco decorations for line highlighting

// Sets of elements for HTML validation
const selfClosingTags = new Set(['area','base','br','col','embed','hr','img','input','link','meta','param','source','track','wbr']);
const deprecatedTags = new Set(['acronym','applet','basefont','big','center','dir','font','frame','frameset','noframes','strike','tt','u']);
const blockElements = new Set(['address','article','aside','blockquote','canvas','dd','div','dl','dt','fieldset','figcaption','figure','footer','form','h1','h2','h3','h4','h5','h6','header','hr','li','main','nav','noscript','ol','p','pre','section','table','tfoot','ul','video']);
const inlineElements = new Set(['a','abbr','b','bdo','br','button','cite','code','dfn','em','i','img','input','kbd','label','map','object','q','samp','script','select','small','span','strong','sub','sup','textarea','time','var']);
const mediaSizingElements = new Set(['img','iframe','video','canvas','object','embed']);
const targetValidElements = new Set(['a', 'form']);
const ignoredTags = new Set(['doc']);

// Add this inside the DOMContentLoaded wrapper
const validationResultsDiv = document.getElementById('validationResults');
validationResultsDiv.addEventListener('click', handleResultClick);
			
			const toggleBottomPanel = document.getElementById('toggleBottomPanel');
    const searchAndValidatePanel = document.getElementById('searchAndValidatePanel');
    const searchValidateToggle = document.getElementById('searchValidateToggle');

    const openSearchControlsBtn = document.getElementById('openSearchControlsBtn');
    const openValidationBtn = document.getElementById('openValidationBtn');
    
    const searchControlsView = document.getElementById('searchRegex');
    const validationResultsView = document.getElementById('validationResultsContainer');
	
	const validateNowBtn = document.getElementById('validateNowBtn');

    // --- Main Panel Show/Hide ---
    toggleBottomPanel.addEventListener('click', () => {
        const isPanelHidden = searchAndValidatePanel.classList.toggle('hidden');
        searchValidateToggle.classList.toggle('hidden', isPanelHidden);
        toggleBottomPanel.textContent = isPanelHidden ? 'Show Panel' : 'Hide Panel';
    });

    // --- Switch to Search View ---
    openSearchControlsBtn.addEventListener('click', () => {
        // Show Search controls
        searchControlsView.classList.remove('view-hidden');
        openSearchControlsBtn.classList.add('active');

        // Hide Validation results
        validationResultsView.classList.add('view-hidden');
        openValidationBtn.classList.remove('active');
    });

    // --- Switch to Validation View ---
    openValidationBtn.addEventListener('click', () => {
        // Show Validation results
        validationResultsView.classList.remove('view-hidden');
        openValidationBtn.classList.add('active');

        // Hide Search controls
        searchControlsView.classList.add('view-hidden');
        openSearchControlsBtn.classList.remove('active');
    });
validateNowBtn.addEventListener('click', async () => {
    // 1. Switch the view to "Validation Results"
    openValidationBtn.click();

    // 2. Ensure the main panel is visible
    if (searchAndValidatePanel.classList.contains('hidden')) {
        toggleBottomPanel.click();
    }
    
    // 3. Get the code from Monaco and run the validation function
    if (monacoEditorInstance) {
        const codeToValidate = monacoEditorInstance.getValue();
        // The validateHtmlContent function returns the 'errors' array now.
        const errors = await validateHtmlContent(codeToValidate); 

        // Temporarily disable the button to prevent rapid clicks
        validateNowBtn.disabled = true;

        // 4. Change button color based on validation results
        if (errors.length === 0) {
            // SUCCESS: Turn green
            validateNowBtn.classList.remove('bg-blue-700', 'hover:bg-blue-600', 'bg-red-600', 'hover:bg-red-700');
            validateNowBtn.classList.add('bg-green-600', 'hover:bg-green-700');
            validateNowBtn.innerHTML = '<i class="fa-solid fa-check"></i> Valid!';
        } else {
            // FAILURE: Turn red
            validateNowBtn.classList.remove('bg-blue-700', 'hover:bg-blue-600', 'bg-green-600', 'hover:bg-green-700');
            validateNowBtn.classList.add('bg-red-600', 'hover:bg-red-700');
            validateNowBtn.innerHTML = `<i class="fa-solid fa-triangle-exclamation"></i> ${errors.length} Errors`;
        }

        // 5. Revert the button to its original state after a delay
        setTimeout(() => {
            validateNowBtn.classList.remove('bg-green-600', 'hover:bg-green-700', 'bg-red-600', 'hover:bg-red-700');
            validateNowBtn.classList.add('bg-blue-700', 'hover:bg-blue-600');
            validateNowBtn.innerHTML = '<i class="fa-solid fa-check-double"></i> Validate';
            validateNowBtn.disabled = false;
        }, 2500); // Revert after 2.5 seconds

    } else {
        const validationResultsDiv = document.getElementById('validationResults');
        validationResultsDiv.innerHTML = '<p class="text-red-700 text-center">Error: Editor not found.</p>';
    }
});
    // --- Set Initial State on Page Load ---
    function initializeViews() {
        // Start with search controls visible
        searchControlsView.classList.remove('view-hidden');
        openSearchControlsBtn.classList.add('active');
        
        // Ensure validation results are hidden
        validationResultsView.classList.add('view-hidden');
        openValidationBtn.classList.remove('active');
    }

    initializeViews();
			
			/**
 * Handles clicks on the validation error list items to highlight the line in Monaco.
 */
function handleResultClick(event) {
    const listItem = event.target.closest('li[data-line-number]');
    if (listItem && monacoEditorInstance) {
        const lineNumber = parseInt(listItem.dataset.lineNumber, 10);
        currentLineDecorations = monacoEditorInstance.deltaDecorations(currentLineDecorations, []);
        currentLineDecorations = monacoEditorInstance.deltaDecorations(currentLineDecorations, [{
            range: new monaco.Range(lineNumber, 1, lineNumber, monacoEditorInstance.getModel().getLineMaxColumn(lineNumber)),
            options: {
                className: 'highlighted-line',
                isOverviewRuler: true,
                overviewRulerLane: monaco.editor.OverviewRulerLane.Full,
                overviewRulerColor: 'rgba(100, 149, 237, 0.6)'
            }
        }]);
        monacoEditorInstance.revealLineInCenter(lineNumber);
        monacoEditorInstance.focus();
    }
}

/**
 * Displays validation results in the UI.
 */
function displayValidationResults(errors) {
    const validationResultsDiv = document.getElementById('validationResults');
    validationResultsDiv.innerHTML = '';
    
    // Sort errors by line number
    errors.sort((a, b) => (a.lineNumber || 0) - (b.lineNumber || 0));

    if (errors.length === 0) {
        validationResultsDiv.classList.remove('bg-red-100', 'text-red-800', 'border-red-300');
        validationResultsDiv.classList.add('bg-green-100', 'text-green-800', 'border-green-300');
        validationResultsDiv.innerHTML = '<p class="font-semibold text-center">🎉 Valid! No issues found. 🎉</p>';
    } else {
        validationResultsDiv.classList.remove('bg-green-100', 'text-green-800', 'border-green-300');
        validationResultsDiv.classList.add('bg-red-100', 'text-red-800', 'border-red-300');
        const errorList = document.createElement('ul');
        errorList.classList.add('list-none', 'pl-2'); // Using list-none to have more control
        
        errors.forEach(error => {
            const listItem = document.createElement('li');
            listItem.classList.add('mb-1');
            // Format the error message as requested
            listItem.innerHTML = `<strong>Line ${error.lineNumber}:</strong> ${error.message}`;
            if (typeof error.lineNumber === 'number') {
                listItem.dataset.lineNumber = error.lineNumber;
            }
            errorList.appendChild(listItem);
        });
        validationResultsDiv.appendChild(errorList);
    }
}

function isWithinAnyRange(index, ranges) {
    for (const range of ranges) {
        if (index >= range.start && index <= range.end) {
            return true;
        }
    }
    return false;
}

async function validateHtmlContent(fullHtmlCode) {
    const errors = [];
    if (monacoEditorInstance) {
        currentLineDecorations = monacoEditorInstance.deltaDecorations(currentLineDecorations, []);
    }
    const validationResultsDiv = document.getElementById('validationResults');
    validationResultsDiv.classList.remove('bg-green-100', 'bg-red-100');
    validationResultsDiv.classList.add('bg-gray-50', 'text-gray-700', 'border-gray-200');
    validationResultsDiv.innerHTML = '<p class="text-gray-500 text-center">Validating HTML... please wait.</p>';
    await new Promise(resolve => setTimeout(resolve, 50));

    try {
        const parser = new DOMParser();
        const tempDoc = parser.parseFromString(fullHtmlCode, 'text/html');
        
        // --- PRE-CHECKS ---
        // Find all valid anchor IDs for href checks later
        const validAnchors = new Set();
        tempDoc.querySelectorAll('[id]').forEach(el => {
            if (el.id) validAnchors.add(el.id);
        });

        // --- CHECK 1: Duplicate IDs ---
        const idRegex = /id\s*=\s*(["'])(.*?)\1/g;
        const foundIds = new Map();
        let idMatch;
        while ((idMatch = idRegex.exec(fullHtmlCode)) !== null) {
            const idValue = idMatch[2];
            const lineNumber = monacoEditorInstance.getModel().getPositionAt(idMatch.index).lineNumber;
            if (foundIds.has(idValue)) {
                errors.push({ 
                    message: `<strong>Duplicate ID:</strong> The ID "${idValue}" is used more than once.`, 
                    lineNumber: lineNumber 
                });
            } else {
                foundIds.set(idValue, lineNumber);
            }
        }
        
        // --- CHECK 2: Main Tag Parsing and Rule Application ---
        const tagRegexForValidation = /<\/?([a-zA-Z0-9]+)(\s+[^>]*?)?(\/?)>/g;
        const tagStack = [];
        let match;
        while ((match = tagRegexForValidation.exec(fullHtmlCode)) !== null) {
            const fullTag = match[0];
            const tagName = match[1].toLowerCase();
            const attributesString = (match[2] || '').trim();
            const isClosingTag = fullTag.startsWith('</');
            const isSelfClosingSyntax = match[3] === '/';
            const lineNumber = monacoEditorInstance.getModel().getPositionAt(match.index).lineNumber;
            const parentTag = tagStack.length > 0 ? tagStack[tagStack.length - 1] : null;

            // --- Logic for ignored tags ---
            if (ignoredTags.has(tagName)) {
                if (!isClosingTag && !isSelfClosingSyntax) {
                    tagStack.push({ tagName: tagName, lineNumber: lineNumber, ignored: true });
                } else if (isClosingTag) {
                    // Find and remove the corresponding opening ignored tag from the stack
                    let found = false;
                    for (let i = tagStack.length - 1; i >= 0; i--) {
                        if (tagStack[i].tagName === tagName && tagStack[i].ignored) {
                            tagStack.splice(i, 1);
                            found = true;
                            break;
                        }
                    }
                }
                continue; // Skip all other validation for this tag
            }

            // --- Logic for closing tags ---
            if (isClosingTag) {
                if (tagStack.length === 0 || parentTag.ignored) {
                    errors.push({ message: `<strong>Unmatched Tag:</strong> Found a closing &lt;/${tagName}&gt; tag without a matching opening tag.`, lineNumber: lineNumber });
                } else {
                    const lastOpenTag = tagStack.pop();
                    if (lastOpenTag.tagName !== tagName) {
                        errors.push({ message: `<strong>Mismatched Tag:</strong> Expected &lt;/${lastOpenTag.tagName}&gt; (from line ${lastOpenTag.lineNumber}) but found &lt;/${tagName}&gt;.`, lineNumber: lineNumber });
                        tagStack.push(lastOpenTag); // Push back, as it's still unclosed
                    }
                }
            } 
            // --- Logic for opening tags ---
            else { 
                if (!selfClosingTags.has(tagName) && !isSelfClosingSyntax) {
                    tagStack.push({ tagName, lineNumber, ignored: false });
                }

                // --- NESTING RULES ---
                if (tagName === 'chapter' && (!parentTag || parentTag.tagName !== 'chapters')) errors.push({ message: `<strong>Invalid Nesting:</strong> &lt;chapter&gt; must be a direct child of &lt;chapters&gt;.`, lineNumber: lineNumber });
                if (tagName === 'clause' && (!parentTag || parentTag.tagName !== 'clauses')) errors.push({ message: `<strong>Invalid Nesting:</strong> &lt;clause&gt; must be a direct child of &lt;clauses&gt;.`, lineNumber: lineNumber });
                if (tagName === 'appendix' && (!parentTag || (parentTag.tagName !== 'appendices' && parentTag.tagName !== 'appendix'))) errors.push({ message: `<strong>Invalid Nesting:</strong> &lt;appendix&gt; must be within &lt;appendices&gt; or another &lt;appendix&gt;.`, lineNumber: lineNumber });
                if (parentTag && !parentTag.ignored && inlineElements.has(parentTag.tagName) && blockElements.has(tagName)) {
                    errors.push({ message: `<strong>Invalid Nesting:</strong> Block element &lt;${tagName}&gt; cannot be inside inline element &lt;${parentTag.tagName}&gt; (from line ${parentTag.lineNumber}).`, lineNumber: lineNumber });
                }
                
                // --- TAG & ATTRIBUTE RULES ---
                if (deprecatedTags.has(tagName)) errors.push({ message: `<strong>Deprecated Tag:</strong> The &lt;${tagName}&gt; tag is deprecated.`, lineNumber: lineNumber });
                if (isSelfClosingSyntax && !selfClosingTags.has(tagName)) errors.push({ message: `<strong>Invalid Syntax:</strong> The &lt;${tagName}&gt; tag should not be self-closing.`, lineNumber: lineNumber });
                
                if (tagName === 'img') {
                    if (!/\balt\s*=/.test(attributesString)) errors.push({ message: `<strong>Missing Attribute:</strong> &lt;img&gt; tag requires an 'alt' attribute.`, lineNumber: lineNumber });
                    if (!/\bsrc\s*=/.test(attributesString)) errors.push({ message: `<strong>Missing Attribute:</strong> &lt;img&gt; tag requires a 'src' attribute.`, lineNumber: lineNumber });
                } else if (tagName === 'th') {
                    if (!/\bscope\s*=/.test(attributesString) && !/\bid\s*=/.test(attributesString)) errors.push({ message: `<strong>Accessibility Error:</strong> &lt;th&gt; should have a 'scope' or 'id' attribute.`, lineNumber: lineNumber });
                } else if (tagName === 'tr') {
                    if (/\b(colspan|rowspan)\s*=/.test(attributesString)) errors.push({ message: `<strong>Invalid Attribute:</strong> 'colspan' or 'rowspan' cannot be on a &lt;tr&gt; tag.`, lineNumber: lineNumber });
                }

                // Deprecated and improper attribute checks
                if (/\balign\s*=/.test(attributesString)) errors.push({ message: `<strong>Deprecated Attribute:</strong> 'align' on &lt;${tagName}&gt;. Use CSS instead.`, lineNumber: lineNumber });
                if ((/\bwidth\s*=/.test(attributesString) || /\bheight\s*=/.test(attributesString)) && !mediaSizingElements.has(tagName)) errors.push({ message: `<strong>Improper Attribute:</strong> 'width' or 'height' on &lt;${tagName}&gt;. Use CSS for sizing.`, lineNumber: lineNumber });
                if (/\btarget\s*=/.test(attributesString) && !targetValidElements.has(tagName)) errors.push({ message: `<strong>Improper Attribute:</strong> 'target' on &lt;${tagName}&gt;.`, lineNumber: lineNumber });

                // Anchor tag specific checks
                if (tagName === 'a') {
                    const hrefMatch = attributesString.match(/\bhref\s*=\s*(["'])(.*?)\1/i);
                    if (hrefMatch) {
                        const href = hrefMatch[2];
                        if (href.includes(' ') && !href.includes('%20')) errors.push({ message: `<strong>Invalid URL:</strong> Space found in href. URL-encode spaces to '%20'.`, lineNumber: lineNumber });
                        if (href.startsWith('#') && href.length > 1) {
                            const anchorId = href.substring(1);
                            if (!validAnchors.has(anchorId)) errors.push({ message: `<strong>Broken Anchor:</strong> &lt;a href="#${anchorId}"&gt; points to a non-existent ID.`, lineNumber: lineNumber });
                        }
                    }
                }
            }
        }

        // --- CHECK 3: Unclosed Tags ---
        tagStack.forEach(unclosedTag => {
            if (!unclosedTag.ignored) {
                errors.push({ 
                    message: `<strong>Unclosed Tag:</strong> The &lt;${unclosedTag.tagName}&gt; tag (from line ${unclosedTag.lineNumber}) was never closed.`,
                    lineNumber: unclosedTag.lineNumber 
                });
            }
        });

    } catch (e) {
        console.error("Error during HTML validation:", e);
        errors.push({ message: `<strong>Validation Error:</strong> An unexpected error occurred: ${e.message}.`, lineNumber: 'N/A' });
    } finally {
        displayValidationResults(errors);
    }
	 return errors; // <-- ADD THIS LINE
}
			
            /**
             * Updates the enabled/disabled state of the undo and redo buttons.
             */
            function updateUndoRedoButtons() {
                // Can undo if there's more than the initial state in the stack.
                undoBtn.disabled = undoStack.length <= 1;
                redoBtn.disabled = redoStack.length === 0;
            }

            /**
             * Records a snapshot of the current editor content to the undo stack.
             * @param {string} content - The editor content to save.
             */
            function recordState(content) {
                // Don't record a new state if we are in the middle of an undo/redo action.
                if (isUndoingOrRedoing) return;

                // A new action clears the redo stack.
                redoStack.length = 0;

                // Avoid storing identical consecutive states.
                if (undoStack.length > 0 && undoStack[undoStack.length - 1] === content) {
                    return;
                }

                undoStack.push(content);

                // Enforce a memory limit on the undo history.
                if (undoStack.length > UNDO_LIMIT) {
                    undoStack.shift(); // Remove the oldest state.
                }

                updateUndoRedoButtons();
            }
            // --- End Undo/Redo Manager ---

            // --- Undo/Redo Event Listeners ---
            undoBtn.addEventListener('click', () => {
                if (undoStack.length > 1) {
                    isUndoingOrRedoing = true;

                    // Move the current state to the redo stack.
                    const currentState = undoStack.pop();
                    redoStack.push(currentState);

                    // Get the previous state from the undo stack and load it.
                    const prevState = undoStack[undoStack.length - 1];
                    monacoEditorInstance.setValue(prevState);

                    // IMPORTANT: We use a timeout to reset the flag *after* Monaco's
                    // change event has fired, preventing a feedback loop.
                    setTimeout(() => {
                        isUndoingOrRedoing = false;
                        updateUndoRedoButtons();
                    }, 10);
                }
            });

            redoBtn.addEventListener('click', () => {
                if (redoStack.length > 0) {
                    isUndoingOrRedoing = true;

                    // Pop the state you want to restore from the redo stack.
                    const stateToRestore = redoStack.pop();

                    // Push this restored state back onto the undo stack, as it is now the "current" state.
                    undoStack.push(stateToRestore);

                    // Apply this state to the editor.
                    monacoEditorInstance.setValue(stateToRestore);

                    // Use a timeout to reset the flag *after* Monaco's change event has fired.
                    setTimeout(() => {
                        isUndoingOrRedoing = false;
                        updateUndoRedoButtons();
                    }, 10);
                }
            });
            // --- End Undo/Redo Event Listeners ---

            /**
             * Replaces all forms of non-breaking spaces with a single, unique placeholder.
             * @param {string} htmlString - The HTML string to process.
             * @returns {string} The HTML string with NBSP replaced by placeholders.
             */
            function applyNBSPPlaceholders(htmlString) {
                let processedString = htmlString;
                processedString = processedString.replace(/&nbsp;|&#160;|\u00A0/g, NBSP_PLACEHOLDER);
                return processedString;
            }

            /**
             * Reverts the unique placeholder back to the numeric HTML entity for non-breaking space.
             * @param {string} htmlString - The HTML string with NBSP placeholders.
             * @returns {string} The HTML string with original NBSP entities restored.
             */
            function revertNBSPPlaceholders(htmlString) {
                let processedString = htmlString;
                processedString = processedString.replace(new RegExp(NBSP_PLACEHOLDER, 'g'), '&#160;');
                return processedString;
            }

            /**
             * Encodes a string to Base64.
             * @param {string} str The string to encode.
             * @returns {string} The Base64 encoded string.
             */
            function encodeBase64(str) {
                return btoa(unescape(encodeURIComponent(str)));
            }

            /**
             * Decodes a Base64 string.
             * @param {string} str The Base64 string to decode.
             * @returns {string} The decoded string.
             */
            function decodeBase64(str) {
                return decodeURIComponent(escape(atob(str)));
            }

            /**
             * Protects all data- attributes by Base64 encoding their values and replacing them with a temporary attribute.
             * This function operates purely on the HTML string using regex to avoid DOM parsing issues with complex attribute values.
             * @param {string} htmlString - The HTML content to process.
             * @returns {string} The HTML with protected data- attributes.
             */
            function protectDataAttributes(htmlString) {
                // Regex to find any data- attribute.
                // Captures the full attribute name (e.g., "data-toggle") in group 1, and the value in group 2.
                const regex = /(data-[a-zA-Z0-9-]+)="([^"]*)"/g;
                return htmlString.replace(regex, (match, attrName, value) => {
                    const encodedValue = encodeBase64(value);
                    // Return a temporary attribute that stores the original attribute name and the encoded value.
                    // We use a distinct prefix and include the original attribute name for later restoration.
                    return `data-temp-protected-${attrName}="${encodedValue}"`;
                });
            }

            /**
             * Restores protected data- attributes by Base64 decoding their values and replacing them back.
             * The decoded value's internal double quotes are explicitly re-escaped as &quot; to prevent corruption during later DOM operations.
             * This function operates purely on the HTML string using regex.
             * @param {string} htmlString - The HTML content to process.
             * @returns {string} The HTML with original data- attributes restored.
             */
            function restoreDataAttributes(htmlString) {
                // Regex to find the temporary protected data- attributes.
                // Captures the original attribute name (e.g., "data-toggle") in group 1, and the encoded value in group 2.
                const regex = /data-temp-protected-(data-[a-zA-Z0-9-]+)="([^"]*)"/g;
                return htmlString.replace(regex, (match, originalAttrName, encodedValue) => {
                    try {
                        let decodedValue = decodeBase64(encodedValue);
                        // Ensure literal double quotes and numeric double quote entities are converted to &quot;
                        // This is crucial to prevent re-escaping of the ampersand in &quot;
                        let safeValue = decodedValue.replace(/"/g, '&quot;');
                        safeValue = safeValue.replace(/&#34;/g, '&quot;');

                        // Restore the original data attribute with the safely escaped value.
                        return `${originalAttrName}="${safeValue}"`;
                    } catch (e) {
                        console.error("Error decoding or re-escaping Base64 data-attribute:", e);
                        // If decoding/re-escaping fails, remove the attribute to prevent malformed HTML.
                        return '';
                    }
                });
            }


            /**
             * Decodes HTML entities within a string to their actual Unicode characters.
             * Uses a temporary textarea element for reliable decoding.
             * @param {string} html - The HTML string containing entities.
             * @returns {string} The HTML string with entities decoded.
             */
            function decodeHtmlEntities(html) {
                const textarea = document.createElement('textarea');
                textarea.innerHTML = html; // Browser decodes entities when setting innerHTML
                return textarea.value; // Retrieving value gives the decoded string
            }

            /**
             * Cleans HTML content for display in HugeRTE.
             * This function is specifically for preparing content *before* setting it to the rich text editor.
             * It decodes HTML entities to ensure they render correctly in the visual editor.
             * @param {string} content - The HTML content to clean.
             * @returns {string} The cleaned HTML content.
             */
            function cleanHtmlForRichTextDisplay(content) {
                // Ensure content passed to rich text editor is also decoded
                return decodeHtmlEntities(content);
            }

            /**
             * Applies URL cleaning to HTML content.
             * Converts specific absolute URLs to relative paths and removes target/rel attributes from <a> tags.
             * Also removes <a> tags that ONLY contain a name attribute (i.e., no href).
             * @param {string} htmlString - The HTML content to clean.
             * @returns {string} The cleaned HTML content.
             */
            function applyUrlCleaning(htmlString) {
                const parser = new DOMParser(); // Create a new parser instance
                const tempDiv = parser.parseFromString(htmlString, 'text/html').body; // Parse string into a temporary DOM body

                const urlMappings = [{
                        old: 'https://canada-preview.adobecqms.net/en/treasury-board-secretariat',
                        new: '/content/canadasite/en/treasury-board-secretariat'
                    },
                    {
                        old: 'https://canada-preview.adobecqms.net/fr/secretariat-conseil-tresor',
                        new: '/content/canadasite/fr/secretariat-conseil-tresor'
                    },
                    {
                        old: 'https://canada-preview.adobecqms.net/en/government',
                        new: '/content/canadasite/en/government'
                    },
                    {
                        old: 'https://canada-preview.adobecqms.net/fr/gouvernement',
                        new: '/content/canadasite/fr/gouvernement'
                    },
                    {
                        old: 'https://www.canada.ca/en/treasury-board-secretariat',
                        new: '/content/canadasite/en/treasury-board-secretariat'
                    },
                    {
                        old: 'https://www.canada.ca/fr/secretariat-conseil-tresor',
                        new: '/content/canadasite/fr/secretaria-conseil-tresor'
                    },
                    {
                        old: 'https://www.canada.ca/en/government',
                        new: '/content/canadasite/en/government'
                    },
                    {
                        old: 'https://www.canada.ca/fr/gouvernement',
                        new: '/content/canadasite/fr/gouvernement'
                    }
                ];

                const prependPatterns = [
                    '/en/treasury-board-secretariat', 'en/treasury-board-secretariat',
                    '/fr/secretariat-conseil-tresor', 'fr/secretariat-conseil-tresor',
                    '/en/government', 'en/government',
                    '/fr/gouvernement', 'fr/gouvernement'
                ];

                const aElements = tempDiv.querySelectorAll('a');
                aElements.forEach(a => {
                    let href = a.getAttribute('href');
                    const name = a.getAttribute('name');

                    // Case 1: Remove <a> tags that ONLY contain a name attribute (no href)
                    if (name && !href) {
                        const parent = a.parentNode;
                        if (parent) {
                            while (a.firstChild) {
                                parent.insertBefore(a.firstChild, a);
                            }
                            parent.removeChild(a);
                        }
                        return; // Skip further processing for this <a> tag
                    }

                    // Case 2: Process <a> tags with href
                    if (href) {
                        // Handle Outlook Safelinks
                        if (href.startsWith('https://can01.safelinks.protection.outlook.com')) {
                            try {
                                const urlObj = new URL(href);
                                const actualUrlParam = urlObj.searchParams.get('url');
                                if (actualUrlParam) {
                                    // Decode the actual URL parameter to get the clean link
                                    href = decodeURIComponent(actualUrlParam);
                                    a.setAttribute('href', href);
                                }
                            } catch (e) {
                                console.error("Error parsing Outlook Safelink URL:", e);
                                // Fallback: If parsing fails, keep the original safelink or remove it
                                // For now, we'll just keep the original href if parsing fails.
                            }
                        }

                        // Rule: Prepend /content/canadasite to specific relative links
                        let prepended = false;
                        for (const pattern of prependPatterns) {
                            if (href.startsWith(pattern)) {
                                if (href.startsWith('/')) {
                                    href = '/content/canadasite' + href;
                                } else {
                                    href = '/content/canadasite/' + href;
                                }
                                a.setAttribute('href', href);
                                prepended = true;
                                break; // Stop after the first match
                            }
                        }

                        // If already prepended, skip other URL conversions for this link
                        if (prepended) {
                            // Remove target attribute
                            if (a.hasAttribute('target')) {
                                a.removeAttribute('target');
                            }

                            // Remove rel attribute
                            if (a.hasAttribute('rel')) {
                                a.removeAttribute('rel');
                            }
                            return;
                        }

                        // Specific handling for "/content/canadasite" or "/content/dam" links
                        if (href.includes('/content/canadasite') || href.includes('/content/dam')) {
                            const contentPath = href.includes('/content/canadasite') ? '/content/canadasite' : '/content/dam';
                            const contentIndex = href.indexOf(contentPath);
                            if (contentIndex !== 0) {
                                href = href.substring(contentIndex);
                            }
                            a.setAttribute('href', href);
                        } else {
                            // Convert other URLs using existing mappings
                            for (const mapping of urlMappings) {
                                if (href.startsWith(mapping.old)) {
                                    href = href.replace(mapping.old, mapping.new);
                                    a.setAttribute('href', href);
                                    break; // Stop after the first match
                                }
                            }
                        }
                    }

                    // Remove target attribute
                    if (a.hasAttribute('target')) {
                        a.removeAttribute('target');
                    }

                    // Remove rel attribute
                    if (a.hasAttribute('rel')) {
                        a.removeAttribute('rel');
                    }
                });

                // NEW: Handle <img> tags with src attributes containing "/content/dam"
                const imgElements = tempDiv.querySelectorAll('img');
                imgElements.forEach(img => {
                    let src = img.getAttribute('src');
                    if (src && src.includes('/content/dam')) {
                        const contentDamIndex = src.indexOf('/content/dam');
                        if (contentDamIndex !== 0) { // If it doesn't start with /content/dam
                            src = src.substring(contentDamIndex); // Adjust to start from /content/dam
                            img.setAttribute('src', src);
                        }
                    }
                    // Also remove target and rel attributes from img tags for consistency, though less common
                    if (img.hasAttribute('target')) {
                        img.removeAttribute('target');
                    }
                    if (img.hasAttribute('rel')) {
                        img.removeAttribute('rel');
                    }
                });

                return tempDiv.innerHTML;
            }

            /**
             * Applies auto-spacing and cleans multiple <br> tags in HTML content.
             * Includes new rules for non-breaking spaces and empty tag removal/replacement.
             * Also trims leading/trailing spaces and non-breaking spaces within <p>, heading, and <li> tags.
             * @param {string} htmlString - The HTML content to clean.
             * @returns {string} The cleaned HTML content.
             */
            function applyAutoSpacing(htmlString) {
                const parser = new DOMParser();
                let doc = parser.parseFromString(htmlString, 'text/html');
                const body = doc.body;

                // 1. Unwrap <div> and <span> elements if they have no attributes.
                // Note: Section elements are now explicitly NOT unwrapped here.
                const elementsToUnwrap = Array.from(body.querySelectorAll('div, span'));
                elementsToUnwrap.forEach(element => {
                    // Only unwrap if element has NO attributes AT ALL
                    if (element.attributes.length === 0) {
                        const parent = element.parentNode;
                        if (parent) {
                            while (element.firstChild) {
                                parent.insertBefore(element.firstChild, element);
                            }
                            parent.removeChild(element);
                        }
                    }
                });

                // 2. Handle <span style="mso-spacerun: yes"> tags (existing logic, still relevant)
                const spacerunSpans = body.querySelectorAll('span[style*="mso-spacerun: yes"]');
                spacerunSpans.forEach(span => {
                    const parent = span.parentNode;
                    if (parent) {
                        // Check if the span's text content contains a normal space
                        if (span.textContent.includes(' ')) {
                            // Replace the span with a single normal space
                            parent.replaceChild(doc.createTextNode(' '), span);
                        } else {
                            // Remove the span entirely if it's not containing a normal space
                            parent.removeChild(span);
                        }
                    }
                });

                // NEW: Remove empty text nodes (representing empty lines/excess whitespace)
                const walker = doc.createTreeWalker(
                    body,
                    NodeFilter.SHOW_TEXT, {
                        acceptNode: function(node) {
                            const txt = node.nodeValue;
                            // Only remove if it’s pure whitespace AND more than a single space (or contains newline/tab)
                            if (txt.trim() === '' && (txt.length > 1 || /[\r\n\t]/.test(txt))) {
                                return NodeFilter.FILTER_ACCEPT;
                            }
                            return NodeFilter.FILTER_REJECT;
                        }
                    },
                    false
                );

                const nodesToRemove = [];
                let currentNode;
                while (currentNode = walker.nextNode()) {
                    nodesToRemove.push(currentNode);
                }

                nodesToRemove.forEach(node => {
                    if (node.parentNode) {
                        node.parentNode.removeChild(node);
                    }
                });

                // Re-serialize to string to apply regex-based cleaning
                let cleanedHtml = body.innerHTML;

                // 3. Condense multiple non-breaking spaces (&#160; or its Unicode char)
                // Replace multiple &#160; sequences (numeric or named entity)
                cleanedHtml = cleanedHtml.replace(/(?:&#160;|\u00A0|&nbsp;){2,}/gi, '&#160;');

                // 4. Clean non-breaking spaces with normal spaces to their left/right
                // Replace sequences like ' &#160;' with '&#160;'
                cleanedHtml = cleanedHtml.replace(/\s+(&#160;|\u00A0|&nbsp;)/gi, '&#160;');
                // Replace sequences like '&#160; ' with '&#160;'
                cleanedHtml = cleanedHtml.replace(/(&#160;|\u00A0|&nbsp;)\s+/gi, '&#160;');


                // 5. Replace sequences of two or more <br> tags (with optional whitespace) with </p><p> (existing logic)
                cleanedHtml = cleanedHtml.replace(/(<br\s*\/?>\s*){2,}/gi, '</p><p>');

                // 6. Completely remove <br clear="all"> and <br clear="ALL">
                cleanedHtml = cleanedHtml.replace(/<br\s+clear=["']?(all|ALL)["']?\s*\/?>/gi, '');


                // Re-parse to work with DOM for empty tag rules and other final cleanups
                doc.body.innerHTML = cleanedHtml;
                const finalBody = doc.body; // Use final body reference after re-parsing

                // 7. Remove/Replace empty tags
                // Include <section> in elements to check for emptiness now as well
                const elementsToCheckForEmptiness = Array.from(finalBody.querySelectorAll('p, li, div, span, strong, em, u, b, i, section'));

                // Process in reverse to avoid issues with DOM changes affecting iteration
                for (let i = elementsToCheckForEmptiness.length - 1; i >= 0; i--) {
                    const element = elementsToCheckForEmptiness[i];
                    const tagName = element.tagName.toLowerCase();
                    const trimmedContent = element.innerHTML.trim();
                    const containsOnlyNBSP = (trimmedContent === '&#160;' || trimmedContent === '&nbsp;' || trimmedContent === '\u00A0');
                    const containsOnlySpace = (trimmedContent === ' ');

                    // Rule for <p> tags: remove only if outside a table
                    if (tagName === 'p') {
                        const isInsideTable = element.closest('table');
                        if (!isInsideTable && (trimmedContent === '' || containsOnlyNBSP)) {
                            if (element.parentNode) {
                                element.parentNode.removeChild(element);
                            }
                        } else if (!isInsideTable && containsOnlySpace) {
                            // For <p> with single space, replace with text node of space
                            if (element.parentNode) {
                                element.parentNode.replaceChild(doc.createTextNode(' '), element);
                            }
                        }
                    }
                    // Rules for other tags: remove if empty or contains only NBSP, replace with space if contains only space
                    else {
                        // IMPORTANT CHANGE: Exclude div, span, and section elements with *any* attributes
                        // from being removed/replaced by emptiness logic.
                        // This means `div`, `span`, and `section` tags with attributes are preserved.
                        if (['div', 'span', 'section'].includes(tagName) && element.attributes.length > 0) {
                            continue; // Skip this element, keep it intact
                        }
                        if (element.textContent === ' ' && ['strong', 'em', 'u', 'b', 'i'].includes(tagName)) {
                            element.parentNode.replaceChild(
                                doc.createTextNode(' '),
                                element
                            );
                            continue;
                        }
                        if (trimmedContent === '' || containsOnlyNBSP) {
                            if (element.parentNode) {
                                element.parentNode.removeChild(element);
                            }
                        } else if (containsOnlySpace) {
                            if (element.parentNode) {
                                element.parentNode.replaceChild(doc.createTextNode(' '), element);
                            }
                        }
                    }
                }

                // --- New: Trim leading/trailing spaces and non-breaking spaces for <p>, heading, and <li> tags ---
                const elementsToTrim = finalBody.querySelectorAll('p, h1, h2, h3, h4, h5, h6, li');
                elementsToTrim.forEach(element => {
                    let currentHtml = element.innerHTML;

                    // Regex to match leading/trailing spaces, tabs, newlines, and &nbsp; entities
                    // (?:&nbsp;|\s) ensures both &#160; and literal spaces are covered.
                    // It's important to use &nbsp; in regex for string manipulation, as innerHTML might return it as such.
                    currentHtml = currentHtml.replace(/^(?:&nbsp;|\s|&#160;|\u00A0)+/, ''); // Remove leading
                    currentHtml = currentHtml.replace(/(?:&nbsp;|\s|&#160;|\u00A0)+$/, ''); // Remove trailing

                    element.innerHTML = currentHtml;
                });
                // --- End of New Trim Logic ---

                return finalBody.innerHTML;
            }

            /**
             * Converts single <br> tags into paragraph breaks (</p><p>) while ignoring <br> tags within tables.
             * This simplified version does not attempt to preserve inline element nesting across the break.
             * @param {string} htmlString - The HTML content to process.
             * @returns {string} The processed HTML content.
             */
            function applyCleanSingleBreaks(htmlString) {
                const parser = new DOMParser();
                const doc = parser.parseFromString(htmlString, 'text/html');
                const brElements = Array.from(doc.querySelectorAll('br'));

                // Process elements in reverse order to avoid issues with DOM manipulation affecting iteration
                for (let i = brElements.length - 1; i >= 0; i--) {
                    const br = brElements[i];

                    // Check if br still exists in the DOM and has a parent
                    if (!br || !br.parentNode) {
                        continue;
                    }

                    let currentParent = br.parentNode;
                    let isInsideTable = false;
                    // Traverse up the DOM tree to check if the <br> is inside a <table>
                    while (currentParent && currentParent !== doc.body) {
                        if (currentParent.tagName && currentParent.tagName.toLowerCase() === 'table') {
                            isInsideTable = true;
                            break;
                        }
                        currentParent = currentParent.parentNode;
                    }

                    if (isInsideTable) {
                        continue; // Skip this <br> if it's inside a table
                    }

                    // Create a new paragraph element
                    const newParagraph = doc.createElement('p');

                    // Move all siblings after the <br> into the new paragraph
                    while (br.nextSibling) {
                        newParagraph.appendChild(br.nextSibling);
                    }

                    // Insert the new paragraph after the original parent of the <br>
                    // This effectively closes the current paragraph and starts a new one.
                    if (br.parentNode.parentNode) {
                        br.parentNode.parentNode.insertBefore(newParagraph, br.parentNode.nextSibling);
                    } else {
                        // Fallback for very unusual structures where parentNode.parentNode is null
                        doc.body.appendChild(newParagraph);
                    }

                    // Remove the <br> itself
                    br.parentNode.removeChild(br);
                }

                return doc.body.innerHTML;
            }

            /**
             * Unwraps <p> tags within <td> or <th> elements, moving their content directly into the cell.
             * @param {string} htmlString - The HTML content to clean.
             * @returns {string} The cleaned HTML content.
             */
            function applyCleanPTagsInTables(htmlString) {
                const parser = new DOMParser();
                const doc = parser.parseFromString(htmlString, 'text/html');

                // Select all <p> tags that are direct or indirect children of <td> or <th>
                const pElementsInCells = doc.querySelectorAll('td p, th p');

                // Iterate in reverse to avoid issues when modifying the DOM while looping
                for (let i = pElementsInCells.length - 1; i >= 0; i--) {
                    const pTag = pElementsInCells[i];
                    const parentCell = pTag.parentNode; // This should be a td or th (or an element within them)

                    // Ensure the direct parent is indeed a td or th, or that it's nested within one.
                    // We want to unwrap <p> tags only if they are logically "inside" a cell.
                    const closestCell = pTag.closest('td, th');

                    if (closestCell) {
                        // Move all children of the <p> tag to its immediate parent
                        while (pTag.firstChild) {
                            parentCell.insertBefore(pTag.firstChild, pTag);
                        }
                        // Remove the now empty <p> tag
                        parentCell.removeChild(pTag);
                    }
                }
                return doc.body.innerHTML;
            }


            /**
             * Removes <p>&nbsp;</p> tags that are not within <table> or <li> tags.
             * @param {string} htmlString - The HTML content to clean.
             * @returns {string} The cleaned HTML content.
             */
            function removeEmptyParagraphsOutsideTablesAndLists(htmlString) {
                const parser = new DOMParser();
                const doc = doc.parseFromString(htmlString, 'text/html');
                const paragraphs = doc.querySelectorAll('p');

                for (let i = paragraphs.length - 1; i >= 0; i--) {
                    const p = paragraphs[i];
                    // Check if the paragraph contains only &nbsp; or is effectively empty after decoding
                    // After decodeHtmlEntities, &nbsp; becomes a non-breaking space character (\u00A0)
                    const containsOnlyNBSP = p.innerHTML.trim() === '&nbsp;' || p.innerHTML.trim() === '\u00A0';

                    if (containsOnlyNBSP) {
                        let parent = p.parentElement;
                        let isInsideTableOrList = false;
                        while (parent) {
                            if (parent.tagName === 'TABLE' || parent.tagName === 'LI') {
                                isInsideTableOrList = true;
                                break;
                            }
                            parent = parent.parentElement;
                        }

                        if (!isInsideTableOrList) {
                            p.parentNode.removeChild(p);
                        }
                    }
                }
                return doc.body.innerHTML;
            }

            /**
             * Removes empty <p> tags and <p> tags that contain only a single non-breaking space,
             * specifically if they have a class starting with "Mso" and are not within a table.
             * @param {string} htmlString - The HTML content to clean.
             * @returns {string} The cleaned HTML content.
             */
            function removeEmptyParagraphs(htmlString) {
                const parser = new DOMParser();
                const doc = parser.parseFromString(htmlString, 'text/html');
                const paragraphs = doc.querySelectorAll('p');

                for (let i = paragraphs.length - 1; i >= 0; i--) {
                    const p = paragraphs[i];

                    // Condition 1: Check if the paragraph is empty or contains only a non-breaking space
                    const trimmedContent = p.innerHTML.trim();
                    const isEmptyOrNBSP = trimmedContent === '' || trimmedContent === '&nbsp;' || trimmedContent === '\u00A0';

                    // Condition 2: Check if the paragraph has a class attribute starting with "Mso"
                    const hasMsoClass = p.classList.length > 0 && p.className.startsWith('Mso');

                    // Condition 3: Check if the paragraph is NOT within a table
                    const isInsideTable = p.closest('table');

                    if (isEmptyOrNBSP && hasMsoClass && !isInsideTable) {
                        if (p.parentNode) {
                            p.parentNode.removeChild(p);
                        }
                    }
                }
                return doc.body.innerHTML;
            }

            /**
             * Removes inline width and height styles from all elements in the HTML content.
             * @param {string} htmlString - The HTML content to clean.
             * @returns {string} The cleaned HTML content.
             */
            function removeInlineWidthHeightStyles(htmlString) {
                const parser = new DOMParser();
                const doc = parser.parseFromString(htmlString, 'text/html');
                const allElements = doc.querySelectorAll('*');

                allElements.forEach(element => {
                    if (element.hasAttribute('style')) {
                        let style = element.getAttribute('style');
                        // Remove width: ...; and height: ...;
                        style = style.replace(/width:\s*[^;]+;?/gi, '');
                        style = style.replace(/height:\s*[^;]+;?/gi, '');
                        // Clean up extra spaces or semicolons
                        style = style.replace(/;{2,}/g, ';').trim();
                        if (style.endsWith(';')) {
                            style = style.slice(0, -1);
                        }

                        if (style) {
                            element.setAttribute('style', style);
                        } else {
                            element.removeAttribute('style');
                        }
                    }
                });
                return doc.body.innerHTML;
            }

            /**
             * Converts common character entities and named entities to their numeric HTML entity equivalents.
             * This function operates on an HTML string, parsing it to a temporary DOM, modifying text nodes,
             * and then serializing it back to a string, ensuring numeric entities are preserved.
             * @param {string} htmlString - The HTML content to process.
             * @returns {string} The processed HTML string with numeric entities.
             */
            function convertAllEntitiesToNumeric(htmlString) {
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = htmlString; // This parses entities to characters

                const walker = document.createTreeWalker(
                    tempDiv,
                    NodeFilter.SHOW_TEXT, {
                        acceptNode: function(textNode) {
                            let parent = textNode.parentNode;
                            while (parent) {
                                const tagName = parent.tagName ? parent.tagName.toLowerCase() : '';
                                if (tagName === 'script' || tagName === 'style' || tagName === 'time') {
                                    return NodeFilter.FILTER_REJECT;
                                }
                                parent = parent.parentNode;
                            }
                            return NodeFilter.FILTER_ACCEPT;
                        }
                    },
                    false

                );

                let currentNode;
                const textNodesToProcess = [];
                while (currentNode = walker.nextNode()) {
                    textNodesToProcess.push(currentNode);
                }

                textNodesToProcess.forEach(textNode => {
                    let text = textNode.nodeValue;
                    // Replace specific named entities/characters with their numeric character references
                    text = text.replace(/’/g, '&#8217;'); // literal ’
                    text = text.replace(/&rsquo;/g, '&#8217;'); // &rsquo;
                    text = text.replace(/“/g, '&#8220;'); // literal “
                    text = text.replace(/&ldquo;/g, '&#8220;'); // &ldquo;
                    text = text.replace(/”/g, '&#8221;'); // literal ”
                    text = text.replace(/&rdquo;/g, '&#8221;'); // &rdquo;
                    text = text.replace(/«/g, '&#171;'); // literal «
                    text = text.replace(/&laquo;/g, '&#171;'); // &laquo;
                    text = text.replace(/»/g, '&#187;'); // literal »
                    text = text.replace(/&raquo;/g, '&#187;'); // &raquo;
                    text = text.replace(/\u00A0/g, '&#160;'); // This converts literal NBSP char to numeric entity
                    text = text.replace(/&nbsp;/g, '&#160;'); // This handles named NBSP entity to numeric

                    textNode.nodeValue = text;
                });

                let processedHtml = tempDiv.innerHTML; // This re-serializes characters to entities

                // Final string-based replacements to ensure numeric entities are explicitly present
                // This is a safeguard against browser's innerHTML serialization re-converting entities.
                processedHtml = processedHtml.replace(/&nbsp;/g, '&#160;');
                processedHtml = processedHtml.replace(/&rsquo;/g, '&#8217;');
                processedHtml = processedHtml.replace(/&ldquo;/g, '&#8220;');
                processedHtml = processedHtml.replace(/&rdquo;/g, '&#8221;');
                processedHtml = processedHtml.replace(/&laquo;/g, '&#171;');
                processedHtml = processedHtml.replace(/&raquo;/g, '&#187;');

                // Handle double encoding if it occurs (e.g., &amp;#160; -> &#160;)
                processedHtml = processedHtml.replace(/&amp;#(\d+);/g, '&#$1;');

                return processedHtml;
            }

            /**
             * Recursively cleans and preserves only specified HTML content from a source DOM node.
             * Disallowed tags are unwrapped, preserving their allowed children.
             * This function is used for both footnote content and general MSO problematic content.
             * @param {HTMLElement} sourceNode - The DOM node whose children are to be filtered.
             * @param {Document} doc - The document object to create new elements.
             * @returns {string} The HTML string containing only the preserved content.
             */
            function cleanAndPreserveAllowedContent(sourceNode, doc) {
                let tempContainer = doc.createElement('div');

                Array.from(sourceNode.childNodes).forEach(child => {
                    if (child.nodeType === Node.TEXT_NODE) {
                        // Always preserve text nodes (including character entities which are parsed into text nodes)
                        tempContainer.appendChild(child.cloneNode(true));
                    } else if (child.nodeType === Node.ELEMENT_NODE) {
                        const tagName = child.tagName.toLowerCase();

                        // Function to check if class or id contains disallowed patterns (case-sensitive)
                        const containsDisallowedPattern = (element) => {
                            const elemClassAttr = element.getAttribute('class');
                            if (elemClassAttr) {
                                const classes = elemClassAttr.split(/\s+/);
                                for (const cls of classes) {
                                    if (cls.includes('Mso') || cls.includes('Word') || cls.includes('Style') || cls.includes('DocumentTitle') || cls.includes('Heading') || cls.includes('BCX0')) {
                                        return true;
                                    }
                                }
                            }
                            const elemIdAttr = element.getAttribute('id');
                            if (elemIdAttr) {
                                if (elemIdAttr.includes('Mso') || elemIdAttr.includes('Word') || elemIdAttr.includes('BCX0')) {
                                    return true;
                                }
                            }
                            return false;
                        };

                        const alwaysPreservedTags = [
                            'p', 'section', 'blockquote', 'article', 'ol', 'ul', 'li',
                            'figure', 'caption', 'details', 'summary',
                            'strong', 'u', 'em', 'i', 'b', 'br', 'mark', 'sup', 'sub', 'img',
                            'h1', 'h2', 'h3', 'h4', 'h5', 'h6' // Added heading tags
                        ];

                        const tableTags = ['table', 'thead', 'tbody', 'tfoot', 'tr', 'th', 'td'];

                        if (alwaysPreservedTags.includes(tagName) || tableTags.includes(tagName)) {
                            // These tags are always preserved, recursively clean their content
                            const clonedChild = child.cloneNode(false);
                            clonedChild.innerHTML = cleanAndPreserveAllowedContent(child, doc);
                            tempContainer.appendChild(clonedChild);
                        } else if (tagName === 'a' && child.hasAttribute('href')) {
                            // <a> tags only if they have an href
                            const clonedChild = child.cloneNode(false);
                            clonedChild.innerHTML = cleanAndPreserveAllowedContent(child, doc); // Still clean content inside
                            tempContainer.appendChild(clonedChild);
                        } else if (tagName === 'div' || tagName === 'span') {
                            // <div>, <span>, <ins> ONLY if they have a class or ID that DON'T contain "Mso" or "Word" or "BCX0"
                            if ((child.hasAttribute('class') || child.hasAttribute('id')) && !containsDisallowedPattern(child)) {
                                const clonedChild = child.cloneNode(false);
                                clonedChild.innerHTML = cleanAndPreserveAllowedContent(child, doc);
                                tempContainer.appendChild(clonedChild);
                            } else {
                                // Unwrap if it doesn't meet the criteria
                                const unwrappedContentHtml = cleanAndPreserveAllowedContent(child, doc);
                                const tempUnwrapDiv = doc.createElement('div'); // Temporary div to parse HTML string
                                tempUnwrapDiv.innerHTML = unwrappedContentHtml;
                                while (tempUnwrapDiv.firstChild) {
                                    tempContainer.appendChild(tempUnwrapDiv.firstChild);
                                }
                            }
                        } else {
                            // For any other element not explicitly allowed, unwrap its content
                            const unwrappedContentHtml = cleanAndPreserveAllowedContent(child, doc);
                            const tempUnwrapDiv = doc.createElement('div'); // Temporary div to parse HTML string
                            tempUnwrapDiv.innerHTML = unwrappedContentHtml;
                            while (tempUnwrapDiv.firstChild) {
                                tempContainer.appendChild(tempUnwrapDiv.firstChild);
                            }
                        }
                    }
                });
                return tempContainer.innerHTML;
            }

            /**
             * Processes <p> or heading tags with "MsoListParagraph" class or specific style attributes,
             * converting them to <ul><li> structures.
             * @param {string} htmlString - The HTML content to clean.
             * @returns {string} The cleaned HTML content.
             */
            function applyCleanLists(htmlString) {
                const parser = new DOMParser();
                const doc = parser.parseFromString(htmlString, 'text/html');
                const body = doc.body;
                // --- NEW LOGIC: Stripping comment and endnote anchors specifically from headings ---
                // Select elements with style containing "mso-element: comment-list" or "mso-element: endnote-list"
                // that are direct children or descendants of a heading tag.
                // This is more robust as it finds them even if they are nested within a span inside a heading.
                doc.querySelectorAll('h1 [style*="mso-element: comment-list"], h1 [style*="mso-element: endnote-list"], ' +
                    'h2 [style*="mso-element: comment-list"], h2 [style*="mso-element: endnote-list"], ' +
                    'h3 [style*="mso-element: comment-list"], h3 [style*="mso-element: endnote-list"], ' +
                    'h4 [style*="mso-element: comment-list"], h4 [style*="mso-element: endnote-list"], ' +
                    'h5 [style*="mso-element: comment-list"], h5 [style*="mso-element: endnote-list"], ' +
                    'h6 [style*="mso-element: comment-list"], h6 [style*="mso-element: endnote-list"]').forEach(element => {
                    if (element.parentNode) {
                        element.parentNode.removeChild(element);
                    }
                });

                // Select <a> elements with href containing "#_msocom" or "#_edn" that are direct children or descendants of a heading tag.
                doc.querySelectorAll('h1 a[href*="#_msocom"], h1 a[href*="#_edn"], ' +
                    'h2 a[href*="#_msocom"], h2 a[href*="#_edn"], ' +
                    'h3 a[href*="#_msocom"], h3 a[href*="#_edn"], ' +
                    'h4 a[href*="#_msocom"], h4 a[href*="#_edn"], ' +
                    'h5 a[href*="#_msocom"], h5 a[href*="#_edn"], ' +
                    'h6 a[href*="#_msocom"], h6 a[href*="#_edn"]').forEach(link => {
                    if (link.parentNode) {
                        link.parentNode.removeChild(link);
                    }
                });
                // --- END NEW LOGIC ---
                // ——— SPECIAL-CASE HEADINGS WITH MSO-LIST ———
                // Turn them back into plain headings with only their text
                doc.querySelectorAll(
                    'h1[style*="mso-list"],h2[style*="mso-list"],h3[style*="mso-list"],' +
                    'h4[style*="mso-list"],h5[style*="mso-list"],h6[style*="mso-list"]'
                ).forEach(h => {
                    const tag = h.tagName.toLowerCase();
                    // collapse whitespace so you don’t get accidental newlines/tabs
                    const text = h.textContent.trim().replace(/\s+/g, ' ');
                    const cleanH = doc.createElement(tag);
                    cleanH.textContent = text;
                    h.replaceWith(cleanH);
                });

                // Helper to get the level from style attribute for lists
                function getLevel(styleAttr) {
                    if (!styleAttr) return null;
                    const match = styleAttr.match(/level(\d+)/);
                    return match ? parseInt(match[1], 10) : null;
                }

                // Helper to extract allowed content for lists
                function extractAllowedContentForLists(sourceNode) {
                    let contentHtml = '';
                    const childrenToProcess = Array.from(sourceNode.childNodes);

                    childrenToProcess.forEach(child => {
                        if (child.nodeType === Node.ELEMENT_NODE && child.tagName.toLowerCase() === 'span' && child.hasAttribute('style') && child.getAttribute('style').includes('mso-list: Ignore')) {
                            return;
                        }

                        if (child.nodeType === Node.TEXT_NODE) {
                            contentHtml += child.nodeValue;
                        } else if (child.nodeType === Node.ELEMENT_NODE) {
                            const tagName = child.tagName.toLowerCase();
                            const hasClassOrId = child.hasAttribute('class') || child.hasAttribute('id');

                            // Use the containsDisallowedPattern from cleanAndPreserveAllowedContent for consistent MSO/Word/BCX0 checks
                            const containsDisallowedPattern = (element) => {
                                const elemClassAttr = element.getAttribute('class');
                                if (elemClassAttr) {
                                    const classes = elemClassAttr.split(/\s+/);
                                    for (const cls of classes) {
                                        if (cls.includes('Mso') || cls.includes('Word') || cls.includes('Style') || cls.includes('DocumentTitle') || cls.includes('Heading') || cls.includes('BCX0')) {
                                            return true;
                                        }
                                    }
                                }
                                const elemIdAttr = element.getAttribute('id');
                                if (elemIdAttr) {
                                    if (elemIdAttr.includes('Mso') || elemIdAttr.includes('Word') || elemIdAttr.includes('BCX0')) {
                                        return true;
                                    }
                                }
                                return false;
                            };

                            if (tagName === 'br' || tagName === 'strong' || tagName === 'a' || tagName === 'em' || tagName === 'u' || tagName === 'sup' || tagName === 'sub' || tagName === 'section' || tagName === 'ins') {
                                contentHtml += child.outerHTML;
                            } else if ((tagName === 'span' || tagName === 'div') && !containsDisallowedPattern(child)) {
                                const clonedChild = child.cloneNode(false);
                                // PASS THE ORIGINAL NODE INTO THE RECURSION, NOT THE EMPTY CLONE:
                                clonedChild.innerHTML = extractAllowedContentForLists(child);
                                contentHtml += clonedChild.outerHTML;
                            } else if (tagName === 'a' && child.hasAttribute('href')) { // Explicitly handle <a> with href
                                contentHtml += child.outerHTML;
                            } else {
                                contentHtml += extractAllowedContentForLists(child);
                            }
                        }
                    });
                    return contentHtml;
                }

                // Helper to determine list type
                function detectListType(element) {
                    const msoListIgnoreSpan = element.querySelector('span[style*="mso-list: Ignore"]');
                    if (msoListIgnoreSpan) {
                        const bulletText = msoListIgnoreSpan.textContent.trim();
                        if (/^\d+(\.\d+)+[\.\)]*$/.test(bulletText)) {
                            return 'complex-bullet';
                        }
                        if (/^[A-Za-z](\.\d+)+[\.\)]*$/.test(bulletText)) {
                            return 'complex-bullet';
                        }
                        if (/^\d+[\.\)]$/.test(bulletText)) {
                            return 'ordered-numeric';
                        }
                        if (/^[a-z][\.\)]$/.test(bulletText)) {
                            return 'ordered-alpha';
                        }
                    }
                    return 'unordered';
                }

                // Query for p AND heading tags
                const targetElements = Array.from(body.querySelectorAll('p, h1, h2, h3, h4, h5, h6'));
                const elementsToReplace = new Map(); // Maps old element to new list element
                const elementsToRemove = new Set(); // Elements that have been integrated into a list

                for (let i = 0; i < targetElements.length; i++) {
                    const element = targetElements[i];

                    if (elementsToRemove.has(element)) {
                        continue; // Skip if already processed and marked for removal
                    }

                    const tagName = element.tagName.toLowerCase();
                    const classList = Array.from(element.classList);
                    const styleAttr = element.getAttribute('style') || '';

                    // Condition 1: Check for existing MsoListParagraph classes
                    const isMsoListParagraphClass = classList.some(cls =>
                        cls === 'MsoListParagraphCxSpFirst' ||
                        cls === 'MsoListParagraphCxSpSpMiddle' ||
                        cls === 'MsoListParagraphCxSpLast' ||
                        cls === 'MsoListParagraph'
                    );

                    // Condition 2: Check for new rule: p or heading with no class OR class that DOES NOT contain "MsoList", AND style contains "mso-list"
                    const matchesNewRule =
                        (['p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6'].includes(tagName)) &&
                        (!element.hasAttribute('class') || !element.className.includes('MsoList')) &&
                        (styleAttr.includes('mso-list'));

                    // Combined condition for a list item
                    if (isMsoListParagraphClass || matchesNewRule) {
                        const level = getLevel(styleAttr);

                        // If it's identified as a list paragraph but no level is found,
                        // assume it's not a proper MSO list item and convert to MsoNormal or remove styling.
                        if (level === null) {
                            element.removeAttribute('class');
                            element.removeAttribute('style'); // Also remove style
                            element.classList.add('MsoNormal');
                            continue; // Skip further list processing for this element
                        }

                        const msoListIgnoreSpan = element.querySelector('span[style*="mso-list: Ignore"]');
                        let bulletTextToPrepend = '';
                        let listType = 'unordered';

                        if (msoListIgnoreSpan) {
                            bulletTextToPrepend = msoListIgnoreSpan.textContent.trim();
                            listType = detectListType(element);
                            msoListIgnoreSpan.parentNode.removeChild(msoListIgnoreSpan);
                        }

                        let newRootListElement;
                        if (listType === 'ordered-numeric') {
                            newRootListElement = doc.createElement('ol');
                        } else if (listType === 'ordered-alpha') {
                            newRootListElement = doc.createElement('ol');
                            newRootListElement.classList.add('lst-lwr-alph');
                        } else {
                            newRootListElement = doc.createElement('ul');
                        }

                        let currentListStack = [{
                            domElement: newRootListElement,
                            level: level
                        }];
                        let currentParentList = newRootListElement;

                        const li = doc.createElement('li');
                        let listItemContent = extractAllowedContentForLists(element);

                        if (listType === 'complex-bullet') {
                            li.innerHTML = bulletTextToPrepend + ' ' + listItemContent;
                        } else {
                            li.innerHTML = listItemContent;
                        }
                        currentParentList.appendChild(li);
                        elementsToReplace.set(element, newRootListElement); // Mark the first element of the sequence for replacement

                        // Remove class and style attributes from the processed element
                        element.removeAttribute('class');
                        element.removeAttribute('style');


                        // Process subsequent sibling elements that are part of the same list sequence
                        let nextSibling = element.nextElementSibling;
                        let currentSequenceIndex = i + 1; // Track index in original targetElements array

                        while (nextSibling && currentSequenceIndex < targetElements.length) {
                            const nextElement = targetElements[currentSequenceIndex]; // Get from original array
                            if (nextElement !== nextSibling) { // Ensure we are still processing actual next siblings
                                break;
                            }

                            const nextTagName = nextElement.tagName.toLowerCase();
                            const nextClassList = Array.from(nextElement.classList);
                            const nextStyleAttr = nextElement.getAttribute('style') || '';

                            const isNextMsoListParagraphClass = nextClassList.some(cls =>
                                cls === 'MsoListParagraphCxSpFirst' ||
                                cls === 'MsoListParagraphCxSpMiddle' ||
                                cls === 'MsoListParagraphCxSpLast' ||
                                cls === 'MsoListParagraph'
                            );
                            const nextMatchesNewRule =
                                (['p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6'].includes(nextTagName)) &&
                                (!nextElement.hasAttribute('class') || !nextElement.className.includes('MsoList')) &&
                                (nextStyleAttr.includes('mso-list'));

                            if (isNextMsoListParagraphClass || nextMatchesNewRule) {
                                const nextLevel = getLevel(nextStyleAttr);

                                // If next element is identified as list but has no level, break the sequence
                                if (nextLevel === null) {
                                    nextElement.removeAttribute('class');
                                    nextElement.removeAttribute('style');
                                    nextElement.classList.add('MsoNormal');
                                    break;
                                }

                                const nextMsoListIgnoreSpan = nextElement.querySelector('span[style*="mso-list: Ignore"]');
                                let nextBulletTextToPrepend = '';
                                let nextListType = 'unordered';

                                if (nextMsoListIgnoreSpan) {
                                    nextBulletTextToPrepend = nextMsoListIgnoreSpan.textContent.trim();
                                    nextListType = detectListType(nextElement);
                                    nextMsoListIgnoreSpan.parentNode.removeChild(nextMsoListIgnoreSpan);
                                }

                                // Adjust list nesting based on level
                                let currentDepth = currentListStack[currentListStack.length - 1].level;

                                if (nextLevel > currentDepth) {
                                    // Deeper level, create nested list
                                    let nestedListElement;
                                    if (nextListType === 'ordered-numeric') {
                                        nestedListElement = doc.createElement('ol');
                                    } else if (nextListType === 'ordered-alpha') {
                                        nestedListElement = doc.createElement('ol');
                                        nestedListElement.classList.add('lst-lwr-alph');
                                    } else {
                                        nestedListElement = doc.createElement('ul');
                                    }

                                    // Append to the last <li> of the current parent list
                                    let targetLi = currentParentList.lastElementChild;
                                    if (!targetLi || targetLi.tagName.toLowerCase() !== 'li') {
                                        // Should ideally not happen if structure is well-formed, but a fallback
                                        targetLi = doc.createElement('li');
                                        currentParentList.appendChild(targetLi);
                                    }
                                    targetLi.appendChild(nestedListElement);
                                    currentListStack.push({
                                        domElement: nestedListElement,
                                        level: nextLevel
                                    });
                                    currentParentList = nestedListElement;

                                } else if (nextLevel < currentDepth) {
                                    // Higher level, pop from stack until appropriate parent is found
                                    while (currentListStack.length > 1 && nextLevel <= currentListStack[currentListStack.length - 1].level) {
                                        currentListStack.pop();
                                    }
                                    currentParentList = currentListStack[currentListStack.length - 1].domElement;

                                    // If after popping, the next level is still greater than current parent's level,
                                    // it means an intermediate level was skipped, so create missing intermediate list(s).
                                    // This logic might need further refinement for complex cases but aims to prevent too-deep jumps.
                                    while (currentListStack.length < nextLevel) {
                                        let targetLi = currentParentList.lastElementChild;
                                        if (!targetLi || targetLi.tagName.toLowerCase() !== 'li') {
                                            targetLi = doc.createElement('li');
                                            currentParentList.appendChild(targetLi);
                                        }
                                        let newNestedList;
                                        if (currentListStack.length + 1 === nextLevel) { // Only create the *correct* type if this is the target level
                                            if (nextListType === 'ordered-numeric') {
                                                newNestedList = doc.createElement('ol');
                                            } else if (nextListType === 'ordered-alpha') {
                                                newNestedList = doc.createElement('ol');
                                                newNestedList.classList.add('lst-lwr-alph');
                                            } else {
                                                newNestedList = doc.createElement('ul');
                                            }
                                        } else { // Intermediate levels are always <ul>
                                            newNestedList = doc.createElement('ul');
                                        }
                                        targetLi.appendChild(newNestedList);
                                        currentListStack.push({
                                            domElement: newNestedList,
                                            level: currentListStack.length + 1
                                        });
                                        currentParentList = newNestedList;
                                    }

                                }
                                // If nextLevel === currentDepth, simply append to currentParentList


                                const nextLi = doc.createElement('li');
                                let nextListItemContent = extractAllowedContentForLists(nextElement);
                                if (nextListType === 'complex-bullet') {
                                    nextLi.innerHTML = nextBulletTextToPrepend + ' ' + nextListItemContent;
                                } else {
                                    nextLi.innerHTML = nextListItemContent;
                                }
                                currentParentList.appendChild(nextLi);
                                elementsToRemove.add(nextElement); // Mark subsequent elements for removal

                                // Remove class and style attributes from the processed element
                                nextElement.removeAttribute('class');
                                nextElement.removeAttribute('style');

                                nextSibling = nextElement.nextElementSibling;
                                currentSequenceIndex++;
                            } else {
                                break; // End of list sequence
                            }
                        }
                        i = currentSequenceIndex - 1; // Adjust outer loop index
                    }
                }

                // Perform DOM modifications based on maps
                targetElements.forEach(element => {
                    if (elementsToReplace.has(element)) {
                        if (element.parentNode) {
                            element.parentNode.replaceChild(elementsToReplace.get(element), element);
                        }
                    } else if (elementsToRemove.has(element)) {
                        if (element.parentNode) {
                            element.parentNode.removeChild(element);
                        }
                    }
                });

                return doc.body.innerHTML;
            }

            /**
             * Applies basic cleaning to tables and their elements.
             * This includes removing colgroup/col tags, cleaning table/td/th attributes,
             * and handling paragraphs within table cells.
             * @param {string} htmlString - The HTML content to clean.
             * @returns {string} The cleaned HTML content.
             */
            function applyCleanTablesBasic(htmlString) {
                const parser = new DOMParser();
                const doc = parser.parseFromString(htmlString, 'text/html');
                const body = doc.body;

                // Remove colgroup and col elements
                const colgroupElements = doc.querySelectorAll('colgroup');
                for (let i = colgroupElements.length - 1; i >= 0; i--) {
                    if (colgroupElements[i].parentNode) {
                        colgroupElements[i].parentNode.removeChild(colgroupElements[i]);
                    }
                }

                const colElements = doc.querySelectorAll('col');
                for (let i = colElements.length - 1; i >= 0; i--) {
                    if (colElements[i].parentNode) {
                        colElements[i].parentNode.removeChild(colElements[i]);
                    }
                }

                // Clean attributes from table and its structural tags (thead, tbody, tfoot, tr, th, td)
                const tableRelatedTags = doc.querySelectorAll('table, thead, tbody, tfoot, tr, th, td');
                tableRelatedTags.forEach(element => {
                    const attributesToKeep = ['rowspan', 'colspan', 'class', 'id', 'headers', 'scope'];
                    const attributesToRemove = [];
                    for (let j = 0; j < element.attributes.length; j++) {
                        const attr = element.attributes[j];
                        if (!attributesToKeep.includes(attr.name.toLowerCase())) {
                            attributesToRemove.push(attr.name);
                        }
                    }
                    attributesToRemove.forEach(attrName => {
                        element.removeAttribute(attrName);
                    });
                });

                // Remove MsoTable class from tables
                doc.querySelectorAll('table').forEach(table => {
                    const classAttr = table.getAttribute('class');
                    if (classAttr && classAttr.includes('MsoTable')) {
                        table.removeAttribute('class');
                    }
                });

                // Unwrap spans inside td with class^="xl"
                doc.querySelectorAll('table td[class^="xl"] span').forEach(span => {
                    if (span.parentNode) {
                        while (span.firstChild) {
                            span.parentNode.insertBefore(span.firstChild, span);
                        }
                        span.parentNode.removeChild(span);
                    }
                });

                // Remove class^="xl" from td elements
                doc.querySelectorAll('td').forEach(td => {
                    const classAttr = td.getAttribute('class');
                    if (classAttr && classAttr.startsWith('xl')) {
                        td.removeAttribute('class');
                    }
                });

                // Clean paragraphs within tables: remove Mso/Aligned classes, inline styles, and convert align attribute to Tailwind classes
                doc.querySelectorAll('table p').forEach(p => {
                    const parentCell = p.closest('td, th');

                    if (parentCell) {
                        const classAttr = p.getAttribute('class');
                        if (classAttr && (classAttr.includes('Mso') || cls.includes('Style') || cls.includes('DocumentTitle') || cls.includes('Heading') || classAttr.includes('Aligned'))) {
                            p.removeAttribute('class');
                        }

                        if (p.hasAttribute('style')) {
                            p.removeAttribute('style');
                        }

                        const alignAttr = p.getAttribute('align');
                        if (alignAttr) {
                            p.removeAttribute('align');
                            let tailwindAlignClass = ''; // Fixed typo from tailwclassName
                            switch (alignAttr.toLowerCase()) {
                                case 'left':
                                    tailwindAlignClass = 'text-left';
                                    break;
                                case 'center':
                                    tailwindAlignClass = 'text-center';
                                    break;
                                case 'right':
                                    tailwindAlignClass = 'text-right';
                                    break;
                            }
                            if (tailwindAlignClass) {
                                parentCell.classList.add(tailwindAlignClass);
                            }
                        }
                    }
                });
                return doc.body.innerHTML;
            }

            /**
             * Applies cleaning for Microsoft Office specific code.
             * This function removes tags and their entire content if they have specific MSO-related attributes or hrefs.
             * Attributes targeted for removal: "mso-element: comment-list", "mso-element: endnote-list".
             * Hrefs targeted for removal: containing "#_msocom", "#_edn", or "#_ftn".
             * For "#_ftn" links, converts <a> to <sup><a> with only text content and href attribute.
             * Also transforms elements with "mso-element: footnote-list" style into <aside> with cleaned content.
             * Also removes content from and cleans attributes of elements with 'style' attribute or MSO/Word/BCX0 classes.
             * Additionally handles specific heading class cleanup, and attribute removal for non-table elements,
             * UL/OL tags, and LI tags with 'role' attributes.
             * Also now handles cleaning of file:// or data: img src attributes.
             * @param {string} htmlString - The HTML content to clean.
             * @returns {string} The cleaned HTML content.
             */
            function applyCleanMsoCode(htmlString) {
                const parser = new DOMParser();
                const doc = parser.parseFromString(htmlString, 'text/html');
                // Remove spans with mso-special-character: comment
                doc.querySelectorAll('span[style*="mso-special-character: comment"]').forEach(span => {
                    if (span.parentNode) {
                        span.parentNode.removeChild(span);
                    }
                });
                doc.querySelectorAll('a[href]').forEach(aTag => {
                    const trimmedTextContent = aTag.textContent.trim().replace(/\s/g, '');
                    const innerHTMLTrimmed = aTag.innerHTML.replace(/&nbsp;|\s/g, '').trim();

                    if (trimmedTextContent === '' || innerHTMLTrimmed === '') {
                        const parent = aTag.parentNode;
                        if (parent) {
                            // Move the content (which is just whitespace) out of the <a> tag
                            while (aTag.firstChild) {
                                parent.insertBefore(aTag.firstChild, aTag);
                            }
                            // Then remove the empty <a> tag
                            parent.removeChild(aTag);
                        }
                    }
                });

                doc.querySelectorAll('span[style*="mso-"]').forEach(span => {
                    const p = span.parentNode;
                    while (span.firstChild) p.insertBefore(span.firstChild, span);
                    p.removeChild(span);

                });
                doc.querySelectorAll('del, span.msoDel').forEach(node => {
                    node.remove();
                });
                doc.querySelectorAll('span.msoIns').forEach(ins => {
                    const parent = ins.parentNode;
                    while (ins.firstChild) parent.insertBefore(ins.firstChild, ins);
                    parent.removeChild(ins);
                });
                doc.querySelectorAll('ins').forEach(ins => {
                    const parent = ins.parentNode;
                    while (ins.firstChild) parent.insertBefore(ins.firstChild, ins);
                    parent.removeChild(ins);
                });

                // --- Start of Clean IMGs Logic (Moved from applyCleanImgs) ---
                doc.querySelectorAll('img').forEach(img => {
                    const src = img.getAttribute('src');
                    if (src && (src.startsWith('file://') || src.startsWith('data:'))) {
                        const replacementDiv = doc.createElement('div');
                        replacementDiv.classList.add('clearfix');
                        const replacementMark = doc.createElement('mark');
                        replacementMark.textContent = 'IMAGE NOT IMPORTED';
                        replacementDiv.appendChild(replacementMark);
                        if (img.parentNode) {
                            img.parentNode.replaceChild(replacementDiv, img);
                        }
                    }
                });
                // --- End of Clean IMGs Logic ---

                // Select elements with style containing "mso-element: comment-list" or "mso-element: endnote-list"
                const elementsToRemoveByStyle = doc.querySelectorAll('[style*="mso-element: comment-list"], [style*="mso-element: endnote-list"]');
                elementsToRemoveByStyle.forEach(element => {
                    if (element.parentNode) {
                        element.parentNode.removeChild(element);
                    }
                });

                // Select <a> elements with href containing "#_msocom" or "#_edn" and remove them completely
                const commentEndnoteLinks = doc.querySelectorAll('a[href*="#_msocom"], a[href*="#_edn"]');
                commentEndnoteLinks.forEach(link => {
                    if (link.parentNode) {
                        link.parentNode.removeChild(link);
                    }
                });

                // Process <a> tags with href containing "#_ftn" to ensure only one <sup> wrapper
                const footnoteLinks = Array.from(doc.querySelectorAll('a[href*="#_ftn"]')); // Convert to array to avoid live NodeList issues
                footnoteLinks.forEach(link => {
                    const originalHref = link.getAttribute('href');
                    const textContent = link.textContent;

                    // Create the ideal new <a> tag, copying only necessary attributes
                    const newCleanLink = doc.createElement('a');
                    newCleanLink.setAttribute('href', originalHref);
                    newCleanLink.textContent = textContent;

                    // Create the ideal new <sup> tag
                    const idealSupElement = doc.createElement('sup');
                    idealSupElement.appendChild(newCleanLink);

                    // Find the target element to replace. This could be the link itself
                    // or an existing <sup> parent that solely contains the link (or other <sup>s leading to it).
                    let elementToReplace = link; // This `link` is the current <a> element being processed
                    let currentParent = link.parentNode; // Start the the immediate parent of the link

                    // Traverse up the DOM tree as long as the parent is <sup> and solely contains `elementToReplace`
                    while (currentParent && currentParent !== doc.body && currentParent.tagName.toLowerCase() === 'sup') {
                        // Check if this <sup> only contains the elementToReplace (which is the link or another sup)
                        // and no other significant content (like additional text nodes or other elements).
                        const children = Array.from(currentParent.childNodes).filter(n => n.nodeType === Node.ELEMENT_NODE || (n.nodeType === Node.TEXT_NODE && n.nodeValue.trim() !== ''));

                        // If the <sup> has only one child and that child is our current elementToReplace (or nested <sup>),
                        // then this <sup> is an exclusive wrapper and we can move up.
                        if (children.length === 1 && children[0] === elementToReplace) {
                            elementToReplace = currentParent; // Move up: now `elementToReplace` is this <sup>
                            currentParent = currentParent.parentNode; // Move `currentParent` further up
                        } else {
                            break; // This <sup> contains other content, stop unwrapping here.
                        }
                    }

                    // Perform the replacement:
                    // Replace the determined 'elementToReplace' (which could be the original <a>
                    // or the outermost exclusively wrapping <sup>) with the 'idealSupElement'.
                    if (elementToReplace.parentNode) {
                        elementToReplace.parentNode.replaceChild(idealSupElement, elementToReplace);
                    }
                });

                // Process elements with "mso-element: footnote-list" in their style attribute
                const footnoteListElements = doc.querySelectorAll('[style*="mso-element: footnote-list"]');
                footnoteListElements.forEach(element => {
                    if (element.parentNode) {
                        // Clean the content of the current element first, based on the preservation rules
                        const cleanedInnerHtml = cleanAndPreserveAllowedContent(element, doc);

                        // Create a new <aside> element
                        const asideElement = doc.createElement('aside');
                        asideElement.innerHTML = cleanedInnerHtml;

                        // Replace the original element with the new <aside>
                        if (element.parentNode) {
                            element.parentNode.replaceChild(asideElement, element);
                        }
                    }
                });

                // Process heading character tags
                // Find all elements that have a class like "Heading#Char" where # is 1-6
                const elementsWithHeadingClass = doc.querySelectorAll('[class*="Heading"]'); // Broad selection then filter

                // Convert to array to avoid issues with live NodeList during modifications
                Array.from(elementsWithHeadingClass).forEach(element => {
                    const classAttr = element.getAttribute('class');
                    if (!classAttr) return;

                    const classes = classAttr.split(/\s+/);
                    const headingCharClass = classes.find(cls => /^Heading[1-6]Char$/.test(cls));

                    if (headingCharClass) {
                        const headingLevel = parseInt(headingCharClass.match(/\d/)[0], 10);
                        const parent = element.parentNode;

                        if (!parent) return;

                        // Unwrap the current element: move its children to its parent
                        while (element.firstChild) {
                            parent.insertBefore(element.firstChild, element);
                        }
                        parent.removeChild(element); // Remove the now empty element

                        const currentParent = parent; // This is the original parent after unwrapping

                        // If the original parent is NOT already a heading (h1-h6)
                        if (!/^H[1-6]$/i.test(currentParent.tagName)) {
                            const newHeadingTag = doc.createElement(`h${headingLevel}`);

                            // Move *all* content of the original parent into the new headingTag
                            while (currentParent.firstChild) {
                                newHeadingTag.appendChild(currentParent.firstChild);
                            }

                            // Replace the original parent with the new heading tag
                            if (currentParent.parentNode) {
                                currentParent.parentNode.replaceChild(newHeadingTag, currentParent);
                            }
                        }
                        // If the original parent *was* already a heading, we've already unwrapped the span, so no further action needed.
                    }
                });

                // NEW: Remove 'align' attribute from elements *outside* of tables
                doc.querySelectorAll('[align]').forEach(element => {
                    if (!element.closest('table')) { // Check if the element is not inside a table
                        element.removeAttribute('align');
                    }
                });

                // NEW: Remove 'type' and 'role' attributes from UL and OL tags
                doc.querySelectorAll('ul, ol').forEach(list => {
                    list.removeAttribute('type');
                    list.removeAttribute('role');
                });

                // NEW: Remove all attributes from LI tags if they have a 'role' attribute
                doc.querySelectorAll('li').forEach(li => {
                    if (li.hasAttribute('role')) {
                        // Create an array of attribute names to remove
                        const attributesToRemove = Array.from(li.attributes).map(attr => attr.name);
                        attributesToRemove.forEach(attrName => {
                            li.removeAttribute(attrName);
                        });
                    }
                });

                // NEW: Remove span tags with 'lang' attribute unless lang is 'en' or 'fr'
                doc.querySelectorAll('span[lang]').forEach(span => {
                    const langAttr = span.getAttribute('lang');
                    if (langAttr && langAttr.toLowerCase() !== 'en' && langAttr.toLowerCase() !== 'fr') {
                        // Unwrap the span: move its children to its parent
                        const parent = span.parentNode;
                        if (parent) {
                            while (span.firstChild) {
                                parent.insertBefore(span.firstChild, span);
                            }
                            parent.removeChild(span); // Remove the now empty span
                        }
                    }
                });


                // Process all elements that have a style attribute or MSO/Word/BCX0 classes
                // Iterate in reverse to handle nested elements correctly without breaking the loop
                const allElements = Array.from(doc.querySelectorAll('*'));
                for (let i = allElements.length - 1; i >= 0; i--) {
                    const element = allElements[i];

                    // Skip html, head, body, script, style tags, and the aside tags just created
                    const tagName = element.tagName.toLowerCase();
                    if (['html', 'head', 'body', 'script', 'style', 'aside'].includes(tagName)) {
                        continue;
                    }

                    const hasStyle = element.hasAttribute('style');
                    const classAttr = element.getAttribute('class') || '';
                    const idAttr = element.getAttribute('id') || '';

                    // Check if any class contains "Mso", "Word", or "BCX0" (case-sensitive)
                    const hasMsoWordBcx0Class = classAttr.split(/\s+/).some(cls =>
                        cls.includes('Mso') || cls.includes('Style') || cls.includes('DocumentTitle') || cls.includes('Heading') || cls.includes('Word') || cls.includes('BCX0')
                    );

                    // Check if ID contains "Mso", "Word", or "BCX0" (case-sensitive)
                    const hasMsoWordBcx0Id = idAttr.includes('Mso') || idAttr.includes('Word') || idAttr.includes('BCX0');

                    // NEW: Check for classes that trigger complete unwrapping
                    const shouldUnwrapCompletely = classAttr.split(/\s+/).some(cls =>
                        cls.includes('eop') ||
                        cls.includes('eoc') ||
                        cls.includes('eocx') ||
                        cls.includes('textrun')
                    );

                    if (shouldUnwrapCompletely) {
                        const parent = element.parentNode;
                        if (parent) {
                            // Move children out of the element
                            while (element.firstChild) {
                                parent.insertBefore(element.firstChild, element);
                            }
                            parent.removeChild(element); // Remove the now empty element
                        }
                        continue; // Continue to the next element in the loop after unwrapping
                    }

                    // Existing logic for cleaning attributes and content if not completely unwrapped
                    if (hasStyle || hasMsoWordBcx0Class || hasMsoWordBcx0Id) {
                        // Get the cleaned innerHTML based on the preservation rules
                        const cleanedInnerHtml = cleanAndPreserveAllowedContent(element, doc);

                        // Replace the original content with the cleaned content
                        element.innerHTML = cleanedInnerHtml;

                        // Remove the style attribute
                        if (hasStyle) {
                            element.removeAttribute('style');
                        }

                        // Clean the class attribute: remove the entire attribute if any class contains "Mso", "Word", or "BCX0"
                        if (classAttr) {
                            const hasDisallowedClass = classAttr.split(/\s+/).some(cls =>
                                cls.includes('Mso') || cls.includes('Style') || cls.includes('DocumentTitle') || cls.includes('Heading') || cls.includes('Word') || cls.includes('BCX0')
                            );
                            if (hasDisallowedClass) {
                                element.removeAttribute('class');
                            }
                            // If no disallowed class, the attribute remains as is.
                        }

                        // Clean the id attribute: remove id if it contains "Mso", "Word", or "BCX0"
                        if (idAttr && (idAttr.includes('Mso') || idAttr.includes('Word') || idAttr.includes('BCX0'))) {
                            element.removeAttribute('id');
                        }
                    }
                }

                // Remove 'title' attribute from all <a> tags
                doc.querySelectorAll('a[title]').forEach(aTag => {
                    aTag.removeAttribute('title');
                });

                return doc.body.innerHTML;
            }

            /**
             * Converts common formatting tags: removes <u>, converts <b> to <strong>, and <i> to <em>.
             * @param {string} htmlString - The HTML content to clean.
             * @returns {string} The cleaned HTML content.
             */
            function applyCleanFormattingTags(htmlString) {
                const parser = new DOMParser();
                const doc = parser.parseFromString(htmlString, 'text/html');

                // 1. Remove <u> tags (unwrap them)
                const uElements = Array.from(doc.querySelectorAll('u'));
                for (let i = uElements.length - 1; i >= 0; i--) {
                    const u = uElements[i];
                    if (u.parentNode) {
                        while (u.firstChild) {
                            u.parentNode.insertBefore(u.firstChild, u);
                        }
                        u.parentNode.removeChild(u);
                    }
                }

                // 2. Convert <b> to <strong>
                const bElements = Array.from(doc.querySelectorAll('b'));
                for (let i = bElements.length - 1; i >= 0; i--) {
                    const b = bElements[i];
                    if (b.parentNode) {
                        const strong = doc.createElement('strong');
                        while (b.firstChild) {
                            strong.appendChild(b.firstChild);
                        }
                        b.parentNode.replaceChild(strong, b);
                    }
                }

                // 3. Convert <i> to <em>
                const iElements = Array.from(doc.querySelectorAll('i'));
                for (let i = iElements.length - 1; i >= 0; i--) {
                    const i_tag = iElements[i]; // Renamed to avoid conflict with loop variable
                    if (i_tag.parentNode) {
                        const em = doc.createElement('em');
                        while (i_tag.firstChild) {
                            em.appendChild(i_tag.firstChild);
                        }
                        i_tag.parentNode.replaceChild(em, i_tag);
                    }
                }

                return doc.body.innerHTML;
            }

            /**
             * Adjusts heading levels (h1-h6) to ensure a correct hierarchical structure.
             *
             * Rules:
             * - If an H1 exists with `property="name"` and `id="wb-cont"`, it is preserved as H1.
             * - Otherwise, the very first encountered heading in the document (regardless of its initial level)
             * is converted to H2.
             * - All subsequent headings are adjusted relative to this H2 (or the preserved H1).
             * Specifically, if the document starts with H1 (which becomes H2), all subsequent headings shift down one level.
             * If the document starts with H3 (which becomes H2), all subsequent headings shift down one level.
             * If an H2 follows an H2, it remains H2. If an H2 follows an H1 (now H2), it becomes H3.
             * No more than one level skip down is allowed (e.g., H2 followed by H4 becomes H3).
             * All headings are guaranteed to be at least H2 (except the special H1).
             *
             * @param {string} htmlString - The HTML content to process.
             * @returns {string} The HTML content with adjusted heading levels.
             */
            function applyAutoLevelHeadings(htmlString) {
                const parser = new DOMParser();
                const doc = parser.parseFromString(htmlString, 'text/html');
                const body = doc.body;

                const headings = Array.from(body.querySelectorAll('h1, h2, h3, h4, h5, h6'));

                // Find the special H1, if it exists, which should be preserved.
                const specialH1 = headings.find(h =>
                    h.tagName.toLowerCase() === 'h1' &&
                    (h.getAttribute('property') === 'name' || h.id === 'wb-cont')
                );

                let levelAdjustmentForGlobalShift = 0; // The numerical shift to apply to all relevant headings (+1 for H1->H2, -1 for H3->H2 etc.)
                let firstRelevantHeadingFound = false;

                // First pass: Determine the overall level adjustment based on the first non-special heading
                for (const h of headings) {
                    if (h === specialH1) {
                        continue; // Skip the special H1 in this calculation
                    }
                    if (!firstRelevantHeadingFound) {
                        const actualLevel = parseInt(h.tagName.substring(1), 10);
                        // Calculate the adjustment needed for this first heading to become an H2.
                        // If actualLevel is 1 (H1), adjust by +1 (1 + 1 = 2). So adjustment = 1.
                        // If actualLevel is 3 (H3), adjust by -1 (3 - 1 = 2). So adjustment = -1.
                        // General formula: levelAdjustment = (Target Level for First) - (Actual Level for First)
                        // Here, Target Level for First is always 2.
                        levelAdjustmentForGlobalShift = 2 - actualLevel;
                        firstRelevantHeadingFound = true;
                        break; // Only need to consider the very first one
                    }
                }

                // Second pass: Apply the adjustments and enforce hierarchical rules
                let effectivePreviousLevel = 0; // Tracks the *resulting* level of the previously processed heading

                for (let i = 0; i < headings.length; i++) {
                    let currentHeading = headings[i]; // Get the element reference

                    // If it's the special H1, skip modification and set effectivePreviousLevel as H1 (level 1)
                    if (currentHeading === specialH1) {
                        effectivePreviousLevel = 1;
                        continue;
                    }

                    const currentActualLevel = parseInt(currentHeading.tagName.substring(1), 10);
                    let newLevel;

                    // Calculate the 'globally adjusted' level based on the initial shift
                    // (e.g., if first H1 became H2, all subsequent headings effectively shift up by 1 level number)
                    let globallyAdjustedLevel = currentActualLevel + levelAdjustmentForGlobalShift;
                    globallyAdjustedLevel = Math.max(2, globallyAdjustedLevel); // Ensure it's at least H2


                    if (effectivePreviousLevel === 0) {
                        // This is the very first non-special heading we're processing. It must be H2.
                        newLevel = 2;
                    } else {
                        // For subsequent headings, ensure two rules are met:
                        // 1. It maintains the overall global shift (`globallyAdjustedLevel`).
                        // 2. It doesn't jump more than one level down from the `effectivePreviousLevel`.
                        newLevel = Math.min(globallyAdjustedLevel, effectivePreviousLevel + 1);
                        // Also, ensure the new level is never below H2
                        newLevel = Math.max(2, newLevel);
                    }

                    // Only replace the element if its level needs to be changed
                    if (newLevel !== currentActualLevel) {
                        const newHeadingTag = doc.createElement(`h${newLevel}`);
                        // Copy all attributes from the original heading to the new one
                        Array.from(currentHeading.attributes).forEach(attr => {
                            newHeadingTag.setAttribute(attr.name, attr.value);
                        });
                        // Move all children (content) from the original heading to the new one
                        while (currentHeading.firstChild) {
                            newHeadingTag.appendChild(currentHeading.firstChild);
                        }
                        // Replace the original heading element with the newly created one in the DOM.
                        // This is crucial if subsequent iterations might re-evaluate elements that were
                        // later in the original 'headings' array but whose parent or context might have changed.
                        // Although not strictly necessary with the current loop, it's safer for DOM manipulations.
                        if (currentHeading.parentNode) {
                            currentHeading.parentNode.replaceChild(newHeadingTag, currentHeading);
                        }
                        headings[i] = newHeadingTag; // Update the reference in the 'headings' array
                    }

                    // Update effectivePreviousLevel with the level that the current heading *actually* became
                    effectivePreviousLevel = newLevel;
                }

                return body.innerHTML;
            }

            /**
             * Wraps <section> tags around heading tags and their content, nesting based on heading level.
             * Treats <aside> tags as H2 for sectioning purposes but does not wrap them.
             * Ignores sections with 'colophon' in their ID or containing a paragraph with '©' for auto-sectioning.
             * @param {string} htmlString - The HTML content to section.
             * @returns {string} The sectioned HTML content.
             */
            function applyAutoSectioning(htmlString) {
                const parser = new DOMParser();
                const doc = parser.parseFromString(htmlString, 'text/html');
                const originalBody = doc.body;

                const newBody = doc.createElement('body');
                // Stack stores { domElement: Node, level: number }
                let currentSectionStack = [{
                    domElement: newBody,
                    level: 0
                }]; // Level 0 for body (root container)

                // Iterate over the live childNodes of the originalBody
                while (originalBody.firstChild) {
                    const node = originalBody.firstChild;
                    // Temporarily remove the node from originalBody to process it
                    originalBody.removeChild(node);

                    if (node.nodeType === Node.ELEMENT_NODE) {
                        const tagName = node.tagName.toLowerCase();
                        let nodeLevel = null; // Conceptual level of the current node (e.g., 1 for h1, 2 for h2 or aside)
                        let shouldCreateNewSectionForNode = true; // Does this specific node warrant a new <section>?
                        let isProtectedSection = false; // Flag for sections to ignore

                        if (tagName === 'section') {
                            // Check if this section should be ignored (colophon ID, has any class, or p with ©)
                            // IMPORTANT CHANGE: Added condition to ignore sections that have a class attribute
                            if (node.id.includes('colophon') || node.querySelector('p')?.textContent?.includes('©') || node.hasAttribute('class') || (node.id && !/^sec\d+(-\d+)*$/.test(node.id))) {
                                isProtectedSection = true;
                                shouldCreateNewSectionForNode = false; // Do not wrap or re-section this
                            } else {
                                // For non-protected existing sections (those without class, not colophon/copyright, and follow 'sec' ID pattern),
                                // unwrap their content. This allows re-sectioning to properly build hierarchy.
                                const fragment = doc.createDocumentFragment();
                                while (node.firstChild) {
                                    fragment.appendChild(node.firstChild);
                                }
                                // Temporarily append the fragment's children back to the originalBody
                                // so they are picked up in the next iteration of the while loop.
                                // Insert at the beginning so they are processed immediately.
                                originalBody.insertBefore(fragment, originalBody.firstChild);
                                // The original section 'node' is now empty. It will be implicitly removed
                                // when originalBody.removeChild(node) is called at the beginning of the next loop iteration.
                                // We use 'continue' to skip the rest of the current loop iteration, ensuring
                                // the unwrapped children are processed next.
                                continue;
                            }
                        }

                        const headingLevelMatch = tagName.match(/^h([1-6])$/);
                        if (headingLevelMatch) {
                            nodeLevel = parseInt(headingLevelMatch[1], 10);
                        } else if (tagName === 'aside') {
                            nodeLevel = 2; // Treat <aside> as H2 for sectioning logic
                            shouldCreateNewSectionForNode = false; // Do NOT wrap <aside> in its own section
                        }

                        if (isProtectedSection) {
                            // For protected sections, append them directly to the current effective parent
                            // and *don't* modify the currentSectionStack.
                            let parentToAppendTo = currentSectionStack[currentSectionStack.length - 1].domElement;
                            parentToAppendTo.appendChild(node);
                        } else if (nodeLevel !== null) { // It's either a heading (h1-h6) or an <aside> and not a protected section
                            // Pop sections from stack if current node's level is less than or equal to the top section's level.
                            while (currentSectionStack.length > 1 && nodeLevel <= currentSectionStack[currentSectionStack.length - 1].level) {
                                currentSectionStack.pop();
                            }

                            let currentParentDomElement = currentSectionStack[currentSectionStack.length - 1].domElement;

                            if (shouldCreateNewSectionForNode) { // It's a heading, create a new section
                                const newSection = doc.createElement('section');
                                currentParentDomElement.appendChild(newSection);
                                // Push the new section onto the stack, updating the current parent for next elements
                                currentSectionStack.push({
                                    domElement: newSection,
                                    level: nodeLevel
                                });
                                // Append the original heading node to the newly created section
                                currentSectionStack[currentSectionStack.length - 1].domElement.appendChild(node);
                            } else { // It's an <aside>, append it directly to the current effective parent
                                currentParentDomElement.appendChild(node);
                                // IMPORTANT: <aside> does NOT create a new section for itself and is not pushed onto the stack.
                                // This means subsequent content will be appended relative to the section that *contains* the <aside>.
                            }
                        } else { // Not a heading, aside, or protected section; append to the current open section
                            currentSectionStack[currentSectionStack.length - 1].domElement.appendChild(node);
                        }
                    } else { // Text node or comment node, append to the current open section
                        currentSectionStack[currentSectionStack.length - 1].domElement.appendChild(node);
                    }
                }

                return newBody.innerHTML;
            }

            /**
             * Inserts IDs to all heading tags (h1-h6), section, and table tags based on specified rules.
             * This function ensures full re-numbering on each run, allowing for dynamic updates
             * after elements are added, deleted, or reordered. This version is resilient to missing
             * <section> tags and imperfect heading structures.
             *
             * @param {string} htmlString - The HTML content to process.
             * @param {object} options - An object specifying which elements to ID.
             * @returns {string} The HTML content with IDs inserted.
             */
            function applyAutoId(htmlString, options = {}) {
                // Default options to true if not provided
                const defaultOptions = {
                    idSections: true,
                    idHeadings: true,
                    idFigures: true,
                    idTables: true,
                    idFigureTables: true
                };
                const currentOptions = {
                    ...defaultOptions,
                    ...options
                };

                const parser = new DOMParser();
                const doc = parser.parseFromString(htmlString, 'text/html');
                const body = doc.body;

                const idChangeMap = {};

                function toAlpha(num) {
                    let s = '';
                    while (num > 0) {
                        let t = (num - 1) % 26;
                        s = String.fromCharCode(65 + t) + s;
                        num = Math.floor((num - t) / 26);
                    }
                    return s || 'A';
                }

                function getLetterFromAppendixText(text) {
                    const match = text.match(/^(?:Appendix|Annexe)\s*([A-Z])?/i);
                    return (match && match[1]) ? match[1].toUpperCase() : null;
                }

                const existingIds = new Set();
                doc.querySelectorAll('[id]').forEach(el => existingIds.add(el.id));

                if (currentOptions.idHeadings) {
                    let h2_num_counter = 0;
                    let h2_general_alpha_counter = 0;
                    let h2_appendix_alpha_counter = 0;
                    let sub_num_counters = new Map();
                    let sub_appendix_alpha_counters = new Map();

                    // --- MODIFICATION START: Use a more robust tracking method ---
                    // This tracks the full ID of the last seen heading at each level.
                    const lastSeenHeadingIds = {
                        2: '',
                        3: '',
                        4: '',
                        5: '',
                        6: ''
                    };
                    // --- MODIFICATION END ---

                    let hasAnyNumberedH2 = Array.from(body.querySelectorAll('h2')).some(h => h.textContent.trim().match(/^\s*(\d+)(?:\.|\s|\)|\-)?/));

                    doc.querySelectorAll('h1, h2, h3, h4, h5, h6').forEach(heading => {
                        const level = parseInt(heading.tagName.substring(1), 10);
                        const text = heading.textContent.trim();
                        const oldId = heading.id;
                        let newId = oldId;

                        const ignoredParents = ['aside', 'caption', 'figure', 'figcaption', 'table'];
                        if (heading.closest(ignoredParents.join(','))) {
                            return; // Skip headings inside these elements
                        }

                        if (level === 1) return; // Skip H1s as per original logic

                        let id_segment = '';
                        const isNumericHeading = text.match(/^\s*(\d+)(?:\.|\s|\)|\-)?/);
                        const isAppendixHeading = text.match(/^(?:Appendix|Annexe)/i);

                        if (level === 2) {
                            if (isAppendixHeading) {
                                const letter = getLetterFromAppendixText(text) || toAlpha(++h2_appendix_alpha_counter);
                                id_segment = `app${letter}`;
                            } else if (hasAnyNumberedH2) {
                                id_segment = isNumericHeading ? `toc${++h2_num_counter}` : `toc${toAlpha(++h2_general_alpha_counter)}`;
                            } else {
                                id_segment = `toc${++h2_num_counter}`;
                            }
                            newId = id_segment;
                            lastSeenHeadingIds[2] = newId; // Track the new H2 ID

                        } else { // For H3, H4, H5, H6
                            // --- MODIFICATION START: Robust Parent ID lookup ---
                            // Find the parent ID from the last seen heading of the level above.
                            const parent_id = lastSeenHeadingIds[level - 1];
                            if (!parent_id) { // If no parent found (e.g., an H3 before any H2), skip IDing
                                return;
                            }
                            // --- MODIFICATION END ---

                            if (isAppendixHeading) {
                                const currentAppCount = (sub_appendix_alpha_counters.get(parent_id) || 0) + 1;
                                sub_appendix_alpha_counters.set(parent_id, currentAppCount);
                                id_segment = `app${getLetterFromAppendixText(text) || toAlpha(currentAppCount)}`;
                            } else {
                                const currentNumCount = (sub_num_counters.get(parent_id) || 0) + 1;
                                sub_num_counters.set(parent_id, currentNumCount);
                                id_segment = String(currentNumCount);
                            }
                            newId = `${parent_id}-${id_segment}`;
                        }

                        lastSeenHeadingIds[level] = newId; // Track the new ID for this level
                        if (oldId && oldId !== newId) {
                            idChangeMap[oldId] = newId;
                        }
                        heading.setAttribute('id', newId);
                        existingIds.add(newId);
                    });
                }

                // --- Section, Figure, and Table logic remains the same as it is already safe ---
                if (currentOptions.idSections) {
                    // This logic is safe. If no sections are found, it does nothing.
                    let sectionChildCounters = {
                        'root': 0
                    };
                    doc.querySelectorAll('section').forEach(section => {
                        if (section.id && (!/^sec\d+(-\d+)*$/.test(section.id) || section.hasAttribute('class'))) return;
                        let parentSection = section.parentElement.closest('section');
                        let parentId = parentSection && parentSection.id && /^sec\d+(-\d+)*$/.test(parentSection.id) ? parentSection.id : 'root';
                        sectionChildCounters[parentId] = (sectionChildCounters[parentId] || 0) + 1;
                        const newNum = sectionChildCounters[parentId];
                        const newId = (parentId === 'root') ? `sec${newNum}` : `${parentId}-${newNum}`;
                        if (section.id && section.id !== newId) idChangeMap[section.id] = newId;
                        section.id = newId;
                    });
                }

                if (currentOptions.idFigures) {
                    let figureCounter = 0;
                    doc.querySelectorAll('figure:not([id])').forEach(figure => {
                        figure.id = `fig${++figureCounter}`;
                    });
                }

                if (currentOptions.idTables || currentOptions.idFigureTables) {
                    let tableCounter = 0;
                    let figureTableCounter = 0;
                    doc.querySelectorAll('table').forEach(table => {
                        if (table.id) return; // Skip tables that already have an ID
                        if (table.closest('figure') && currentOptions.idFigureTables) {
                            table.id = `ftbl${++figureTableCounter}`;
                        } else if (!table.closest('figure') && currentOptions.idTables) {
                            table.id = `tbl${++tableCounter}`;
                        }
                    });
                }

                doc.querySelectorAll('a[href^="#"]').forEach(link => {
                    const currentAnchor = link.getAttribute('href').substring(1);
                    if (idChangeMap[currentAnchor]) {
                        link.setAttribute('href', `#${idChangeMap[currentAnchor]}`);
                    }
                });

                return body.innerHTML;
            }


            /**
             * Function to set the content of the HugeRTE editor.
             * This is called from the parent window.
             */
            window.setRichEditorContent = function(content) {
                // console.log("Parent: Attempting to set HugeRTE content.");
                if (richTextEditorInstance) {
                    richTextEditorInstance.setContent(cleanHtmlForRichTextDisplay(content));
                    richTextEditorInstance.focus(); // Re-focus the rich editor after content update
                    // console.log('Parent: HugeRTE updated from HTML editor.');
                } else {
                    console.warn('Parent: HugeRTE editor not yet initialized. Content will be set once ready.');
                }
            };

            /**
             * Function to get the content from the HugeRTE editor.
             * This is called from the parent window.
             */
            window.getRichEditorContent = function() {
                // console.log("Parent: Attempting to get HugeRTE content.");
                if (richTextEditorInstance) {
                    const content = richTextEditorInstance.getContent();
                    // console.log("Parent: HugeRTE content requested by parent.");
                    return content;
                } else {
                    console.warn('Iframe: HugeRTE editor not yet initialized. Cannot get content.');
                    return '';
                }
            };

            /**
             * Updates the disabled state of all interactive buttons.
             * Buttons are disabled if any button has 'data-temp-active' set to 'true'.
             */
            function updateAllInteractiveButtonStates() {
                const anyTempMessageActive = allInteractiveButtons.some(btn => btn.getAttribute('data-temp-active') === 'true');

                allInteractiveButtons.forEach(btn => {
                    // If a button itself has 'data-temp-active', it means its modal is open, so it should be disabled.
                    // Otherwise, it's disabled if ANY other button has 'data-temp-active'.
                    btn.disabled = btn.getAttribute('data-temp-active') === 'true' || anyTempMessageActive;
                });
            }


            /**
             * Toggles the active editor view between 'richtext' and 'code'.
             * Includes automatic content synchronization.
             */
            function toggleEditorView() {
                // Prevent toggling if any button is disabled (implicitly means a temp message is active)
                const anyTempMessageActive = allInteractiveButtons.some(btn => btn.getAttribute('data-temp-active') === 'true');
                if (anyTempMessageActive) {
                    console.log("Toggle prevented: another button is active.");
                    return;
                }

                console.log("Toggle Editor View triggered. Current view:", currentView);
                if (currentView === 'richtext') {
                    // --- Logic when switching FROM Rich-Text TO Code ---
                    // 1. Get content from Rich-Text editor.
                    if (default_ifr.contentWindow && default_ifr.contentWindow.getRichEditorContent) {
                        richTextContent = default_ifr.contentWindow.getRichEditorContent();
                        console.log("Syncing from Rich Text to HTML. Rich Text Content length:", richTextContent.length);
                    } else {
                        console.warn("Rich Text Editor not ready for content retrieval on toggle. Using empty string.");
                        richTextContent = '';
                    }

                    // ================== NEW DOM-BASED SOLUTION ==================
                    try {
                        // Step 1: Parse the HTML string into a DOM document
                        const parser = new DOMParser();
                        const doc = parser.parseFromString(richTextContent, 'text/html');

                        // Step 2: Find all <details> elements in the parsed document
                        const allDetails = doc.querySelectorAll('details');

                        // Step 3: Loop through them and remove the 'open' attribute
                        allDetails.forEach(detail => {
                            detail.removeAttribute('open');
                        });

                        // Step 4: Serialize the cleaned content back into an HTML string.
                        // We take the content from the <body> because the parser adds <html> and <body> tags.
                        richTextContent = doc.body.innerHTML;

                    } catch (e) {
                        console.error("Failed to parse and clean HTML, proceeding with raw content.", e);
                        // If parsing fails for any reason, the old regex is a fallback.
                        richTextContent = richTextContent.replace(/<details[^>]*\s(open|open="")/gi, '<details');
                    }
                    // ============================================================

                    // Restore protected data attributes FIRST, as other cleaning might remove elements
                    let processedContent = restoreDataAttributes(richTextContent);
                    console.log("Data attributes restored after Rich Text editor roundtrip.");

                    // Apply Auto-Clean MSO in the specified order when switching to HTML editor
                    if (toggleAutoCleanMsoOnSwitchRichText.checked) {
                        console.log("Auto-Clean MSO applied when switching to HTML editor.");
                        // Apply Clean Mso Lists
                        processedContent = applyCleanLists(processedContent);
                        console.log("Clean MSO Lists applied.");
                        // Apply Clean Mso Tables
                        processedContent = applyCleanTablesBasic(processedContent);
                        console.log("Clean MSO Tables applied.");
                        // Apply Clean Mso Code (includes IMGs now)
                        processedContent = applyCleanMsoCode(processedContent);
                        console.log("Clean MSO Code (including IMGs) applied.");
                        // Apply URL cleaning
                        processedContent = applyUrlCleaning(processedContent);
                        console.log("Clean URLs applied.");
                        // Apply Clean Spaces
                        processedContent = applyAutoSpacing(processedContent);
                        console.log("Clean Spaces applied.");
                    } else {
                        // If auto-clean MSO is not checked, still apply URL cleaning on switch.
                        // URL cleaning is always applied when switching to HTML.
                        processedContent = applyUrlCleaning(processedContent);
                        console.log("URL cleaning applied (not part of Auto-Clean MSO, but always on switch).");
                    }

                    // 2. Update HTML output content and Monaco editor.
                    htmlOutputContent = processedContent;
                    if (monacoEditorInstance) {
                        monacoEditorInstance.setValue(htmlOutputContent);
                        monacoEditorInstance.focus();
                        applyEntityHighlighting();
                        console.log("Monaco editor updated with Rich Text content.");
                    } else {
                        console.warn('Monaco editor not yet initialized. Content will be set once ready.');
                    }

                    // Auto-Indent when switching to HTML editor
                    autoFormatBtn.click();

                    // 3. Switch panel visibility.
                    richtextOutputPanel.classList.remove('panel-visible');
                    richtextOutputPanel.classList.add('panel-hidden');
                    mainEditorArea.classList.remove('panel-hidden'); // Show main editor area
                    mainEditorArea.classList.add('panel-visible');

                    // 4. Update button styles.
                    // "Go to HTML" button (toggleEditorViewBtnRichText) is now inactive/hidden.
                    // Remove all color classes and set to default slate.
                    toggleEditorViewBtnRichText.classList.remove('bg-green-600', 'hover:bg-green-700', 'bg-cyan-700', 'hover:bg-cyan-800');
                    toggleEditorViewBtnRichText.classList.add('bg-slate-800', 'hover:bg-slate-700');

                    // "Go to Rich-Text" button (toggleEditorViewBtnCode) is now active/visible.
                    // It should be cyan.
                    toggleEditorViewBtnCode.classList.remove('bg-green-600', 'hover:bg-green-700', 'bg-slate-800', 'hover:bg-slate-700');
                    toggleEditorViewBtnCode.classList.add('bg-cyan-700', 'hover:bg-cyan-800');

                    currentView = 'code';
                    console.log("Switched to Code View.");
                    updateCleanMsoButtonState(); // Ensure Clean Mso button state is correct after view switch
                } else { // currentView === 'code'
                    // --- Logic when switching FROM Code TO Rich-Text ---
                    // No auto-clean MSO should happen when switching TO the Rich-Text editor.
                    // 1. Get content from Monaco editor.
                    if (monacoEditorInstance) {
                        htmlOutputContent = monacoEditorInstance.getValue();
                        console.log("Syncing from HTML to Rich Text. HTML Output Content length:", htmlOutputContent.length);
                    } else {
                        console.warn("Monaco editor not ready for content retrieval on toggle. Using empty string.");
                        htmlOutputContent = '';
                    }

                    // Protect data attributes BEFORE sending to TinyMCE
                    let contentToSendToRichText = protectDataAttributes(htmlOutputContent);
                    console.log("Data attributes protected before sending to Rich Text editor.");

                    // 2. Update Rich Text content and editor.
                    richTextContent = contentToSendToRichText; // Use the protected content
                    if (default_ifr.contentWindow && default_ifr.contentWindow.setRichEditorContent) {
                        default_ifr.contentWindow.setRichEditorContent(cleanHtmlForRichTextDisplay(richTextContent));
                        console.log("HugeRTE editor updated with HTML content.");
                    } else {
                        console.warn("Rich Text Editor not ready for content setting on toggle.");
                    }

                    // 3. Switch panel visibility.
                    mainEditorArea.classList.remove('panel-visible'); // Hide main editor area
                    mainEditorArea.classList.add('panel-hidden');
                    richtextOutputPanel.classList.remove('panel-hidden');
                    richtextOutputPanel.classList.add('panel-visible');

                    // 4. Update button styles.
                    // "Go to Rich-Text" button (toggleEditorViewBtnCode) is now inactive/hidden.
                    // It should be cyan.
                    toggleEditorViewBtnCode.classList.remove('bg-green-600', 'hover:bg-green-700', 'bg-slate-800', 'hover:bg-slate-700');
                    toggleEditorViewBtnCode.classList.add('bg-cyan-700', 'hover:bg-cyan-800');

                    // "Go to HTML" button (toggleEditorViewBtnRichText) is now active/visible.
                    // Its color depends on the MSO toggle.
                    updateGoToHtmlButtonColor(); // This function handles its specific coloring.

                    currentView = 'richtext';
                    console.log("Switched to Rich Text View.");
                    updateCleanMsoButtonState(); // Ensure Clean Mso button state is correct after view switch
                }
            }

            // Variable to store Monaco decorations for entities
            let entityDecorations = [];

            /**
             * Applies highlighting to HTML character entities in the Monaco editor.
             */
            function applyEntityHighlighting() {
                if (!monacoEditorInstance) return;

                const model = monacoEditorInstance.getModel();
                if (!model) return;

                const newDecorations = [];
                const text = model.getValue();
                // Regex to find HTML entities like &nbsp; &#160; &amp;
                const regex = /&[a-zA-Z0-9#]+;/g;

                let match;
                while ((match = regex.exec(text)) !== null) {
                    const startPos = model.getPositionAt(match.index);
                    const endPos = model.getPositionAt(match.index + match[0].length);

                    newDecorations.push({
                        range: new monaco.Range(startPos.lineNumber, startPos.column, endPos.lineNumber, endPos.column),
                        options: {
                            inlineClassName: 'entity-highlight',
                            hoverMessage: {
                                value: 'HTML Character Entity'
                            } // Optional: show tooltip on hover
                        }
                    });
                }

                // Apply the new decorations and clear old ones
                entityDecorations = monacoEditorInstance.deltaDecorations(entityDecorations, newDecorations);
            }

            /**
             * Updates the color of the "Go to HTML" button based on the "Auto-Clean MSO when switching" toggle state.
             * This function is now responsible for setting the correct color for the "Go to HTML" button
             * when the `currentView` is 'richtext' (meaning the "Go to HTML" button is visible and active).
             */
            function updateGoToHtmlButtonColor() {
                // This function is called when the rich text panel is visible and the "Go to HTML" button is active.
                // Its color should reflect the state of toggleAutoCleanMsoOnSwitchRichText.
                if (toggleAutoCleanMsoOnSwitchRichText.checked) {
                    toggleEditorViewBtnRichText.classList.remove('bg-cyan-700', 'hover:bg-cyan-800', 'bg-slate-800', 'hover:bg-slate-700');
                    toggleEditorViewBtnRichText.classList.add('bg-green-600', 'hover:bg-green-700');
                } else {
                    toggleEditorViewBtnRichText.classList.remove('bg-green-600', 'hover:bg-green-700', 'bg-slate-800', 'hover:bg-slate-700');
                    toggleEditorViewBtnRichText.classList.add('bg-cyan-700', 'hover:bg-cyan-800');
                }
            }

            /**
             * Updates the state of the "Clean Mso" button based on the "Auto-Clean MSO" toggle.
             */
            function updateCleanMsoButtonState() {
                const isAutoCleanEnabled = toggleAutoCleanMsoOnSwitchRichText.checked; // Check any of the synced toggles
                if (isAutoCleanEnabled) {
                    cleanMsoBtn.disabled = true;
                    cleanMsoBtn.classList.remove('bg-blue-700', 'hover:bg-blue-800');
                    cleanMsoBtn.classList.add('bg-gray-400', 'cursor-not-allowed', 'opacity-60');
                } else {
                    cleanMsoBtn.disabled = false;
                    cleanMsoBtn.classList.remove('bg-gray-400', 'cursor-not-allowed', 'opacity-60');
                    cleanMsoBtn.classList.add('bg-blue-700', 'hover:bg-blue-800');
                }
            }

            /**
             * Simple debounce function.
             * @param {Function} func The function to debounce.
             * @param {number} delay The delay in milliseconds.
             * @returns {Function} The debounced function.
             */
            function debounce(func, delay) {
                let timeout;
                return function(...args) {
                    const context = this;
                    clearTimeout(timeout);
                    timeout = setTimeout(() => func.apply(context, args), delay);
                };
            }

            // Debounced version of monacoEditorInstance.layout() for window resize
            const debouncedMonacoLayout = debounce(() => {
                if (monacoEditorInstance) {
                    monacoEditorInstance.layout();
                }
            }, 200); // Debounce for window resize, not internal panel resize

            /**
             * Displays a modal dialog with a given title and HTML content.
             * Note: This `showModal` function is specifically for the Colophon, and is distinct from `showFootnoteModal`.
             * @param {string} title - The title of the modal.
             * @param {string} contentHtml - The HTML content for the modal body.
             * @param {HTMLElement} triggeringButton - The button that opened this modal.
             * @param {string} originalButtonText - The original text of the triggering button before "Opening...".
             */
            function showModal(title, contentHtml, triggeringButton, originalButtonText) {
                const modalOverlay = document.createElement('div');
                modalOverlay.className = 'modal-overlay';
                modalOverlay.innerHTML = `
                <div class="modal-content">
                    <h3>${title}</h3>
                    <div id="modalBody">${contentHtml}</div>
                    <div class="flex justify-end mt-4 space-x-2">
                        <button id="modalCancelBtn" class="px-4 py-2 bg-gray-500 text-white rounded-md hover:bg-gray-600">Cancel</button>
                        <button id="modalInsertBtn" class="px-4 py-2 bg-green-600 text-white rounded-md hover:bg-green-700">Insert</button>
                    </div>
                </div>
            `;
                document.body.appendChild(modalOverlay);

                // Function to clean up and re-enable buttons
                function closeModalAndReEnableButtons() {
                    modalOverlay.remove();
                    triggeringButton.removeAttribute('data-temp-active'); // Crucial: Remove flag
                    // Directly revert the button text and color here
                    triggeringButton.textContent = originalButtonText;
                    triggeringButton.classList.remove('bg-green-500', 'hover:bg-green-600');
                    triggeringButton.classList.add('bg-slate-600', 'hover:bg-slate-500');
                    updateAllInteractiveButtonStates(); // Re-enable all buttons
                }


                document.getElementById('modalCancelBtn').addEventListener('click', closeModalAndReEnableButtons);

                // Get references to elements within the newly created modal
                const langEnglishBtn = document.getElementById('langEnglishBtn');
                const langFrenchBtn = document.getElementById('langFrenchBtn');
                const monarchKingBtn = document.getElementById('monarchKingBtn');
                const monarchQueenBtn = document.getElementById('monarchQueenBtn');
                const idISBNBtn = document.getElementById('idISBNBtn');
                const idISSNBtn = document.getElementById('idISSNBtn');
                const colophonYearInput = document.getElementById('colophonYear');
                const colophonNumberInput = document.getElementById('colophonNumber'); // Reference for the number input
                const modalInsertBtn = document.getElementById('modalInsertBtn');

                let selectedLanguage = 'English'; // Default to English
                let selectedMonarch = 'King'; // Default
                let selectedIdentifier = 'ISBN'; // Default

                // Function to update button active state
                function updateButtonActiveState(buttons, activeBtn) {
                    buttons.forEach(btn => {
                        btn.classList.remove('active', 'bg-indigo-600'); /* Changed */
                        btn.classList.add('bg-gray-600', 'hover:bg-gray-500'); /* Changed */
                    });
                    activeBtn.classList.add('active', 'bg-indigo-600'); /* Changed */
                    activeBtn.classList.remove('bg-gray-600', 'hover:bg-gray-500'); /* Changed */
                }

                // Initial active states
                updateButtonActiveState([langEnglishBtn, langFrenchBtn], langEnglishBtn);
                updateButtonActiveState([monarchKingBtn, monarchQueenBtn], monarchKingBtn);
                updateButtonActiveState([idISBNBtn, idISSNBtn], idISBNBtn);

                // Event listeners for language buttons
                langEnglishBtn.addEventListener('click', () => {
                    selectedLanguage = 'English';
                    updateButtonActiveState([langEnglishBtn, langFrenchBtn], langEnglishBtn);
                });

                langFrenchBtn.addEventListener('click', () => {
                    selectedLanguage = 'French';
                    updateButtonActiveState([langEnglishBtn, langFrenchBtn], langFrenchBtn);
                });

                // Event listeners for Monarch toggle
                monarchKingBtn.addEventListener('click', () => {
                    selectedMonarch = 'King';
                    updateButtonActiveState([monarchKingBtn, monarchQueenBtn], monarchKingBtn);
                });

                monarchQueenBtn.addEventListener('click', () => {
                    selectedMonarch = 'Queen';
                    updateButtonActiveState([monarchKingBtn, monarchQueenBtn], monarchQueenBtn);
                });

                // Event listeners for ISBN/ISSN toggle
                idISBNBtn.addEventListener('click', () => {
                    selectedIdentifier = 'ISBN';
                    updateButtonActiveState([idISBNBtn, idISSNBtn], idISBNBtn);
                });

                idISSNBtn.addEventListener('click', () => {
                    selectedIdentifier = 'ISSN';
                    updateButtonActiveState([idISBNBtn, idISSNBtn], idISSNBtn);
                });

                // Year input validation
                colophonYearInput.addEventListener('input', (event) => {
                    const input = event.target;
                    // Remove any non-digit characters
                    input.value = input.value.replace(/\D/g, '');
                    // Truncate to 4 digits if longer
                    if (input.value.length > 4) {
                        input.value = input.value.substring(0, 4);
                    }
                });

                // Insert button logic
                modalInsertBtn.addEventListener('click', () => {
                    const currentYear = new Date().getFullYear();
                    const year = colophonYearInput.value || currentYear;
                    const number = colophonNumberInput.value || '###';
                    let colophonHtmlContent = `<section id="colophon">\n<p class="mrgn-tp-lg text-center small">© `;

                    if (selectedLanguage === 'English') {
                        if (selectedMonarch === 'King') {
                            colophonHtmlContent += `His Majesty the King in Right of Canada, represented by the President of the Treasury Board, ${year},<br>${selectedIdentifier}:&#160;${number}</p>\n</section>`;
                        } else { // Queen
                            colophonHtmlContent += `Her Majesty the Queen in Right of Canada, represented by the President of the Treasury Board, ${year},<br>${selectedIdentifier}:&#160;${number}</p>\n</section>`;
                        }
                    } else { // French
                        if (selectedMonarch === 'King') {
                            colophonHtmlContent += `Sa Majesté le Roi du chef du Canada, représenté par le président du Conseil du Trésor, ${year},<br>${selectedIdentifier}&#160;:&#160;${number}</p>\n</section>`;
                        } else { // Queen
                            colophonHtmlContent += `Sa Majesté la Reine du chef du Canada, représentée par le président du Conseil du Conseil du Trésor, ${year},<br>${selectedIdentifier}&#160;:&#160;${number}</p>\n</section>`;
                        }
                    }

                    // Insert the generated HTML into the Monaco editor
                    if (monacoEditorInstance) {
                        let currentContent = monacoEditorInstance.getValue();
                        currentContent = protectDataAttributes(currentContent); // Protect attributes before string manipulation

                        // Append the new colophon HTML
                        currentContent += colophonHtmlContent;

                        currentContent = restoreDataAttributes(currentContent); // Restore attributes
                        currentContent = convertAllEntitiesToNumeric(currentContent); // Ensure entities are correct after all operations

                        monacoEditorInstance.setValue(currentContent);
                        htmlOutputContent = currentContent; // Update main content variable
                        applyEntityHighlighting(); // Re-apply highlighting
                    }

                    closeModalAndReEnableButtons(); // Cleanup and re-enable immediately

                    // Capture originalButtonText in a local constant for the setTimeout closure
                    const capturedOriginalText = originalButtonText;

                    // Provide visual feedback for the triggering button only after successful insert
                    triggeringButton.textContent = 'Inserted!';
                    triggeringButton.classList.add('bg-green-500', 'hover:bg-green-600');
                    triggeringButton.classList.remove('bg-slate-600', 'hover:bg-slate-500');
                    // The disabled state is managed by updateAllInteractiveButtonStates()
                    setTimeout(() => {
                        triggeringButton.textContent = capturedOriginalText; // Revert to initial text
                        triggeringButton.classList.remove('bg-green-500', 'hover:bg-green-600');
                        triggeringButton.classList.add('bg-slate-600', 'hover:bg-slate-500');
                    }, 1500);
                });
            }

            /**
             * Displays a modal dialog for configuring and inserting footnote lists.
             * @param {HTMLElement} triggeringButton - The button that opened this modal.
             * @param {string} originalButtonText - The original text of the triggering button.
             */
            function showFootnoteModal(triggeringButton, originalButtonText) {
                const footnoteContentHtml = `
                <div class="flex flex-col space-y-4">
				<div>
				<p>NOTE: This only creates an empty list of footnotes, you must populate it on your own. It also does not add/change anchors. 
				</div>
                    <div>
                        <span class="text-sm font-medium text-gray-200 mr-2">Language:</span>
                        <div class="button-group inline-flex">
                            <button id="fnLangEnglishBtn" class="px-3 py-1 text-sm bg-gray-600 text-white rounded-md hover:bg-gray-500 focus:outline-none focus:ring-2 focus:ring-slate-500 focus:ring-opacity-50 font-bold">English</button>
                            <button id="fnLangFrenchBtn" class="px-3 py-1 text-sm bg-gray-600 text-white rounded-md hover:bg-gray-500 focus:outline-none focus:ring-2 focus:ring-slate-500 focus:ring-opacity-50 font-bold">French</button>
                        </div>
                    </div>
                    
                    <div>
                        <label for="fnCount" class="block text-sm font-medium text-gray-200">How many?</label>
                        <input type="number" id="fnCount" class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500" placeholder="1" min="1" value="1">
                    </div>
					<div>
                        <label for="fnIdPrefix" class="block text-sm font-medium text-gray-200">ID Prefix (optional):</label>
                        <input type="text" id="fnIdPrefix" class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500" placeholder="e.g., mydoc-">
					</div>
                </div>
            `;

                const modalOverlay = document.createElement('div');
                modalOverlay.className = 'modal-overlay';
                modalOverlay.innerHTML = `
                <div class="modal-content">
                    <h3>Insert Footnote List</h3>
                    <div id="modalBody">${footnoteContentHtml}</div>
                    <div class="flex justify-end mt-4 space-x-2">
                        <button id="modalCancelFnBtn" class="px-4 py-2 bg-gray-500 text-white rounded-md hover:bg-gray-600">Cancel</button>
                        <button id="modalInsertFnBtn" class="px-4 py-2 bg-green-600 text-white rounded-md hover:bg-green-700">Insert</button>
                    </div>
                </div>
            `;
                document.body.appendChild(modalOverlay);

                // Function to clean up and re-enable buttons
                function closeModalAndReEnableButtons() {
                    modalOverlay.remove();
                    triggeringButton.removeAttribute('data-temp-active'); // Crucial: Remove flag
                    triggeringButton.textContent = originalButtonText; // Revert immediately
                    triggeringButton.classList.remove('bg-green-500', 'hover:bg-green-600');
                    triggeringButton.classList.add('bg-slate-600', 'hover:bg-slate-500');
                    updateAllInteractiveButtonStates(); // Re-enable all buttons
                }

                document.getElementById('modalCancelFnBtn').addEventListener('click', closeModalAndReEnableButtons);

                const fnLangEnglishBtn = document.getElementById('fnLangEnglishBtn');
                const fnLangFrenchBtn = document.getElementById('fnLangFrenchBtn');
                const fnIdPrefixInput = document.getElementById('fnIdPrefix');
                const fnCountInput = document.getElementById('fnCount');
                const modalInsertFnBtn = document.getElementById('modalInsertFnBtn');

                let selectedFnLanguage = 'English';

                // Helper for button active state in modal
                function updateFnButtonActiveState(buttons, activeBtn) {
                    buttons.forEach(btn => {
                        btn.classList.remove('active', 'bg-indigo-600'); /* Changed */
                        btn.classList.add('bg-gray-600', 'hover:bg-gray-500'); /* Changed */
                    });
                    activeBtn.classList.add('active', 'bg-indigo-600'); /* Changed */
                    activeBtn.classList.remove('bg-gray-600', 'hover:bg-gray-500'); /* Changed */
                }

                updateFnButtonActiveState([fnLangEnglishBtn, fnLangFrenchBtn], fnLangEnglishBtn);

                fnLangEnglishBtn.addEventListener('click', () => {
                    selectedFnLanguage = 'English';
                    updateFnButtonActiveState([fnLangEnglishBtn, fnLangFrenchBtn], fnLangEnglishBtn);
                });

                fnLangFrenchBtn.addEventListener('click', () => {
                    selectedFnLanguage = 'French';
                    updateFnButtonActiveState([fnLangEnglishBtn, fnLangFrenchBtn], fnLangFrenchBtn);
                });

                // Ensure number input only accepts digits
                fnCountInput.addEventListener('input', (event) => {
                    const input = event.target;
                    input.value = input.value.replace(/\D/g, ''); // Remove non-digits
                    if (input.value === '') {
                        input.value = '1'; // Default to 1 if cleared
                    }
                });

                modalInsertFnBtn.addEventListener('click', () => {
                    const idPrefix = fnIdPrefixInput.value.trim();
                    const footnoteCount = parseInt(fnCountInput.value) || 1; // Default to 1

                    // Capture originalButtonText in a local constant for the setTimeout closure
                    const capturedOriginalText = originalButtonText;

                    let footnoteHtmlContent = `<aside class="wb-fnote" role="note">\n`;
                    footnoteHtmlContent += `\t<h2 id="${idPrefix}fn">${selectedFnLanguage === 'English' ? 'Footnotes' : 'Notes en bas de page'}</h2>\n`;
                    footnoteHtmlContent += `\t<dl>\n`;

                    for (let i = 1; i <= footnoteCount; i++) {
                        const dtText = selectedFnLanguage === 'English' ? `Footnote ${i}` : `Note en bas de page ${i}`;
                        const ddContent = selectedFnLanguage === 'English' ? `ENG footnote ${i} content.` : `FRA footnote ${i} content.`;
                        const returnTextInv = selectedFnLanguage === 'English' ? `Return to footnote ` : `Retour à la référence de la note en bas de page `;
                        const returnTextRef = selectedFnLanguage === 'English' ? ` referrer` : ``;

                        footnoteHtmlContent += `\t\t<dt>${dtText}</dt>\n`;
                        footnoteHtmlContent += `\t\t<dd id="${idPrefix}fn${i}">\n`;
                        footnoteHtmlContent += `\t\t\t<p>${ddContent}</p>\n`;
                        footnoteHtmlContent += `\t\t\t<p class="fn-rtn"> <a href="#${idPrefix}fn${i}-rf"><span class="wb-inv">${returnTextInv}</span>${i}<span class="wb-inv">${returnTextRef}</span></a> </p>\n`;
                        footnoteHtmlContent += `\t\t</dd>\n`;
                    }

                    footnoteHtmlContent += `\t</dl>\n`;
                    footnoteHtmlContent += `</aside>\n`;

                    if (monacoEditorInstance) {
                        let currentContent = monacoEditorInstance.getValue();
                        currentContent = protectDataAttributes(currentContent); // Protect attributes

                        // Find the insertion point: before any section with 'colophon' in its ID
                        const colophonSectionMatch = currentContent.match(/<section[^>]*id=["'][^"']*colophon[^"']*["'][^>]*>/i);
                        let insertionIndex = -1;

                        if (colophonSectionMatch) {
                            insertionIndex = currentContent.indexOf(colophonSectionMatch[0]);
                        }

                        if (insertionIndex !== -1) {
                            // Insert the footnote HTML before the colophon section
                            currentContent = currentContent.substring(0, insertionIndex) + footnoteHtmlContent + currentContent.substring(insertionIndex);
                        } else {
                            // If no colophon section, append to the end of the body just before </body>
                            const bodyEndTagIndex = currentContent.lastIndexOf('</body>');
                            if (bodyEndTagIndex !== -1) {
                                currentContent = currentContent.substring(0, bodyEndTagIndex) + footnoteHtmlContent + '\n' + currentContent.substring(bodyEndTagIndex);
                            } else {
                                currentContent += footnoteHtmlContent; // Fallback to simply appending
                            }
                        }

                        currentContent = restoreDataAttributes(currentContent); // Restore attributes
                        currentContent = convertAllEntitiesToNumeric(currentContent); // Ensure entities are correct after all operations

                        monacoEditorInstance.setValue(currentContent);
                        htmlOutputContent = currentContent;
                        applyEntityHighlighting();
                    }

                    closeModalAndReEnableButtons(); // Cleanup and re-enable immediately

                    // Provide visual feedback for the button after successful insert
                    triggeringButton.textContent = 'Inserted!';
                    triggeringButton.classList.add('bg-green-500', 'hover:bg-green-600');
                    triggeringButton.classList.remove('bg-slate-600', 'hover:bg-slate-500'); /* Changed */
                    // The disabled state is managed by updateAllInteractiveButtonStates()
                    setTimeout(() => {
                        triggeringButton.textContent = capturedOriginalText; // Use the captured variable
                        triggeringButton.classList.remove('bg-green-500', 'hover:bg-green-600');
                        triggeringButton.classList.add('bg-slate-600', 'hover:bg-slate-500');
                    }, 1500);
                });
            }
            /**
             * Displays the Regex Guide modal dialog.
             * @param {HTMLElement} triggeringButton - The button that opened this modal.
             * @param {string} originalButtonText - The original text of the triggering button.
             */
            function showRegexGuideModal(triggeringButton, originalButtonText) {
                const regexGuideContentHtml = `
        <p class="mb-4">Regular expressions are patterns used to match character combinations in strings. Here are some common metacharacters:</p>
        
            <p><code class="font-bold">.</code> : Matches any single character (except newline).</p>
            <p><code class="font-bold">\\d</code> : Matches any digit (0-9).</p>
            <p><code class="font-bold">\\D</code> : Matches any non-digit character.</p>
            <p><code class="font-bold">\\w</code> : Matches any word character (alphanumeric and underscore).</p>
            <p><code class="font-bold">\\W</code> : Matches any non-word character.</p>
            <p><code class="font-bold">\\s</code> : Matches any whitespace character (space, tab, newline).</p>
            <p><code class="font-bold">\\S</code> : Matches any non-whitespace character.</p>
            <p><code class="font-bold">\\b</code> : Matches a word boundary.</p>
            <p><code class="font-bold">\\B</code> : Matches a non-word boundary.</p>
            <p><code class="font-bold">^</code> : Matches the beginning of the string.</p>
            <p><code class="font-bold">$</code> : Matches the end of the string.</p>
            <p><code class="font-bold">*</code> : Matches the previous character zero or more times.</p>
            <p><code class="font-bold">+</code> : Matches the previous character one or more times.</p>
            <p><code class="font-bold">?</code> : Matches the previous character zero or one time (also for non-greedy matching).</p>
            <p><code class="font-bold">{n}</code> : Matches the previous character exactly 'n' times.</p>
            <p><code class="font-bold">{n,}</code> : Matches the previous character 'n' or more times.</p>
            <p><code class="font-bold">{n,m}</code> : Matches the previous character between 'n' and 'm' times.</p>
            <p><code class="font-bold">[abc]</code> : Matches any one of the characters inside the brackets.</p>
            <p><code class="font-bold">[^abc]</code> : Matches any character NOT inside the brackets.</p>
            <p><code class="font-bold">(x|y)</code> : Matches either 'x' or 'y'.</p>
            <p><code class="font-bold">(...)</code> : Capturing group.</p>
            <p><code class="font-bold">\\n</code> : Backreference to the n-th capturing group.</p>
            <p><code class="font-bold">|</code> : OR operator.</p>
            <p><code class="font-bold">\\\\</code> : Escapes a special character (e.g., '\.' to match a literal dot).</p>
    `;

                const modalOverlay = document.createElement('div');
                modalOverlay.className = 'modal-overlay'; // Use your existing modal-overlay class
                modalOverlay.innerHTML = `
        <div class="modal-content regex-guide-modal-content">
            <h3>Regex Guide</h3> <!-- Changed from h2 to h3 to match other modals' titles -->
            <div id="modalBody">${regexGuideContentHtml}</div>
            <div class="flex justify-end mt-4 space-x-2">
                <button id="modalCloseRegexBtn" class="px-4 py-2 bg-gray-500 text-white rounded-md hover:bg-gray-600">Close</button>
            </div>
        </div>
    `;
                document.body.appendChild(modalOverlay);

                // Function to clean up and re-enable buttons
                function closeModalAndReEnableButtons() {
                    modalOverlay.remove();
                    triggeringButton.removeAttribute('data-temp-active'); // Crucial: Remove flag
                    triggeringButton.textContent = originalButtonText; // Revert immediately
                    triggeringButton.classList.remove('bg-green-500', 'hover:bg-green-600');
                    triggeringButton.classList.add('bg-gray-600', 'hover:bg-gray-700'); // Revert to original gray button style
                    updateAllInteractiveButtonStates(); // Re-enable all buttons
                }

                document.getElementById('modalCloseRegexBtn').addEventListener('click', closeModalAndReEnableButtons);

                // Close modal if clicked outside content
                modalOverlay.addEventListener('click', (event) => {
                    if (event.target === modalOverlay) {
                        closeModalAndReEnableButtons();
                    }
                });

                // Provide immediate visual feedback for the triggering button
                triggeringButton.textContent = 'Opening...';
                triggeringButton.classList.add('bg-green-500', 'hover:bg-green-600');
                triggeringButton.classList.remove('bg-gray-600', 'hover:bg-gray-700'); // Change to green immediately
                triggeringButton.setAttribute('data-temp-active', 'true'); // Set the flag
                updateAllInteractiveButtonStates(); // Disable all buttons
            }
            /**
             * Displays a modal dialog for Auto-ID options.
             * @param {HTMLElement} triggeringButton - The button that opened this modal.
             * @param {string} originalButtonText - The original text of the triggering button.
             */
            function showAutoIdModal(triggeringButton, originalButtonText) {
                const autoIdContentHtml = `
                <div class="flex flex-col space-y-4">
                    <div>
                        <span class="text-sm font-medium text-CBD5E1 mr-2">Choose elements to ID:</span> <!-- Changed text color -->
                        <div class="space-y-2 mt-2">
                            <!-- Section Toggle -->
                            <div class="toggle-switch-container">
                                <label class="toggle-switch is-checked" for="toggleSectionsId">
                                    <input type="checkbox" id="toggleSectionsId" checked>
                                    <span class="toggle-switch-slider"></span>
                                </label>
                                <span class="toggle-switch-label text-white text-sm">Sections (sec#)</span>
                            </div>
                            <!-- Headings Toggle -->
                            <div class="toggle-switch-container">
                                <label class="toggle-switch is-checked" for="toggleHeadingsId">
                                    <input type="checkbox" id="toggleHeadingsId" checked>
                                    <span class="toggle-switch-slider"></span>
                                </label>
                                <span class="toggle-switch-label text-white text-sm">Headings (toc#)</span>
                            </div>
                            <!-- NEW: Figures Toggle -->
                            <div class="toggle-switch-container">
                                <label class="toggle-switch is-checked" for="toggleFiguresId">
                                    <input type="checkbox" id="toggleFiguresId" checked>
                                    <span class="toggle-switch-slider"></span>
                                </label>
                                <span class="toggle-switch-label text-white text-sm">Figures (fig#)</span>
                            </div>
                            <!-- Tables Toggle (OFF by default) -->
                            <div class="toggle-switch-container">
                                <label class="toggle-switch" for="toggleTablesId">
                                    <input type="checkbox" id="toggleTablesId">
                                    <span class="toggle-switch-slider"></span>
                                </label>
                                <span class="toggle-switch-label text-white text-sm">Tables (tbl#)</span>
                            </div>
                            <!-- Figure Tables Toggle (OFF by default) -->
                            <div class="toggle-switch-container">
                                <label class="toggle-switch" for="toggleFigureTablesId">
                                    <input type="checkbox" id="toggleFigureTablesId">
                                    <span class="toggle-switch-slider"></span>
                                </label>
                                <span class="toggle-switch-label text-white text-sm">Figure Tables (ftbl#)</span>
                            </div>
                        </div>
                    </div>
                </div>
            `;

                const modalOverlay = document.createElement('div');
                modalOverlay.className = 'modal-overlay';
                modalOverlay.innerHTML = `
                <div class="modal-content">
                    <h3>Element ID's Options</h3> <!-- Changed title -->
                    <div id="modalBody">${autoIdContentHtml}</div>
                    <div class="flex justify-end mt-4 space-x-2">
                        <button id="modalCancelAutoIdBtn" class="px-4 py-2 bg-gray-500 text-white rounded-md hover:bg-gray-600">Cancel</button> <!-- Changed bg -->
                        <button id="modalApplyAutoIdBtn" class="px-4 py-2 bg-green-600 text-white rounded-md hover:bg-green-700">Apply IDs</button> <!-- Changed bg -->
                    </div>
                </div>
            `;
                document.body.appendChild(modalOverlay);

                // Function to clean up and re-enable buttons
                function closeModalAndReEnableButtons() {
                    modalOverlay.remove();
                    triggeringButton.removeAttribute('data-temp-active'); // Crucial: Remove flag
                    triggeringButton.textContent = originalButtonText; // Revert immediately
                    triggeringButton.classList.remove('bg-green-500', 'hover:bg-green-600');
                    triggeringButton.classList.add('bg-slate-600', 'hover:bg-slate-500'); /* Changed */
                    updateAllInteractiveButtonStates(); // Re-enable all buttons
                }

                document.getElementById('modalCancelAutoIdBtn').addEventListener('click', closeModalAndReEnableButtons);

                // Get references to elements within the newly created modal
                const toggleSectionsId = document.getElementById('toggleSectionsId');
                const toggleHeadingsId = document.getElementById('toggleHeadingsId');
                const toggleFiguresId = document.getElementById('toggleFiguresId'); // NEW: Figures toggle
                const toggleTablesId = document.getElementById('toggleTablesId');
                const toggleFigureTablesId = document.getElementById('toggleFigureTablesId');
                const modalApplyAutoIdBtn = document.getElementById('modalApplyAutoIdBtn');

                // Event listeners for pill switches
                [toggleSectionsId, toggleHeadingsId, toggleFiguresId, toggleTablesId, toggleFigureTablesId].forEach(toggle => { // Added toggleFiguresId
                    toggle.addEventListener('change', (event) => {
                        const parentLabel = event.target.closest('.toggle-switch');
                        if (event.target.checked) {
                            parentLabel.classList.add('is-checked');
                        } else {
                            parentLabel.classList.remove('is-checked');
                        }
                    });
                });

                modalApplyAutoIdBtn.addEventListener('click', () => {
                    const options = {
                        idSections: toggleSectionsId.checked,
                        idHeadings: toggleHeadingsId.checked,
                        idFigures: toggleFiguresId.checked, // NEW: Pass figures option
                        idTables: toggleTablesId.checked,
                        idFigureTables: toggleFigureTablesId.checked
                    };

                    if (monacoEditorInstance) {
                        let currentContent = monacoEditorInstance.getValue();
                        currentContent = protectDataAttributes(currentContent);
                        currentContent = applyAutoId(currentContent, options); // Pass options to applyAutoId
                        currentContent = restoreDataAttributes(currentContent);
                        currentContent = convertAllEntitiesToNumeric(currentContent);
                        monacoEditorInstance.setValue(currentContent);
                        htmlOutputContent = currentContent;
                        applyEntityHighlighting();

                        closeModalAndReEnableButtons(); // Cleanup and re-enable immediately

                        // Capture originalButtonText in a local constant for the setTimeout closure
                        const capturedOriginalText = originalButtonText;

                        // Provide visual feedback for the main Auto-ID button
                        triggeringButton.textContent = 'ID\'d!';
                        triggeringButton.classList.add('bg-green-500', 'hover:bg-green-600');
                        triggeringButton.classList.remove('bg-slate-600', 'hover:bg-slate-500'); /* Changed */
                        // The disabled state is managed by updateAllInteractiveButtonStates()
                        setTimeout(() => {
                            triggeringButton.textContent = capturedOriginalText; // Revert to initial text
                            triggeringButton.classList.remove('bg-green-500', 'hover:bg-green-600');
                            triggeringButton.classList.add('bg-slate-600', 'hover:bg-slate-500'); /* Changed */
                        }, 1500);
                    }
                });
            }

            // Array of Quick Formatting toggle inputs
            const quickFormattingToggles = [
                toggleCleanSpaces, toggleCleanUrls, toggleTimeTags, toggleFixFnIds,
                toggleCleanSingleBreaks, toggleCleanPTables, toggleCleanFormattingTags, // Added toggleCleanPTables
                toggleAutoLevelHeadings, toggleAutoSection
            ];

            /**
             * Updates the disabled state of the Format button based on selected quick formatting options.
             */
            function updateFormatButtonState() {
                const anySelected = quickFormattingToggles.some(toggle => toggle.checked);
                if (anySelected) {
                    formatSelectedBtn.disabled = false;
                    formatSelectedBtn.classList.remove('bg-gray-400', 'cursor-not-allowed', 'opacity-60');
                    formatSelectedBtn.classList.add('bg-blue-600', 'hover:bg-blue-700');
                } else {
                    formatSelectedBtn.disabled = true;
                    formatSelectedBtn.classList.remove('bg-blue-600', 'hover:bg-blue-700');
                    formatSelectedBtn.classList.add('bg-gray-400', 'cursor-not-allowed', 'opacity-60');
                }
            }

            /**
             * Performs auto-encoding of HTML entities to numeric entities.
             * This function is now reusable by both the "Auto-Encode" button and the "Format" button.
             * @param {string} htmlContent - The HTML content to encode.
             * @returns {string} The encoded HTML content.
             */
            function doAutoEncode(htmlContent) {
                let processedContent = protectDataAttributes(htmlContent);
                processedContent = convertAllEntitiesToNumeric(processedContent);
                processedContent = restoreDataAttributes(processedContent);
                return processedContent;
            }

            // Initialize and set up event listeners on window load
            window.onload = function() {
                console.log("Parent window.onload triggered.");
                // Initial setup: Ensure rich text panel is visible and code panel is hidden
                richtextOutputPanel.classList.add('panel-visible');
                mainEditorArea.classList.add('panel-hidden'); // Hide main editor area initially

                // Set initial button styles based on default view (richtext)
                // The "Go to HTML" button is visible initially, so its color depends on the Mso toggle.
                // The "Go to Rich-Text" button is hidden initially, so it should have its default cyan color.
                toggleEditorViewBtnCode.classList.add('bg-cyan-700', 'hover:bg-cyan-800');
                toggleEditorViewBtnCode.classList.remove('bg-cyan-700', 'hover:bg-cyan-800', 'bg-slate-800', 'hover:bg-slate-700'); /* Changed */
                updateGoToHtmlButtonColor(); // Call to set initial color for "Go to HTML" button

                // Initialize Monaco Editor
                require.config({
                    paths: {
                        'vs': 'https://cdn.jsdelivr.net/npm/monaco-editor@0.52.2/min/vs'
                    }
                });
                require(['vs/editor/editor.main'], function() {
                    monaco.languages.html.htmlDefaults.setOptions({
                        // Add your custom options here, for example:
                        //	  tabSize: 4,
                        //    insertSpaces: true,
                        //    scrollBeyondLastLine: false,
                        //    wordWrap: 'on',
                        //    wrappingIndent: 'same',
                        wrapLineLength: 500,
                    });
                    monacoEditorInstance = monaco.editor.create(monacoEditorContainer, { // Use monacoEditorContainer here
                        value: htmlOutputContent, // Set initial content
                        language: 'html',
                        theme: 'vs-dark', // Or 'hc-black'
                        automaticLayout: true, // Important for responsiveness
                        minimap: {
                            enabled: true
                        },
                        fontSize: 14,
                        tabSize: 4,
                        insertSpaces: true,
                        // Additional options for better UX
                        scrollBeyondLastLine: false,
                        wordWrap: 'on',
                        wrappingIndent: 'same',
                    });
                    console.log("Monaco editor initialized.");

                    // --- START: MODIFICATION FOR UNDO/REDO ---

                    // 1. Initialize the Undo Manager with the editor's starting content.
                    recordState(monacoEditorInstance.getValue());
                    updateUndoRedoButtons(); // Set initial button states.

                    // 2. Create a debounced function to record state after typing stops.
                    const debouncedRecordState = debounce(() => {
                        recordState(monacoEditorInstance.getValue());
                    }, 500); // 500ms delay

                    monacoEditorInstance.onDidChangeModelContent(() => {
                        // Update the main content variable first
                        htmlOutputContent = monacoEditorInstance.getValue();

                        // --- Trigger functions that need to run on content change ---

                        // 1. For the Undo/Redo Manager
                        // Only record a new state if the change isn't from an undo/redo operation.
                        if (!isUndoingOrRedoing) {
                            debouncedRecordState();
                        }

                        // 2. For highlighting HTML entities (like &nbsp;)
                        applyEntityHighlighting();

                        // 3. For the "Better Search" feature to update its dropdowns and state
                        populateTagDropdown();
                        populateIdDropdown();
                        resetSearchState(true);
                    });
                    // =========================================================================


                    // Apply initial highlighting after Monaco is created
                    applyEntityHighlighting();


                    // Ensure Monaco refreshes layout on window resize
                    window.addEventListener('resize', debouncedMonacoLayout);

                    // --- START PASTED JAVASCRIPT FROM BETTER-SEARCH.HTML ---
                    // Get references to the DOM elements (adjust 'editor' to 'monacoEditorInstance')
                    const findInput = document.getElementById('find-input');
                    const replaceInput = document.getElementById('replace-input');
                    const findNextButton = document.getElementById('find-next-button');
                    const findPreviousButton = document.getElementById('find-previous-button');
                    const replaceOneButton = document.getElementById('replace-one-button');
                    const replaceAllButton = document.getElementById('replace-all-button');
                    const tagDropdown = document.getElementById('target-tag-dropdown');
                    const idDropdown = document.getElementById('target-id-dropdown');
                    const enableRegexCheckbox = document.getElementById('enable-regex');
                    const matchCaseCheckbox = document.getElementById('match-case');
                    const highlightAllCheckbox = document.getElementById('highlight-all');
                    const sequenceCheckbox = document.getElementById('sequence');
                    const sequenceContainer = document.getElementById('sequence-container');
                    const sequenceRangeContainer = document.getElementById('sequence-range-container');
                    const startIndexInput = document.getElementById('start-index');
                    const endIndexInput = document.getElementById('end-index');
                    const matchCountSpan = document.getElementById('match-count');
                    const regexGuideButton = document.getElementById('regex-guide-button');
                    // Get a reference to the new toggle button
                    const toggleBottomPanel = document.getElementById('toggleBottomPanel');
                    // Get a reference to the container holding all search controls content
                    const searchRegex = document.getElementById('searchRegex'); // Changed ID here!
                    // Get a reference to the outer panel div (for show/hide logic related to the panel itself)
                    const searchAndValidatePanel = document.getElementById('searchAndValidatePanel'); // Keep reference to outer panel
                    // NOW, PUSH regexGuideButton onto the array here, after it's defined
                    allInteractiveButtons.push(regexGuideButton);

                    let allDecorations = [];
                    let allMatches = [];
                    let currentMatchIndex = -1;
                    let currentFindText = '';
                    let currentSelectedId = 'all';
                    let currentSelectedTag = 'all';
                    let currentIsRegex = false;
                    let currentMatchCase = false;



                    // State variable for search controls visibility
                    let searchControlsVisible = true; // Initial state

                    // Function to toggle search controls visibility
                    function toggleSearchControls() {
                        searchControlsVisible = !searchControlsVisible;

                        if (searchControlsVisible) {
                            // Show the inner content
                            searchRegex.classList.remove('search-controls-hidden');
                            searchRegex.classList.add('search-controls-visible');

                            // Show the outer panel (if it was hidden)
                            searchAndValidatePanel.classList.remove('hidden');
                            searchAndValidatePanel.classList.remove('search-controls-hidden'); // In case it was hidden by the previous logic
                            searchAndValidatePanel.classList.add('search-controls-visible'); // Ensure it's visible for the inner content to animate

                            toggleBottomPanel.textContent = 'Hide Panel';
                        } else {
                            // Hide the inner content
                            searchRegex.classList.remove('search-controls-visible');
                            searchRegex.classList.add('search-controls-hidden');

                            // You might want to delay hiding the outer panel's background slightly
                            // or just ensure its padding collapses.
                            // For simplicity, let's just make sure it doesn't take up too much space.
                            // The CSS for search-controls-hidden with !important padding handles this well.

                            toggleBottomPanel.textContent = 'Show Panel';
                        }
                    }

                    // Add event listener to the toggle button
                    toggleBottomPanel.addEventListener('click', toggleSearchControls);

                    // Apply initial state when the page loads
                    // Ensure the main panel is visible if it was initially set to 'hidden' in HTML
                    searchAndValidatePanel.classList.remove('hidden'); // Remove the initial 'hidden' class from searchAndValidatePanel
                    searchRegex.classList.add('search-controls-visible'); // Ensure inner content starts visible

                    /**
                     * Populates the dropdown menu with unique HTML tags from the editor's content.
                     * Preserves the currently selected tag if it still exists.
                     */
                    function populateTagDropdown() {
                        const currentSelection = tagDropdown.value; // Store current selection
                        const editorValue = editor.getValue();
                        const tagRegex = /<(\w+)(?=\s|>)/g;
                        const uniqueTags = new Set();
                        let match;

                        while ((match = tagRegex.exec(editorValue)) !== null) {
                            uniqueTags.add(match[1]);
                        }

                        tagDropdown.innerHTML = '';
                        const defaultOption = document.createElement('option');
                        defaultOption.value = 'all';
                        defaultOption.textContent = 'All Tags';
                        tagDropdown.appendChild(defaultOption);

                        const sortedTags = [...uniqueTags].sort();

                        sortedTags.forEach(tag => {
                            const option = document.createElement('option');
                            option.value = tag;
                            option.textContent = `<${tag}>`;
                            tagDropdown.appendChild(option);
                        });

                        // Restore previous selection if it's still a valid option
                        if (Array.from(tagDropdown.options).some(option => option.value === currentSelection)) {
                            tagDropdown.value = currentSelection;
                        } else {
                            tagDropdown.value = 'all'; // Fallback if old selection is gone
                        }
                    }

                    /**
                     * Populates the dropdown menu with unique HTML IDs from the editor's content.
                     * Preserves the currently selected ID if it still exists.
                     */
                    function populateTagDropdown() {
                        const currentSelection = tagDropdown.value;
                        const editorValue = monacoEditorInstance.getValue(); // Use monacoEditorInstance
                        const tagRegex = /<(\w+)(?=\s|>)/g;
                        const uniqueTags = new Set();
                        let match;

                        while ((match = tagRegex.exec(editorValue)) !== null) {
                            uniqueTags.add(match[1]);
                        }

                        tagDropdown.innerHTML = '';
                        const defaultOption = document.createElement('option');
                        defaultOption.value = 'all';
                        defaultOption.textContent = 'All Tags';
                        tagDropdown.appendChild(defaultOption);

                        const sortedTags = [...uniqueTags].sort();

                        sortedTags.forEach(tag => {
                            const option = document.createElement('option');
                            option.value = tag;
                            option.textContent = `<${tag}>`;
                            tagDropdown.appendChild(option);
                        });

                        if (Array.from(tagDropdown.options).some(option => option.value === currentSelection)) {
                            tagDropdown.value = currentSelection;
                        } else {
                            tagDropdown.value = 'all';
                        }
                    }

                    /**
                     * Populates the dropdown menu with unique HTML IDs from the editor's content.
                     */
                    function populateIdDropdown() {
                        const currentSelection = idDropdown.value;
                        const editorValue = monacoEditorInstance.getValue(); // Use monacoEditorInstance
                        const idRegex = /id="([^"]+)"/g;
                        const uniqueIds = [];
                        const seenIds = new Set();

                        let match;
                        while ((match = idRegex.exec(editorValue)) !== null) {
                            const id = match[1];
                            if (!seenIds.has(id)) {
                                uniqueIds.push(id);
                                seenIds.add(id);
                            }
                        }

                        idDropdown.innerHTML = '';
                        const defaultOption = document.createElement('option');
                        defaultOption.value = 'all';
                        defaultOption.textContent = 'All ID\'s';
                        idDropdown.appendChild(defaultOption);

                        uniqueIds.forEach(id => {
                            const option = document.createElement('option');
                            option.value = id;
                            option.textContent = `#${id}`;
                            idDropdown.appendChild(option);
                        });

                        if (Array.from(idDropdown.options).some(option => option.value === currentSelection)) {
                            idDropdown.value = currentSelection;
                        } else {
                            idDropdown.value = 'all';
                        }
                    }

                    populateTagDropdown();
                    populateIdDropdown();


                    // Function to handle the visibility of the sequence options container
                    function toggleSequenceVisibility() {
                        if (enableRegexCheckbox.checked) {
                            sequenceContainer.classList.remove('max-h-0', 'opacity-0', 'pointer-events-none');
                            sequenceContainer.classList.add('max-h-40', 'opacity-100');
                        } else {
                            sequenceContainer.classList.remove('max-h-40', 'opacity-0', 'pointer-events-none');
                            sequenceContainer.classList.add('max-h-0', 'opacity-0', 'pointer-events-none');
                        }
                    }

                    // Toggle visibility of the sequence range inputs based on the sequence checkbox
                    sequenceCheckbox.addEventListener('change', () => {
                        if (sequenceCheckbox.checked) {
                            sequenceRangeContainer.classList.remove('opacity-0', 'pointer-events-none');
                        } else {
                            sequenceRangeContainer.classList.add('opacity-0', 'pointer-events-none');
                        }
                    });

                    // Function to toggle the regex active border
                    function toggleRegexBorder() {
                        if (enableRegexCheckbox.checked) {
                            findInput.classList.add('regex-active-border');
                            replaceInput.classList.add('regex-active-border');
                        } else {
                            findInput.classList.remove('regex-active-border');
                            replaceInput.classList.remove('regex-active-border');
                        }
                    }

                    // Toggle visibility of the entire sequence container based on the regex checkbox
                    enableRegexCheckbox.addEventListener('change', () => {
                        toggleSequenceVisibility();
                        toggleRegexBorder();
                        resetSearchState(true);
                    });

                    // Initial check for sequence container visibility and regex border
                    toggleSequenceVisibility();
                    toggleRegexBorder();

                    /**
                     * Generates a context string based on selected ID and Tag.
                     */
                    function getContextString() {
                        const selectedId = idDropdown.value;
                        const selectedTag = tagDropdown.value;
                        let contextText = '';

                        if (selectedId !== 'all' && selectedTag !== 'all') {
                            contextText = ` in selected <span class="text-blue-400 font-bold">#${selectedId}</span> and <span class="text-purple-400 font-bold">&lt;${selectedTag}&gt;</span> tags only`;
                        } else if (selectedId !== 'all') {
                            contextText = ` in selected <span class="text-blue-400 font-bold">#${selectedId}</span> only`;
                        } else if (selectedTag !== 'all') {
                            contextText = ` in selected <span class="text-purple-400 font-bold">&lt;${selectedTag}&gt;</span> tags only`;
                        }
                        return contextText;
                    }

                    /**
                     * Finds and returns a list of all matches based on the current search criteria.
                     */
                    function findMatches() {
                        const findText = findInput.value;
                        if (!findText) return [];

                        const selectedId = idDropdown.value;
                        const selectedTag = tagDropdown.value;
                        const isRegex = enableRegexCheckbox.checked;
                        const matchCase = matchCaseCheckbox.checked;
                        const isCaseSensitive = matchCase;
                        const model = monacoEditorInstance.getModel();
                        const editorValue = model.getValue();
                        let matches = [];
                        let searchScopeRange = null; // This will define the overall range for the search

                        // --- Determine the ID-based search scope first ---
                        if (selectedId !== 'all') {
                            const idAttributeRegex = new RegExp(`<(\\w+)([^>]*id="${selectedId}"[^>]*)>`, 'i'); // Capture tagName
                            const idMatch = idAttributeRegex.exec(editorValue);

                            if (idMatch) {
                                const startOffset = idMatch.index;
                                const tagName = idMatch[1];
                                const tagContent = idMatch[2];

                                const isSelfClosing = tagContent.endsWith('/') || ['area', 'base', 'br', 'col', 'embed', 'hr', 'img', 'input', 'link', 'meta', 'param', 'source', 'track', 'wbr'].includes(tagName.toLowerCase());

                                if (isSelfClosing) {
                                    searchScopeRange = new monaco.Range(
                                        model.getPositionAt(startOffset).lineNumber,
                                        model.getPositionAt(startOffset).column,
                                        model.getPositionAt(startOffset + idMatch[0].length).lineNumber,
                                        model.getPositionAt(startOffset + idMatch[0].length).column
                                    );
                                } else {
                                    searchScopeRange = findFullElementRange(model, startOffset);
                                }
                            } else {
                                return []; // ID not found, so no search scope
                            }
                        }

                        // --- Now, refine the search scope further if a tag is selected ---
                        if (selectedTag !== 'all') {
                            let currentSearchAreaRange = searchScopeRange; // Start with ID scope if present, else full document
                            let allRangesToSearch = []; // Collect all ranges for selected tag within the current scope

                            const tagOpeningRegex = new RegExp(`<${selectedTag}([^>]*)>`, 'gi');
                            tagOpeningRegex.lastIndex = currentSearchAreaRange ? model.getOffsetAt(currentSearchAreaRange.getStartPosition()) : 0;

                            let match;
                            while ((match = tagOpeningRegex.exec(editorValue)) !== null) {
                                const matchStartOffset = match.index;
                                const matchEndOffset = match.index + match[0].length;

                                // If a broader scope (like ID scope) is active, ensure this tag is within it
                                if (currentSearchAreaRange) {
                                    const matchStartPos = model.getPositionAt(matchStartOffset);
                                    if (!currentSearchAreaRange.containsPosition(matchStartPos) && matchStartOffset >= model.getOffsetAt(currentSearchAreaRange.getEndPosition())) {
                                        // Optimization: if we've passed the end of the current search area, stop.
                                        break;
                                    }
                                    if (!currentSearchAreaRange.containsPosition(matchStartPos)) {
                                        continue; // Skip if this match is outside the defined scope
                                    }
                                }

                                const elementFullRange = findFullElementRange(model, matchStartOffset);
                                if (elementFullRange) {
                                    allRangesToSearch.push(elementFullRange);
                                }
                            }

                            // If specific tags are selected, concatenate all matches found within those tag ranges
                            if (allRangesToSearch.length > 0) {
                                allRangesToSearch.forEach(range => {
                                    matches.push(...model.findMatches(findText, range, isRegex, isCaseSensitive, null, true));
                                });
                            } else {
                                return []; // No elements of the selected tag type found in the scope
                            }

                        } else {
                            // If only ID is selected, or no filters are applied, perform a search within searchScopeRange
                            const textToSearch = isRegex ? findText : escapeRegExp(findText);
                            matches = model.findMatches(textToSearch, searchScopeRange, isRegex, isCaseSensitive, null, true);
                        }

                        return matches;
                    }

                    // Helper function to find the full range of an HTML element given its opening tag's start offset
                    function findFullElementRange(model, initialStartOffset) {
                        const editorValue = model.getValue();
                        const startPos = model.getPositionAt(initialStartOffset);

                        // 1. Find the opening tag and extract its name and whether it's self-closing
                        // Regex for an opening tag (e.g., <div id="x"> or <img src="y"/>)
                        const openTagMatch = editorValue.substring(initialStartOffset).match(/^<(\w+)([^>]*)>/);
                        if (!openTagMatch) {
                            return null; // Not a valid opening tag at this position
                        }

                        const tagName = openTagMatch[1];
                        const tagContent = openTagMatch[2]; // Attributes and closing part
                        const openTagLength = openTagMatch[0].length;
                        const isSelfClosing = tagContent.endsWith('/') || ['area', 'base', 'br', 'col', 'embed', 'hr', 'img', 'input', 'link', 'meta', 'param', 'source', 'track', 'wbr'].includes(tagName.toLowerCase());

                        if (isSelfClosing) {
                            // For self-closing tags, the range is just the tag itself
                            return new monaco.Range(
                                startPos.lineNumber,
                                startPos.column,
                                model.getPositionAt(initialStartOffset + openTagLength).lineNumber,
                                model.getPositionAt(initialStartOffset + openTagLength).column
                            );
                        }

                        // 2. For paired tags, scan to find the matching closing tag
                        let balance = 1; // Start with 1 for the initial opening tag
                        let currentOffset = initialStartOffset + openTagLength;

                        const openingTagRegex = new RegExp(`<${tagName}([^>]*)>`, 'gi');
                        const closingTagRegex = new RegExp(`<\/${tagName}>`, 'gi');

                        // Reset regex lastIndex to search from currentOffset
                        openingTagRegex.lastIndex = currentOffset;
                        closingTagRegex.lastIndex = currentOffset;

                        let nextOpenMatch = openingTagRegex.exec(editorValue);
                        let nextCloseMatch = closingTagRegex.exec(editorValue);

                        while (balance > 0 && (nextOpenMatch || nextCloseMatch)) {
                            if (nextCloseMatch && (!nextOpenMatch || nextCloseMatch.index < nextOpenMatch.index)) {
                                // Found a closing tag before the next opening tag (or no more opening tags)
                                balance--;
                                currentOffset = nextCloseMatch.index + nextCloseMatch[0].length;
                                if (balance === 0) {
                                    // Found the matching closing tag
                                    return new monaco.Range(
                                        startPos.lineNumber,
                                        startPos.column,
                                        model.getPositionAt(currentOffset).lineNumber,
                                        model.getPositionAt(currentOffset).column
                                    );
                                }
                                // Continue searching from after this closing tag
                                openingTagRegex.lastIndex = currentOffset;
                                closingTagRegex.lastIndex = currentOffset;
                                nextOpenMatch = openingTagRegex.exec(editorValue);
                                nextCloseMatch = closingTagRegex.exec(editorValue);
                            } else if (nextOpenMatch) {
                                // Found an opening tag (nested) before the next closing tag
                                balance++;
                                currentOffset = nextOpenMatch.index + nextOpenMatch[0].length;
                                // Continue searching from after this opening tag
                                openingTagRegex.lastIndex = currentOffset;
                                closingTagRegex.lastIndex = currentOffset;
                                nextOpenMatch = openingTagRegex.exec(editorValue);
                                nextCloseMatch = closingTagRegex.exec(editorValue);
                            } else {
                                // No more opening or closing tags, but balance > 0 (unclosed tag)
                                break;
                            }
                        }

                        // If we reach here, the tag was unclosed or an error occurred.
                        // Highlight from the start of the opening tag to the end of the document
                        // or to the end of the line if that's more appropriate.
                        // For now, let's just highlight the opening tag itself as a fallback
                        return new monaco.Range(
                            startPos.lineNumber,
                            startPos.column,
                            model.getPositionAt(initialStartOffset + openTagLength).lineNumber,
                            model.getPositionAt(initialStartOffset + openTagLength).column
                        );
                    }

                    /**
                     * Updates all decorations (ID highlight and find matches) based on the current state.
                     */
                    function updateDecorations() {
                        const newDecorations = [];
                        const selectedId = idDropdown.value;
                        const selectedTag = tagDropdown.value;
                        const editorValue = monacoEditorInstance.getModel().getValue();
                        const model = monacoEditorInstance.getModel();

                        let idBlockRange = null;

                        // --- ID Highlight Logic ---
                        if (selectedId !== 'all') {
                            const idAttributeRegex = new RegExp(`<(\\w+)([^>]*id="${selectedId}"[^>]*)>`, 'i'); // Capture tagName
                            const idMatch = idAttributeRegex.exec(editorValue);

                            if (idMatch) {
                                const startOffset = idMatch.index;
                                const tagName = idMatch[1]; // Get the tag name (e.g., 'section', 'div')
                                const tagContent = idMatch[2]; // Attributes and closing part (needed for self-closing check)

                                const isSelfClosing = tagContent.endsWith('/') || ['area', 'base', 'br', 'col', 'embed', 'hr', 'img', 'input', 'link', 'meta', 'param', 'source', 'track', 'wbr'].includes(tagName.toLowerCase());

                                if (isSelfClosing) {
                                    // For self-closing tags with ID, just highlight the tag itself
                                    idBlockRange = new monaco.Range(
                                        model.getPositionAt(startOffset).lineNumber,
                                        model.getPositionAt(startOffset).column,
                                        model.getPositionAt(startOffset + idMatch[0].length).lineNumber,
                                        model.getPositionAt(startOffset + idMatch[0].length).column
                                    );
                                } else {
                                    // Use the tag balancing function for paired tags
                                    idBlockRange = findFullElementRange(model, startOffset);
                                }
                            }
                        }

                        if (idBlockRange) {
                            newDecorations.push({
                                range: idBlockRange,
                                options: {
                                    inlineClassName: 'id-highlight'
                                }
                            });
                        }

                        // --- Tag Highlight Logic (with ID scope awareness) ---
                        if (selectedTag !== 'all') {
                            let contentToSearchForTags = editorValue;
                            let baseOffsetForTags = 0;
                            let searchStartOffset = 0; // Where to start searching in editorValue

                            // If an ID is selected AND its block was successfully found,
                            // restrict the tag search to that block's content and adjust baseOffset.
                            if (selectedId !== 'all' && idBlockRange) {
                                searchStartOffset = model.getOffsetAt(new monaco.Position(idBlockRange.startLineNumber, idBlockRange.startColumn));
                                contentToSearchForTags = model.getValueInRange(idBlockRange); // This might not be strictly needed for findFullElementRange
                                baseOffsetForTags = searchStartOffset; // Base offset for ranges found within this content
                            }

                            // Find all occurrences of the selectedTag
                            const tagOpeningRegex = new RegExp(`<${selectedTag}([^>]*)>`, 'gi'); // Find all opening tags
                            tagOpeningRegex.lastIndex = searchStartOffset; // Start search from the correct position

                            let match;
                            while ((match = tagOpeningRegex.exec(editorValue)) !== null) {
                                // Ensure this match is within the current ID scope if one is active
                                if (selectedId !== 'all' && idBlockRange) {
                                    const matchStartPos = model.getPositionAt(match.index);
                                    if (!idBlockRange.containsPosition(matchStartPos)) {
                                        // If the match is outside the ID scope, skip it.
                                        // This can happen if regex.lastIndex goes past idBlockRange end.
                                        // To prevent infinite loops or missing tags, it's safer to break if outside current scope.
                                        if (match.index >= model.getOffsetAt(idBlockRange.getEndPosition())) {
                                            break;
                                        }
                                        continue; // Skip current match, continue searching
                                    }
                                }

                                const currentElementFullRange = findFullElementRange(model, match.index);
                                if (currentElementFullRange) {
                                    newDecorations.push({
                                        range: currentElementFullRange,
                                        options: {
                                            inlineClassName: 'tag-highlight'
                                        }
                                    });
                                }
                            }
                        }

                        // --- Existing Find Match Highlighting Logic ---
                        if (allMatches.length > 0) {
                            if (highlightAllCheckbox.checked) {
                                allMatches.forEach(match => {
                                    newDecorations.push({
                                        range: match.range,
                                        options: {
                                            inlineClassName: 'highlight-all-magenta'
                                        }
                                    });
                                });
                                if (currentMatchIndex !== -1) {
                                    newDecorations.push({
                                        range: allMatches[currentMatchIndex].range,
                                        options: {
                                            inlineClassName: 'find-current-match-highlight'
                                        }
                                    });
                                }
                            } else if (currentMatchIndex !== -1) {
                                newDecorations.push({
                                    range: allMatches[currentMatchIndex].range,
                                    options: {
                                        inlineClassName: 'find-highlight'
                                    }
                                });
                            }

                            if (currentMatchIndex !== -1) {
                                monacoEditorInstance.revealRangeInCenterIfOutsideViewport(allMatches[currentMatchIndex].range, 0);
                                const position = allMatches[currentMatchIndex].range.getStartPosition();
                                monacoEditorInstance.setPosition(position);

                                matchCountSpan.innerHTML = `${currentMatchIndex + 1} of ${allMatches.length}${getContextString()}`;
                            }
                        } else {
                            const matchCase = matchCaseCheckbox.checked;
                            let statusMessage = "No matches";
                            let optionsDescription = [];

                            if (findInput.value === '') {
                                matchCountSpan.innerHTML = "";
                                allDecorations = monacoEditorInstance.deltaDecorations(allDecorations, newDecorations);
                                return;
                            }

                            if (matchCase) {
                                optionsDescription.push("case-sensitive");
                            }

                            if (optionsDescription.length > 0) {
                                statusMessage = `No ${optionsDescription.join(' ')} matches`;
                            }
                            matchCountSpan.innerHTML = `${statusMessage}${getContextString()}`;
                        }

                        allDecorations = monacoEditorInstance.deltaDecorations(allDecorations, newDecorations);
                    }

                    /**
                     * Resets the search state and decorations when search criteria change,
                     * or forces a re-index if 'force' is true.
                     */
                    function resetSearchState(force = false) {
                        const newFindText = findInput.value;
                        const newSelectedId = idDropdown.value;
                        const newSelectedTag = tagDropdown.value;
                        const newIsRegex = enableRegexCheckbox.checked;
                        const newMatchCase = matchCaseCheckbox.checked;

                        const criteriaChanged = (
                            newFindText !== currentFindText ||
                            newSelectedId !== currentSelectedId ||
                            newSelectedTag !== currentSelectedTag ||
                            newIsRegex !== currentIsRegex ||
                            newMatchCase !== currentMatchCase
                        );

                        if (force || criteriaChanged) {
                            currentFindText = newFindText;
                            currentSelectedId = newSelectedId;
                            currentSelectedTag = newSelectedTag;
                            currentIsRegex = newIsRegex;
                            currentMatchCase = newMatchCase;

                            allMatches = findMatches();
                            currentMatchIndex = -1;

                            if (allMatches.length > 0 && newFindText !== '') {
                                currentMatchIndex = 0;
                            }
                        }

                        updateDecorations();
                    }

                    // Helper function to process replacement text for a single match
                    function processReplacement(originalMatchText, replaceText, isRegex, isSequencing, sequenceCurrentValue) {
                        let finalReplacement = replaceText;

                        // Handle sequencing
                        if (isSequencing) {
                            if (finalReplacement.includes('{$#+}')) {
                                finalReplacement = finalReplacement.replaceAll('{$#+}', sequenceCurrentValue.toString());
                            } else if (finalReplacement.includes('{$#-}')) {
                                finalReplacement = finalReplacement.replaceAll('{$#-}', sequenceCurrentValue.toString());
                            }
                        }

                        // Handle backreferences ($1, $2, etc.) and $& if regex is enabled
                        if (isRegex) {
                            const findText = findInput.value;
                            const matchCase = matchCaseCheckbox.checked;
                            // FIX: Ensure 'pattern' is not escaped if REGEX is enabled
                            const pattern = findText; // Directly use findText for regex pattern
                            const regexForGroups = new RegExp(pattern, matchCase ? '' : 'i');

                            const groupMatch = regexForGroups.exec(originalMatchText);

                            if (groupMatch) {
                                finalReplacement = finalReplacement.replaceAll('$&', groupMatch[0] || '');
                                for (let i = 1; i < groupMatch.length; i++) {
                                    const placeholder = `$${i}`;
                                    finalReplacement = finalReplacement.replaceAll(placeholder, groupMatch[i] || '');
                                }
                            }
                        }
                        return finalReplacement;
                    }

                    // Event listeners for UI elements
                    findNextButton.addEventListener('click', () => {
                        resetSearchState();
                        if (allMatches.length > 0) {
                            currentMatchIndex = (currentMatchIndex + 1) % allMatches.length;
                            updateDecorations();
                        } else {
                            // Message already handled by updateDecorations
                        }
                    });

                    findPreviousButton.addEventListener('click', () => {
                        resetSearchState();
                        if (allMatches.length > 0) {
                            currentMatchIndex = (currentMatchIndex - 1 + allMatches.length) % allMatches.length;
                            updateDecorations();
                        } else {
                            // Message already handled by updateDecorations
                        }
                    });

                    // Logic for the new "Replace" button
                    replaceOneButton.addEventListener('click', () => {
                        const findText = findInput.value;
                        const replaceText = replaceInput.value;
                        const isRegex = enableRegexCheckbox.checked;
                        const isSequencing = sequenceCheckbox.checked && (replaceText.includes('{$#+}') || replaceText.includes('{$#-}'));
                        let startIndex = parseInt(startIndexInput.value, 10);

                        if (!findText) {
                            updateDecorations();
                            return;
                        }

                        if (isSequencing && isNaN(startIndex)) {
                            showMessageBox("Please enter a valid number for 'Start' index when sequencing.", true);
                            return;
                        }

                        if (allMatches.length === 0 || currentMatchIndex === -1 || currentMatchIndex >= allMatches.length) {
                            resetSearchState();
                            if (allMatches.length === 0) {
                                updateDecorations();
                                return;
                            }
                        }

                        const matchToReplace = allMatches[currentMatchIndex];
                        const originalMatchRange = matchToReplace.range;
                        const originalMatchText = monacoEditorInstance.getModel().getValueInRange(originalMatchRange); // Use monacoEditorInstance

                        const processedReplaceText = processReplacement(
                            originalMatchText,
                            replaceText,
                            isRegex,
                            isSequencing,
                            startIndex
                        );

                        monacoEditorInstance.executeEdits( // Use monacoEditorInstance
                            null,
                            [{
                                range: originalMatchRange,
                                text: processedReplaceText,
                                forceMoveMarkers: true
                            }]
                        );

                        if (isSequencing) {
                            if (replaceText.includes('{$#+}')) {
                                startIndexInput.value = (startIndex + 1).toString();
                            } else if (replaceText.includes('{$#-}')) {
                                startIndexInput.value = (startIndex - 1).toString();
                            }
                        }

                        const oldEndPosition = originalMatchRange.getEndPosition();

                        resetSearchState(true);

                        let newCurrentMatchIndex = -1;

                        for (let i = 0; i < allMatches.length; i++) {
                            const newMatchRange = allMatches[i].range;
                            if (monaco.Position.compare(newMatchRange.getStartPosition(), oldEndPosition) >= 0) {
                                newCurrentMatchIndex = i;
                                break;
                            }
                        }

                        if (newCurrentMatchIndex !== -1) {
                            currentMatchIndex = newCurrentMatchIndex;
                        } else if (allMatches.length > 0) {
                            currentMatchIndex = 0;
                        } else {
                            currentMatchIndex = -1;
                        }

                        allDecorations = monacoEditorInstance.deltaDecorations(allDecorations, []); // Use monacoEditorInstance
                        updateDecorations();
                    });

                    idDropdown.addEventListener('change', () => resetSearchState(true));
                    tagDropdown.addEventListener('change', () => resetSearchState(true));
                    matchCaseCheckbox.addEventListener('change', () => resetSearchState(true));
                    highlightAllCheckbox.addEventListener('change', updateDecorations);
                    findInput.addEventListener('input', () => resetSearchState(true));

                    // The original replace button is now Replace All
                    replaceAllButton.addEventListener('click', () => {
                        const findText = findInput.value;
                        const replaceText = replaceInput.value;
                        const isRegex = enableRegexCheckbox.checked;
                        const matchCase = matchCaseCheckbox.checked;
                        const isSequencing = sequenceCheckbox.checked && (replaceText.includes('{$#+}') || replaceText.includes('{$#-}'));

                        if (!findText) {
                            // If find input is empty, clear decorations and show a message
                            resetSearchState(); // This will effectively clear old matches and decorations
                            matchCountSpan.innerHTML = "Enter text to find.";
                            return;
                        }

                        let startIndex = parseInt(startIndexInput.value, 10);
                        if (isSequencing && (isNaN(startIndex) || startIndex < 0)) { // Added check for negative startIndex
                            showMessageBox("Please enter a valid non-negative number for 'Start' index when sequencing.", true);
                            return;
                        }

                        // Find all matches *before* starting replacements, as replacements can change offsets
                        let matchesToReplace = findMatches();

                        if (matchesToReplace.length === 0) {
                            resetSearchState(); // Show "No matches"
                            return;
                        }

                        const edits = [];
                        let replacementCount = 0;
                        let sequenceCounter = startIndex; // Start sequence from the input value

                        // Important: endIndex should only be considered if sequence is enabled.
                        // Also, ensure endIndex is treated as inclusive if user intends it that way.
                        const endIndex = parseInt(endIndexInput.value, 10);
                        const hasEndIndex = isSequencing && !isNaN(endIndex);

                        const pattern = isRegex ? findText : escapeRegExp(findText);

                        // Filter matches based on the end index if sequencing is active and an end index is provided
                        let filteredMatches = matchesToReplace;
                        if (hasEndIndex) {
                            filteredMatches = matchesToReplace.filter((match, index) => {
                                const currentMatchSequenceValue = sequenceCounter + index;
                                return currentMatchSequenceValue <= endIndex;
                            });
                        }

                        filteredMatches.forEach((match, index) => {
                            // Use `sequenceCounter + index` for calculation, as `sequenceCounter` is the base for the *first* item
                            // and `index` is its offset within the `filteredMatches` array.
                            const effectiveSequenceValue = sequenceCounter + index;

                            let finalReplacement = replaceText;

                            if (isSequencing) {
                                // Apply sequencing tokens
                                if (finalReplacement.includes('{$#+}')) {
                                    finalReplacement = finalReplacement.replaceAll('{$#+}', effectiveSequenceValue.toString());
                                } else if (finalReplacement.includes('{$#-}')) {
                                    finalReplacement = finalReplacement.replaceAll('{$#-}', effectiveSequenceValue.toString());
                                }
                            }

                            if (isRegex) {
                                const originalMatchText = monacoEditorInstance.getModel().getValueInRange(match.range);
                                const regexForGroups = new RegExp(pattern, matchCase ? '' : 'i');
                                const groupMatch = regexForGroups.exec(originalMatchText);

                                if (groupMatch) {
                                    finalReplacement = finalReplacement.replaceAll('$&', groupMatch[0] || '');

                                    for (let i = 1; i < groupMatch.length; i++) {
                                        const placeholder = `$${i}`;
                                        finalReplacement = finalReplacement.replaceAll(placeholder, groupMatch[i] || '');
                                    }
                                }
                            }

                            edits.push({
                                range: match.range,
                                text: finalReplacement
                            });
                            replacementCount++;
                        });

                        if (edits.length === 0) {
                            // This case should ideally be caught by matchesToReplace.length === 0,
                            // but if `hasEndIndex` filters everything out, this handles it.
                            matchCountSpan.innerHTML = "No matches found within the specified sequence range.";
                            return;
                        }

                        monacoEditorInstance.getModel().pushEditOperations(
                            [],
                            edits,
                            () => null // This function is called to compute new selections after edits.
                            // Returning `null` means selections are not automatically adjusted.
                            // You might want to adjust this if you need specific cursor placement.
                        );

                        // After replacement, clear old decorations and re-run findMatches to update current state
                        matchCountSpan.innerHTML = `Replaced ${replacementCount} occurrences.`;
                        resetSearchState(true); // Force a re-search and re-decoration
                    });

                    // NEW Regex Guide button event listener:
                    regexGuideButton.addEventListener('click', () => {
                        const originalText = regexGuideButton.textContent;
                        showRegexGuideModal(regexGuideButton, originalText);
                    });
                    updateAllInteractiveButtonStates();
                });

                copyCodeBtn.addEventListener('click', async () => {
                    const codeContent = monacoEditorInstance ? monacoEditorInstance.getValue() : '';
                    try {
                        await navigator.clipboard.writeText(codeContent);
                        const originalHTML = copyCodeBtn.innerHTML; // Store original HTML
                        copyCodeBtn.textContent = 'Copied!';
                        copyCodeBtn.classList.add('bg-green-500', 'hover:bg-green-600');
                        copyCodeBtn.classList.remove('bg-zinc-700', 'hover:bg-zinc-600');
                        copyCodeBtn.disabled = true;
                        copyCodeBtn.setAttribute('data-temp-active', 'true');
                        updateAllInteractiveButtonStates();
                        setTimeout(() => {
                            copyCodeBtn.innerHTML = originalHTML; // Restore original HTML
                            copyCodeBtn.classList.remove('bg-green-500', 'hover:bg-green-600');
                            copyCodeBtn.classList.add('bg-zinc-700', 'hover:bg-zinc-600');
                            copyCodeBtn.disabled = false;
                            copyCodeBtn.removeAttribute('data-temp-active');
                            updateAllInteractiveButtonStates();
                        }, 1500);
                    } catch (err) {
                        console.error('Failed to copy text: ', err);
                    }
                });

                autoFormatBtn.addEventListener('click', () => {
                    if (monacoEditorInstance) {
                        let currentContent = monacoEditorInstance.getValue();
                        // Do NOT decodeHtmlEntities here. Protect attributes directly from Monaco's value.
                        currentContent = protectDataAttributes(currentContent); // Protect attributes (string replacement)

                        // Use js_beautify to format the HTML content
                        let formattedContent = html_beautify(currentContent, {
                            indent_size: 4, // You can customize indentation size
                            space_in_paren: true // Example option
                        });

                        formattedContent = restoreDataAttributes(formattedContent); // Restore attributes
                        formattedContent = convertAllEntitiesToNumeric(formattedContent); // Re-encode after formatting

                        monacoEditorInstance.setValue(formattedContent);
                        applyEntityHighlighting(); // Re-apply highlighting after formatting

                        const originalText = autoFormatBtn.textContent;
                        autoFormatBtn.textContent = 'Formatted!';
                        autoFormatBtn.classList.add('bg-green-500', 'hover:bg-green-600');
                        autoFormatBtn.classList.remove('bg-red-700', 'hover:bg-red-800'); /* Changed */
                        autoFormatBtn.disabled = true; // Disable the button
                        autoFormatBtn.setAttribute('data-temp-active', 'true'); // Mark as active
                        updateAllInteractiveButtonStates(); // Update all buttons
                        setTimeout(() => {
                            autoFormatBtn.textContent = originalText;
                            autoFormatBtn.classList.remove('bg-green-500', 'hover:bg-green-600');
                            autoFormatBtn.classList.add('bg-red-700', 'hover:bg-red-800'); /* Changed */
                            autoFormatBtn.disabled = false; // Re-enable the button
                            autoFormatBtn.removeAttribute('data-temp-active'); // Unmark as active
                            updateAllInteractiveButtonStates(); // Update all buttons
                        }, 1500);
                    }
                });

                // New Auto-Encode button event listener
                autoEncodeBtn.addEventListener('click', () => {
                    if (monacoEditorInstance) {
                        let currentContent = monacoEditorInstance.getValue();
                        let encodedContent = doAutoEncode(currentContent); // Call the new auto-encode function

                        monacoEditorInstance.setValue(encodedContent);
                        htmlOutputContent = encodedContent; // Keep the main content variable updated
                        applyEntityHighlighting(); // Re-apply highlighting after encoding

                        const originalText = autoEncodeBtn.textContent;
                        autoEncodeBtn.textContent = 'Encoded!';
                        autoEncodeBtn.classList.add('bg-green-500', 'hover:bg-green-600');
                        autoEncodeBtn.classList.remove('bg-red-700', 'hover:bg-red-800'); /* Changed */
                        autoEncodeBtn.disabled = true; // Disable the button
                        autoEncodeBtn.setAttribute('data-temp-active', 'true'); // Mark as active
                        updateAllInteractiveButtonStates(); // Update all buttons
                        setTimeout(() => {
                            autoEncodeBtn.textContent = originalText;
                            autoEncodeBtn.classList.remove('bg-green-500', 'hover:bg-green-600');
                            autoEncodeBtn.classList.add('bg-red-700', 'hover:bg-red-800'); /* Changed */
                            autoEncodeBtn.disabled = false; // Re-enable the button
                            autoEncodeBtn.removeAttribute('data-temp-active'); // Unmark as active
                            updateAllInteractiveButtonStates(); // Update all buttons
                        }, 1500);
                    }
                });

                exportHtmlBtn.addEventListener('click', () => {
                    const htmlContent = monacoEditorInstance ? monacoEditorInstance.getValue() : '';
                    const blob = new Blob([htmlContent], {
                        type: 'text/html'
                    });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = 'index.html';
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    const originalHTML = exportHtmlBtn.innerHTML; // Store original HTML
                    exportHtmlBtn.textContent = 'Exported!';
                    exportHtmlBtn.classList.add('bg-green-500', 'hover:bg-green-600');
                    exportHtmlBtn.classList.remove('bg-red-700', 'hover:bg-red-800');
                    exportHtmlBtn.disabled = true;
                    exportHtmlBtn.setAttribute('data-temp-active', 'true');
                    updateAllInteractiveButtonStates();
                    setTimeout(() => {
                        exportHtmlBtn.innerHTML = originalHTML; // Restore original HTML
                        exportHtmlBtn.classList.remove('bg-green-500', 'hover:bg-green-600');
                        exportHtmlBtn.classList.add('bg-red-700', 'hover:bg-red-800');
                        exportHtmlBtn.disabled = false;
                        exportHtmlBtn.removeAttribute('data-temp-active');
                        updateAllInteractiveButtonStates();
                    }, 1500);
                });

                importHtmlBtn.addEventListener('click', () => htmlFileInput.click());
                htmlFileInput.addEventListener('change', (event) => {
                    const file = event.target.files[0];
                    if (file) {
                        const reader = new FileReader();
                        reader.onload = (e) => {
                            const importedContent = e.target.result;
                            if (monacoEditorInstance) {
                                monacoEditorInstance.setValue(importedContent);
                                htmlOutputContent = importedContent;
                                applyEntityHighlighting();
                            }
                            const originalHTML = importHtmlBtn.innerHTML; // Store original HTML
                            importHtmlBtn.textContent = 'Imported!';
                            importHtmlBtn.classList.add('bg-green-500', 'hover:bg-green-600');
                            importHtmlBtn.classList.remove('bg-purple-700', 'hover:bg-purple-800');
                            importHtmlBtn.disabled = true;
                            importHtmlBtn.setAttribute('data-temp-active', 'true');
                            updateAllInteractiveButtonStates();
                            setTimeout(() => {
                                importHtmlBtn.innerHTML = originalHTML; // Restore original HTML
                                importHtmlBtn.classList.remove('bg-green-500', 'hover:bg-green-600');
                                importHtmlBtn.classList.add('bg-purple-700', 'hover:bg-purple-800');
                                htmlFileInput.value = null;
                                importHtmlBtn.removeAttribute('data-temp-active');
                                updateAllInteractiveButtonStates();
                            }, 1500);
                        };
                        reader.readAsText(file);
                    }
                });

                // Event listeners for the new individual toggle buttons
                toggleEditorViewBtnRichText.addEventListener('click', toggleEditorView);
                toggleEditorViewBtnCode.addEventListener('click', toggleEditorView);

                // Clean Mso button event listener
                cleanMsoBtn.addEventListener('click', () => {
                    if (monacoEditorInstance) {
                        let currentContent = monacoEditorInstance.getValue();
                        currentContent = protectDataAttributes(currentContent);

                        // Apply all MSO cleaning functions in the specified order
                        currentContent = applyCleanLists(currentContent);
                        console.log("Clean MSO Lists applied by Clean MSO button.");
                        currentContent = applyCleanTablesBasic(currentContent);
                        console.log("Clean MSO Tables applied by Clean MSO button.");
                        currentContent = applyCleanMsoCode(currentContent);
                        console.log("Clean MSO Code (including IMGs) applied by Clean MSO button.");
                        currentContent = applyUrlCleaning(currentContent);
                        console.log("Clean URLs applied by Clean Mso button.");
                        currentContent = applyAutoSpacing(currentContent);
                        console.log("Clean Spaces applied by Clean MSO button.");

                        currentContent = restoreDataAttributes(currentContent);
                        currentContent = convertAllEntitiesToNumeric(currentContent);

                        monacoEditorInstance.setValue(currentContent);
                        htmlOutputContent = currentContent;
                        applyEntityHighlighting();
                        autoEncodeBtn.click();

                        const originalText = cleanMsoBtn.textContent;
                        cleanMsoBtn.textContent = 'Cleaned!';
                        cleanMsoBtn.classList.add('bg-green-500', 'hover:bg-green-600');
                        cleanMsoBtn.classList.remove('bg-blue-700', 'hover:bg-blue-800');
                        cleanMsoBtn.disabled = true; // Disable until timeout or next user action
                        cleanMsoBtn.setAttribute('data-temp-active', 'true');
                        updateAllInteractiveButtonStates();
                        setTimeout(() => {
                            cleanMsoBtn.textContent = originalText;
                            cleanMsoBtn.classList.remove('bg-green-500', 'hover:bg-green-600');
                            cleanMsoBtn.classList.add('bg-blue-700', 'hover:bg-blue-800');
                            cleanMsoBtn.disabled = false;
                            cleanMsoBtn.removeAttribute('data-temp-active');
                            updateAllInteractiveButtonStates();
                            // Re-evaluate clean Mso button state based on auto-clean toggle
                            updateCleanMsoButtonState();
                        }, 1500);
                    }
                });

                // Clear All button event listener
                clearAllBtn.addEventListener('click', () => {
                    if (monacoEditorInstance) {
                        monacoEditorInstance.setValue('');
                        htmlOutputContent = '';
                        applyEntityHighlighting();
                    }
                    const originalHTML = clearAllBtn.innerHTML; // Store original HTML
                    clearAllBtn.textContent = 'Cleared!';
                    clearAllBtn.classList.add('bg-green-500', 'hover:bg-green-600');
                    clearAllBtn.classList.remove('bg-zinc-700', 'hover:bg-zinc-600');
                    clearAllBtn.disabled = true;
                    clearAllBtn.setAttribute('data-temp-active', 'true');
                    updateAllInteractiveButtonStates();
                    setTimeout(() => {
                        clearAllBtn.innerHTML = originalHTML; // Restore original HTML
                        clearAllBtn.classList.remove('bg-green-500', 'hover:bg-green-600');
                        clearAllBtn.classList.add('bg-zinc-700', 'hover:bg-zinc-600');
                        clearAllBtn.disabled = false;
                        clearAllBtn.removeAttribute('data-temp-active');
                        updateAllInteractiveButtonStates();
                    }, 1500);
                });

                // Initial content for the iframe
                const iframeDocument = default_ifr.contentDocument || default_ifr.contentWindow.document;
                iframeDocument.open();
                iframeDocument.write(`
                <!DOCTYPE html>
                <html lang="en">
                <head>
                    <meta charset="UTF-8">
                    <meta name="viewport" content="width=device-width, initial-scale=1.0">
                    <title>Rich Editor</title>
                    <script src="https://cdn.jsdelivr.net/npm/hugerte@1/hugerte.min.js"><\/script>
                    <script src="https://cdn.tailwindcss.com"><\/script>
                    <style>
                        html, body {
                            height: 100%; /* Ensure html and body take full height */
                            margin: 0;
                            /* Removed padding from html, body to avoid height calculation issues */
                            box-sizing: border-box; /* Include padding in height calculations for all elements */
                        }
                        body {
                            font-family: sans-serif;
                            background-color: #ffffff; /* White background for iframe body */
                            color: #333;
                            display: flex; /* Use flexbox for body to make form fill height */
                            flex-direction: column;
                            padding: 1rem; /* Add padding to the body of the iframe */
                        }
                        form {
                            height: 100%;
                            display: flex;
                            flex-direction: column;
                        }
                        textarea {
                            width: 100%;
                            flex-grow: 1;
                            border: 1px solid #ccc;
                            border-radius: 0.5rem;
                            padding: 0.75rem;
                            font-size: 1rem;
                            resize: none; /* Prevent manual resizing */
                            box-sizing: border-box; /* Include padding in width/height */
                        }
                        /* Style for HugeRTE container */
                        .tox.tox-tinymce { /* Use .tox.tox-tinymce as HugeRTE uses TinyMCE classes */
                            height: 100% !important; /* Force full height */
                            display: flex; /* Make it a flex container */
                            flex-direction: column; /* Stack its children vertically */
                        }
                        .tox-editor-container {
                            flex-grow: 1; /* Allow the editor area to grow */
                            display: flex;
                            flex-direction: column;
                        }
                        .tox-edit-area {
                            flex-grow: 1; /* Allow the editing area to grow */
                            display: flex;
                            flex-direction: column;
                        }
                        .tox-edit-area__iframe {
                            flex-grow: 1; /* Make the actual iframe within TinyMCE fill space */
                        }
                        /* Class for time tags to prevent wrapping */
                        .nowrap {
                            white-space: nowrap;
                        }
						
                    </style>
                </head>
                <body>
                    <form method="post">
                        <textarea id="richEditor"></textarea>
                    </form>
                    <script type="text/javascript">
                        console.log("Iframe script started executing.");
                        // Global variable to hold the HugeRTE editor instance
                        let richTextEditorInstance;
                        // Flag to prevent infinite loop when updating HugeRTE from CodeMirror
                        let isUpdatingFromCodeMirror = false;

                        /**
                         * Function to set the content of the HugeRTE editor.
                         * This is called from the parent window.
                         */
                        window.setRichEditorContent = function(content) {
                            // console.log("Iframe: setRichEditorContent called by parent.");
                            if (richTextEditorInstance && !isUpdatingFromCodeMirror) {
                                isUpdatingFromCodeMirror = true;
                                richTextEditorInstance.setContent(content);
                                richTextEditorInstance.focus(); // Re-focus the rich editor after content update
                                // console.log('Iframe: HugeRTE updated from parent.');
                                isUpdatingFromCodeMirror = false;
                            } else {
                                console.warn('Iframe: HugeRTE editor not yet initialized or isUpdatingFromCodeMirror is true. Content will be set once ready.');
                            }
                        };

                        /**
                         * Function to get the content from the HugeRTE editor.
                         * This is called from the parent window.
                         */
                        window.getRichEditorContent = function() {
                            // console.log("Iframe: getRichEditorContent called by parent.");
                            if (richTextEditorInstance) {
                                const content = richTextEditorInstance.getContent();
                                // console.log("Iframe: HugeRTE content requested by parent.");
                                return content;
                            } else {
                                console.warn('Iframe: HugeRTE editor not yet initialized. Cannot get content.');
                                return '';
                            }
                        };
						// Place the helper function here, before the hugerte.init call
function openAllDetailsInEditor(editor) {
    const editorDoc = editor.getDoc();
    if (editorDoc) {
        const detailsElements = editorDoc.querySelectorAll('details');
        detailsElements.forEach(el => {
            el.setAttribute('open', '');
        });
    }
}
                        /**
                         * HugeRTE init
                         */
                        if (typeof hugerte === 'undefined') {
                            console.error("Iframe: HugeRTE library not loaded!");
                        }
                        else {
                            console.log("Iframe: HugeRTE library loaded. Initializing editor.");
                            hugerte.init({
                                selector: '#richEditor',
								toolbar: 'undo redo styles bold italic alignleft aligncenter alignright numlist bullist link table',
								plugins: [ 'table', 'lists', 'link' ], // 'lists' plugin is relevant for ol/ul, but not directly dl
								height: '100%',
								tab_focus: false,
								formats: {
									alignleft: { selector: 'p,h1,h2,h3,h4,h5,h6,td,th,div,ul,ol,li,table,img', classes: 'text-left', exact: true },
									aligncenter: { selector: 'p,h1,h2,h3,h4,h5,h6,td,th,div,ul,ol,li,table,img', classes: 'text-center', exact: true },
									alignright: { selector: 'p,h1,h2,h3,h4,h5,h6,td,th,div,ul,ol,li,table,img', classes: 'text-right', exact: true },
								},
								content_style: 'body { max-width: 1170px; margin-left: auto; margin-right: auto; padding: 15px; box-sizing: border-box; } h1 { background-color: #FF6347; padding: 2px 5px; border-radius: 3px; display: inline-block; } h2 { background-color: #FE9900; padding: 2px 5px; border-radius: 3px; display: inline-block; } h3 { background-color: #FFDE59; padding: 2px 5px; border-radius: 3px; display: inline-block; } h4 { background-color: #7DDA58; padding: 2px 5px; border-radius: 3px; display: inline-block; } h5 { background-color: #5DE2E7; padding: 2px 5px; border-radius: 3px; display: inline-block; } h6 { background-color: #E7DDFF; padding: 2px 5px; border-radius: 3px; display: inline-block; } section { border: #060270 2px dashed; margin: 5px; padding: 5px;} div, aside { border: #8D6F64 2px solid; margin: 5px; padding: 5px;} details > *:not(summary) { display: block !important; } details summary { cursor: default !important; font-weight: bold; margin-bottom: 5px; color: #333; }',
                                extended_valid_elements: 'dl[class|id],dt[class|id],dd[class|id],details[open],summary',
								valid_children: '+body[dl],+dl[dt|dd],+dt[a|abbr|acronym|b|bdo|big|br|button|cite|code|del|dfn|em|i|img|input|ins|kbd|label|map|q|samp|select|small|span|strike|strong|sub|sup|textarea|tt|var|p],+dd[a|abbr|acronym|b|bdo|big|br|button|cite|code|del|dfn|em|i|img|input|ins|kbd|label|map|q|samp|select|small|span|strike|strong|sub|sup|textarea|tt|var|p|ul|ol|dl],+details[summary|p|div|ul|ol|table|h1|h2|h3|h4|h5|h6]',
								custom_elements: 'dl,dt,dd,details,summary',
								 // --- START MODIFICATION ---
    setup: function(editor) {
        // This function runs when the content is set or changed
        editor.on('SetContent', function(e) {
            openAllDetailsInEditor(editor);
        });
    },
    init_instance_callback: function(editorInstance) {
        console.log('Iframe: HugeRTE editor initialized inside iframe.');
        richTextEditorInstance = editorInstance; // Store the instance globally

        // NEW: Call the function to open details when the editor first loads
        openAllDetailsInEditor(editorInstance);

        // Expose the instance to the parent window
        if (window.parent) {
            window.parent.richTextEditorInstanceFromIframe = editorInstance;
            console.log("Iframe: HugeRTE instance exposed to parent.");
        }

        // Handle Tab key
        editorInstance.on('keydown', (event) => {
            if (event.key === 'Tab') {
                event.preventDefault();
                editorInstance.focus();
            }
        });

        // Initial content sync
        if (window.parent.richTextContent) {
            editorInstance.setContent(window.parent.richTextContent);
            console.log("Iframe: Initial HugeRTE content set from parent.");
            // Note: The 'SetContent' event handler will fire here, so openAllDetailsInEditor() is called automatically.
        }
    }
    // --- END MODIFICATION ---
                            });
                        }
                    <\/script>
                </body>
                </html>
            `);
                iframeDocument.close();

                // After the iframe content is loaded and the editor is initialized within it,
                // the iframe's script will assign its editor instance to window.parent.richTextEditorInstanceFromIframe
                // We can then pick it up here.
                default_ifr.onload = () => {
                    console.log("Parent: Iframe finished loading.");
                    if (default_ifr.contentWindow && default_ifr.contentWindow.richTextEditorInstanceFromIframe) {
                        richTextEditorInstanceFromIframe = default_ifr.contentWindow.richTextEditorInstanceFromIframe;
                        console.log("Parent: HugeRTE instance captured by parent.");
                    } else {
                        console.warn("Parent: Could not capture HugeRTE instance from iframe. Is HugeRTE initializing correctly inside?");
                    }
                };

                // Event listeners for Auto-Clean MSO when switching toggles
                toggleAutoCleanMsoOnSwitchRichText.addEventListener('change', (event) => {
                    const isChecked = event.target.checked;
                    const parentLabel = event.target.closest('.toggle-switch');
                    if (isChecked) {
                        parentLabel.classList.add('is-checked');
                    } else {
                        parentLabel.classList.remove('is-checked');
                    }
                    toggleAutoCleanMsoOnSwitchCode.checked = isChecked; // Sync state
                    toggleAutoCleanMsoOnSwitchCode.closest('.toggle-switch').classList.toggle('is-checked', isChecked);
                    console.log(`Auto-Clean MSO on RichText switch is now: ${isChecked ? 'ON' : 'OFF'}`);
                    updateGoToHtmlButtonColor(); // Update button color
                    updateCleanMsoButtonState(); // Update Clean Mso button state
                });

                toggleAutoCleanMsoOnSwitchCode.addEventListener('change', (event) => {
                    const isChecked = event.target.checked;
                    const parentLabel = event.target.closest('.toggle-switch');
                    if (isChecked) {
                        parentLabel.classList.add('is-checked');
                        toggleAutoCleanMsoOnSwitchCode.checked = true;
                    } else {
                        parentLabel.classList.remove('is-checked');
                        toggleAutoCleanMsoOnSwitchCode.checked = false;
                    }
                    toggleAutoCleanMsoOnSwitchRichText.checked = isChecked; // Sync state
                    toggleAutoCleanMsoOnSwitchRichText.closest('.toggle-switch').classList.toggle('is-checked', isChecked);
                    console.log(`Auto-Clean MSO on Code switch is now: ${isChecked ? 'ON' : 'OFF'}`);
                    // No button color update needed here as it's the "Go to Rich-Text" button
                    updateCleanMsoButtonState(); // Update Clean Mso button state
                });

                // Set initial checked states and add event listeners for new pill toggles in "Quick Formatting"
                quickFormattingToggles.forEach(toggle => {
                    // Set initial checked state based on requirements
                    if (toggle.id === 'toggleCleanSingleBreaks' || toggle.id === 'toggleCleanFormattingTags' || toggle.id === 'toggleCleanPTables') {
                        toggle.checked = false;
                        toggle.closest('.toggle-switch').classList.remove('is-checked');
                    } else {
                        toggle.checked = true;
                        toggle.closest('.toggle-switch').classList.add('is-checked');
                    }

                    toggle.addEventListener('change', (event) => {
                        const parentLabel = event.target.closest('.toggle-switch');
                        if (event.target.checked) {
                            parentLabel.classList.add('is-checked');
                        } else {
                            parentLabel.classList.remove('is-checked');
                        }
                        updateFormatButtonState(); // Update format button state on change
                    });
                });

                // Set initial state of the Format button
                updateFormatButtonState();


                // New "Format" button event listener for Quick Formatting toggles
                formatSelectedBtn.addEventListener('click', async () => {
                    console.log("Format button clicked.");
                    if (monacoEditorInstance) {
                        console.log("Monaco instance is valid.");
                        let currentContent = monacoEditorInstance.getValue();
                        console.log("Content before processing (length):", currentContent.length);

                        currentContent = protectDataAttributes(currentContent);

                        // Apply NBSP placeholders early for spacing and time tagging
                        currentContent = applyNBSPPlaceholders(currentContent);

                        if (toggleCleanSingleBreaks.checked) {
                            currentContent = applyCleanSingleBreaks(currentContent);
                            console.log("Clean Single Breaks applied. Content length:", currentContent.length);
                        }
                        if (toggleCleanPTables.checked) {
                            currentContent = applyCleanPTagsInTables(currentContent);
                            console.log("Clean <p> in Tables applied. Content length:", currentContent.length);
                        }
                        if (toggleCleanSpaces.checked) {
                            currentContent = applyAutoSpacing(currentContent);
                            console.log("Clean Spaces applied. Content length:", currentContent.length);
                        }
                        if (toggleCleanUrls.checked) {
                            currentContent = applyUrlCleaning(currentContent);
                            console.log("Clean URLs applied. Content length:", currentContent.length);
                        }
                        if (toggleCleanFormattingTags.checked) {
                            currentContent = applyCleanFormattingTags(currentContent);
                            console.log("Clean <U> | <B> | <I> applied. Content length:", currentContent.length);
                        }
                        if (toggleAutoLevelHeadings.checked) {
                            currentContent = applyAutoLevelHeadings(currentContent);
                            console.log("Auto-Level Headings applied. Content length:", currentContent.length);
                        }
                        if (toggleAutoSection.checked) {
                            currentContent = applyAutoSectioning(currentContent);
                            console.log("Auto-Section applied. Content length:", currentContent.length);
                        }
                        if (toggleTimeTags.checked) {
                            // --- START: MODIFIED TIME TAG LOGIC ---
                            // This new logic parses the HTML and operates on text nodes directly,
                            // which prevents it from incorrectly tagging dates inside HTML attributes.
                            const parser = new DOMParser();
                            const doc = parser.parseFromString(currentContent, 'text/html');
                            const body = doc.body;

                            // First, unwrap any existing <time> tags to prevent re-wrapping and allow for re-evaluation.
                            body.querySelectorAll('time').forEach(timeEl => {
                                const parent = timeEl.parentNode;
                                if (parent) {
                                    while (timeEl.firstChild) {
                                        parent.insertBefore(timeEl.firstChild, timeEl);
                                    }
                                    parent.removeChild(timeEl);
                                }
                            });

                            // Use a TreeWalker to safely iterate over only text nodes.
                            const walker = doc.createTreeWalker(
                                body,
                                NodeFilter.SHOW_TEXT, {
                                    acceptNode: function(node) {
                                        // Reject text nodes within elements where tagging is undesirable.
                                        const parentTag = node.parentNode.tagName.toLowerCase();
                                        if (['script', 'style', 'time'].includes(parentTag)) {
                                            return NodeFilter.FILTER_REJECT;
                                        }
                                        return NodeFilter.FILTER_ACCEPT;
                                    }
                                },
                                false
                            );

                            // Collect all text nodes to process.
                            const textNodes = [];
                            let currentNode;
                            while (currentNode = walker.nextNode()) {
                                textNodes.push(currentNode);
                            }

                            // Define date patterns and helpers.
                            const monthMap = {
                                'january': '01',
                                'jan': '01',
                                'janvier': '01',
                                'february': '02',
                                'feb': '02',
                                'février': '02',
                                'march': '03',
                                'mar': '03',
                                'mars': '03',
                                'april': '04',
                                'apr': '04',
                                'avril': '04',
                                'may': '05',
                                'mai': '05',
                                'june': '06',
                                'jun': '06',
                                'juin': '06',
                                'july': '07',
                                'jul': '07',
                                'juillet': '07',
                                'august': '08',
                                'aug': '08',
                                'août': '08',
                                'september': '09',
                                'sep': '09',
                                'septembre': '09',
                                'october': '10',
                                'oct': '10',
                                'octobre': '10',
                                'november': '11',
                                'nov': '11',
                                'novembre': '11',
                                'december': '12',
                                'dec': '12',
                                'décembre': '12'
                            };

                            function getMonthNumber(monthName) {
                                return monthMap[monthName.toLowerCase()] || null;
                            }

                            const sortedMonthKeys = Object.keys(monthMap).sort((a, b) => b.length - a.length);
                            const monthPattern = sortedMonthKeys.map(m => m.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&')).join('|');
                            const spaceOrNBSPChar = `(?:\\s|${NBSP_PLACEHOLDER})+`;
                            const daySuffixPattern = '(?:<sup>er<\\/sup>|<sup>st<\\/sup>|<sup>nd<\\/sup>|<sup>rd<\\/sup>|<sup>th<\\/sup>|er|st|nd|rd|th)?';

                            const regexIsoDateFull = /(?<!\d)(\d{4}-(?:0[1-9]|1[0-2])-(?:0[1-9]|[12]\d|3[01]))(?!\d)/g;
                            const regexMonthDayYear = new RegExp(`(?<!\\d)\\b(${monthPattern})\\b${spaceOrNBSPChar}(\\d{1,2}${daySuffixPattern})\\s*,?${spaceOrNBSPChar}(\\d{4})(?!\\d)`, 'gi');
                            const regexDayMonthYear = new RegExp(`(?<!\\d)(?:(?:le|the)${spaceOrNBSPChar})?(\\d{1,2}${daySuffixPattern})${spaceOrNBSPChar}\\b(${monthPattern})\\b\\s*,?${spaceOrNBSPChar}(\\d{4})(?!\\d)`, 'gi');
                            const regexMonthYear = new RegExp(`(?<!\\d)\\b(${monthPattern})\\b${spaceOrNBSPChar}(\\d{4})(?!\\d|(?:${spaceOrNBSPChar}\\d{1,2}))`, 'gi');
                            const regexMonthDayNoYear = new RegExp(`(?<!\\d)\\b(${monthPattern})\\b${spaceOrNBSPChar}(\\d{1,2}${daySuffixPattern})(?!\\d|(?:${spaceOrNBSPChar}\\d{4}))(?!-)`, 'gi');
                            const regexDayMonthNoYear = new RegExp(`(?<!\\d)(?:(?:le|the)${spaceOrNBSPChar})?(\\d{1,2}${daySuffixPattern})${spaceOrNBSPChar}\\b(${monthPattern})\\b(?!\d|(?:${spaceOrNBSPChar}\\d{4}))(?!-)`, 'gi');

                            const patternsToTest = [{
                                    name: 'IsoDateFull',
                                    regex: regexIsoDateFull,
                                    handler: (match) => match[1],
                                    priority: 3
                                },
                                {
                                    name: 'MonthDayYear',
                                    regex: regexMonthDayYear,
                                    handler: (match) => {
                                        const [, month, dayPart, year] = match;
                                        const monthNum = getMonthNumber(month);
                                        let cleanDay = dayPart.replace(/(?:<sup>er<\/sup>|<sup>st<\/sup>|<sup>nd<\/sup>|<sup>rd<\/sup>|<sup>th<\/sup>|er|st|nd|rd|th)/gi, '').trim();
                                        const parsedDay = parseInt(cleanDay);
                                        if (!monthNum || isNaN(parsedDay) || parsedDay < 1 || parsedDay > 31) return null;
                                        return `${year}-${monthNum}-${String(parsedDay).padStart(2, '0')}`;
                                    },
                                    priority: 2
                                },
                                {
                                    name: 'DayMonthYear',
                                    regex: regexDayMonthYear,
                                    handler: (match) => {
                                        const [, dayPart, month, year] = match;
                                        const monthNum = getMonthNumber(month);
                                        let cleanDay = dayPart.replace(/(?:<sup>er<\/sup>|<sup>st<\/sup>|<sup>nd<\/sup>|<sup>rd<\/sup>|<sup>th<\/sup>|er|st|nd|rd|th)/gi, '').trim();
                                        const parsedDay = parseInt(cleanDay);
                                        if (!monthNum || isNaN(parsedDay) || parsedDay < 1 || parsedDay > 31) return null;
                                        return `${year}-${monthNum}-${String(parsedDay).padStart(2, '0')}`;
                                    },
                                    priority: 2
                                },
                                {
                                    name: 'MonthYear',
                                    regex: regexMonthYear,
                                    handler: (match) => {
                                        const [, month, year] = match;
                                        const monthNum = getMonthNumber(month);
                                        if (!monthNum) return null;
                                        return `${year}-${monthNum}`;
                                    },
                                    priority: 2
                                },
                                {
                                    name: 'MonthDayNoYear',
                                    regex: regexMonthDayNoYear,
                                    handler: (match) => {
                                        const [, month, dayPart] = match;
                                        const monthNum = getMonthNumber(month);
                                        let cleanDay = dayPart.replace(/(?:<sup>er<\/sup>|<sup>st<\/sup>|<sup>nd<\/sup>|<sup>rd<\/sup>|<sup>th<\/sup>|er|st|nd|rd|th)/gi, '').trim();
                                        const parsedDay = parseInt(cleanDay);
                                        if (!monthNum || isNaN(parsedDay) || parsedDay < 1 || parsedDay > 31) return null;
                                        return `${monthNum}-${String(parsedDay).padStart(2, '0')}`;
                                    },
                                    priority: 1
                                },
                                {
                                    name: 'DayMonthNoYear',
                                    regex: regexDayMonthNoYear,
                                    handler: (match) => {
                                        const [, dayPart, month] = match;
                                        const monthNum = getMonthNumber(month);
                                        let cleanDay = dayPart.replace(/(?:<sup>er<\/sup>|<sup>st<\/sup>|<sup>nd<\/sup>|<sup>rd<\/sup>|<sup>th<\/sup>|er|st|nd|rd|th)/gi, '').trim();
                                        const parsedDay = parseInt(cleanDay);
                                        if (!monthNum || isNaN(parsedDay) || parsedDay < 1 || parsedDay > 31) return null;
                                        return `${monthNum}-${String(parsedDay).padStart(2, '0')}`;
                                    },
                                    priority: 1
                                }
                            ];

                            // Process nodes in reverse to avoid issues with DOM manipulation affecting subsequent nodes.
                            for (let i = textNodes.length - 1; i >= 0; i--) {
                                const node = textNodes[i];
                                const text = node.nodeValue;

                                let allMatchesInNode = [];
                                patternsToTest.forEach(pattern => {
                                    let localRegex = new RegExp(pattern.regex.source, 'gi'); // Use 'gi' for global, case-insensitive
                                    let match;
                                    while ((match = localRegex.exec(text)) !== null) {
                                        const datetimeValue = pattern.handler(match);
                                        if (datetimeValue) {
                                            allMatchesInNode.push({
                                                start: match.index,
                                                end: match.index + match[0].length,
                                                original: match[0],
                                                datetime: datetimeValue,
                                                priority: pattern.priority
                                            });
                                        }
                                    }
                                });

                                if (allMatchesInNode.length === 0) continue;

                                // Sort and filter for non-overlapping matches.
                                allMatchesInNode.sort((a, b) => {
                                    if (a.start !== b.start) return a.start - b.start;
                                    if (a.original.length !== b.original.length) return b.original.length - a.original.length;
                                    return b.priority - a.priority;
                                });

                                let nonOverlappingMatches = [];
                                if (allMatchesInNode.length > 0) {
                                    nonOverlappingMatches.push(allMatchesInNode[0]);
                                    for (let j = 1; j < allMatchesInNode.length; j++) {
                                        const currentMatch = allMatchesInNode[j];
                                        const lastAddedMatch = nonOverlappingMatches[nonOverlappingMatches.length - 1];
                                        if (currentMatch.start >= lastAddedMatch.end) {
                                            nonOverlappingMatches.push(currentMatch);
                                        }
                                    }
                                }

                                if (nonOverlappingMatches.length > 0) {
                                    const parent = node.parentNode;
                                    const fragment = doc.createDocumentFragment();
                                    let lastIndex = 0;

                                    nonOverlappingMatches.forEach(match => {
                                        // Add text before the match
                                        if (match.start > lastIndex) {
                                            fragment.appendChild(doc.createTextNode(text.substring(lastIndex, match.start)));
                                        }
                                        // Add the <time> element
                                        const timeEl = doc.createElement('time');
                                        timeEl.className = 'nowrap';
                                        timeEl.setAttribute('datetime', match.datetime);

                                        // The matched text might contain HTML (like <sup>), so parse it.
                                        const tempDiv = doc.createElement('div');
                                        tempDiv.innerHTML = match.original;
                                        while (tempDiv.firstChild) {
                                            timeEl.appendChild(tempDiv.firstChild);
                                        }
                                        fragment.appendChild(timeEl);

                                        lastIndex = match.end;
                                    });

                                    // Add any remaining text after the last match
                                    if (lastIndex < text.length) {
                                        fragment.appendChild(doc.createTextNode(text.substring(lastIndex)));
                                    }

                                    // Replace the original text node with the new fragment.
                                    if (parent) {
                                        parent.replaceChild(fragment, node);
                                    }
                                }
                            }

                            // Serialize the modified DOM back to a string.
                            currentContent = body.innerHTML;
                            console.log("Time Tags applied using DOM walker. Content length:", currentContent.length);
                            // --- END: MODIFIED TIME TAG LOGIC ---

                        }


                        if (toggleFixFnIds.checked) {
                            // Fix FN ID's functionality - copied from original fixFnIdsBtn.click()
                            const parser = new DOMParser();
                            const doc = parser.parseFromString(currentContent, 'text/html');

                            const baseIdToSupElements = new Map();
                            const supElements = doc.querySelectorAll('sup[id$="-rf"]');
                            supElements.forEach(sup => {
                                const originalId = sup.id;
                                const baseId = originalId.replace(/-rf$/, '');

                                if (!baseIdToSupElements.has(baseId)) {
                                    baseIdToSupElements.set(baseId, []);
                                }
                                baseIdToSupElements.get(baseId).push(sup);
                            });

                            const idMapping = {};

                            for (const [baseId, supList] of baseIdToSupElements.entries()) {
                                let canonicalTargetId = supList[0].id;

                                if (supList.length > 1) {
                                    canonicalTargetId = `${baseId}-rf-0`;
                                    supList.forEach((sup, index) => {
                                        const newSupId = `${baseId}-rf-${index}`;
                                        sup.id = newSupId;
                                    });
                                }
                                supList.forEach(sup => {
                                    idMapping[sup.id] = canonicalTargetId;
                                });
                                if (supList.length > 1) {
                                    idMapping[`${baseId}-rf`] = canonicalTargetId;
                                }
                            }

                            const links = doc.querySelectorAll('a[href^="#"]');
                            links.forEach(link => {
                                let href = link.getAttribute('href');
                                const anchor = href.substring(1);

                                if (idMapping.hasOwnProperty(anchor)) {
                                    link.setAttribute('href', `#${idMapping[anchor]}`);
                                }
                            });
                            currentContent = doc.body.innerHTML; // Update currentContent after FN ID processing
                            console.log("Fix FN ID's applied. Content length:", currentContent.length);
                        }


                        currentContent = revertNBSPPlaceholders(currentContent); // Revert placeholders after all spacing/time tagging
                        currentContent = restoreDataAttributes(currentContent);
                        currentContent = doAutoEncode(currentContent); // Call the new auto-encode function
                        console.log("Auto-Encode applied. Content length:", currentContent.length);


                        monacoEditorInstance.setValue(currentContent);
                        htmlOutputContent = currentContent;
                        applyEntityHighlighting();

                        const originalText = formatSelectedBtn.textContent;
                        formatSelectedBtn.textContent = 'Formatted!';
                        formatSelectedBtn.classList.add('bg-green-500', 'hover:bg-green-600');
                        formatSelectedBtn.classList.remove('bg-blue-600', 'hover:bg-blue-700'); /* Changed */
                        formatSelectedBtn.disabled = true;
                        formatSelectedBtn.setAttribute('data-temp-active', 'true');
                        updateAllInteractiveButtonStates();
                        setTimeout(() => {
                            formatSelectedBtn.textContent = originalText;
                            formatSelectedBtn.classList.remove('bg-green-500', 'hover:bg-green-600');
                            formatSelectedBtn.classList.add('bg-blue-600', 'hover:bg-blue-700'); /* Changed */
                            formatSelectedBtn.disabled = false;
                            formatSelectedBtn.removeAttribute('data-temp-active');
                            updateAllInteractiveButtonStates();
                        }, 1500);
                    } else {
                        console.error("Monaco editor instance is not available.");
                    }
                });

                // Auto-ID button event listener
                autoIdBtn.addEventListener('click', () => {
                    const originalText = autoIdBtn.textContent;
                    autoIdBtn.textContent = 'Opening...';
                    autoIdBtn.classList.add('bg-green-500', 'hover:bg-green-600');
                    autoIdBtn.classList.remove('bg-slate-600', 'hover:bg-slate-500');
                    autoIdBtn.setAttribute('data-temp-active', 'true'); // Set the flag
                    updateAllInteractiveButtonStates(); // Disable all buttons
                    showAutoIdModal(autoIdBtn, originalText); // Pass original text to the modal
                });

                // Colophon button event listener
                colophonBtn.addEventListener('click', () => {
                    const originalText = colophonBtn.textContent;
                    colophonBtn.textContent = 'Opening...';
                    colophonBtn.classList.add('bg-green-500', 'hover:bg-green-600');
                    colophonBtn.classList.remove('bg-slate-600', 'hover:bg-slate-500');
                    colophonBtn.setAttribute('data-temp-active', 'true'); // Set the flag
                    updateAllInteractiveButtonStates(); // Disable all buttons

                    const colophonHtmlContent = `
                    <div class="flex flex-col space-y-4">
                        <div>
                            <span class="text-sm font-medium text-CBD5E1 mr-2">Language:</span> <!-- Changed text color -->
                            <div class="button-group inline-flex">
                                <button id="langEnglishBtn" class="px-3 py-1 text-sm bg-gray-600 text-white rounded-md hover:bg-gray-500 focus:outline-none focus:ring-2 focus:ring-slate-500 focus:ring-opacity-50 font-bold">English</button>
                                <button id="langFrenchBtn" class="px-3 py-1 text-sm bg-gray-600 text-white rounded-md hover:bg-gray-500 focus:outline-none focus:ring-2 focus:ring-slate-500 focus:ring-opacity-50 font-bold">French</button>
                            </div>
                        </div>
                        <div>
                            <span class="text-sm font-medium text-CBD5E1 mr-2">Monarch:</span>
                            <div class="button-group inline-flex">
                                <button id="monarchKingBtn" class="px-3 py-1 text-sm bg-gray-600 text-white rounded-md hover:bg-gray-500 focus:outline-none focus:ring-2 focus:ring-slate-500 focus:ring-opacity-50 font-bold">King</button>
                                <button id="monarchQueenBtn" class="px-3 py-1 text-sm bg-gray-600 text-white rounded-md hover:bg-gray-500 focus:outline-none focus:ring-2 focus:ring-slate-500 focus:ring-opacity-50 font-bold">Queen</button>
                            </div>
                        </div>
                        <div>
                            <span class="text-sm font-medium text-CBD5E1 mr-2">Identifier Type:</span>
                            <div class="button-group inline-flex">
                                <button id="idISBNBtn" class="px-3 py-1 text-sm bg-gray-600 text-white rounded-md hover:bg-gray-500 focus:outline-none focus:ring-2 focus:ring-slate-500 focus:ring-opacity-50 font-bold">ISBN</button>
                                <button id="idISSNBtn" class="px-3 py-1 text-sm bg-gray-600 text-white rounded-md hover:bg-gray-500 focus:outline-none focus:ring-2 focus:ring-slate-500 focus:ring-opacity-50 font-bold">ISSN</button>
                            </div>
                        </div>
                        <div>
                            <label for="colophonYear" class="block text-sm font-medium text-gray-200">Year (optional, defaults to current year):</label>
                            <input type="number" id="colophonYear" class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500" placeholder="e.g., 2024" min="1900" max="2100">
                        </div>
                        <div>
                            <label for="colophonNumber" class="block text-sm font-medium text-gray-200">Identifier Number (optional, defaults to ###):</label>
                            <input type="text" id="colophonNumber" class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500" placeholder="e.g., 123-456-789-X">
                        </div>
                    </div>
                `;
                    showModal('Insert Colophon', colophonHtmlContent, colophonBtn, originalText); // Pass original text
                });

                // Footnote List button event listener
                footnoteListBtn.addEventListener('click', () => {
                    const originalText = footnoteListBtn.textContent;
                    footnoteListBtn.textContent = 'Opening...';
                    footnoteListBtn.classList.add('bg-green-500', 'hover:bg-green-600');
                    footnoteListBtn.classList.remove('bg-slate-600', 'hover:bg-slate-500');
                    footnoteListBtn.setAttribute('data-temp-active', 'true');
                    updateAllInteractiveButtonStates();
                    showFootnoteModal(footnoteListBtn, originalText); // Pass original text
                });
                // Helper function to generate a valid, unique ID for HTML elements.
                // It sanitizes baseText, and ensures the generated ID is not already present in the document.
                function generateUniqueId(baseText, existingIds) {
                    let id = baseText.toLowerCase()
                        .replace(/[^a-z0-9\s-]/g, '') // Remove characters not allowed in IDs (keep letters, numbers, spaces, hyphens)
                        .replace(/\s+/g, '-') // Replace spaces with single hyphens
                        .replace(/^-+|-+$/g, ''); // Trim hyphens from start/end

                    if (!id) { // If the baseText was empty or only special characters, use a generic fallback
                        id = 'auto-id';
                    }

                    let counter = 1;
                    let uniqueId = id;
                    // Check if the generated ID already exists. If so, append a counter until unique.
                    while (existingIds.has(uniqueId)) {
                        uniqueId = `${id}-${counter}`;
                        counter++;
                    }
                    existingIds.add(uniqueId); // Add the newly generated unique ID to our set of existing IDs
                    return uniqueId;
                }

                function escapeRegExp(string) {
                    return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'); // $& means the matched substring
                }

                /**
                 * Helper function to recursively collect classes from existing list items.
                 * This version focuses on li and a classes.
                 * @param {HTMLElement} listElement - The current ul/ol element to traverse.
                 * @param {Map} liClassMap - Map to store li classes.
                 * @param {Map} aClassMap - Map to store a classes.
                 */
                function collectExistingListClasses(listElement, liClassMap, aClassMap) {
                    Array.from(listElement.children).forEach(child => {
                        if (child.tagName.toLowerCase() === 'li') {
                            const li = child;
                            const a = li.querySelector('a');
                            const hrefTargetId = a ? a.getAttribute('href')?.substring(1) : null;

                            if (hrefTargetId) {
                                if (li.className) {
                                    liClassMap.set(hrefTargetId, li.className);
                                }
                                if (a && a.className) {
                                    aClassMap.set(hrefTargetId, a.className);
                                }
                            }

                            // Recursively collect classes from any nested lists within this li
                            Array.from(li.children).forEach(liChild => {
                                if (liChild.tagName.toLowerCase() === 'ul' || liChild.tagName.toLowerCase() === 'ol') {
                                    collectExistingListClasses(liChild, liClassMap, aClassMap);
                                }
                            });
                        }
                    });
                }

                /**
                 * Inserts or updates the "On this page" / "Sur cette page" Table of Contents.
                 * It removes any existing Page ToC and regenerates it based on H2 (and optionally H3) headings,
                 * preserving any manually added classes on the ToC elements.
                 *
                 * @param {number} maxLevel - The maximum heading level to include (2 for H2 only, 3 for H2 and H3).
                 * @param {string} lang - The language ('en' for English, 'fr' for French).
                 */
                function insertPageToc(maxLevel, lang) {
                    const html = monacoEditorInstance.getValue();
                    const doc = new DOMParser().parseFromString(html, 'text/html');
                    const existingIds = new Set();
                    doc.querySelectorAll('[id]').forEach(el => existingIds.add(el.id));

                    // Ensure all H-level headings have unique IDs before generating links
                    doc.querySelectorAll('h1, h2, h3, h4, h5, h6').forEach(heading => {
                        if (!heading.id) {
                            heading.id = generateUniqueId(heading.textContent || `heading-${heading.tagName.toLowerCase()}`, existingIds);
                        }
                    });

                    let pageTocSectionClass = '';
                    let pageTocH2Class = '';
                    let pageTocUlClass = '';
                    let initialListTagName = 'ul'; // Default to ul
                    const pageTocLiClassMap = new Map();
                    const pageTocALinkClassMap = new Map();

                    // 1) Find and remove any existing Page ToC, and collect its classes
                    let oldToc = doc.getElementById('page-nav');
                    if (oldToc) {
                        pageTocSectionClass = oldToc.getAttribute('class') || '';
                        const existingH2 = oldToc.querySelector('h2');
                        if (existingH2) {
                            pageTocH2Class = existingH2.getAttribute('class') || '';
                        }
                        const existingUlOrOl = oldToc.querySelector('ul, ol');
                        if (existingUlOrOl) {
                            pageTocUlClass = existingUlOrOl.getAttribute('class') || '';
                            initialListTagName = existingUlOrOl.tagName.toLowerCase();
                            collectExistingListClasses(existingUlOrOl, pageTocLiClassMap, pageTocALinkClassMap);
                        }
                        oldToc.remove();
                    } else {
                        const existingH2ByContent = Array.from(doc.querySelectorAll('h2')).find(h =>
                            h.textContent.trim().toLowerCase() === 'on this page' || h.textContent.trim().toLowerCase() === 'sur cette page'
                        );
                        if (existingH2ByContent && existingH2ByContent.parentNode && existingH2ByContent.parentNode.tagName.toLowerCase() === 'section') {
                            const potentialOldTocSection = existingH2ByContent.parentNode;
                            pageTocSectionClass = potentialOldTocSection.getAttribute('class') || '';
                            pageTocH2Class = existingH2ByContent.getAttribute('class') || '';
                            const existingUlOrOl = potentialOldTocSection.querySelector('ul, ol');
                            if (existingUlOrOl) {
                                pageTocUlClass = existingUlOrOl.getAttribute('class') || '';
                                initialListTagName = existingUlOrOl.tagName.toLowerCase();
                                collectExistingListClasses(existingUlOrOl, pageTocLiClassMap, pageTocALinkClassMap);
                            }
                            potentialOldTocSection.remove();
                        }
                    }

                    // 2) Collect all relevant headings, filtering out those within <aside> tags
                    const relevantHeadings = Array.from(doc.querySelectorAll('h1, h2, h3, h4, h5, h6')).filter(h => {
                        return parseInt(h.tagName.substring(1), 10) <= maxLevel && !h.closest('aside') && !h.closest('table');
                    });

                    if (!relevantHeadings.length) return;

                    // --- DOM-based List Building Logic (Mirroring insertSectionToc directly) ---

                    // Create the root UL/OL element for the Page TOC
                    const rootUl = doc.createElement(initialListTagName);
                    if (pageTocUlClass) rootUl.setAttribute('class', pageTocUlClass);

                    // The stack holds references to actual DOM ul/ol elements.
                    // Each item: { domElement: HTMLUListElement | HTMLOListElement, level: number, tagName: 'ul' | 'ol' }
                    // The `level` here represents the heading level that this `domElement` is meant to contain.
                    // Start with the rootUl, which will contain H2s (level 2).
                    let currentListStack = [{
                        domElement: rootUl,
                        level: 2,
                        tagName: initialListTagName
                    }];
                    let currentListDomElement = rootUl; // The actual DOM element to append LIs to

                    relevantHeadings.forEach(h => {
                        const hLevel = parseInt(h.tagName.substring(1), 10);
                        const txt = h.textContent.trim();
                        const id = h.id;
                        const liClass = pageTocLiClassMap.get(id) || '';
                        const aClass = pageTocALinkClassMap.get(id) || '';

                        // Create the <li> and <a> elements for the current heading
                        const li = doc.createElement('li');
                        if (liClass) li.setAttribute('class', liClass);
                        const a = doc.createElement('a');
                        a.setAttribute('href', `#${id}`);
                        a.textContent = txt;
                        if (aClass) a.setAttribute('class', aClass);
                        li.appendChild(a);

                        // Adjust stack based on heading level
                        // IMPORTANT FIX: Changed hLevel <= to hLevel < in the while condition,
                        // mirroring insertSectionToc's working logic.
                        while (currentListStack.length > 1 && hLevel < currentListStack[currentListStack.length - 1].level) {
                            currentListStack.pop();
                        }
                        currentListDomElement = currentListStack[currentListStack.length - 1].domElement; // Update current list DOM element

                        if (hLevel > currentListStack[currentListStack.length - 1].level) {
                            // New, deeper level: Create a new nested <ul>/ol.
                            // This new list will be a child of the *last <li>* added to the currentListDomElement.
                            const parentLiElement = currentListDomElement.lastElementChild; // Get the last <li> appended

                            if (parentLiElement && parentLiElement.tagName.toLowerCase() === 'li') {
                                const newNestedListDomElement = doc.createElement(initialListTagName); // Use initialListTagName for consistency
                                parentLiElement.appendChild(newNestedListDomElement); // Append new <ul> to the last <li>

                                // Push this new list DOM element onto the stack
                                currentListStack.push({
                                    domElement: newNestedListDomElement,
                                    level: hLevel,
                                    tagName: initialListTagName
                                });
                                currentListDomElement = newNestedListDomElement; // Update current list DOM element
                            } else {
                                // This scenario means an H3 (or deeper) appeared without a preceding H2/LI to nest under.
                                // It indicates a malformed heading structure or an issue with heading collection.
                                // For robustness, add the LI directly to the current (likely root) UL.
                                console.warn(`H${hLevel} (${txt}) found with no valid parent LI to nest under. Appending to current UL.`);
                            }
                        }

                        // Add the current <li> to the current active <ul>/ol DOM element
                        currentListDomElement.appendChild(li);
                    });

                    // 3) Get the final HTML string from the constructed DOM tree
                    const finalHtmlListContent = rootUl.outerHTML;

                    // 4) Assemble new ToC HTML
                    const tocTitle = lang === 'en' ? 'On this page' : 'Sur cette page';
                    const toc = `
    <section id="page-nav"${pageTocSectionClass ? ` class="${pageTocSectionClass}"` : ''}>
        <h2 id="toc"${pageTocH2Class ? ` class="${pageTocH2Class}"` : ''}>${tocTitle}</h2>
        ${finalHtmlListContent}
    </section>`;

                    // 5) Find insertion point: first <section> or fallback to top of body
                    const firstSection = doc.querySelector('section');
                    if (firstSection) {
                        firstSection.insertAdjacentHTML('beforebegin', toc);
                    } else {
                        doc.body.insertAdjacentHTML('afterbegin', toc);
                    }

                    // 6) Write back updated HTML
                    monacoEditorInstance.setValue(doc.body.innerHTML);
                    autoFormatBtn.click(); // Format the new HTML
                }

                // Update your button event listeners to use the new insertPageToc function:
                document.getElementById('enPageToCBtn').addEventListener('click', () => insertPageToc(2, 'en')); // H2 only
                document.getElementById('frPageToCBtn').addEventListener('click', () => insertPageToc(2, 'fr')); // H2 only
                document.getElementById('enPageToCH3Btn').addEventListener('click', () => insertPageToc(3, 'en')); // H2 and H3
                document.getElementById('frPageToCH3Btn').addEventListener('click', () => insertPageToc(3, 'fr')); // H2 and H3


                function insertSectionToc(maxLevel, lang) {
                    const html = monacoEditorInstance.getValue();
                    const doc = new DOMParser().parseFromString(html, 'text/html');
                    const existingIds = new Set();
                    doc.querySelectorAll('[id]').forEach(el => existingIds.add(el.id));

                    // Ensure all H-level elements have unique IDs first (essential for linking)
                    doc.querySelectorAll('h2, h3, h4, h5, h6').forEach(heading => {
                        if (!heading.id) {
                            heading.id = generateUniqueId(heading.textContent || `heading-${heading.tagName.toLowerCase()}`, existingIds);
                        }
                    });

                    // Data structures to store existing classes for li and a tags
                    const liClassMap = new Map();
                    const aClassMap = new Map();
                    // Only store the type of the ROOT list for each section TOC
                    const rootListTypeMap = new Map(); // Key: details.id, Value: 'ul' or 'ol'

                    // Pre-scan existing TOCs to collect classes and root list types
                    doc.querySelectorAll('details[id^="sec-nav-"]').forEach(existingDetails => {
                        const detailsId = existingDetails.id;
                        const existingUlOrOl = existingDetails.querySelector('ul, ol');

                        if (existingUlOrOl) {
                            // Store the type of this root section list
                            rootListTypeMap.set(detailsId, existingUlOrOl.tagName.toLowerCase());

                            // Collect classes from li and a tags
                            collectExistingListClasses(existingUlOrOl, liClassMap, aClassMap);
                        }
                    });

                    Array.from(doc.querySelectorAll('h2')).forEach(h2 => {
                        const items = [];
                        let currentElement = h2.nextElementSibling;
                        while (currentElement && !['h1', 'h2'].includes(currentElement.tagName.toLowerCase())) {
                            Array.from(currentElement.querySelectorAll('h3, h4, h5, h6')).forEach(subHeading => {
                                const subLevel = parseInt(subHeading.tagName.substring(1), 10);
                                if (subLevel <= maxLevel) {
                                    items.push(subHeading);
                                }
                            });
                            currentElement = currentElement.nextElementSibling;
                        }

                        const detailsId = 'sec-nav-' + h2.id;
                        let details = doc.getElementById(detailsId);
                        let summary, ulOrOl;
                        let oldDetailsClasses = details ? details.getAttribute('class') || '' : '';
                        let oldSummaryClasses = details ? (details.querySelector('summary') ? details.querySelector('summary').getAttribute('class') || '' : '') : '';
                        let oldListClasses = details ? (details.querySelector('ul, ol') ? details.querySelector('ul, ol').getAttribute('class') || '' : '') : '';
                        let initialListTagName = rootListTypeMap.get(detailsId) || 'ul';

                        // NEW LOGIC START: Check for un-ID'd details elements to adopt
                        if (!details) {
                            // Look for a sibling <details> element that doesn't have an ID
                            // and whose summary content matches the expected ToC titles.
                            // THIS IS THE CRUCIAL CHANGE: `child === h2.nextElementSibling`
                            const potentialDetails = Array.from(h2.parentNode.children).find(child => {
                                return child.tagName.toLowerCase() === 'details' &&
                                    !child.id &&
                                    child === h2.nextElementSibling && // The potential details element MUST immediately follow the h2
                                    child.querySelector('summary') &&
                                    (child.querySelector('summary').textContent.trim().toLowerCase() === 'in this section' ||
                                        child.querySelector('summary').textContent.trim().toLowerCase() === 'dans cette section');
                            });

                            if (potentialDetails) {
                                details = potentialDetails;
                                // Assign the correct ID to the adopted details element
                                details.id = detailsId;
                                existingIds.add(detailsId); // Add to our set of known IDs
                                // Capture its existing classes, if any
                                oldDetailsClasses = details.getAttribute('class') || '';
                                oldSummaryClasses = details.querySelector('summary') ? details.querySelector('summary').getAttribute('class') || '' : '';
                                oldListClasses = details.querySelector('ul, ol') ? details.querySelector('ul', 'ol').getAttribute('class') || '' : '';
                                const existingUl = details.querySelector('ul');
                                const existingOl = details.querySelector('ol');
                                if (existingUl) initialListTagName = 'ul';
                                else if (existingOl) initialListTagName = 'ol';
                            }
                        }
                        // NEW LOGIC END

                        if (!items.length && (!details || !details.id || !details.id.startsWith('sec-nav-'))) {
                            // If no items found, and no existing *section toc* details, just return.
                            // If a generic un-ID'd details was found but doesn't map to a section TOC, it's ignored.
                            return;
                        }
                        if (!items.length && details) { // If there were items previously but no longer, remove the old ToC
                            details.remove();
                            return;
                        }


                        if (details) {
                            summary = details.querySelector('summary');
                            ulOrOl = details.querySelector('ul, ol');
                            if (ulOrOl) {
                                ulOrOl.innerHTML = ''; // Clear existing list items to rebuild
                            } else {
                                // If details exist but no list inside, create new with initialListTagName
                                ulOrOl = doc.createElement(initialListTagName);
                                if (oldListClasses) ulOrOl.setAttribute('class', oldListClasses);
                                details.appendChild(ulOrOl);
                            }
                        } else {
                            details = doc.createElement('details');
                            details.id = detailsId;
                            summary = doc.createElement('summary');
                            summary.className = 'wb-toggle';
                            ulOrOl = doc.createElement(initialListTagName); // Use determined initial list tag
                            details.appendChild(summary);
                            details.appendChild(ulOrOl);
                        }

                        if (oldDetailsClasses) details.setAttribute('class', oldDetailsClasses);
                        if (oldSummaryClasses) summary.setAttribute('class', oldSummaryClasses);
                        if (oldListClasses) ulOrOl.setAttribute('class', oldListClasses);

                        summary.setAttribute('data-toggle', '{"print":"on"}');
                        summary.textContent = lang === 'en' ? 'In this section' : 'Dans cette section';

                        // Initialize stack with the root list element for this section TOC
                        let currentListStack = [{
                            domElement: ulOrOl,
                            level: 3,
                            tagName: initialListTagName
                        }];

                        items.forEach(el => {
                            const elLevel = parseInt(el.tagName.substring(1), 10);
                            const li = doc.createElement('li');
                            const a = doc.createElement('a');
                            const hrefTargetId = el.id;
                            a.href = `#${hrefTargetId}`;
                            a.textContent = el.textContent.trim();

                            if (liClassMap.has(hrefTargetId)) {
                                li.setAttribute('class', liClassMap.get(hrefTargetId));
                            }
                            if (aClassMap.has(hrefTargetId)) {
                                a.setAttribute('class', aClassMap.get(hrefTargetId));
                            }

                            li.appendChild(a);

                            let currentParentListContainer = currentListStack[currentListStack.length - 1];
                            let currentParentList = currentParentListContainer.domElement;
                            let currentParentLevel = currentParentListContainer.level;
                            let currentParentListType = currentParentListContainer.tagName;

                            if (elLevel > currentParentLevel) {
                                while (elLevel > currentParentLevel) {
                                    let newNestedListTagName = 'ul';
                                    if (currentParentListType === 'ol') {
                                        newNestedListTagName = 'ol';
                                    }
                                    const newNestedList = doc.createElement(newNestedListTagName);

                                    if (currentParentList.lastElementChild && currentParentList.lastElementChild.tagName.toLowerCase() === 'li') {
                                        currentParentList.lastElementChild.appendChild(newNestedList);
                                    } else {
                                        console.warn(`Unexpected structure: Appending new ${newNestedListTagName.toUpperCase()} to ${currentParentList.tagName.toUpperCase()} without preceding LI.`);
                                        currentParentList.appendChild(newNestedList);
                                    }
                                    currentListStack.push({
                                        domElement: newNestedList,
                                        level: currentParentLevel + 1,
                                        tagName: newNestedListTagName
                                    });
                                    currentParentList = newNestedList;
                                    currentParentLevel++;
                                    currentParentListType = newNestedListTagName;
                                }
                                currentParentList.appendChild(li);
                            } else if (elLevel < currentParentLevel) {
                                while (currentListStack.length > 1 && elLevel < currentListStack[currentListStack.length - 1].level) {
                                    currentListStack.pop();
                                }
                                currentParentListContainer = currentListStack[currentListStack.length - 1];
                                currentParentList = currentParentListContainer.domElement;
                                currentParentList.appendChild(li);
                            } else {
                                currentParentList.appendChild(li);
                            }
                        });

                        // Only insert if it was newly created and not already in the DOM (e.g., adopted)
                        if (!doc.getElementById(detailsId)) { // This check ensures we don't re-insert an adopted element
                            h2.parentNode.insertBefore(details, h2.nextSibling);
                        }
                    });

                    monacoEditorInstance.setValue(doc.body.innerHTML);
                    autoFormatBtn.click();
                }

                document.getElementById('formatSelectedBtn').addEventListener('click', () => {
                    // Get the unformatted code from the editor
                    const unformattedCode = monacoEditorInstance.getValue();

                    // Define the options for the beautifier (you can customize these)
                    const options = {
                        indent_size: 4, // The number of spaces to indent with
                        space_in_empty_paren: true // Add a space inside empty parentheses
                    };

                    // Use the html_beautify function from the library you are already loading
                    const formattedCode = html_beautify(unformattedCode, options);

                    // Set the formatted code back into the editor
                    monacoEditorInstance.setValue(formattedCode);
                });
                document.getElementById('cleanMsoBtn').addEventListener('click', () => {
                    // Get the unformatted code from the editor
                    const unformattedCode = monacoEditorInstance.getValue();

                    // Define the options for the beautifier (you can customize these)
                    const options = {
                        indent_size: 4, // The number of spaces to indent with
                        space_in_empty_paren: true // Add a space inside empty parentheses
                    };

                    // Use the html_beautify function from the library you are already loading
                    const formattedCode = html_beautify(unformattedCode, options);

                    // Set the formatted code back into the editor
                    monacoEditorInstance.setValue(formattedCode);
                });

                // now wire your buttons (you may already have these listeners; just point them at our new function)
                enSecToCBtn.addEventListener('click', () => insertSectionToc(3, 'en'));
                frSecToCBtn.addEventListener('click', () => insertSectionToc(3, 'fr'));
                enSecToCH4Btn.addEventListener('click', () => insertSectionToc(4, 'en'));
                frSecToCH4Btn.addEventListener('click', () => insertSectionToc(4, 'fr'));
                enSecToCH5Btn.addEventListener('click', () => insertSectionToc(5, 'en'));
                frSecToCH5Btn.addEventListener('click', () => insertSectionToc(5, 'fr'));
                enSecToCH6Btn.addEventListener('click', () => insertSectionToc(6, 'en'));
                frSecToCH6Btn.addEventListener('click', () => insertSectionToc(6, 'fr'));

                // Initial call to set the state of the Clean Mso button on load
                updateCleanMsoButtonState();

                // Add browser warning for unsaved changes
                window.onbeforeunload = function() {
                    // You can add a condition here if you only want to warn if the editor content is not empty
                    if (monacoEditorInstance && monacoEditorInstance.getValue().trim() !== '') {
                        return "You have unsaved changes. Are you sure you want to leave?";
                    }
                    // If you return nothing or undefined, the browser will not show a warning.
                };
            };
        </script>
</body>

</html>
