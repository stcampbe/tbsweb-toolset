<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WordToCodeâ„¢ - Rich Content Wizard</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/js-beautify/1.14.0/beautify-html.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/monaco-editor@0.49.0/min/vs/loader.js"></script>
    <style>
        /* Custom styles for the editor */
        html, body {
            height: 100%; /* Ensure html and body take full viewport height */
            margin: 0;
            padding: 0;
            overflow: hidden; /* Prevent body from scrolling; all scrolling should be within panels */
        }

        body {
            font-family: 'Inter', sans-serif; /* Using Inter font */
            display: flex;
            flex-direction: column;
            background-color: #09090b; /* Very dark zinc */
        }
        .editor-container {
            display: flex;
            flex-grow: 1; /* Allow container to grow and fill available space */
            padding: 1rem; /* Apply padding to all sides */
            gap: 1rem; /* Space between editor and richtext-output */
            margin: 0;
            width: 100%; /* Full width */
            height: 100%; /* Explicitly make editor-container take full height of flex parent (body) */
            box-sizing: border-box; /* Include padding in total height */
            overflow-y: hidden; /* Prevent editor container from scrolling its children */
            overflow-x: hidden; /* Prevent horizontal scrolling */
        }
        .code-panel, .richtext-output-panel {
            background-color: #18181b; /* Darker zinc */
            border-radius: 0.75rem; /* rounded-xl */
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3); /* Darker shadow */
            padding: 1rem;
            display: flex;
            flex-direction: column; /* Keep column for header, content area, and footer */
            flex-grow: 1; /* Allow panels to grow and shrink horizontally */
            flex-shrink: 1;
            flex-basis: 0; /* Important for equal distribution in flex row */
            height: 100%; /* Take full height of container */
            box-sizing: border-box; /* Include padding and border in element's total width/height */
            overflow-y: hidden; /* Prevent main panels from scrolling; internal elements will manage their own scroll */
            overflow-x: hidden; /* Prevent horizontal scrollbar on panels unless explicitly needed */
        }

        /* Resizer bar styling */
        .resizer {
            width: 10px; /* Width of the draggable bar */
            background-color: #3f3f46; /* Medium zinc */
            cursor: ew-resize; /* East-west resize cursor */
            flex-shrink: 0; /* Prevent resizer from shrinking */
            border-radius: 0.25rem; /* Slightly rounded corners */
            transition: background-color 0.2s ease; /* Smooth transition on hover */
        }
        .resizer:hover {
            background-color: #52525b; /* Lighter zinc on hover */
        }

        /* Monaco Editor specific styling */
        #monacoEditorContainer {
            min-height: 200px; /* Ensure it has a minimum height */
            flex-basis: 75%; /* Initial basis: 75% */
            flex-grow: 0;   /* Controlled by JS */
            flex-shrink: 0; /* Controlled by JS */
            height: 100%; /* Make Monaco take full height of its flex parent */
            /* Monaco editor will handle its own internal scrolling due to automaticLayout: true */
        }

        /* Rich-Text Iframe styling */
        iframe {
            width: 100%;
            height: 100%; /* Make iframe fill its parent's height */
            flex-grow: 1; /* Allow iframe to take all available vertical space */
            border: 1px solid #3f3f46; /* Medium zinc border */
            border-radius: 0.5rem; /* rounded-lg */
            background-color: #ffffff; /* Rich-Text Output window background remains white */
            overflow: auto; /* Ensure iframe itself can scroll if its content overflows */
        }

        /* Sidebar styling */
        #sidebar {
            flex-basis: 25%; /* Initial basis: 25% */
            flex-grow: 0;   /* Controlled by JS */
            flex-grow: 1; /* Allow it to grow vertically to fill available space */
            overflow-y: auto; /* Enable vertical scrolling for sidebar content */
            overflow-x: hidden; /* Prevent horizontal scrolling on sidebar */
            min-height: 0; /* Crucial for flex items to scroll correctly if content overflows */
            background-color: #18181b; /* Darker zinc */
            border-radius: 0.75rem; /* rounded-xl */
            padding: 1rem;
            display: flex;
            flex-direction: column; /* Keep column for header, content area, and footer */
            box-sizing: border-box; /* Include padding and border in element's total width/height */
        }

        h1 {
            color: #ffffff; /* White text for H1 in editor panel */
            margin-bottom: 1rem;
            text-align: center;
        }
        h2 {
            color: #ffffff; /* White text for H2 in panel headers */
        }
        h3 {
            color: #ffffff; /* White text for H3 in panel headers */
            font-size: 1.125rem; /* text-lg */
            font-weight: 600; /* semi-bold */
            margin-bottom: 1rem;
        }
        label {
            color: #d4d4d8; /* Zinc-300 for labels */
        }
        input[type="text"] {
            background-color: #27272a; /* Darker zinc for input */
            color: #ffffff; /* White text for input */
            border-color: #3f3f46; /* Medium zinc border for input */
        }
        input[type="text"]::placeholder {
            color: #a1a1aa; /* Zinc-400 for placeholder text */
        }
        input[type="number"] { /* New style for number input */
            background-color: #27272a; /* Darker zinc for input */
            color: #ffffff; /* White text for input */
            border-color: #3f3f46; /* Medium zinc border for input */
        }
        input[type="number"]::placeholder { /* New style for number input placeholder */
            color: #a1a1aa; /* Zinc-400 for placeholder text */
        }

        /* Add flex-shrink: 0 to the button containers at the top and bottom of panels */
        /* For Richtext panel header */
        #richtextOutputPanel > div.flex.items-center.mb-4 {
            flex-shrink: 0;
        }
        /* For Code panel header */
        #codePanel > div.flex.items-center.mb-4.flex-wrap {
            flex-shrink: 0;
        }
        /* For Code panel footer */
        #codePanel > div.mt-auto.pt-4.flex.justify-center.space-x-2 {
            flex-shrink: 0;
        }

        /* The main content area within the code panel (Monaco + Sidebar) */
        /* This div needs to correctly take up remaining vertical space */
        .code-panel > .flex.flex-grow.gap-4 {
            flex-grow: 1; /* Ensures it takes all remaining vertical space */
            height: 100%; /* Explicit height is often helpful in nested flex */
            display: flex; /* Already a flex container */
            gap: 1rem; /* Space between Monaco and Sidebar */
            overflow: hidden; /* Prevent this container from scrolling */
        }


        /* Responsive adjustments */
        @media (max-width: 768px) {
            .editor-container {
                flex-direction: column; /* Stack vertically on small screens */
            }
            .resizer {
                width: 100%; /* Full width for vertical resizer on small screens */
                height: 10px; /* Height for vertical resizer */
                cursor: ns-resize; /* North-south resize cursor */
            }
            /* Stack editor and sidebar vertically on small screens */
            .code-panel > .flex-grow { /* Target the div containing Monaco and Sidebar */
                flex-direction: column;
            }
            #monacoEditorContainer {
                width: 100%; /* Full width on small screens */
            }
            #sidebar {
                width: 100%; /* Full width on small screens */
            }
        }

        /* Styles for button group */
        .button-group {
            display: flex;
            width: 100%; /* Make it span full width */
            border-radius: 0.5rem; /* rounded-md */
            box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05); /* shadow-sm */
            border: 1px solid #3f3f46; /* Darker border for button group */
            flex-wrap: wrap; /* Keep for responsiveness on smaller screens */
        }

        .button-group button {
            flex: 1; /* Make buttons take up equal space */
            border-radius: 0; /* Remove individual button rounded corners */
            border: none; /* Remove individual button borders */
            margin: 0; /* Remove individual button margins */
            padding: 0.5rem 0.75rem; /* Consistent padding */
            font-size: 0.875rem; /* text-sm */
            line-height: 1.25rem; /* leading-5 */
            position: relative; /* For z-index if needed */
            color: #ffffff; /* White text for all buttons */
            font-weight: bold; /* Make buttons bold */
        }

        /* Specific styles for the Sections and Headings buttons - NO FLEX */
        #toggleSectionsBtn,
        #toggleHeadingsBtn {
            flex: none; /* Override flex: 1; for these specific buttons */
            width: auto; /* Allow buttons to size based on content */
            border: 1px solid #3f3f46; /* Add border back for individual buttons */
            border-radius: 0.5rem; /* Add rounded corners back for individual buttons */
            margin-left: 0.5rem; /* Add spacing between them and other buttons */
        }

        /* Adjust border between buttons in the main button groups */
        .button-group:not(.no-border-buttons) button:not(:last-child) {
            border-right: 1px solid rgba(63, 63, 70, 0.5); /* Darker separator between buttons */
        }
        .button-group.no-border-buttons button:not(:last-child) {
            border-right: none; /* Remove border for this specific group */
        }

        /* Specific styling for the byline and URL/Image source button groups */
        .button-group.individual-rounded-buttons {
            border: none; /* Remove group border */
            box-shadow: none; /* Remove group shadow */
            width: auto; /* Allow the group to size to content */
            gap: 0.5rem; /* Add gap between individual buttons */
        }

        .button-group.individual-rounded-buttons button {
            flex: none; /* Do not make buttons take equal space */
            border-radius: 0.5rem; /* Ensure rounded corners */
            border: 1px solid #3f3f46; /* Add individual button border */
            padding: 0.5rem 0.75rem; /* Consistent padding */
        }
        /* Remove right border for individual rounded buttons */
        .button-group.individual-rounded-buttons button:not(:last-child) {
            border-right: 1px solid #3f3f46; /* Keep individual border */
        }


        .button-group button:first-child {
            border-top-left-radius: 0.5rem;
            border-bottom-left-radius: 0.5rem;
        }

        .button-group button:last-child {
            border-top-right-radius: 0.5rem;
            border-bottom-right-radius: 0.5rem;
        }

        .button-group button:hover {
            z-index: 1; /* Bring hovered button to front to show full border/shadow */
        }

        /* Visibility classes for toggle view */
        .panel-hidden {
            display: none;
        }
        .panel-visible {
            display: flex; /* Or 'block' for iframe if it's not a flex container */
        }


        /* Customize section styles (removed, but keeping styles for reference if needed) */
        .customize-section {
            background-color: #27272a; /* Same as input background */
            border-radius: 0.5rem;
            padding: 1rem; /* Re-added padding */
            margin-bottom: 1rem; /* Re-added margin-bottom */
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .customize-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            /* Removed padding-bottom, margin-bottom, border-bottom */
        }

        .customize-content {
            /* Now uses max-height instead of height */
            max-height: 0; /* Changed from height: 0; */
            overflow: hidden;
            /* Unified transition for smoother effect */
            transition: max-height 0.5s ease-in-out, padding 0.5s ease-in-out; /* Transition max-height and padding */
            padding: 0 1rem; /* Padding for content area, default to 0 for collapsed */
            background-color: #3f3f46; /* Match header background */
            border-radius: 0 0 0.5rem 0.5rem; /* Rounded bottom corners */
        }

        .collapsible-content.expanded {
            /* max-height will be set by JS dynamically to scrollHeight or a large value */
            padding-top: 0.75rem; /* Add padding to content when expanded */
            padding-bottom: 0.75rem; /* Add padding to content when expanded */
        }

        .customize-header svg {
            transition: transform 0.3s ease;
        }

        .customize-header.expanded svg {
            transform: rotate(180deg);
        }

        /* Adjustments for button spacing */
        .code-panel h2 .inline-flex.mr-auto button,
        .richtext-output-panel h2 .inline-flex.mr-auto button {
            margin-right: 0.5rem; /* Default margin for buttons within the group */
        }

        /* When in fullscreen editor mode, remove margin from the first button group */
        .editor-container.fullscreen-editor .code-panel h2 .inline-flex.mr-auto {
            margin-left: 0 !important; /* Remove any left margin on the button container */
        }

        /* When in fullscreen richtext-output mode, remove margin from the first button group */
        .editor-container.fullscreen-richtext .richtext-output-panel h2 .inline-flex.mr-auto {
            margin-left: 0 !important; /* Remove any left margin on the button */
        }

        /* Ensure the button itself doesn't have an undesired left margin when its parent is adjusted */
        .editor-container.fullscreen-editor .code-panel h2 .inline-flex.mr-auto #fullScreenBtn,
        .editor-container.fullscreen-editor .code-panel h2 .inline-flex.mr-auto #exitFullScreenBtn,
        .editor-container.fullscreen-richtext .richtext-output-panel h2 .inline-flex.mr-auto #fullScreenRichTextBtn,
        .editor-container.fullscreen-richtext .richtext-output-panel h2 .inline-flex.mr-auto #exitFullScreenRichTextBtn {
            margin-left: 0; /* Explicitly remove any left margin on the button */
        }

        /* Modal styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .modal-content {
            background-color: #18181b; /* Darker zinc */
            padding: 2rem;
            border-radius: 0.75rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            color: #ffffff;
            text-align: left; /* Left align content */
            max-width: 90%;
            width: 400px;
        }

        .modal-content h3 {
            font-size: 1.5rem;
            font-weight: bold;
            margin-bottom: 1rem;
            text-align: left; /* Ensure title is left aligned */
        }

        .modal-content p {
            margin-bottom: 1.5rem;
        }

        .modal-content button {
            background-color: #52525b; /* Zinc-600 */
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            font-weight: bold;
            transition: background-color 0.2s ease;
        }

        .modal-content button:hover {
            background-color: #3f3f46; /* Zinc-700 */
        }

        .modal-content .button-group {
            border: none; /* Remove border for button groups inside modal */
            box-shadow: none; /* Remove shadow for button groups inside modal */
            width: auto; /* Allow buttons to size naturally */
        }

        .modal-content .button-group button {
            flex: none; /* Prevent buttons from taking equal space */
            margin: 0.25rem; /* Add some margin between buttons */
            border: 1px solid #3f3f46; /* Add border back for individual buttons */
            border-radius: 0.5rem; /* Add rounded corners back for individual buttons */
            padding: 0.3rem 0.6rem; /* Reduced padding for smaller buttons */
            font-size: 0.8rem; /* Reduced font size for smaller buttons */
        }

        .modal-content .button-group button.active {
            background-color: #27272a; /* Zinc-800 for active state */
            color: white;
            border-color: #27272a;
        }

        /* Styles for collapsible sections */
        .collapsible-section {
            background-color: #3f3f46; /* Medium zinc for section background */
            border-radius: 0.5rem;
            margin-bottom: 0.75rem; /* Space between sections */
            overflow: hidden; /* Hide overflowing content during collapse */
        }

        .collapsible-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem 1rem;
            cursor: pointer;
            background-color: #3f3f46; /* Medium zinc for header background */
            border-bottom: 1px solid #52525b; /* Lighter zinc border */
            border-radius: 0.5rem 0.5rem 0 0; /* Rounded top corners */
        }

        .collapsible-header.collapsed {
            border-bottom: none; /* No border when collapsed */
            border-radius: 0.5rem; /* Fully rounded when collapsed */
        }

        .collapsible-header h4 {
            font-size: 1rem;
            font-weight: bold;
            color: #ffffff;
        }

        .collapsible-header svg {
            transition: transform 0.3s ease;
        }

        .collapsible-header.expanded svg {
            transform: rotate(180deg);
        }

        .collapsible-content {
            /* Now uses max-height instead of height */
            max-height: 0; /* Changed from height: 0; */
            overflow: hidden;
            /* Unified transition for smoother effect */
            transition: max-height 0.5s ease-in-out, padding 0.5s ease-in-out; /* Transition max-height and padding */
            padding: 0 1rem; /* Padding for content area, default to 0 for collapsed */
            background-color: #3f3f46; /* Match header background */
            border-radius: 0 0 0.5rem 0.5rem; /* Rounded bottom corners */
        }

        .collapsible-content.expanded {
            /* max-height will be set by JS dynamically to scrollHeight or a large value */
            padding-top: 0.75rem; /* Add padding to content when expanded */
            padding-bottom: 0.75rem; /* Add padding to content when expanded */
        }

        /* Toggle Switch Styles */
        .toggle-switch-container {
            display: flex;
            align-items: center;
            margin-bottom: 0.5rem; /* Space between switches */
            padding: 0.5rem 0; /* Vertical padding for each switch row */
            /* Removed flex-direction: row-reverse; */
            /* Removed justify-content: flex-end; */
            gap: 0.5rem; /* Space between toggle and label */
            margin-left: auto; /* Push the entire container to the right */
        }

        .toggle-switch-label {
            color: #d4d4d8; /* Light gray for label text */
            font-size: 0.9rem;
            /* Removed flex-grow: 1; */
            flex-shrink: 1; /* Allow label to shrink */
            min-width: 0; /* Allow text to wrap within the label */
            /* Removed text-align: right; */
        }

        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 44px; /* Width of the pill */
            height: 24px; /* Height of the pill */
            border-radius: 12px; /* Half of height for pill shape */
            background-color: #71717a; /* Off state background - Zinc-600 */
            cursor: pointer;
            transition: background-color 0.3s ease;
            flex-shrink: 0; /* Prevent the switch from shrinking */
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-switch-slider {
            position: absolute;
            content: "";
            height: 20px; /* Height of the inner circle */
            width: 20px; /* Width of the inner circle */
            left: 2px; /* Initial position for off state */
            bottom: 2px;
            background-color: #ffffff; /* Circle color */
            border-radius: 50%;
            transition: transform 0.3s ease;
        }

        /* Checked state styles (applied to the .toggle-switch label itself) */
        .toggle-switch.is-checked {
            background-color: #22c55e; /* Green for on state */
        }

        .toggle-switch.is-checked .toggle-switch-slider {
            transform: translateX(20px); /* Move circle to the right */
        }

        /* Custom style for HTML character entities in Monaco Editor */
        .entity-highlight {
            color: gold !important; /* Use !important to ensure override */
        }

        /* Styling for disabled button */
        .button-list button:disabled,
        .flex.justify-center.space-x-2 button:disabled,
        .flex.items-center.mb-4 button:disabled,
        .modal-content button:disabled { /* Apply to all buttons within these containers and modal buttons */
            background-color: #4a4a4a !important; /* Darker gray for disabled state, use !important to override other styles */
            cursor: not-allowed !important;
            opacity: 0.6 !important;
        }

        /* New styles for the button list */
        .button-list {
            display: flex;
            flex-direction: column; /* Stack buttons vertically */
            width: 100%;
            border: 1px solid #3f3f46; /* Border for the entire list */
            border-radius: 0.5rem; /* Rounded corners for the list container */
            overflow: hidden; /* Ensures child borders don't exceed parent radius */
            margin-bottom: 1rem; /* Space below button list */
        }

        .button-list button {
            width: 100%; /* Full width within the list */
            border-radius: 0; /* No individual button rounded corners */
            margin: 0; /* No individual button margins */
            border: none; /* No individual button borders */
            border-bottom: 1px solid rgba(63, 63, 70, 0.5); /* Separator between buttons */
            padding: 0.5rem 0.75rem; /* Consistent padding */
            text-align: center; /* Center text */
            font-weight: 600; /* semi-bold */
        }

        .button-list button:last-child {
            border-bottom: none; /* No border after the last button */
        }
    </style>
</head>
<body>
    <div class="editor-container">
        <div id="richtextOutputPanel" class="richtext-output-panel panel-visible">
            <div class="flex items-center mb-4">
                <h2 class="text-xl font-semibold text-white">Rich-Text Editor</h2>
                <button id="toggleEditorViewBtnRichText" class="ml-4 px-4 py-2 text-base font-semibold bg-sky-700 text-white rounded-md hover:bg-sky-800 focus:outline-none focus:ring-2 focus:ring-sky-600 focus:ring-opacity-50 font-bold">
                    Go to HTML
                </button>
                <!-- Auto-Clean MSO toggle for Rich-Text Editor -->
                <div class="ml-4 p-2 bg-zinc-700 rounded-lg flex items-center gap-2">
                    <label class="toggle-switch">
                        <input type="checkbox" id="toggleAutoCleanMsoOnSwitchRichText">
                        <span class="toggle-switch-slider"></span>
                    </label>
                    <span class="toggle-switch-label text-white text-sm">Auto-Clean MSO</span>
                </div>
            </div>
            <iframe id="default_ifr"></iframe>
        </div>

        <div id="codePanel" class="code-panel panel-hidden">
            <div class="flex items-center mb-4 flex-wrap">
                <h2 class="text-xl font-semibold text-white">HTML Editor</h2>
                <button id="toggleEditorViewBtnCode" class="ml-4 px-4 py-2 text-base font-semibold bg-sky-700 text-white rounded-md hover:bg-sky-800 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50 font-bold">
                    Go to Rich-Text
                </button>
                <!-- Auto-Clean MSO toggle for HTML Editor -->
                <div class="ml-4 p-2 bg-zinc-700 rounded-lg flex items-center gap-2">
                    <label class="toggle-switch">
                        <input type="checkbox" id="toggleAutoCleanMsoOnSwitchCode">
                        <span class="toggle-switch-slider"></span>
                    </label>
                    <span class="toggle-switch-label text-white text-sm">Auto-Clean MSO</span>
                </div>
                <!-- New Clean MSO Button -->
                <button id="cleanMsoBtn" class="ml-4 px-4 py-2 text-base bg-blue-700 text-white rounded-md hover:bg-blue-800 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50 font-bold">
                    Clean MSO
                </button>
                <div class="inline-flex space-x-2 ml-auto mt-2 sm:mt-0">
                    <button id="importHtmlBtn" class="px-3 py-1 text-sm bg-purple-700 text-white rounded-md hover:bg-purple-800 focus:outline-none focus:ring-2 focus:ring-purple-600 focus:ring-opacity-50 font-bold">Import HTML</button>
                    <button id="exportHtmlBtn" class="px-3 py-1 text-sm bg-red-700 text-white rounded-md hover:bg-red-800 focus:outline-none focus:ring-2 focus:ring-red-600 focus:ring-opacity-50 font-bold">Export HTML</button>
                    <input type="file" id="htmlFileInput" accept=".html" style="display: none;">
                </div>
            </div>

            <div class="flex flex-grow gap-4">
                <div id="monacoEditorContainer" class="flex-grow border border-zinc-700 rounded-lg overflow-hidden"></div>

                <!-- Resizer for Monaco and Sidebar -->
                <div id="monacoResizer" class="resizer"></div>

                <div id="sidebar">
                    <h3 class="text-lg font-semibold text-white mb-4">Quick Formatting</h3>

                    <div class="button-list">
						<!-- New Clean Spaces Button -->
                        <button id="cleanSpacesBtn" class="px-4 py-2 text-sm bg-zinc-700 text-white hover:bg-zinc-600 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50">
                            Clean Spaces
                        </button>

                        <!-- New Clean URLs Button -->
                        <button id="cleanUrlsBtn" class="px-4 py-2 text-sm bg-zinc-700 text-white hover:bg-zinc-600 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50">
                            Clean URLs
                        </button>                        
						
						<!-- Set Time Tags Button -->
                        <button id="timeTagsBtn" class="px-4 py-2 text-sm bg-zinc-700 text-white hover:bg-zinc-600 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50">
                            Set Time Tags
                        </button>

                        <!-- Fix FN ID's Button -->
                        <button id="fixFnIdsBtn" class="px-4 py-2 text-sm bg-zinc-700 text-white hover:bg-zinc-600 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50">
                            Fix FN ID's
                        </button>
						
						<!-- New Clean Single Breaks Button -->
                        <button id="cleanSingleBreaksBtn" class="px-4 py-2 text-sm bg-zinc-700 text-white hover:bg-zinc-600 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50">
                            Clean Single Breaks
                        </button>

                        <!-- New Clean <u> | <b> | <i> Button -->
                        <button id="cleanFormattingTagsBtn" class="px-4 py-2 text-sm bg-zinc-700 text-white hover:bg-zinc-600 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50">
                            Clean &lt;u&gt; | &lt;b&gt; | &lt;i&gt;
                        </button>

                        <!-- New Auto-Level Headings Button -->
                        <button id="autoLevelHeadingsBtn" class="px-4 py-2 text-sm bg-zinc-700 text-white hover:bg-zinc-600 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50">
                            Auto-Level Headings
                        </button>

                        <!-- New Auto-Section Button -->
                        <button id="autoSectionBtn" class="px-4 py-2 text-sm bg-zinc-700 text-white hover:bg-zinc-600 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50">
                            Auto-Section
                        </button>

                        <!-- New Auto-ID Button -->
                        <button id="autoIdBtn" class="px-4 py-2 text-sm bg-zinc-700 text-white hover:bg-zinc-600 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50">
                            Auto-ID
                        </button>
                    </div>

                    <h3 class="text-lg font-semibold text-white mb-4">Quick Insert</h3>
                    <div class="button-list">
                        <!-- New Footnote List Button -->
                        <button id="footnoteListBtn" class="px-4 py-2 text-sm bg-zinc-700 text-white hover:bg-zinc-600 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50">
                            Footnote List
                        </button>
                        <!-- New Colophon Button -->
                        <button id="colophonBtn" class="px-4 py-2 text-sm bg-zinc-700 text-white hover:bg-zinc-600 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50">
                            Colophon
                        </button>
                    </div>

                </div>

            </div>

            <div class="mt-auto pt-4 flex justify-center space-x-2">
                <button id="clearAllBtn" class="px-4 py-2 text-sm bg-zinc-700 text-white rounded-md hover:bg-zinc-600 focus:outline-none focus:ring-2 focus:ring-zinc-500 focus:ring-opacity-50 font-semibold">Clear All</button>
                <button id="autoEncodeBtn" class="px-4 py-2 text-sm bg-red-700 text-white rounded-md hover:bg-red-800 focus:outline-none focus:ring-2 focus:ring-red-600 focus:ring-opacity-50 font-semibold">
                    Auto-Encode
                </button>
                <button id="autoFormatBtn" class="px-4 py-2 text-sm bg-red-700 text-white rounded-md hover:bg-red-800 focus:outline-none focus:ring-2 focus:ring-red-600 focus:ring-opacity-50 font-semibold">
                    Auto-Indent
                </button>
                <button id="copyCodeBtn" class="px-4 py-2 text-sm bg-zinc-700 text-white rounded-md hover:bg-zinc-600 focus:outline-none focus:ring-2 focus:ring-zinc-500 focus:ring-opacity-50 font-semibold">
                    Copy Code
                </button>
            </div>
        </div>
    </div>

    <script>
        // Get references to the elements
        const default_ifr = document.getElementById('default_ifr');
        const codePanel = document.getElementById('codePanel');
        const richtextOutputPanel = document.getElementById('richtextOutputPanel');
        const toggleEditorViewBtnRichText = document.getElementById('toggleEditorViewBtnRichText');
        const toggleEditorViewBtnCode = document.getElementById('toggleEditorViewBtnCode');
        const copyCodeBtn = document.getElementById('copyCodeBtn');
        const autoFormatBtn = document.getElementById('autoFormatBtn');
        const autoEncodeBtn = document.getElementById('autoEncodeBtn'); // New button reference
        const exportHtmlBtn = document.getElementById('exportHtmlBtn');
        const importHtmlBtn = document.getElementById('importHtmlBtn');
        const htmlFileInput = document.getElementById('htmlFileInput');
        const clearAllBtn = document.getElementById('clearAllBtn');
        const timeTagsBtn = document.getElementById('timeTagsBtn'); // New: Get reference to Set Time Tags button
        const fixFnIdsBtn = document.getElementById('fixFnIdsBtn'); // Fixed: Corrected ID for Fix FN ID's button
        const cleanMsoBtn = document.getElementById('cleanMsoBtn'); // New: Get reference to Clean MSO button
        // New button references for former toggles
        const cleanUrlsBtn = document.getElementById('cleanUrlsBtn');
        const cleanSpacesBtn = document.getElementById('cleanSpacesBtn');
        const cleanSingleBreaksBtn = document.getElementById('cleanSingleBreaksBtn');
        const cleanFormattingTagsBtn = document.getElementById('cleanFormattingTagsBtn');
        const autoLevelHeadingsBtn = document.getElementById('autoLevelHeadingsBtn'); // New: Auto-Level Headings button
        const autoSectionBtn = document.getElementById('autoSectionBtn'); // New: Auto-Section button
        const autoIdBtn = document.getElementById('autoIdBtn'); // New: Auto-ID button
        const colophonBtn = document.getElementById('colophonBtn'); // New: Colophon button
        const footnoteListBtn = document.getElementById('footnoteListBtn'); // New: Footnote List button

        // Monaco Resizer elements
        const monacoEditorContainer = document.getElementById('monacoEditorContainer');
        const monacoResizer = document.getElementById('monacoResizer');
        const sidebar = document.getElementById('sidebar');

        // Auto-Clean MSO when switching toggles
        const toggleAutoCleanMsoOnSwitchRichText = document.getElementById('toggleAutoCleanMsoOnSwitchRichText');
        const toggleAutoCleanMsoOnSwitchCode = document.getElementById('toggleAutoCleanMsoOnSwitchCode');

        // NEW: Array of all interactive buttons to control their disabled state
        const allInteractiveButtons = [
            toggleEditorViewBtnRichText,
            toggleEditorViewBtnCode,
            cleanMsoBtn,
            importHtmlBtn,
            exportHtmlBtn,
            cleanSpacesBtn,
            cleanUrlsBtn,
            timeTagsBtn,
            fixFnIdsBtn,
            cleanSingleBreaksBtn,
            cleanFormattingTagsBtn,
            autoLevelHeadingsBtn,
            autoSectionBtn,
            autoIdBtn,
            footnoteListBtn,
            colophonBtn,
            clearAllBtn,
            autoEncodeBtn,
            autoFormatBtn,
            copyCodeBtn
        ];

        let richTextEditorInstance; // HugeRTE editor instance
        let monacoEditorInstance; // Monaco editor instance
        let currentView = 'richtext'; // 'richtext' or 'code'

        // Separate content storage for each editor
        let richTextContent = '';
        let htmlOutputContent = ''; // This will now hold the content for Monaco

        // Variable to hold the HugeRTE editor instance from the iframe
        let richTextEditorInstanceFromIframe;

        // NEW: Simplified NBSP Placeholder
        const NBSP_PLACEHOLDER = '__NBSP_PLACEHOLDER__'; // A unique string that won't conflict with content

        /**
         * Replaces all forms of non-breaking spaces with a single, unique placeholder.
         * @param {string} htmlString - The HTML string to process.
         * @returns {string} The HTML string with NBSP replaced by placeholders.
         */
        function applyNBSPPlaceholders(htmlString) {
            let processedString = htmlString;
            processedString = processedString.replace(/&nbsp;|&#160;|\u00A0/g, NBSP_PLACEHOLDER);
            return processedString;
        }

        /**
         * Reverts the unique placeholder back to the numeric HTML entity for non-breaking space.
         * @param {string} htmlString - The HTML string with NBSP placeholders.
         * @returns {string} The HTML string with original NBSP entities restored.
         */
        function revertNBSPPlaceholders(htmlString) {
            let processedString = htmlString;
            processedString = processedString.replace(new RegExp(NBSP_PLACEHOLDER, 'g'), '&#160;');
            return processedString;
        }

        /**
         * Encodes a string to Base64.
         * @param {string} str The string to encode.
         * @returns {string} The Base64 encoded string.
         */
        function encodeBase64(str) {
            return btoa(unescape(encodeURIComponent(str)));
        }

        /**
         * Decodes a Base64 string.
         * @param {string} str The Base64 string to decode.
         * @returns {string} The decoded string.
         */
        function decodeBase64(str) {
            return decodeURIComponent(escape(atob(str)));
        }

        /**
         * Protects all data- attributes by Base64 encoding their values and replacing them with a temporary attribute.
         * This function operates purely on the HTML string using regex to avoid DOM parsing issues with complex attribute values.
         * @param {string} htmlString - The HTML content to process.
         * @returns {string} The HTML with protected data- attributes.
         */
        function protectDataAttributes(htmlString) {
            // Regex to find any data- attribute.
            // Captures the full attribute name (e.g., "data-toggle") in group 1, and the value in group 2.
            const regex = /(data-[a-zA-Z0-9-]+)="([^"]*)"/g;
            return htmlString.replace(regex, (match, attrName, value) => {
                const encodedValue = encodeBase64(value);
                // Return a temporary attribute that stores the original attribute name and the encoded value.
                // We use a distinct prefix and include the original attribute name for later restoration.
                return `data-temp-protected-${attrName}="${encodedValue}"`;
            });
        }

        /**
         * Restores protected data- attributes by Base64 decoding their values and replacing them back.
         * The decoded value's internal double quotes are explicitly re-escaped as &quot; to prevent corruption during later DOM operations.
         * This function operates purely on the HTML string using regex.
         * @param {string} htmlString - The HTML content to process.
         * @returns {string} The HTML with original data- attributes restored.
         */
        function restoreDataAttributes(htmlString) {
            // Regex to find the temporary protected data- attributes.
            // Captures the original attribute name (e.g., "data-toggle") in group 1, and the encoded value in group 2.
            const regex = /data-temp-protected-(data-[a-zA-Z0-9-]+)="([^"]*)"/g;
            return htmlString.replace(regex, (match, originalAttrName, encodedValue) => {
                try {
                    let decodedValue = decodeBase64(encodedValue);
                    // Ensure literal double quotes and numeric double quote entities are converted to &quot;
                    // This is crucial to prevent re-escaping of the ampersand in &quot;
                    let safeValue = decodedValue.replace(/"/g, '&quot;');
                    safeValue = safeValue.replace(/&#34;/g, '&quot;');

                    // Restore the original data attribute with the safely escaped value.
                    return `${originalAttrName}="${safeValue}"`;
                } catch (e) {
                    console.error("Error decoding or re-escaping Base64 data-attribute:", e);
                    // If decoding/re-escaping fails, remove the attribute to prevent malformed HTML.
                    return '';
                }
            });
        }


        /**
         * Decodes HTML entities within a string to their actual Unicode characters.
         * Uses a temporary textarea element for reliable decoding.
         * @param {string} html - The HTML string containing entities.
         * @returns {string} The HTML string with entities decoded.
         */
        function decodeHtmlEntities(html) {
            const textarea = document.createElement('textarea');
            textarea.innerHTML = html; // Browser decodes entities when setting innerHTML
            return textarea.value; // Retrieving value gives the decoded string
        }

        /**
         * Cleans HTML content for display in HugeRTE.
         * This function is specifically for preparing content *before* setting it to the rich text editor.
         * It decodes HTML entities to ensure they render correctly in the visual editor.
         * @param {string} content - The HTML content to clean.
         * @returns {string} The cleaned HTML content.
         */
        function cleanHtmlForRichTextDisplay(content) {
            // Ensure content passed to rich text editor is also decoded
            return decodeHtmlEntities(content);
        }

        /**
         * Applies URL cleaning to HTML content.
         * Converts specific absolute URLs to relative paths and removes target/rel attributes from <a> tags.
         * Also removes <a> tags that ONLY contain a name attribute (i.e., no href).
         * @param {string} htmlString - The HTML content to clean.
         * @returns {string} The cleaned HTML content.
         */
        function applyUrlCleaning(htmlString) {
            const parser = new DOMParser(); // Create a new parser instance
            const tempDiv = parser.parseFromString(htmlString, 'text/html').body; // Parse string into a temporary DOM body

            const urlMappings = [
                { old: 'https://canada-preview.adobecqms.net/en/treasury-board-secretariat', new: '/content/canadasite/en/treasury-board-secretariat' },
                { old: 'https://canada-preview.adobecqms.net/fr/secretariat-conseil-tresor', new: '/content/canadasite/fr/secretariat-conseil-tresor' },
                { old: 'https://canada-preview.adobecqms.net/en/government', new: '/content/canadasite/en/government' },
                { old: 'https://canada-preview.adobecqms.net/fr/gouvernement', new: '/content/canadasite/fr/gouvernement' },
                { old: 'https://www.canada.ca/en/treasury-board-secretariat', new: '/content/canadasite/en/treasury-board-secretariat' },
                { old: 'https://www.canada.ca/fr/secretariat-conseil-tresor', new: '/content/canadasite/fr/secretaria-conseil-tresor' },
                { old: 'https://www.canada.ca/en/government', new: '/content/canadasite/en/government' },
                { old: 'https://www.canada.ca/fr/gouvernement', new: '/content/canadasite/fr/gouvernement' }
            ];

            const prependPatterns = [
                '/en/treasury-board-secretariat', 'en/treasury-board-secretariat',
                '/fr/secretariat-conseil-tresor', 'fr/secretariat-conseil-tresor',
                '/en/government', 'en/government',
                '/fr/gouvernement', 'fr/gouvernement'
            ];

            const aElements = tempDiv.querySelectorAll('a');
            aElements.forEach(a => {
                let href = a.getAttribute('href');
                const name = a.getAttribute('name');

                // Case 1: Remove <a> tags that ONLY contain a name attribute (no href)
                if (name && !href) {
                    const parent = a.parentNode;
                    if (parent) {
                        while (a.firstChild) {
                            parent.insertBefore(a.firstChild, a);
                        }
                        parent.removeChild(a);
                    }
                    return; // Skip further processing for this <a> tag
                }

                // Case 2: Process <a> tags with href
                if (href) {
                    // Handle Outlook Safelinks
                    if (href.startsWith('https://can01.safelinks.protection.outlook.com')) {
                        try {
                            const urlObj = new URL(href);
                            const actualUrlParam = urlObj.searchParams.get('url');
                            if (actualUrlParam) {
                                // Decode the actual URL parameter to get the clean link
                                href = decodeURIComponent(actualUrlParam);
                                a.setAttribute('href', href);
                            }
                        } catch (e) {
                            console.error("Error parsing Outlook Safelink URL:", e);
                            // Fallback: If parsing fails, keep the original safelink or remove it
                            // For now, we'll just keep the original href if parsing fails.
                        }
                    }

                    // Rule: Prepend /content/canadasite to specific relative links
                    let prepended = false;
                    for (const pattern of prependPatterns) {
                        if (href.startsWith(pattern)) {
                            if (href.startsWith('/')) {
                                href = '/content/canadasite' + href;
                            } else {
                                href = '/content/canadasite/' + href;
                            }
                            a.setAttribute('href', href);
                            prepended = true;
                            break; // Stop after the first match
                        }
                    }

                    // If already prepended, skip other URL conversions for this link
                    if (prepended) {
                        // Remove target attribute
                        if (a.hasAttribute('target')) {
                            a.removeAttribute('target');
                        }

                        // Remove rel attribute
                        if (a.hasAttribute('rel')) {
                            a.removeAttribute('rel');
                        }
                        return;
                    }

                    // Specific handling for "/content/canadasite" or "/content/dam" links
                    if (href.includes('/content/canadasite') || href.includes('/content/dam')) {
                        const contentPath = href.includes('/content/canadasite') ? '/content/canadasite' : '/content/dam';
                        const contentIndex = href.indexOf(contentPath);
                        if (contentIndex !== 0) {
                            href = href.substring(contentIndex);
                        }
                        a.setAttribute('href', href);
                    } else {
                        // Convert other URLs using existing mappings
                        for (const mapping of urlMappings) {
                            if (href.startsWith(mapping.old)) {
                                href = href.replace(mapping.old, mapping.new);
                                a.setAttribute('href', href);
                                break; // Stop after the first match
                            }
                        }
                    }
                }

                // Remove target attribute
                if (a.hasAttribute('target')) {
                    a.removeAttribute('target');
                }

                // Remove rel attribute
                if (a.hasAttribute('rel')) {
                    a.removeAttribute('rel');
                }
            });

            // NEW: Handle <img> tags with src attributes containing "/content/dam"
            const imgElements = tempDiv.querySelectorAll('img');
            imgElements.forEach(img => {
                let src = img.getAttribute('src');
                if (src && src.includes('/content/dam')) {
                    const contentDamIndex = src.indexOf('/content/dam');
                    if (contentDamIndex !== 0) { // If it doesn't start with /content/dam
                        src = src.substring(contentDamIndex); // Adjust to start from /content/dam
                        img.setAttribute('src', src);
                    }
                }
                // Also remove target and rel attributes from img tags for consistency, though less common
                if (img.hasAttribute('target')) {
                    img.removeAttribute('target');
                }
                if (img.hasAttribute('rel')) {
                    img.removeAttribute('rel');
                }
            });

            return tempDiv.innerHTML;
        }

        /**
         * Applies auto-spacing and cleans multiple <br> tags in HTML content.
         * Includes new rules for non-breaking spaces and empty tag removal/replacement.
         * Also trims leading/trailing spaces and non-breaking spaces within <p>, heading, and <li> tags.
         * @param {string} htmlString - The HTML content to clean.
         * @returns {string} The cleaned HTML content.
         */
        function applyAutoSpacing(htmlString) {
            const parser = new DOMParser();
            let doc = parser.parseFromString(htmlString, 'text/html');
            const body = doc.body;

            // 1. Unwrap <div> and <span> elements if they have no attributes.
            const elementsToUnwrap = Array.from(body.querySelectorAll('div, span'));
            elementsToUnwrap.forEach(element => {
                if (element.attributes.length === 0) {
                    const parent = element.parentNode;
                    if (parent) {
                        while (element.firstChild) {
                            parent.insertBefore(element.firstChild, element);
                        }
                        parent.removeChild(element);
                    }
                }
            });

            // 2. Handle <span style="mso-spacerun: yes"> tags (existing logic, still relevant)
            const spacerunSpans = body.querySelectorAll('span[style*="mso-spacerun: yes"]');
            spacerunSpans.forEach(span => {
                const parent = span.parentNode;
                if (parent) {
                    // Check if the span's text content contains a normal space
                    if (span.textContent.includes(' ')) {
                        // Replace the span with a single normal space
                        parent.replaceChild(doc.createTextNode(' '), span);
                    } else {
                        // Remove the span entirely if it's not containing a normal space
                        parent.removeChild(span);
                    }
                }
            });

            // Re-serialize and re-parse to handle previous DOM manipulations affecting string content for regex
            let cleanedHtml = body.innerHTML;
            doc = parser.parseFromString(cleanedHtml, 'text/html'); // Re-parse after initial DOM changes
            const currentBody = doc.body; // Use current body reference

            // 3. Condense multiple non-breaking spaces (&#160; or its Unicode char)
            // Replace multiple &#160; sequences (numeric or named entity)
            cleanedHtml = cleanedHtml.replace(/(?:&#160;|\u00A0|&nbsp;){2,}/gi, '&#160;');

            // 4. Clean non-breaking spaces with normal spaces to their left/right
            // Replace sequences like ' &#160;' with '&#160;'
            cleanedHtml = cleanedHtml.replace(/\s+(&#160;|\u00A0|&nbsp;)/gi, '&#160;');
            // Replace sequences like '&#160; ' with '&#160;'
            cleanedHtml = cleanedHtml.replace(/(&#160;|\u00A0|&nbsp;)\s+/gi, '&#160;');


            // 5. Replace sequences of two or more <br> tags (with optional whitespace) with </p><p> (existing logic)
            cleanedHtml = cleanedHtml.replace(/(<br\s*\/?>\s*){2,}/gi, '</p><p>');

            // 6. Completely remove <br clear="all"> and <br clear="ALL">
            cleanedHtml = cleanedHtml.replace(/<br\s+clear=["']?(all|ALL)["']?\s*\/?>/gi, '');


            // Re-parse to work with DOM for empty tag rules and other final cleanups
            doc.body.innerHTML = cleanedHtml;
            const finalBody = doc.body; // Use final body reference after re-parsing

            // 7. Remove/Replace empty tags
            const elementsToCheckForEmptiness = Array.from(finalBody.querySelectorAll('p, li, div, span, strong, em, u, b, i, section'));

            // Process in reverse to avoid issues with DOM changes affecting iteration
            for (let i = elementsToCheckForEmptiness.length - 1; i >= 0; i--) {
                const element = elementsToCheckForEmptiness[i];
                const tagName = element.tagName.toLowerCase();
                const trimmedContent = element.innerHTML.trim();
                const hasChildren = element.children.length > 0;
                const hasTextContent = element.textContent.trim().length > 0; // Check real text content
                const containsOnlyNBSP = (trimmedContent === '&#160;' || trimmedContent === '&nbsp;' || trimmedContent === '\u00A0');
                const containsOnlySpace = (trimmedContent === ' ');

                // Rule for <p> tags: remove only if outside a table
                if (tagName === 'p') {
                    const isInsideTable = element.closest('table');
                    if (!isInsideTable && (trimmedContent === '' || containsOnlyNBSP)) {
                        if (element.parentNode) {
                            element.parentNode.removeChild(element);
                        }
                    } else if (!isInsideTable && containsOnlySpace) {
                        // For <p> with single space, replace with text node of space
                        if (element.parentNode) {
                             element.parentNode.replaceChild(doc.createTextNode(' '), element);
                        }
                    }
                }
                // Rules for other tags: remove if empty or contains only NBSP, replace with space if contains only space
                else {
                    if (trimmedContent === '' || containsOnlyNBSP) {
                        if (element.parentNode) {
                            element.parentNode.removeChild(element);
                        }
                    } else if (containsOnlySpace) {
                        if (element.parentNode) {
                            element.parentNode.replaceChild(doc.createTextNode(' '), element);
                        }
                        }
                }
            }

            // --- New: Trim leading/trailing spaces and non-breaking spaces for <p>, heading, and <li> tags ---
            const elementsToTrim = finalBody.querySelectorAll('p, h1, h2, h3, h4, h5, h6, li');
            elementsToTrim.forEach(element => {
                let currentHtml = element.innerHTML;

                // Regex to match leading/trailing spaces, tabs, newlines, and &nbsp; entities
                // (?:&nbsp;|\s) ensures both &#160; and literal spaces are covered.
                // It's important to use &nbsp; in regex for string manipulation, as innerHTML might return it as such.
                currentHtml = currentHtml.replace(/^(?:&nbsp;|\s|&#160;|\u00A0)+/, ''); // Remove leading
                currentHtml = currentHtml.replace(/(?:&nbsp;|\s|&#160;|\u00A0)+$/, ''); // Remove trailing

                element.innerHTML = currentHtml;
            });
            // --- End of New Trim Logic ---

            return finalBody.innerHTML;
        }

        /**
         * Converts single <br> tags into paragraph breaks (</p><p>) while ignoring <br> tags within tables.
         * This simplified version does not attempt to preserve inline element nesting across the break.
         * @param {string} htmlString - The HTML content to process.
         * @returns {string} The processed HTML content.
         */
        function applyCleanSingleBreaks(htmlString) {
            const parser = new DOMParser();
            const doc = parser.parseFromString(htmlString, 'text/html');
            const brElements = Array.from(doc.querySelectorAll('br'));

            // Process elements in reverse order to avoid issues with DOM manipulation affecting iteration
            for (let i = brElements.length - 1; i >= 0; i--) {
                const br = brElements[i];

                // Check if br still exists in the DOM and has a parent
                if (!br || !br.parentNode) {
                    continue;
                }

                let currentParent = br.parentNode;
                let isInsideTable = false;
                // Traverse up the DOM tree to check if the <br> is inside a <table>
                while (currentParent && currentParent !== doc.body) {
                    if (currentParent.tagName && currentParent.tagName.toLowerCase() === 'table') {
                        isInsideTable = true;
                        break;
                    }
                    currentParent = currentParent.parentNode;
                }

                if (isInsideTable) {
                    continue; // Skip this <br> if it's inside a table
                }

                // Create a new paragraph element
                const newParagraph = doc.createElement('p');

                // Move all siblings after the <br> into the new paragraph
                while (br.nextSibling) {
                    newParagraph.appendChild(br.nextSibling);
                }

                // Insert the new paragraph after the original parent of the <br>
                // This effectively closes the current paragraph and starts a new one.
                if (br.parentNode.parentNode) {
                    br.parentNode.parentNode.insertBefore(newParagraph, br.parentNode.nextSibling);
                } else {
                    // Fallback for very unusual structures where parentNode.parentNode is null
                    doc.body.appendChild(newParagraph);
                }

                // Remove the <br> itself
                br.parentNode.removeChild(br);
            }

            return doc.body.innerHTML;
        }


        /**
         * Removes <p>&nbsp;</p> tags that are not within <table> or <li> tags.
         * @param {string} htmlString - The HTML content to clean.
         * @returns {string} The cleaned HTML content.
         */
        function removeEmptyParagraphsOutsideTablesAndLists(htmlString) {
            const parser = new DOMParser();
            const doc = parser.parseFromString(htmlString, 'text/html');
            const paragraphs = doc.querySelectorAll('p');

            for (let i = paragraphs.length - 1; i >= 0; i--) {
                const p = paragraphs[i];
                // Check if the paragraph contains only &nbsp; or is effectively empty after decoding
                // After decodeHtmlEntities, &nbsp; becomes a non-breaking space character (\u00A0)
                const containsOnlyNBSP = p.innerHTML.trim() === '&nbsp;' || p.innerHTML.trim() === '\u00A0';

                if (containsOnlyNBSP) {
                    let parent = p.parentElement;
                    let isInsideTableOrList = false;
                    while (parent) {
                        if (parent.tagName === 'TABLE' || parent.tagName === 'LI') {
                            isInsideTableOrList = true;
                            break;
                        }
                        parent = parent.parentElement;
                    }

                    if (!isInsideTableOrList) {
                        p.parentNode.removeChild(p);
                    }
                }
            }
            return doc.body.innerHTML;
        }

        /**
         * Removes empty <p> tags and <p> tags that contain only a single non-breaking space,
         * specifically if they have a class starting with "Mso" and are not within a table.
         * @param {string} htmlString - The HTML content to clean.
         * @returns {string} The cleaned HTML content.
         */
        function removeEmptyParagraphs(htmlString) {
            const parser = new DOMParser();
            const doc = parser.parseFromString(htmlString, 'text/html');
            const paragraphs = doc.querySelectorAll('p');

            for (let i = paragraphs.length - 1; i >= 0; i--) {
                const p = paragraphs[i];

                // Condition 1: Check if the paragraph is empty or contains only a non-breaking space
                const trimmedContent = p.innerHTML.trim();
                const isEmptyOrNBSP = trimmedContent === '' || trimmedContent === '&nbsp;' || trimmedContent === '\u00A0';

                // Condition 2: Check if the paragraph has a class attribute starting with "Mso"
                const hasMsoClass = p.classList.length > 0 && p.className.startsWith('Mso');

                // Condition 3: Check if the paragraph is NOT within a table
                const isInsideTable = p.closest('table');

                if (isEmptyOrNBSP && hasMsoClass && !isInsideTable) {
                    if (p.parentNode) {
                        p.parentNode.removeChild(p);
                    }
                }
            }
            return doc.body.innerHTML;
        }

        /**
         * Removes inline width and height styles from all elements in the HTML content.
         * @param {string} htmlString - The HTML content to clean.
         * @returns {string} The cleaned HTML content.
         */
        function removeInlineWidthHeightStyles(htmlString) {
            const parser = new DOMParser();
            const doc = parser.parseFromString(htmlString, 'text/html');
            const allElements = doc.querySelectorAll('*');

            allElements.forEach(element => {
                if (element.hasAttribute('style')) {
                    let style = element.getAttribute('style');
                    // Remove width: ...; and height: ...;
                    style = style.replace(/width:\s*[^;]+;?/gi, '');
                    style = style.replace(/height:\s*[^;]+;?/gi, '');
                    // Clean up extra spaces or semicolons
                    style = style.replace(/;{2,}/g, ';').trim();
                    if (style.endsWith(';')) {
                        style = style.slice(0, -1);
                    }

                    if (style) {
                        element.setAttribute('style', style);
                    } else {
                        element.removeAttribute('style');
                    }
                }
            });
            return doc.body.innerHTML;
        }

        /**
         * Converts common character entities and named entities to their numeric HTML entity equivalents.
         * This function operates on an HTML string, parsing it to a temporary DOM, modifying text nodes,
         * and then serializing it back to a string, ensuring numeric entities are preserved.
         * @param {string} htmlString - The HTML content to process.
         * @returns {string} The processed HTML string with numeric entities.
         */
        function convertAllEntitiesToNumeric(htmlString) {
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = htmlString; // This parses entities to characters

            const walker = document.createTreeWalker(
                tempDiv,
                NodeFilter.SHOW_TEXT,
                {
                    acceptNode: function(textNode) {
                        let parent = textNode.parentNode;
                        while (parent) {
                            const tagName = parent.tagName ? parent.tagName.toLowerCase() : '';
                            if (tagName === 'script' || tagName === 'style' || tagName === 'time') {
                                return NodeFilter.FILTER_REJECT;
                            }
                            parent = parent.parentNode;
                        }
                        return NodeFilter.FILTER_ACCEPT;
                    }
                },
                false

            );

            let currentNode;
            const textNodesToProcess = [];
            while (currentNode = walker.nextNode()) {
                textNodesToProcess.push(currentNode);
            }

            textNodesToProcess.forEach(textNode => {
                let text = textNode.nodeValue;
                // Replace specific named entities/characters with their numeric character references
                text = text.replace(/â€™/g, '&#8217;');     // literal â€™
                text = text.replace(/&rsquo;/g, '&#8217;'); // &rsquo;
                text = text.replace(/â€œ/g, '&#8220;');     // literal â€œ
                text = text.replace(/&ldquo;/g, '&#8220;'); // &ldquo;
                text = text.replace(/â€/g, '&#8221;');     // literal â€
                text = text.replace(/&rdquo;/g, '&#8221;'); // &rdquo;
                text = text.replace(/Â«/g, '&#171;');     // literal Â«
                text = text.replace(/&laquo;/g, '&#171;'); // &laquo;
                text = text.replace(/Â»/g, '&#187;');     // literal Â»
                text = text.replace(/&raquo;/g, '&#187;'); // &raquo;
                text = text.replace(/\u00A0/g, '&#160;'); // This converts literal NBSP char to numeric entity
                text = text.replace(/&nbsp;/g, '&#160;'); // This handles named NBSP entity to numeric

                textNode.nodeValue = text;
            });

            let processedHtml = tempDiv.innerHTML; // This re-serializes characters to entities

            // Final string-based replacements to ensure numeric entities are explicitly present
            // This is a safeguard against browser's innerHTML serialization re-converting entities.
            processedHtml = processedHtml.replace(/&nbsp;/g, '&#160;');
            processedHtml = processedHtml.replace(/&rsquo;/g, '&#8217;');
            processedHtml = processedHtml.replace(/&ldquo;/g, '&#8220;');
            processedHtml = processedHtml.replace(/&rdquo;/g, '&#8221;');
            processedHtml = processedHtml.replace(/&laquo;/g, '&#171;');
            processedHtml = processedHtml.replace(/&raquo;/g, '&#187;');

            // Handle double encoding if it occurs (e.g., &amp;#160; -> &#160;)
            processedHtml = processedHtml.replace(/&amp;#(\d+);/g, '&#$1;');

            return processedHtml;
        }

        /**
         * Recursively cleans and preserves only specified HTML content from a source DOM node.
         * Disallowed tags are unwrapped, preserving their allowed children.
         * This function is used for both footnote content and general MSO problematic content.
         * @param {HTMLElement} sourceNode - The DOM node whose children are to be filtered.
         * @param {Document} doc - The document object to create new elements.
         * @returns {string} The HTML string containing only the preserved content.
         */
        function cleanAndPreserveAllowedContent(sourceNode, doc) {
            let tempContainer = doc.createElement('div');

            Array.from(sourceNode.childNodes).forEach(child => {
                if (child.nodeType === Node.TEXT_NODE) {
                    // Always preserve text nodes (including character entities which are parsed into text nodes)
                    tempContainer.appendChild(child.cloneNode(true));
                } else if (child.nodeType === Node.ELEMENT_NODE) {
                    const tagName = child.tagName.toLowerCase();

                    // Function to check if class or id contains disallowed patterns (case-sensitive)
                    const containsDisallowedPattern = (element) => {
                        const elemClassAttr = element.getAttribute('class');
                        if (elemClassAttr) {
                            const classes = elemClassAttr.split(/\s+/);
                            for (const cls of classes) {
                                if (cls.includes('Mso') || cls.includes('Word') || cls.includes('BCX0')) {
                                    return true;
                                }
                            }
                        }
                        const elemIdAttr = element.getAttribute('id');
                        if (elemIdAttr) {
                            if (elemIdAttr.includes('Mso') || elemIdAttr.includes('Word') || elemIdAttr.includes('BCX0')) {
                                return true;
                            }
                        }
                        return false;
                    };

                    const alwaysPreservedTags = [
                        'p', 'section', 'blockquote', 'article', 'ol', 'ul', 'li',
                        'figure', 'caption', 'details', 'summary',
                        'strong', 'u', 'em', 'i', 'b', 'br', 'mark', 'sup', 'sub', 'img',
                        'h1', 'h2', 'h3', 'h4', 'h5', 'h6' // Added heading tags
                    ];

                    const tableTags = ['table', 'thead', 'tbody', 'tfoot', 'tr', 'th', 'td'];

                    if (alwaysPreservedTags.includes(tagName) || tableTags.includes(tagName)) {
                        // These tags are always preserved, recursively clean their content
                        const clonedChild = child.cloneNode(false);
                        clonedChild.innerHTML = cleanAndPreserveAllowedContent(child, doc);
                        tempContainer.appendChild(clonedChild);
                    } else if (tagName === 'a' && child.hasAttribute('href')) {
                        // <a> tags only if they have an href
                        const clonedChild = child.cloneNode(false);
                        clonedChild.innerHTML = cleanAndPreserveAllowedContent(child, doc); // Still clean content inside
                        tempContainer.appendChild(clonedChild);
                    } else if (tagName === 'div') {
                        // <div> ONLY if they have a class or ID that DON'T contain "Mso" or "Word" or "BCX0"
                        if ((child.hasAttribute('class') || child.hasAttribute('id')) && !containsDisallowedPattern(child)) {
                            const clonedChild = child.cloneNode(false);
                            clonedChild.innerHTML = cleanAndPreserveAllowedContent(child, doc);
                            tempContainer.appendChild(clonedChild);
                        } else {
                            // Unwrap if it doesn't meet the criteria
                            const unwrappedContentHtml = cleanAndPreserveAllowedContent(child, doc);
                            const tempUnwrapDiv = doc.createElement('div'); // Temporary div to parse HTML string
                            tempUnwrapDiv.innerHTML = unwrappedContentHtml;
                            while (tempUnwrapDiv.firstChild) {
                                tempContainer.appendChild(tempUnwrapDiv.firstChild);
                            }
                        }
                    } else if (tagName === 'span') {
                        // <span> ONLY if they have a class or ID that DON'T match the ones mentioned (Mso/Word/BCX0)
                        if ((child.hasAttribute('class') || child.hasAttribute('id')) && !containsDisallowedPattern(child)) {
                            const clonedChild = child.cloneNode(false);
                            clonedChild.innerHTML = cleanAndPreserveAllowedContent(clonedChild, doc);
                            tempContainer.appendChild(clonedChild);
                        } else {
                            // Unwrap if it doesn't meet the criteria
                            const unwrappedContentHtml = cleanAndPreserveAllowedContent(child, doc);
                            const tempUnwrapDiv = doc.createElement('div'); // Temporary div to parse HTML string
                            tempUnwrapDiv.innerHTML = unwrappedContentHtml;
                            while (tempUnwrapDiv.firstChild) {
                                tempContainer.appendChild(tempUnwrapDiv.firstChild);
                            }
                        }
                    } else {
                        // For any other element not explicitly allowed, unwrap its content
                        const unwrappedContentHtml = cleanAndPreserveAllowedContent(child, doc);
                        const tempUnwrapDiv = doc.createElement('div'); // Temporary div to parse HTML string
                        tempUnwrapDiv.innerHTML = unwrappedContentHtml;
                        while (tempUnwrapDiv.firstChild) {
                            tempContainer.appendChild(tempUnwrapDiv.firstChild);
                        }
                    }
                }
            });
            return tempContainer.innerHTML;
        }

        /**
         * Processes <p> tags with "MsoListParagraph" class, converting them to <ul><li> structures.
         * @param {string} htmlString - The HTML content to clean.
         * @returns {string} The cleaned HTML content.
         */
        function applyCleanLists(htmlString) {
            const parser = new DOMParser();
            const doc = parser.parseFromString(htmlString, 'text/html');
            const body = doc.body;

            // Helper to get the level from style attribute for lists
            function getLevel(styleAttr) {
                if (!styleAttr) return null;
                const match = styleAttr.match(/level(\d+)/);
                return match ? parseInt(match[1], 10) : null;
            }

            // Helper to extract allowed content for lists
            function extractAllowedContentForLists(sourceNode) {
                let contentHtml = '';
                const childrenToProcess = Array.from(sourceNode.childNodes);

                childrenToProcess.forEach(child => {
                    if (child.nodeType === Node.ELEMENT_NODE && child.tagName.toLowerCase() === 'span' && child.hasAttribute('style') && child.getAttribute('style').includes('mso-list: Ignore')) {
                        return;
                    }

                    if (child.nodeType === Node.TEXT_NODE) {
                        contentHtml += child.nodeValue;
                    } else if (child.nodeType === Node.ELEMENT_NODE) {
                        const tagName = child.tagName.toLowerCase();
                        const hasClassOrId = child.hasAttribute('class') || child.hasAttribute('id');

                        // Use the containsDisallowedPattern from cleanAndPreserveAllowedContent for consistent MSO/Word/BCX0 checks
                        const containsDisallowedPattern = (element) => {
                            const elemClassAttr = element.getAttribute('class');
                            if (elemClassAttr) {
                                const classes = elemClassAttr.split(/\s+/);
                                for (const cls of classes) {
                                    if (cls.includes('Mso') || cls.includes('Word') || cls.includes('BCX0')) {
                                        return true;
                                    }
                                }
                            }
                            const elemIdAttr = element.getAttribute('id');
                            if (elemIdAttr) {
                                if (elemIdAttr.includes('Mso') || elemIdAttr.includes('Word') || elemIdAttr.includes('BCX0')) {
                                    return true;
                                }
                            }
                            return false;
                        };

                        if (tagName === 'br' || tagName === 'strong' || tagName === 'a' || tagName === 'em' || tagName === 'u' || tagName === 'sup' || tagName === 'sub' || tagName === 'section') {
                            contentHtml += child.outerHTML;
                        } else if ((tagName === 'span' || tagName === 'div') && hasClassOrId && !containsDisallowedPattern(child)) {
                            const clonedChild = child.cloneNode(false);
                            clonedChild.innerHTML = extractAllowedContentForLists(clonedChild);
                            contentHtml += clonedChild.outerHTML;
                        } else if (tagName === 'a' && child.hasAttribute('href')) { // Explicitly handle <a> with href
                            contentHtml += child.outerHTML;
                        }
                        else {
                            contentHtml += extractAllowedContentForLists(child);
                        }
                    }
                });
                return contentHtml;
            }

            // Helper to determine list type
            function detectListType(pElement) {
                const msoListIgnoreSpan = pElement.querySelector('span[style*="mso-list: Ignore"]');
                if (msoListIgnoreSpan) {
                    const bulletText = msoListIgnoreSpan.textContent.trim();
                    if (/^\d+(\.\d+)+[\.\)]*$/.test(bulletText)) {
                        return 'complex-bullet';
                    }
                    if (/^[A-Za-z](\.\d+)+[\.\)]*$/.test(bulletText)) {
                        return 'complex-bullet';
                    }
                    if (/^\d+[\.\)]$/.test(bulletText)) {
                        return 'ordered-numeric';
                    }
                    if (/^[a-z][\.\)]$/.test(bulletText)) {
                        return 'ordered-alpha';
                    }
                }
                return 'unordered';
            }

            const paragraphs = Array.from(body.querySelectorAll('p'));
            const paragraphsToReplace = new Map();
            const paragraphsToRemove = new Set();

            for (let i = 0; i < paragraphs.length; i++) {
                const p = paragraphs[i];
                const classList = Array.from(p.classList);
                const isMsoListParagraph = classList.some(cls =>
                    cls === 'MsoListParagraphCxSpFirst' ||
                    cls === 'MsoListParagraphCxSpMiddle' ||
                    cls === 'MsoListParagraphCxSpLast' ||
                    cls === 'MsoListParagraph'
                );

                if (paragraphsToRemove.has(p)) {
                    continue;
                }

                if (isMsoListParagraph) {
                    const pStyle = p.getAttribute('style') || '';
                    const level = getLevel(pStyle);

                    if (isMsoListParagraph && level === null) {
                        p.removeAttribute('class');
                        p.classList.add('MsoNormal');
                        continue;
                    }

                    const msoListIgnoreSpan = p.querySelector('span[style*="mso-list: Ignore"]');
                    let bulletTextToPrepend = '';
                    let listType = 'unordered';

                    if (msoListIgnoreSpan) {
                        bulletTextToPrepend = msoListIgnoreSpan.textContent.trim();
                        listType = detectListType(p);
                        msoListIgnoreSpan.parentNode.removeChild(msoListIgnoreSpan);
                    }

                    let newRootListElement;

                    if (listType === 'ordered-numeric') {
                        newRootListElement = doc.createElement('ol');
                    } else if (listType === 'ordered-alpha') {
                        newRootListElement = doc.createElement('ol');
                        newRootListElement.classList.add('lst-lwr-alph');
                    } else {
                        newRootListElement = doc.createElement('ul');
                    }

                    let currentListStack = [newRootListElement];
                    let currentParentList = newRootListElement;

                    const li = doc.createElement('li');
                    let listItemContent = extractAllowedContentForLists(p);

                    if (listType === 'complex-bullet') {
                        li.innerHTML = bulletTextToPrepend + ' ' + listItemContent;
                    } else {
                        li.innerHTML = listItemContent;
                    }
                    currentParentList.appendChild(li);
                    paragraphsToReplace.set(p, newRootListElement);

                    let nextSibling = p.nextElementSibling;
                    let currentSequenceIndex = i + 1;

                    while (nextSibling && nextSibling.nodeType === Node.ELEMENT_NODE && nextSibling.tagName.toLowerCase() === 'p') {
                        const nextP = nextSibling;
                        const nextPClassList = Array.from(nextP.classList);
                        const isNextPListParagraph = nextPClassList.some(cls =>
                            cls === 'MsoListParagraphCxSpFirst' ||
                            cls === 'MsoListParagraphCxSpMiddle' ||
                            cls === 'MsoListParagraphCxSpLast' ||
                            cls === 'MsoListParagraph'
                        );

                        const nextPStyle = nextP.getAttribute('style') || '';
                        const nextLevelCheck = getLevel(nextPStyle);
                        if (isNextPListParagraph && nextLevelCheck === null) {
                            nextP.removeAttribute('class');
                            nextP.classList.add('MsoNormal');
                            break;
                        }

                        if (isNextPListParagraph) {
                            const nextLevel = getLevel(nextP.getAttribute('style') || '');
                            let currentDepth = currentListStack.length;

                            const nextMsoListIgnoreSpan = nextP.querySelector('span[style*="mso-list: Ignore"]');
                            let nextBulletTextToPrepend = '';
                            let nextListType = 'unordered';

                            if (nextMsoListIgnoreSpan) {
                                nextBulletTextToPrepend = nextMsoListIgnoreSpan.textContent.trim();
                                nextListType = detectListType(nextP);
                                nextMsoListIgnoreSpan.parentNode.removeChild(nextMsoListIgnoreSpan);
                            }

                            if (nextLevel > currentDepth) {
                                let nestedListElement;

                                if (nextListType === 'ordered-numeric') {
                                    nestedListElement = doc.createElement('ol');
                                } else if (nextListType === 'ordered-alpha') {
                                    nestedListElement = doc.createElement('ol');
                                    nestedListElement.classList.add('lst-lwr-alph');
                                } else {
                                    nestedListElement = doc.createElement('ul');
                                }

                                for (let k = currentDepth; k > nextLevel; k--) {
                                    currentListStack.pop();
                                    currentParentList = currentListStack[currentListStack.length - 1];
                                }
                                while (currentListStack.length < nextLevel) {
                                     let targetLi = currentParentList.lastElementChild;
                                     if (!targetLi || targetLi.tagName.toLowerCase() !== 'li') {
                                         targetLi = doc.createElement('li');
                                         currentParentList.appendChild(targetLi);
                                     }
                                     let newNestedList;
                                     if (currentListStack.length + 1 === nextLevel) {
                                         if (nextListType === 'ordered-numeric') {
                                             newNestedList = doc.createElement('ol');
                                         } else if (nextListType === 'ordered-alpha') {
                                             newNestedList = doc.createElement('ol');
                                             newNestedList.classList.add('lst-lwr-alph');
                                         } else {
                                             newNestedList = doc.createElement('ul');
                                         }
                                     } else {
                                         newNestedList = doc.createElement('ul');
                                     }
                                     targetLi.appendChild(newNestedList);
                                     currentListStack.push(newNestedList);
                                     currentParentList = newNestedList;
                                 }

                            } else if (nextLevel < currentDepth) {
                                for (let k = currentDepth; k > nextLevel; k--) {
                                    currentListStack.pop();
                                    currentParentList = currentListStack[currentListStack.length - 1];
                                }
                            }

                            const nextLi = doc.createElement('li');
                            let nextListItemContent = extractAllowedContentForLists(nextP);
                            if (nextListType === 'complex-bullet') {
                                nextLi.innerHTML = nextBulletTextToPrepend + ' ' + nextListItemContent;
                            } else {
                                nextLi.innerHTML = nextListItemContent;
                            }
                            currentParentList.appendChild(nextLi);
                            paragraphsToRemove.add(nextP);

                            nextSibling = nextP.nextElementSibling;
                            currentSequenceIndex++;
                        } else {
                            break;
                        }
                    }
                    i = currentSequenceIndex - 1;
                }
            }

            paragraphs.forEach(p => {
                if (paragraphsToReplace.has(p)) {
                    if (p.parentNode) {
                        p.parentNode.replaceChild(paragraphsToReplace.get(p), p);
                    }
                } else if (paragraphsToRemove.has(p)) {
                    if (p.parentNode) {
                        p.parentNode.removeChild(p);
                    }
                }
            });

            return doc.body.innerHTML;
        }

        /**
         * Applies basic cleaning to tables and their elements.
         * This includes removing colgroup/col tags, cleaning table/td/th attributes,
         * and handling paragraphs within table cells.
         * @param {string} htmlString - The HTML content to clean.
         * @returns {string} The cleaned HTML content.
         */
        function applyCleanTablesBasic(htmlString) {
            const parser = new DOMParser();
            const doc = parser.parseFromString(htmlString, 'text/html');
            const body = doc.body;

            // Remove colgroup and col elements
            const colgroupElements = doc.querySelectorAll('colgroup');
            for (let i = colgroupElements.length - 1; i >= 0; i--) {
                if (colgroupElements[i].parentNode) {
                    colgroupElements[i].parentNode.removeChild(colgroupElements[i]);
                }
            }

            const colElements = doc.querySelectorAll('col');
            for (let i = colElements.length - 1; i >= 0; i--) {
                if (colElements[i].parentNode) {
                    colElements[i].parentNode.removeChild(colElements[i]);
                }
            }

            // Clean attributes from table and its structural tags (thead, tbody, tfoot, tr, th, td)
            const tableRelatedTags = doc.querySelectorAll('table, thead, tbody, tfoot, tr, th, td');
            tableRelatedTags.forEach(element => {
                const attributesToKeep = ['rowspan', 'colspan', 'class', 'id', 'headers', 'scope'];
                const attributesToRemove = [];
                for (let j = 0; j < element.attributes.length; j++) {
                    const attr = element.attributes[j];
                    if (!attributesToKeep.includes(attr.name.toLowerCase())) {
                        attributesToRemove.push(attr.name);
                    }
                }
                attributesToRemove.forEach(attrName => {
                    element.removeAttribute(attrName);
                });
            });

            // Remove MsoTable class from tables
            doc.querySelectorAll('table').forEach(table => {
                const classAttr = table.getAttribute('class');
                if (classAttr && classAttr.includes('MsoTable')) {
                    table.removeAttribute('class');
                }
            });

            // Unwrap spans inside td with class^="xl"
            doc.querySelectorAll('table td[class^="xl"] span').forEach(span => {
                if (span.parentNode) {
                    while (span.firstChild) {
                        span.parentNode.insertBefore(span.firstChild, span);
                    }
                    span.parentNode.removeChild(span);
                }
            });

            // Remove class^="xl" from td elements
            doc.querySelectorAll('td').forEach(td => {
                const classAttr = td.getAttribute('class');
                if (classAttr && classAttr.startsWith('xl')) {
                    td.removeAttribute('class');
                }
            });

            // Clean paragraphs within tables: remove Mso/Aligned classes, inline styles, and convert align attribute to Tailwind classes
            doc.querySelectorAll('table p').forEach(p => {
                const parentCell = p.closest('td, th');

                if (parentCell) {
                    const classAttr = p.getAttribute('class');
                    if (classAttr && (classAttr.includes('Mso') || classAttr.includes('Aligned'))) {
                        p.removeAttribute('class');
                    }

                    if (p.hasAttribute('style')) {
                        p.removeAttribute('style');
                    }

                    const alignAttr = p.getAttribute('align');
                    if (alignAttr) {
                        p.removeAttribute('align');
                        let tailwclassName = '';
                        switch (alignAttr.toLowerCase()) {
                            case 'left':
                                tailwindAlignClass = 'text-left';
                                break;
                            case 'center':
                                tailwindAlignClass = 'text-center';
                                break;
                            case 'right':
                                tailwindAlignClass = 'text-right';
                                break;
                        }
                        if (tailwindAlignClass) {
                            parentCell.classList.add(tailwindAlignClass);
                        }
                    }
                }
            });
            return doc.body.innerHTML;
        }

        /**
         * Applies cleaning for Microsoft Office specific code.
         * This function removes tags and their entire content if they have specific MSO-related attributes or hrefs.
         * Attributes targeted for removal: "mso-element: comment-list", "mso-element: endnote-list".
         * Hrefs targeted for removal: containing "#_msocom", "#_edn", or "#_ftn".
         * For "#_ftn" links, converts <a> to <sup><a> with only text content and href attribute.
         * Also transforms elements with "mso-element: footnote-list" style into <aside> with cleaned content.
         * Also removes content from and cleans attributes of elements with 'style' attribute or MSO/Word/BCX0 classes.
         * Additionally handles specific heading class cleanup, and attribute removal for non-table elements,
         * UL/OL tags, and LI tags with 'role' attributes.
         * Also now handles cleaning of file:// or data: img src attributes.
         * @param {string} htmlString - The HTML content to clean.
         * @returns {string} The cleaned HTML content.
         */
        function applyCleanMsoCode(htmlString) {
            const parser = new DOMParser();
            const doc = parser.parseFromString(htmlString, 'text/html');

            // --- Start of Clean IMGs Logic (Moved from applyCleanImgs) ---
            doc.querySelectorAll('img').forEach(img => {
                const src = img.getAttribute('src');
                if (src && (src.startsWith('file://') || src.startsWith('data:'))) {
                    const replacementDiv = doc.createElement('div');
                    replacementDiv.classList.add('clearfix');
                    const replacementMark = doc.createElement('mark');
                    replacementMark.textContent = 'IMAGE NOT IMPORTED';
                    replacementDiv.appendChild(replacementMark);
                    if (img.parentNode) {
                        img.parentNode.replaceChild(replacementDiv, img);
                    }
                }
            });
            // --- End of Clean IMGs Logic ---

            // Select elements with style containing "mso-element: comment-list" or "mso-element: endnote-list"
            const elementsToRemoveByStyle = doc.querySelectorAll('[style*="mso-element: comment-list"], [style*="mso-element: endnote-list"]');
            elementsToRemoveByStyle.forEach(element => {
                if (element.parentNode) {
                    element.parentNode.removeChild(element);
                }
            });

            // Select <a> elements with href containing "#_msocom" or "#_edn" and remove them completely
            const commentEndnoteLinks = doc.querySelectorAll('a[href*="#_msocom"], a[href*="#_edn"]');
            commentEndnoteLinks.forEach(link => {
                if (link.parentNode) {
                    link.parentNode.removeChild(link);
                }
            });

            // Process <a> tags with href containing "#_ftn" to ensure only one <sup> wrapper
            const footnoteLinks = Array.from(doc.querySelectorAll('a[href*="#_ftn"]')); // Convert to array to avoid live NodeList issues
            footnoteLinks.forEach(link => {
                const originalHref = link.getAttribute('href');
                const textContent = link.textContent;

                // Create the ideal new <a> tag, copying only necessary attributes
                const newCleanLink = doc.createElement('a');
                newCleanLink.setAttribute('href', originalHref);
                newCleanLink.textContent = textContent;

                // Create the ideal new <sup> tag
                const idealSupElement = doc.createElement('sup');
                idealSupElement.appendChild(newCleanLink);

                // Find the target element to replace. This could be the link itself
                // or an existing <sup> parent that solely contains the link (or other <sup>s leading to it).
                let elementToReplace = link; // This `link` is the current <a> element being processed
                let currentParent = link.parentNode; // Start the the immediate parent of the link

                // Traverse up the DOM tree as long as the parent is <sup> and solely contains `elementToReplace`
                while (currentParent && currentParent !== doc.body && currentParent.tagName.toLowerCase() === 'sup') {
                    // Check if this <sup> only contains the elementToReplace (which is the link or another sup)
                    // and no other significant content (like additional text nodes or other elements).
                    const children = Array.from(currentParent.childNodes).filter(n => n.nodeType === Node.ELEMENT_NODE || (n.nodeType === Node.TEXT_NODE && n.nodeValue.trim() !== ''));

                    // If the <sup> has only one child and that child is our current elementToReplace (or nested <sup>),
                    // then this <sup> is an exclusive wrapper and we can move up.
                    if (children.length === 1 && children[0] === elementToReplace) {
                        elementToReplace = currentParent; // Move up: now `elementToReplace` is this <sup>
                        currentParent = currentParent.parentNode; // Move `currentParent` further up
                    } else {
                        break; // This <sup> contains other content, stop unwrapping here.
                    }
                }

                // Perform the replacement:
                // Replace the determined 'elementToReplace' (which could be the original <a>
                // or the outermost exclusively wrapping <sup>) with the 'idealSupElement'.
                if (elementToReplace.parentNode) {
                    elementToReplace.parentNode.replaceChild(idealSupElement, elementToReplace);
                }
            });

            // Process elements with "mso-element: footnote-list" in their style attribute
            const footnoteListElements = doc.querySelectorAll('[style*="mso-element: footnote-list"]');
            footnoteListElements.forEach(element => {
                if (element.parentNode) {
                    // Clean the content of the current element first, based on the preservation rules
                    const cleanedInnerHtml = cleanAndPreserveAllowedContent(element, doc);

                    // Create a new <aside> element
                    const asideElement = doc.createElement('aside');
                    asideElement.innerHTML = cleanedInnerHtml;

                    // Replace the original element with the new <aside>
                    if (element.parentNode) {
                        element.parentNode.replaceChild(asideElement, element);
                    }
                }
            });

            // Process heading character tags
            // Find all elements that have a class like "Heading#Char" where # is 1-6
            const elementsWithHeadingClass = doc.querySelectorAll('[class*="Heading"]'); // Broad selection then filter

            // Convert to array to avoid issues with live NodeList during modifications
            Array.from(elementsWithHeadingClass).forEach(element => {
                const classAttr = element.getAttribute('class');
                if (!classAttr) return;

                const classes = classAttr.split(/\s+/);
                const headingCharClass = classes.find(cls => /^Heading[1-6]Char$/.test(cls));

                if (headingCharClass) {
                    const headingLevel = parseInt(headingCharClass.match(/\d/)[0], 10);
                    const parent = element.parentNode;

                    if (!parent) return;

                    // Unwrap the current element: move its children to its parent
                    while (element.firstChild) {
                        parent.insertBefore(element.firstChild, element);
                    }
                    parent.removeChild(element); // Remove the now empty element

                    const currentParent = parent; // This is the original parent after unwrapping

                    // If the original parent is NOT already a heading (h1-h6)
                    if (!/^H[1-6]$/i.test(currentParent.tagName)) {
                        const newHeadingTag = doc.createElement(`h${headingLevel}`);

                        // Move *all* content of the original parent into the new headingTag
                        while (currentParent.firstChild) {
                            newHeadingTag.appendChild(currentParent.firstChild);
                        }

                        // Replace the original parent with the new heading tag
                        if (currentParent.parentNode) {
                            currentParent.parentNode.replaceChild(newHeadingTag, currentParent);
                        }
                    }
                    // If the original parent *was* already a heading, we've already unwrapped the span, so no further action needed.
                }
            });

            // NEW: Remove 'align' attribute from elements *outside* of tables
            doc.querySelectorAll('[align]').forEach(element => {
                if (!element.closest('table')) { // Check if the element is not inside a table
                    element.removeAttribute('align');
                }
            });

            // NEW: Remove 'type' and 'role' attributes from UL and OL tags
            doc.querySelectorAll('ul, ol').forEach(list => {
                list.removeAttribute('type');
                list.removeAttribute('role');
            });

            // NEW: Remove all attributes from LI tags if they have a 'role' attribute
            doc.querySelectorAll('li').forEach(li => {
                if (li.hasAttribute('role')) {
                    // Create an array of attribute names to remove
                    const attributesToRemove = Array.from(li.attributes).map(attr => attr.name);
                    attributesToRemove.forEach(attrName => {
                        li.removeAttribute(attrName);
                    });
                }
            });

            // NEW: Remove span tags with 'lang' attribute unless lang is 'en' or 'fr'
            doc.querySelectorAll('span[lang]').forEach(span => {
                const langAttr = span.getAttribute('lang');
                if (langAttr && langAttr.toLowerCase() !== 'en' && langAttr.toLowerCase() !== 'fr') {
                    // Unwrap the span: move its children to its parent
                    const parent = span.parentNode;
                    if (parent) {
                        while (span.firstChild) {
                            parent.insertBefore(span.firstChild, span);
                        }
                        parent.removeChild(span); // Remove the now empty span
                    }
                }
            });


            // Process all elements that have a style attribute or MSO/Word/BCX0 classes
            // Iterate in reverse to handle nested elements correctly without breaking the loop
            const allElements = Array.from(doc.querySelectorAll('*'));
            for (let i = allElements.length - 1; i >= 0; i--) {
                const element = allElements[i];

                // Skip html, head, body, script, style tags, and the aside tags just created
                const tagName = element.tagName.toLowerCase();
                if (['html', 'head', 'body', 'script', 'style', 'aside'].includes(tagName)) {
                    continue;
                }

                const hasStyle = element.hasAttribute('style');
                const classAttr = element.getAttribute('class') || '';
                const idAttr = element.getAttribute('id') || '';

                // Check if any class contains "Mso", "Word", or "BCX0" (case-sensitive)
                const hasMsoWordBcx0Class = classAttr.split(/\s+/).some(cls =>
                    cls.includes('Mso') || cls.includes('Word') || cls.includes('BCX0')
                );

                // Check if ID contains "Mso", "Word", or "BCX0" (case-sensitive)
                const hasMsoWordBcx0Id = idAttr.includes('Mso') || idAttr.includes('Word') || idAttr.includes('BCX0');

                // NEW: Check for classes that trigger complete unwrapping (eop, eoc, eocx, textrun, or any class containing "mso")
                const shouldUnwrapCompletely = classAttr.split(/\s+/).some(cls =>
                    cls.includes('eop') ||
                    cls.includes('eoc') ||
                    cls.includes('eocx') ||
                    cls.includes('mso') || // Broad check: any class containing "mso"
                    cls.includes('textrun')
                );

                if (shouldUnwrapCompletely) {
                    const parent = element.parentNode;
                    if (parent) {
                        // Move children out of the element
                        while (element.firstChild) {
                            parent.insertBefore(element.firstChild, element);
                        }
                        parent.removeChild(element); // Remove the now empty element
                    }
                    continue; // Continue to the next element in the loop after unwrapping
                }

                // Existing logic for cleaning attributes and content if not completely unwrapped
                if (hasStyle || hasMsoWordBcx0Class || hasMsoWordBcx0Id) {
                    // Get the cleaned innerHTML based on the preservation rules
                    const cleanedInnerHtml = cleanAndPreserveAllowedContent(element, doc);

                    // Replace the original content with the cleaned content
                    element.innerHTML = cleanedInnerHtml;

                    // Remove the style attribute
                    if (hasStyle) {
                        element.removeAttribute('style');
                    }

                    // Clean the class attribute: remove the entire attribute if any class contains "Mso", "Word", or "BCX0"
                    if (classAttr) {
                        const hasDisallowedClass = classAttr.split(/\s+/).some(cls =>
                            cls.includes('Mso') || cls.includes('Word') || cls.includes('BCX0')
                        );
                        if (hasDisallowedClass) {
                            element.removeAttribute('class');
                        }
                        // If no disallowed class, the attribute remains as is.
                    }

                    // Clean the id attribute: remove id if it contains "Mso", "Word", or "BCX0"
                    if (idAttr && (idAttr.includes('Mso') || idAttr.includes('Word') || idAttr.includes('BCX0'))) {
                        element.removeAttribute('id');
                    }
                }
            }

            return doc.body.innerHTML;
        }

        /**
         * Cleans common formatting tags: removes <u>, converts <b> to <strong>, and <i> to <em>.
         * @param {string} htmlString - The HTML content to clean.
         * @returns {string} The cleaned HTML content.
         */
        function applyCleanFormattingTags(htmlString) {
            const parser = new DOMParser();
            const doc = parser.parseFromString(htmlString, 'text/html');

            // 1. Remove <u> tags (unwrap them)
            const uElements = Array.from(doc.querySelectorAll('u'));
            for (let i = uElements.length - 1; i >= 0; i--) {
                const u = uElements[i];
                if (u.parentNode) {
                    while (u.firstChild) {
                        u.parentNode.insertBefore(u.firstChild, u);
                    }
                    u.parentNode.removeChild(u);
                }
            }

            // 2. Convert <b> to <strong>
            const bElements = Array.from(doc.querySelectorAll('b'));
            for (let i = bElements.length - 1; i >= 0; i--) {
                const b = bElements[i];
                if (b.parentNode) {
                    const strong = doc.createElement('strong');
                    while (b.firstChild) {
                        strong.appendChild(b.firstChild);
                    }
                    b.parentNode.replaceChild(strong, b);
                }
            }

            // 3. Convert <i> to <em>
            const iElements = Array.from(doc.querySelectorAll('i'));
            for (let i = iElements.length - 1; i >= 0; i--) {
                const i_tag = iElements[i]; // Renamed to avoid conflict with loop variable
                if (i_tag.parentNode) {
                    const em = doc.createElement('em');
                    while (i_tag.firstChild) {
                        em.appendChild(i_tag.firstChild);
                    }
                    i_tag.parentNode.replaceChild(em, i_tag);
                }
            }

            return doc.body.innerHTML;
        }

        /**
         * Adjusts heading levels (h1-h6) to ensure a correct hierarchical structure.
         *
         * Rules:
         * - If an H1 exists with `property="name"` and `id="wb-cont"`, it is preserved as H1.
         * - Otherwise, the very first encountered heading in the document (regardless of its initial level)
         * is converted to H2.
         * - All subsequent headings are adjusted relative to this H2 (or the preserved H1).
         * Specifically, if the document starts with H1 (which becomes H2), all subsequent headings shift down one level.
         * If the document starts with H3 (which becomes H2), all subsequent headings shift down one level.
         * If an H2 follows an H2, it remains H2. If an H2 follows an H1 (now H2), it becomes H3.
         * No more than one level skip down is allowed (e.g., H2 followed by H4 becomes H3).
         * All headings are guaranteed to be at least H2 (except the special H1).
         *
         * @param {string} htmlString - The HTML content to process.
         * @returns {string} The HTML content with adjusted heading levels.
         */
        function applyAutoLevelHeadings(htmlString) {
            const parser = new DOMParser();
            const doc = parser.parseFromString(htmlString, 'text/html');
            const body = doc.body;

            const headings = Array.from(body.querySelectorAll('h1, h2, h3, h4, h5, h6'));

            // Find the special H1, if it exists, which should be preserved.
            const specialH1 = headings.find(h =>
                h.tagName.toLowerCase() === 'h1' &&
                h.getAttribute('property') === 'name' &&
                h.id === 'wb-cont'
            );

            let levelAdjustmentForGlobalShift = 0; // The numerical shift to apply to all relevant headings (+1 for H1->H2, -1 for H3->H2 etc.)
            let firstRelevantHeadingFound = false;

            // First pass: Determine the overall level adjustment based on the first non-special heading
            for (const h of headings) {
                if (h === specialH1) {
                    continue; // Skip the special H1 in this calculation
                }
                if (!firstRelevantHeadingFound) {
                    const actualLevel = parseInt(h.tagName.substring(1), 10);
                    // Calculate the adjustment needed for this first heading to become an H2.
                    // If actualLevel is 1 (H1), adjust by +1 (1 + 1 = 2). So adjustment = 1.
                    // If actualLevel is 3 (H3), adjust by -1 (3 - 1 = 2). So adjustment = -1.
                    // General formula: levelAdjustment = (Target Level for First) - (Actual Level for First)
                    // Here, Target Level for First is always 2.
                    levelAdjustmentForGlobalShift = 2 - actualLevel;
                    firstRelevantHeadingFound = true;
                    break; // Only need to consider the very first one
                }
            }

            // Second pass: Apply the adjustments and enforce hierarchical rules
            let effectivePreviousLevel = 0; // Tracks the *resulting* level of the previously processed heading

            for (let i = 0; i < headings.length; i++) {
                let currentHeading = headings[i]; // Get the element reference

                // If it's the special H1, skip modification and set effectivePreviousLevel as H1 (level 1)
                if (currentHeading === specialH1) {
                    effectivePreviousLevel = 1;
                    continue;
                }

                const currentActualLevel = parseInt(currentHeading.tagName.substring(1), 10);
                let newLevel;

                // Calculate the 'globally adjusted' level based on the initial shift
                // (e.g., if first H1 became H2, all subsequent headings effectively shift up by 1 level number)
                let globallyAdjustedLevel = currentActualLevel + levelAdjustmentForGlobalShift;
                globallyAdjustedLevel = Math.max(2, globallyAdjustedLevel); // Ensure it's at least H2


                if (effectivePreviousLevel === 0) {
                    // This is the very first non-special heading we're processing. It must be H2.
                    newLevel = 2;
                } else {
                    // For subsequent headings, ensure two rules are met:
                    // 1. It maintains the overall global shift (`globallyAdjustedLevel`).
                    // 2. It doesn't jump more than one level down from the `effectivePreviousLevel`.
                    newLevel = Math.min(globallyAdjustedLevel, effectivePreviousLevel + 1);
                    // Also, ensure the new level is never below H2
                    newLevel = Math.max(2, newLevel);
                }

                // Only replace the element if its level needs to be changed
                if (newLevel !== currentActualLevel) {
                    const newHeadingTag = doc.createElement(`h${newLevel}`);
                    // Copy all attributes from the original heading to the new one
                    Array.from(currentHeading.attributes).forEach(attr => {
                        newHeadingTag.setAttribute(attr.name, attr.value);
                    });
                    // Move all children (content) from the original heading to the new one
                    while (currentHeading.firstChild) {
                        newHeadingTag.appendChild(currentHeading.firstChild);
                    }
                    // Replace the original heading element with the newly created one in the DOM
                    if (currentHeading.parentNode) {
                        currentHeading.parentNode.replaceChild(newHeadingTag, currentHeading);
                    }
                    // Update the reference in the 'headings' array to point to the new DOM node.
                    // This is crucial if subsequent iterations might re-evaluate elements that were
                    // later in the original 'headings' array but whose parent or context might have changed.
                    // Although not strictly necessary with the current loop, it's safer for DOM manipulations.
                    headings[i] = newHeadingTag;
                }
                
                // Update effectivePreviousLevel with the level that the current heading *actually* became
                effectivePreviousLevel = newLevel;
            }

            return body.innerHTML;
        }

        /**
         * Wraps <section> tags around heading tags and their content, nesting based on heading level.
         * Treats <aside> tags as H2 for sectioning purposes but does not wrap them.
         * Ignores sections with 'colophon' in their ID or containing a paragraph with 'Â©' for auto-sectioning.
         * @param {string} htmlString - The HTML content to section.
         * @returns {string} The sectioned HTML content.
         */
        function applyAutoSectioning(htmlString) {
            const parser = new DOMParser();
            const doc = parser.parseFromString(htmlString, 'text/html');
            const originalBody = doc.body;

            const newBody = doc.createElement('body');
            // Stack stores { domElement: Node, level: number }
            let currentSectionStack = [{ domElement: newBody, level: 0 }]; // Level 0 for body (root container)

            // Iterate over the live childNodes of the originalBody
            while (originalBody.firstChild) {
                const node = originalBody.firstChild;
                // Temporarily remove the node from originalBody to process it
                originalBody.removeChild(node);

                if (node.nodeType === Node.ELEMENT_NODE) {
                    const tagName = node.tagName.toLowerCase();
                    let nodeLevel = null; // Conceptual level of the current node (e.g., 1 for h1, 2 for h2 or aside)
                    let shouldCreateNewSectionForNode = true; // Does this specific node warrant a new <section>?
                    let isProtectedSection = false; // Flag for sections to ignore

                    if (tagName === 'section') {
                        // Check if this section should be ignored (colophon ID or p with Â©)
                        if (node.id.includes('colophon') || node.querySelector('p')?.textContent?.includes('Â©')) {
                            isProtectedSection = true;
                            shouldCreateNewSectionForNode = false; // Do not wrap or re-section this
                        } else {
                            // For non-protected existing sections, unwrap their content
                            // This ensures the headings/content within them are processed by the main loop
                            const fragment = doc.createDocumentFragment();
                            while (node.firstChild) {
                                fragment.appendChild(node.firstChild);
                            }
                            // Temporarily append the fragment's children back to the originalBody
                            // so they are picked up in the next iteration of the while loop.
                            // Insert at the beginning so they are processed immediately.
                            originalBody.insertBefore(fragment, originalBody.firstChild);
                            // The original section 'node' is now empty. It will be implicitly removed
                            // when originalBody.removeChild(node) is called at the beginning of the next loop iteration.
                            // We use 'continue' to skip the rest of the current loop iteration, ensuring
                            // the unwrapped children are processed next.
                            continue;
                        }
                    }

                    const headingLevelMatch = tagName.match(/^h([1-6])$/);
                    if (headingLevelMatch) {
                        nodeLevel = parseInt(headingLevelMatch[1], 10);
                    } else if (tagName === 'aside') {
                        nodeLevel = 2; // Treat <aside> as H2 for sectioning logic
                        shouldCreateNewSectionForNode = false; // Do NOT wrap <aside> in its own section
                    }

                    if (isProtectedSection) {
                        // For protected sections, append them directly to the current effective parent
                        // and *don't* modify the currentSectionStack.
                        let parentToAppendTo = currentSectionStack[currentSectionStack.length - 1].domElement;
                        parentToAppendTo.appendChild(node);
                    }
                    else if (nodeLevel !== null) { // It's either a heading (h1-h6) or an <aside> and not a protected section
                        // Pop sections from stack if current node's level is less than or equal to the top section's level.
                        while (currentSectionStack.length > 1 && nodeLevel <= currentSectionStack[currentSectionStack.length - 1].level) {
                            currentSectionStack.pop();
                        }

                        let currentParentDomElement = currentSectionStack[currentSectionStack.length - 1].domElement;

                        if (shouldCreateNewSectionForNode) { // It's a heading, create a new section
                            const newSection = doc.createElement('section');
                            currentParentDomElement.appendChild(newSection);
                            // Push the new section onto the stack, updating the current parent for next elements
                            currentSectionStack.push({ domElement: newSection, level: nodeLevel });
                            // Append the original heading node to the newly created section
                            currentSectionStack[currentSectionStack.length - 1].domElement.appendChild(node);
                        } else { // It's an <aside>, append it directly to the current effective parent
                            currentParentDomElement.appendChild(node);
                            // IMPORTANT: <aside> does NOT create a new section for itself and is not pushed onto the stack.
                            // This means subsequent content will be appended relative to the section that *contains* the <aside>.
                        }
                    } else { // Not a heading, aside, or protected section; append to the current open section
                        currentSectionStack[currentSectionStack.length - 1].domElement.appendChild(node);
                    }
                } else { // Text node or comment node, append to the current open section
                    currentSectionStack[currentSectionStack.length - 1].domElement.appendChild(node);
                }
            }

            return newBody.innerHTML;
        }

        /**
         * Inserts IDs to all heading tags (h1-h6), section, and table tags based on specified rules.
         * This function ensures full re-numbering on each run, allowing for dynamic updates
         * after elements are added, deleted, or reordered.
         *
         * Rules:
         * - H1s: Not ID'd.
         * - H2s:
         * - If text starts with a number (e.g., "1. Introduction"): ID is "toc<number>" (e.g., "toc1").
         * - If text starts with "Appendix", "Annex", or "Annexe": ID is "app<letter>" (e.g., "appA", "appB"),
         * where the letter is derived from the text if present, otherwise sequentially generated.
         * - Otherwise (general H2): ID is "toc<sequential_letter>" (e.g., "tocA", "tocB").
         * - H3-H6: Nested IDs.
         * - If text starts with "Appendix", "Annex", or "Annexe": ID is "<parentID>-app<letter>",
         * where the letter is derived from the text if present, otherwise sequentially generated within that parent's scope.
         * - Otherwise (general H3-H6): ID is "<parentID>-<sequential_number>".
         *
         * - Sections:
         * - Top-level sections (direct children of body or not nested within other sections) get "sec#" (e.g., "sec1").
         * - Nested sections get "sec#-#", "sec#-#-#", etc., based on their parent section's ID.
         * - Sections that already have an ID are not modified if their ID does not follow the "sec" pattern.
         *
         * - Tables:
         * - Tables outside of a <figure> element get "tbl#" (e.g., "tbl1").
         * - Tables within a <figure> element get "ftbl#" (e.g., "ftbl1").
         * - "ftbl" IDs are numbered separately from "tbl" IDs.
         * - Tables that already have an ID are not modified (similar to sections).
         *
         * @param {string} htmlString - The HTML content to process.
         * @param {object} options - An object specifying which elements to ID.
         * @param {boolean} options.idSections - Whether to ID sections.
         * @param {boolean} options.idHeadings - Whether to ID headings.
         * @param {boolean} options.idTables - Whether to ID general tables.
         * @param {boolean} options.idFigureTables - Whether to ID tables within figure elements.
         * @returns {string} The HTML content with IDs inserted.
         */
        function applyAutoId(htmlString, options = {}) {
            // Default options to true if not provided
            const defaultOptions = {
                idSections: true,
                idHeadings: true,
                idTables: true,
                idFigureTables: true
            };
            const currentOptions = { ...defaultOptions, ...options };

            const parser = new DOMParser();
            const doc = parser.parseFromString(htmlString, 'text/html');
            const body = doc.body;

            // Helper function to convert a number to an uppercase alphabetical string (A, B, C, ..., Z, AA, AB, ...)
            function toAlpha(num) {
                let s = '';
                let t;
                while (num > 0) {
                    t = (num - 1) % 26;
                    s = String.fromCharCode(65 + t) + s;
                    num = Math.floor((num - t) / 26);
                }
                return s || 'A';
            }

            // Helper function to extract an alphabetical character from an appendix/annex text
            // e.g., "Appendix A" -> "A", "Annex B" -> "B"
            function getLetterFromAppendixText(text) {
                const match = text.match(/^(?:Appendix|Annex|Annexe)\s*([A-Z])?/i);
                if (match && match[1]) {
                    return match[1].toUpperCase();
                }
                return null;
            }

            // Store existing IDs to avoid re-assigning if they match the desired pattern and are already present,
            // though for full re-numbering, we will overwrite. This set helps track uniqueness.
            const existingIds = new Set();
            // Collect existing IDs before processing to ensure no duplicate IDs are generated
            // even if the user had some manually set.
            doc.querySelectorAll('[id]').forEach(el => existingIds.add(el.id));

            // Headings counters - these should be persistent and not reset each other
            let h2_num_counter = 0; // For H2s starting with numbers (toc1, toc2)
            let h2_general_alpha_counter = 0; // For general H2s (tocA, tocB)
            let h2_appendix_alpha_counter = 0; // For H2s explicitly "Appendix" (appA, appB)

            // Sub-level counters (H3-H6)
            // Maps parent ID path string (e.g., "toc1" or "tocA-1") to its child counters
            let sub_num_counters = new Map(); // Stores { "parent_id": next_numeric_count }
            let sub_appendix_alpha_counters = new Map(); // Stores { "parent_id": next_alpha_count_for_appendices }

            // This array will hold segments of the current heading's ID path
            // e.g., ["toc1"], ["toc1", "1"], ["tocA", "appA"]
            let currentHeadingIdPathSegments = [];

            // Table counters
            let tableCounter = 0; // For 'tbl#'
            let figureTableCounter = 0; // For 'ftbl#'

            // Section specific counters: Maps parent section ID to its next child number
            // 'root' key is used for top-level sections (children of body)
            let sectionChildCounters = { 'root': 0 };

            if (currentOptions.idHeadings) {
                // --- Pre-scan: Determine if any H2 is numerically prefaced ---
                let hasAnyNumberedH2 = false;
                const allH2s = Array.from(body.querySelectorAll('h2'));
                const specialH1 = allH2s.find(h => h.tagName.toLowerCase() === 'h1' && h.getAttribute('property') === 'name' && h.id === 'wb-cont');

                for (const h2 of allH2s) {
                    // Skip the special H1 for this check
                    if (h2 === specialH1) continue;

                    // Skip if inside an ignored parent like aside, caption, figure, figcaption, table
                    const ignoredParents = ['aside', 'caption', 'figure', 'figcaption', 'table'];
                    let isInsideIgnoredParent = false;
                    let currentParent = h2.parentNode;
                    while (currentParent && currentParent !== body) {
                        if (ignoredParents.includes(currentParent.tagName.toLowerCase())) {
                            isInsideIgnoredParent = true;
                            break;
                        }
                        currentParent = currentParent.parentNode;
                    }
                    if (isInsideIgnoredParent) continue;

                    const text = h2.textContent.trim();
                    if (text.match(/^\s*(\d+)(?:\.|\s|\)|\-)?/)) {
                        hasAnyNumberedH2 = true;
                        break;
                    }
                }
                // --- End Pre-scan ---

                // Process all headings (H1, H2, H3, H4, H5, H6)
                doc.querySelectorAll('h1, h2, h3, h4, h5, h6').forEach(heading => {
                    // NEW: Check if the heading is inside an ignored parent
                    const ignoredParents = ['aside', 'caption', 'figure', 'figcaption', 'table'];
                    let isInsideIgnoredParent = false;
                    let currentParent = heading.parentNode;
                    while (currentParent && currentParent !== body) {
                        if (ignoredParents.includes(currentParent.tagName.toLowerCase())) {
                            isInsideIgnoredParent = true;
                            break;
                        }
                        currentParent = currentParent.parentNode;
                    }

                    if (isInsideIgnoredParent) {
                        return; // Skip ID assignment for this heading
                    }

                    const level = parseInt(heading.tagName.substring(1), 10);
                    const text = heading.textContent.trim(); // Get raw text for pattern matching

                    // H1s are never ID'd, but reset path for subsequent headings
                    if (level === 1) {
                        currentHeadingIdPathSegments = [];
                        // Clear all sub-level counters as we're starting a new top-level structure
                        sub_num_counters.clear();
                        sub_appendix_alpha_counters.clear();
                        return; // Skip ID assignment for H1
                    }

                    let id_segment = ''; // The ID segment for the current heading's level
                    const isNumericHeading = text.match(/^\s*(\d+)(?:\.|\s|\)|\-)?/);
                    const isAppendixHeading = text.match(/^(?:Appendix|Annex|Annexe)\s*(?:([A-Z]))?/i);

                    if (level === 2) {
                        // Determine H2 segment
                        if (isAppendixHeading) {
                            const letterFromText = getLetterFromAppendixText(text);
                            if (letterFromText) {
                                // If letter exists in text (e.g., "Appendix A"), use it directly
                                // No need to increment counter, as the letter dictates uniqueness
                                id_segment = `app${letterFromText}`;
                            } else {
                                // If "Appendix" but no letter provided, use a sequential letter for app H2s
                                h2_appendix_alpha_counter++; // Only increment its own counter
                                id_segment = `app${toAlpha(h2_appendix_alpha_counter)}`;
                            }
                        } else if (hasAnyNumberedH2) { // If there's *any* numbered H2 in the document
                            if (isNumericHeading) { // This H2 is numeric (e.g., "1. Sample")
                                h2_num_counter++; // Only increment its own counter
                                id_segment = `toc${h2_num_counter}`;
                            } else { // This H2 is NOT numeric, but some H2s *are* numeric (e.g., "Sample Section Title")
                                h2_general_alpha_counter++; // Only increment its own counter
                                id_segment = `toc${toAlpha(h2_general_alpha_counter)}`;
                            }
                        } else { // No numbered H2s in the document, so all H2s get numeric IDs (e.g., "toc1", "toc2")
                            h2_num_counter++; // Only increment its own counter
                            id_segment = `toc${h2_num_counter}`;
                        }
                        // For H2, this starts a new path
                        currentHeadingIdPathSegments = [id_segment];
                        // Reset all sub-level counters (for H3-H6) as a new main branch begins
                        sub_num_counters.clear();
                        sub_appendix_alpha_counters.clear();
                    } else { // For H3, H4, H5, H6
                        // Ensure the currentHeadingIdPathSegments correctly reflects the parent's path
                        // Truncate path to parent's level's segment. E.g., if current is H4 (level 4), parent is H3 (level 3).
                        // Path should be currentHeadingIdPathSegments up to index (level-1)-1 = level-2.
                        currentHeadingIdPathSegments.length = level - 2;

                        const parent_id_path_string = currentHeadingIdPathSegments.join('-'); // The full ID of the immediate parent heading (e.g., "toc1" or "tocA-1")

                        if (isAppendixHeading) {
                            const letterFromText = getLetterFromAppendixText(text);
                            if (letterFromText) {
                                id_segment = `app${letterFromText}`;
                            } else {
                                // If "Appendix" but no letter provided, use sequential letter within this parent's appendix scope
                                const currentAppCount = (sub_appendix_alpha_counters.get(parent_id_path_string) || 0) + 1;
                                sub_appendix_alpha_counters.set(parent_id_path_string, currentAppCount);
                                id_segment = `app${toAlpha(currentAppCount)}`;
                            }
                            // Reset numeric counter for this parent's scope to allow for a clean numeric sequence after an appendix
                            sub_num_counters.delete(parent_id_path_string);
                        } else { // General sub-heading (numeric sequence)
                            const currentNumCount = (sub_num_counters.get(parent_id_path_string) || 0) + 1;
                            sub_num_counters.set(parent_id_path_string, currentNumCount);
                            id_segment = String(currentNumCount);
                            // Reset appendix alpha counter for this parent's scope
                            sub_appendix_alpha_counters.delete(parent_id_path_string);
                        }
                        currentHeadingIdPathSegments.push(id_segment);
                    }

                    const newId = currentHeadingIdPathSegments.join('-');
                    // Forcing re-assignment as per user request to re-number when pressed again.
                    heading.setAttribute('id', newId);
                    existingIds.add(newId); // Add newly assigned ID to set, mainly for uniqueness tracking if not forcing overwrite
                });
            }


            if (currentOptions.idSections) {
                // Process Sections
                // The approach for sections already rebuilds IDs based on hierarchy on each run.
                doc.querySelectorAll('section').forEach(section => {
                    const existingId = section.getAttribute('id');

                    // NEW: If section already has an ID AND it does NOT match the "sec" pattern, skip it.
                    if (existingId && !/^sec\d+(-\d+)*$/.test(existingId)) {
                        return; // Do not overwrite non-standard section IDs
                    }

                    let parentSectionId = 'root'; // Default for top-level sections
                    let tempParent = section.parentNode;

                    // Traverse up to find the closest parent section with an ID
                    while (tempParent && tempParent !== body) {
                        if (tempParent.tagName.toLowerCase() === 'section' && tempParent.id) {
                            parentSectionId = tempParent.id;
                            break;
                        }
                        tempParent = tempParent.parentNode;
                    }

                    // Increment the counter for the current parent's children
                    sectionChildCounters[parentSectionId] = (sectionChildCounters[parentSectionId] || 0) + 1;
                    const newSectionNum = sectionChildCounters[parentSectionId];

                    let newId;
                    if (parentSectionId === 'root') {
                        newId = `sec${newSectionNum}`;
                    } else {
                        newId = `${parentSectionId}-${newSectionNum}`;
                    }
                    section.setAttribute('id', newId);
                    existingIds.add(newId); // Add newly assigned ID to set
                });
            }


            if (currentOptions.idTables || currentOptions.idFigureTables) {
                // Process Tables
                // Similar to sections, table IDing also rebuilds on each run.
                doc.querySelectorAll('table').forEach(table => {
                    // For full re-numbering, we will re-assign table IDs.
                    const parentFigure = table.closest('figure');
                    let newId = null;

                    if (parentFigure && currentOptions.idFigureTables) {
                        // It's inside a figure, assign ftbl#
                        figureTableCounter++;
                        newId = `ftbl${figureTableCounter}`;
                    } else if (!parentFigure && currentOptions.idTables) {
                        // It's not inside a figure, assign tbl#
                        tableCounter++;
                        newId = `tbl${tableCounter}`;
                    }

                    if (newId) {
                        table.setAttribute('id', newId);
                        existingIds.add(newId);
                    } else {
                        // If neither option is selected for this table type, ensure it has no ID.
                        table.removeAttribute('id');
                    }
                });
            }


            return body.innerHTML;
        }

        /**
         * Function to set the content of the HugeRTE editor.
         * This is called from the parent window.
         */
        window.setRichEditorContent = function(content) {
            // console.log("Parent: Attempting to set HugeRTE content.");
            if (richTextEditorInstance) {
                richTextEditorInstance.setContent(cleanHtmlForRichTextDisplay(content));
                richTextEditorInstance.focus(); // Re-focus the rich editor after content update
                // console.log('Parent: HugeRTE updated from HTML editor.');
            } else {
                console.warn('Parent: HugeRTE editor not yet initialized. Content will be set once ready.');
            }
        };

        /**
         * Function to get the content from the HugeRTE editor.
         * This is called from the parent window.
         */
        window.getRichEditorContent = function() {
            // console.log("Parent: Attempting to get HugeRTE content.");
            if (richTextEditorInstance) {
                const content = richTextEditorInstance.getContent();
                // console.log("Parent: HugeRTE content requested by parent.");
                return content;
            } else {
                console.warn('Iframe: HugeRTE editor not yet initialized. Cannot get content.');
                return '';
            }
        };

        /**
         * Updates the disabled state of all interactive buttons.
         * Buttons are disabled if any button has 'data-temp-active' set to 'true'.
         */
        function updateAllInteractiveButtonStates() {
            const anyTempMessageActive = allInteractiveButtons.some(btn => btn.getAttribute('data-temp-active') === 'true');

            allInteractiveButtons.forEach(btn => {
                // If a button itself has 'data-temp-active', it means its modal is open, so it should be disabled.
                // Otherwise, it's disabled if ANY other button has 'data-temp-active'.
                btn.disabled = btn.getAttribute('data-temp-active') === 'true' || anyTempMessageActive;
            });
        }


        /**
         * Toggles the active editor view between 'richtext' and 'code'.
         * Includes automatic content synchronization.
         */
        function toggleEditorView() {
            // Prevent toggling if any button is disabled (implicitly means a temp message is active)
            const anyTempMessageActive = allInteractiveButtons.some(btn => btn.getAttribute('data-temp-active') === 'true');
            if (anyTempMessageActive) {
                console.log("Toggle prevented: another button is active.");
                return;
            }

            console.log("Toggle Editor View triggered. Current view:", currentView);
            if (currentView === 'richtext') {
                // --- Logic when switching FROM Rich-Text TO Code ---
                // 1. Get content from Rich-Text editor.
                if (default_ifr.contentWindow && default_ifr.contentWindow.getRichEditorContent) {
                    richTextContent = default_ifr.contentWindow.getRichEditorContent();
                    console.log("Syncing from Rich Text to HTML. Rich Text Content length:", richTextContent.length);
                } else {
                    console.warn("Rich Text Editor not ready for content retrieval on toggle. Using empty string.");
                    richTextContent = '';
                }

                // Restore protected data attributes FIRST, as other cleaning might remove elements
                let processedContent = restoreDataAttributes(richTextContent);
                console.log("Data attributes restored after Rich Text editor roundtrip.");

                // Apply Auto-Clean MSO in the specified order when switching to HTML editor
                if (toggleAutoCleanMsoOnSwitchRichText.checked) {
                    console.log("Auto-Clean MSO applied when switching to HTML editor.");
                    // Apply Clean Mso Lists
                    processedContent = applyCleanLists(processedContent);
                    console.log("Clean MSO Lists applied.");
                    // Apply Clean Mso Tables
                    processedContent = applyCleanTablesBasic(processedContent);
                    console.log("Clean MSO Tables applied.");
                    // Apply Clean Mso Code (includes IMGs now)
                    processedContent = applyCleanMsoCode(processedContent);
                    console.log("Clean MSO Code (including IMGs) applied.");
                    // Apply URL cleaning
                    processedContent = applyUrlCleaning(processedContent);
                    console.log("Clean URLs applied.");
                    // Apply Clean Spaces
                    processedContent = applyAutoSpacing(processedContent);
                    console.log("Clean Spaces applied.");
                } else {
                     // If auto-clean MSO is not checked, still apply URL cleaning on switch.
                     // URL cleaning is always applied when switching to HTML.
                    processedContent = applyUrlCleaning(processedContent);
                    console.log("URL cleaning applied (not part of Auto-Clean MSO, but always on switch).");
                }

                // 2. Update HTML output content and Monaco editor.
                htmlOutputContent = processedContent;
                if (monacoEditorInstance) {
                    monacoEditorInstance.setValue(htmlOutputContent);
                    monacoEditorInstance.focus();
                    applyEntityHighlighting();
                    console.log("Monaco editor updated with Rich Text content.");
                } else {
                    console.warn('Monaco editor not yet initialized. Content will be set once ready.');
                }

                // Run Auto-Encode and Auto-Indent when switching to HTML editor
                autoEncodeBtn.click();
                autoFormatBtn.click(); // This is already here, no change needed for this specific request.
                                  // The user asked for "go to html" to run Auto-Indent, which is exactly this.

                // 3. Switch panel visibility.
                richtextOutputPanel.classList.remove('panel-visible');
                richtextOutputPanel.classList.add('panel-hidden');
                codePanel.classList.remove('panel-hidden');
                codePanel.classList.add('panel-visible');

                // 4. Update button styles.
                // "Go to HTML" button (toggleEditorViewBtnRichText) is now inactive/hidden.
                // Remove all color classes and set to default zinc.
                toggleEditorViewBtnRichText.classList.remove('bg-green-600', 'hover:bg-green-700', 'bg-sky-700', 'hover:bg-sky-800');
                toggleEditorViewBtnRichText.classList.add('bg-zinc-700', 'hover:bg-zinc-600');

                // "Go to Rich-Text" button (toggleEditorViewBtnCode) is now active/visible.
                // It should be blue.
                toggleEditorViewBtnCode.classList.remove('bg-green-600', 'hover:bg-green-700', 'bg-zinc-700', 'hover:bg-zinc-600');
                toggleEditorViewBtnCode.classList.add('bg-sky-700', 'hover:bg-sky-800');

                currentView = 'code';
                console.log("Switched to Code View.");
            } else { // currentView === 'code'
                // --- Logic when switching FROM Code TO Rich-Text ---
                // No auto-clean MSO should happen when switching TO the Rich-Text editor.
                // 1. Get content from Monaco editor.
                if (monacoEditorInstance) {
                    htmlOutputContent = monacoEditorInstance.getValue();
                    console.log("Syncing from HTML to Rich Text. HTML Output Content length:", htmlOutputContent.length);
                } else {
                    console.warn("Monaco editor not ready for content retrieval on toggle. Using empty string.");
                    htmlOutputContent = '';
                }

                // Protect data attributes BEFORE sending to TinyMCE
                let contentToSendToRichText = protectDataAttributes(htmlOutputContent);
                console.log("Data attributes protected before sending to Rich Text editor.");

                // 2. Update Rich Text content and editor.
                richTextContent = contentToSendToRichText; // Use the protected content
                if (default_ifr.contentWindow && default_ifr.contentWindow.setRichEditorContent) {
                    default_ifr.contentWindow.setRichEditorContent(cleanHtmlForRichTextDisplay(richTextContent));
                    console.log("HugeRTE editor updated with HTML content.");
                } else {
                    console.warn("Rich Text Editor not ready for content setting on toggle.");
                }

                // 3. Switch panel visibility.
                codePanel.classList.remove('panel-visible');
                codePanel.classList.add('panel-hidden');
                richtextOutputPanel.classList.remove('panel-hidden');
                richtextOutputPanel.classList.add('panel-visible');

                // 4. Update button styles.
                // "Go to Rich-Text" button (toggleEditorViewBtnCode) is now inactive/hidden.
                // It should be blue.
                toggleEditorViewBtnCode.classList.remove('bg-green-600', 'hover:bg-green-700', 'bg-zinc-700', 'hover:bg-zinc-600');
                toggleEditorViewBtnCode.classList.add('bg-sky-700', 'hover:bg-sky-800');

                // "Go to HTML" button (toggleEditorViewBtnRichText) is now active/visible.
                // Its color depends on the MSO toggle.
                updateGoToHtmlButtonColor(); // This function handles its specific coloring.

                currentView = 'richtext';
                console.log("Switched to Rich Text View.");
            }
        }

        // Variable to store Monaco decorations for entities
        let entityDecorations = [];

        /**
         * Applies highlighting to HTML character entities in the Monaco editor.
         */
        function applyEntityHighlighting() {
            if (!monacoEditorInstance) return;

            const model = monacoEditorInstance.getModel();
            if (!model) return;

            const newDecorations = [];
            const text = model.getValue();
            // Regex to find HTML entities like &nbsp; &#160; &amp;
            const regex = /&[a-zA-Z0-9#]+;/g;

            let match;
            while ((match = regex.exec(text)) !== null) {
                const startPos = model.getPositionAt(match.index);
                const endPos = model.getPositionAt(match.index + match[0].length);

                newDecorations.push({
                    range: new monaco.Range(startPos.lineNumber, startPos.column, endPos.lineNumber, endPos.column),
                    options: {
                        inlineClassName: 'entity-highlight',
                        hoverMessage: { value: 'HTML Character Entity' } // Optional: show tooltip on hover
                    }
                });
            }

            // Apply the new decorations and clear old ones
            entityDecorations = monacoEditorInstance.deltaDecorations(entityDecorations, newDecorations);
        }

        /**
         * Updates the color of the "Go to HTML" button based on the "Auto-Clean MSO when switching" toggle state.
         * This function is now responsible for setting the correct color for the "Go to HTML" button
         * when the `currentView` is 'richtext' (meaning the "Go to HTML" button is visible and active).
         */
        function updateGoToHtmlButtonColor() {
            // This function is called when the rich text panel is visible and the "Go to HTML" button is active.
            // Its color should reflect the state of toggleAutoCleanMsoOnSwitchRichText.
            if (toggleAutoCleanMsoOnSwitchRichText.checked) {
                toggleEditorViewBtnRichText.classList.remove('bg-sky-700', 'hover:bg-sky-800', 'bg-zinc-700', 'hover:bg-zinc-600');
                toggleEditorViewBtnRichText.classList.add('bg-green-600', 'hover:bg-green-700');
            } else {
                toggleEditorViewBtnRichText.classList.remove('bg-green-600', 'hover:bg-green-700', 'bg-zinc-700', 'hover:bg-zinc-600');
                toggleEditorViewBtnRichText.classList.add('bg-sky-700', 'hover:bg-sky-800');
            }
        }

        /**
         * Updates the state of the "Clean Mso" button based on the "Auto-Clean MSO" toggle.
         */
        function updateCleanMsoButtonState() {
            const isAutoCleanEnabled = toggleAutoCleanMsoOnSwitchRichText.checked; // Check any of the synced toggles
            if (isAutoCleanEnabled) {
                cleanMsoBtn.disabled = true;
                cleanMsoBtn.classList.remove('bg-blue-700', 'hover:bg-blue-800');
                cleanMsoBtn.classList.add('bg-green-600', 'hover:bg-green-700');
            } else {
                cleanMsoBtn.disabled = false;
                cleanMsoBtn.classList.remove('bg-green-600', 'hover:bg-green-700');
                cleanMsoBtn.classList.add('bg-blue-700', 'hover:bg-blue-800');
            }
        }

        /**
         * Simple debounce function.
         * @param {Function} func The function to debounce.
         * @param {number} delay The delay in milliseconds.
         * @returns {Function} The debounced function.
         */
        function debounce(func, delay) {
            let timeout;
            return function(...args) {
                const context = this;
                clearTimeout(timeout);
                timeout = setTimeout(() => func.apply(context, args), delay);
            };
        }

        // Debounced version of monacoEditorInstance.layout() for window resize
        const debouncedMonacoLayout = debounce(() => {
            if (monacoEditorInstance) {
                monacoEditorInstance.layout();
            }
        }, 200); // Debounce for window resize, not internal panel resize

        /**
         * Displays a modal dialog with a given title and HTML content.
         * Note: This `showModal` function is specifically for the Colophon, and is distinct from `showFootnoteModal`.
         * @param {string} title - The title of the modal.
         * @param {string} contentHtml - The HTML content for the modal body.
         * @param {HTMLElement} triggeringButton - The button that opened this modal.
         * @param {string} originalButtonText - The original text of the triggering button before "Opening...".
         */
        function showModal(title, contentHtml, triggeringButton, originalButtonText) {
            const modalOverlay = document.createElement('div');
            modalOverlay.className = 'modal-overlay';
            modalOverlay.innerHTML = `
                <div class="modal-content">
                    <h3>${title}</h3>
                    <div id="modalBody">${contentHtml}</div>
                    <div class="flex justify-end mt-4 space-x-2">
                        <button id="modalCancelBtn" class="px-4 py-2 bg-gray-600 text-white rounded-md hover:bg-gray-700">Cancel</button>
                        <button id="modalInsertBtn" class="px-4 py-2 bg-blue-500 text-white rounded-md hover:bg-blue-600">Insert</button>
                    </div>
                </div>
            `;
            document.body.appendChild(modalOverlay);

            // Function to clean up and re-enable buttons
            function closeModalAndReEnableButtons() {
                modalOverlay.remove();
                triggeringButton.removeAttribute('data-temp-active'); // Crucial: Remove flag
                // Directly revert the button text and color here
                triggeringButton.textContent = originalButtonText;
                triggeringButton.classList.remove('bg-green-500', 'hover:bg-green-600');
                triggeringButton.classList.add('bg-zinc-700', 'hover:bg-zinc-600');
                updateAllInteractiveButtonStates(); // Re-enable all buttons
            }


            document.getElementById('modalCancelBtn').addEventListener('click', closeModalAndReEnableButtons);

            // Get references to elements within the newly created modal
            const langEnglishBtn = document.getElementById('langEnglishBtn');
            const langFrenchBtn = document.getElementById('langFrenchBtn');
            const monarchKingBtn = document.getElementById('monarchKingBtn');
            const monarchQueenBtn = document.getElementById('monarchQueenBtn');
            const idISBNBtn = document.getElementById('idISBNBtn');
            const idISSNBtn = document.getElementById('idISSNBtn');
            const colophonYearInput = document.getElementById('colophonYear');
            const colophonNumberInput = document.getElementById('colophonNumber'); // Reference for the number input
            const modalInsertBtn = document.getElementById('modalInsertBtn');

            let selectedLanguage = 'English'; // Default to English
            let selectedMonarch = 'King'; // Default
            let selectedIdentifier = 'ISBN'; // Default

            // Function to update button active state
            function updateButtonActiveState(buttons, activeBtn) {
                buttons.forEach(btn => {
                    btn.classList.remove('active', 'bg-indigo-600');
                    btn.classList.add('bg-gray-700', 'hover:bg-gray-600');
                });
                activeBtn.classList.add('active', 'bg-indigo-600');
                activeBtn.classList.remove('bg-gray-700', 'hover:bg-gray-600');
            }

            // Initial active states
            updateButtonActiveState([langEnglishBtn, langFrenchBtn], langEnglishBtn);
            updateButtonActiveState([monarchKingBtn, monarchQueenBtn], monarchKingBtn);
            updateButtonActiveState([idISBNBtn, idISSNBtn], idISBNBtn);

            // Event listeners for language buttons
            langEnglishBtn.addEventListener('click', () => {
                selectedLanguage = 'English';
                updateButtonActiveState([langEnglishBtn, langFrenchBtn], langEnglishBtn);
            });

            langFrenchBtn.addEventListener('click', () => {
                selectedLanguage = 'French';
                updateButtonActiveState([langEnglishBtn, langFrenchBtn], langFrenchBtn);
            });

            // Event listeners for Monarch toggle
            monarchKingBtn.addEventListener('click', () => {
                selectedMonarch = 'King';
                updateButtonActiveState([monarchKingBtn, monarchQueenBtn], monarchKingBtn);
            });

            monarchQueenBtn.addEventListener('click', () => {
                selectedMonarch = 'Queen';
                updateButtonActiveState([monarchKingBtn, monarchQueenBtn], monarchQueenBtn);
            });

            // Event listeners for ISBN/ISSN toggle
            idISBNBtn.addEventListener('click', () => {
                selectedIdentifier = 'ISBN';
                updateButtonActiveState([idISBNBtn, idISSNBtn], idISBNBtn);
            });

            idISSNBtn.addEventListener('click', () => {
                selectedIdentifier = 'ISSN';
                updateButtonActiveState([idISBNBtn, idISSNBtn], idISSNBtn);
            });

            // Year input validation
            colophonYearInput.addEventListener('input', (event) => {
                const input = event.target;
                // Remove any non-digit characters
                input.value = input.value.replace(/\D/g, '');
                // Truncate to 4 digits if longer
                if (input.value.length > 4) {
                    input.value = input.value.substring(0, 4);
                }
            });

            // Insert button logic
            modalInsertBtn.addEventListener('click', () => {
                const currentYear = new Date().getFullYear();
                const year = colophonYearInput.value || currentYear;
                const number = colophonNumberInput.value || '###';
                let colophonHtmlContent = `<section id="colophon">\n<p class="mrgn-tp-lg text-center small">Â© `;

                if (selectedLanguage === 'English') {
                    if (selectedMonarch === 'King') {
                        colophonHtmlContent += `His Majesty the King in Right of Canada, represented by the President of the Treasury Board, ${year},<br>${selectedIdentifier}:&#160;${number}</p>\n</section>`;
                    } else { // Queen
                        colophonHtmlContent += `Her Majesty the Queen in Right of Canada, represented by the President of the Treasury Board, ${year},<br>${selectedIdentifier}:&#160;${number}</p>\n</section>`;
                    }
                } else { // French
                    if (selectedMonarch === 'King') {
                        colophonHtmlContent += `Sa MajestÃ© le Roi du chef du Canada, reprÃ©sentÃ© par le prÃ©sident du Conseil du TrÃ©sor, ${year},<br>${selectedIdentifier}&#160;:&#160;${number}</p>\n</section>`;
                    } else { // Queen
                        colophonHtmlContent += `Sa MajestÃ© la Reine du chef du Canada, reprÃ©sentÃ©e par le prÃ©sident du Conseil du Conseil du TrÃ©sor, ${year},<br>${selectedIdentifier}&#160;:&#160;${number}</p>\n</section>`;
                    }
                }

                // Insert the generated HTML into the Monaco editor
                if (monacoEditorInstance) {
                    let currentContent = monacoEditorInstance.getValue();
                    currentContent = protectDataAttributes(currentContent); // Protect attributes before string manipulation

                    // Append the new colophon HTML
                    currentContent += colophonHtmlContent;

                    currentContent = restoreDataAttributes(currentContent); // Restore attributes
                    currentContent = convertAllEntitiesToNumeric(currentContent); // Ensure entities are correct after all operations

                    monacoEditorInstance.setValue(currentContent);
                    htmlOutputContent = currentContent; // Update main content variable
                    applyEntityHighlighting(); // Re-apply highlighting
                }

                closeModalAndReEnableButtons(); // Cleanup and re-enable immediately

                // Capture originalButtonText in a local constant for the setTimeout closure
                const capturedOriginalText = originalButtonText;

                // Provide visual feedback for the triggering button only after successful insert
                triggeringButton.textContent = 'Inserted!';
                triggeringButton.classList.add('bg-green-500', 'hover:bg-green-600');
                triggeringButton.classList.remove('bg-zinc-700', 'hover:bg-zinc-600');
                // The disabled state is managed by updateAllInteractiveButtonStates()
                setTimeout(() => {
                    triggeringButton.textContent = capturedOriginalText; // Revert to initial text
                    triggeringButton.classList.remove('bg-green-500', 'hover:bg-green-600');
                    triggeringButton.classList.add('bg-zinc-700', 'hover:bg-zinc-600');
                }, 1500);
            });
        }

        /**
         * Displays a modal dialog for configuring and inserting footnote lists.
         * @param {HTMLElement} triggeringButton - The button that opened this modal.
         * @param {string} originalButtonText - The original text of the triggering button.
         */
        function showFootnoteModal(triggeringButton, originalButtonText) {
            const footnoteContentHtml = `
                <div class="flex flex-col space-y-4">
				<div>
				<p>NOTE: This only creates an empty list of footnotes, you must populate it on your own. It also does not add/change anchors. 
				</div>
                    <div>
                        <span class="text-sm font-medium text-gray-200 mr-2">Language:</span>
                        <div class="button-group inline-flex">
                            <button id="fnLangEnglishBtn" class="px-3 py-1 text-sm bg-gray-700 text-white rounded-md hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-opacity-50 font-bold">English</button>
                            <button id="fnLangFrenchBtn" class="px-3 py-1 text-sm bg-gray-700 text-white rounded-md hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-opacity-50 font-bold">French</button>
                        </div>
                    </div>
                    
                    <div>
                        <label for="fnCount" class="block text-sm font-medium text-gray-200">How many?</label>
                        <input type="number" id="fnCount" class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500" placeholder="1" min="1" value="1">
                    </div>
					<div>
                        <label for="fnIdPrefix" class="block text-sm font-medium text-gray-200">ID Prefix (optional):</label>
                        <input type="text" id="fnIdPrefix" class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500" placeholder="e.g., mydoc-">
                    </div>
                </div>
            `;

            const modalOverlay = document.createElement('div');
            modalOverlay.className = 'modal-overlay';
            modalOverlay.innerHTML = `
                <div class="modal-content">
                    <h3>Insert Footnote List</h3>
                    <div id="modalBody">${footnoteContentHtml}</div>
                    <div class="flex justify-end mt-4 space-x-2">
                        <button id="modalCancelFnBtn" class="px-4 py-2 bg-gray-600 text-white rounded-md hover:bg-gray-700">Cancel</button>
                        <button id="modalInsertFnBtn" class="px-4 py-2 bg-blue-500 text-white rounded-md hover:bg-blue-600">Insert</button>
                    </div>
                </div>
            `;
            document.body.appendChild(modalOverlay);

            // Function to clean up and re-enable buttons
            function closeModalAndReEnableButtons() {
                modalOverlay.remove();
                triggeringButton.removeAttribute('data-temp-active'); // Crucial: Remove flag
                triggeringButton.textContent = originalButtonText; // Revert immediately
                triggeringButton.classList.remove('bg-green-500', 'hover:bg-green-600');
                triggeringButton.classList.add('bg-zinc-700', 'hover:bg-zinc-600');
                updateAllInteractiveButtonStates(); // Re-enable all buttons
            }

            document.getElementById('modalCancelFnBtn').addEventListener('click', closeModalAndReEnableButtons);

            const fnLangEnglishBtn = document.getElementById('fnLangEnglishBtn');
            const fnLangFrenchBtn = document.getElementById('fnLangFrenchBtn');
            const fnIdPrefixInput = document.getElementById('fnIdPrefix');
            const fnCountInput = document.getElementById('fnCount');
            const modalInsertFnBtn = document.getElementById('modalInsertFnBtn');

            let selectedFnLanguage = 'English';

            // Helper for button active state in modal
            function updateFnButtonActiveState(buttons, activeBtn) {
                buttons.forEach(btn => {
                    btn.classList.remove('active', 'bg-indigo-600');
                    btn.classList.add('bg-gray-700', 'hover:bg-gray-600');
                });
                activeBtn.classList.add('active', 'bg-indigo-600');
                activeBtn.classList.remove('bg-gray-700', 'hover:bg-gray-600');
            }

            updateFnButtonActiveState([fnLangEnglishBtn, fnLangFrenchBtn], fnLangEnglishBtn);

            fnLangEnglishBtn.addEventListener('click', () => {
                selectedFnLanguage = 'English';
                updateFnButtonActiveState([fnLangEnglishBtn, fnLangFrenchBtn], fnLangEnglishBtn);
            });

            fnLangFrenchBtn.addEventListener('click', () => {
                selectedFnLanguage = 'French';
                updateFnButtonActiveState([fnLangEnglishBtn, fnLangFrenchBtn], fnLangFrenchBtn);
            });

            // Ensure number input only accepts digits
            fnCountInput.addEventListener('input', (event) => {
                const input = event.target;
                input.value = input.value.replace(/\D/g, ''); // Remove non-digits
                if (input.value === '') {
                    input.value = '1'; // Default to 1 if cleared
                }
            });

            modalInsertFnBtn.addEventListener('click', () => {
                const idPrefix = fnIdPrefixInput.value.trim();
                const footnoteCount = parseInt(fnCountInput.value) || 1; // Default to 1

                // Capture originalButtonText in a local constant for the setTimeout closure
                const capturedOriginalText = originalButtonText;

                let footnoteHtmlContent = `<aside class="wb-fnote" role="note">\n`;
                footnoteHtmlContent += `\t<h2 id="${idPrefix}fn">${selectedFnLanguage === 'English' ? 'Footnotes' : 'Notes en bas de page'}</h2>\n`;
                footnoteHtmlContent += `\t<dl>\n`;

                for (let i = 1; i <= footnoteCount; i++) {
                    const dtText = selectedFnLanguage === 'English' ? `Footnote ${i}` : `Note en bas de page ${i}`;
                    const ddContent = selectedFnLanguage === 'English' ? `ENG footnote ${i} content.` : `FRA footnote ${i} content.`;
                    const returnTextInv = selectedFnLanguage === 'English' ? `Return to footnote ` : `Retour Ã  la rÃ©fÃ©rence de la note en bas de page `;
                    const returnTextRef = selectedFnLanguage === 'English' ? ` referrer` : ``;

                    footnoteHtmlContent += `\t\t<dt>${dtText}</dt>\n`;
                    footnoteHtmlContent += `\t\t<dd id="${idPrefix}fn${i}">\n`;
                    footnoteHtmlContent += `\t\t\t<p>${ddContent}</p>\n`;
                    footnoteHtmlContent += `\t\t\t<p class="fn-rtn"> <a href="#${idPrefix}fn${i}-rf"><span class="wb-inv">${returnTextInv}</span>${i}<span class="wb-inv">${returnTextRef}</span></a> </p>\n`;
                    footnoteHtmlContent += `\t\t</dd>\n`;
                }

                footnoteHtmlContent += `\t</dl>\n`;
                footnoteHtmlContent += `</aside>\n`;

                if (monacoEditorInstance) {
                    let currentContent = monacoEditorInstance.getValue();
                    currentContent = protectDataAttributes(currentContent); // Protect attributes

                    // Find the insertion point: before any section with 'colophon' in its ID
                    const colophonSectionMatch = currentContent.match(/<section[^>]*id=["'][^"']*colophon[^"']*["'][^>]*>/i);
                    let insertionIndex = -1;

                    if (colophonSectionMatch) {
                        insertionIndex = currentContent.indexOf(colophonSectionMatch[0]);
                    }

                    if (insertionIndex !== -1) {
                        // Insert the footnote HTML before the colophon section
                        currentContent = currentContent.substring(0, insertionIndex) + footnoteHtmlContent + currentContent.substring(insertionIndex);
                    } else {
                        // If no colophon section, append to the end of the body just before </body>
                        const bodyEndTagIndex = currentContent.lastIndexOf('</body>');
                        if (bodyEndTagIndex !== -1) {
                            currentContent = currentContent.substring(0, bodyEndTagIndex) + footnoteHtmlContent + '\n' + currentContent.substring(bodyEndTagIndex);
                        } else {
                            currentContent += footnoteHtmlContent; // Fallback to simply appending
                        }
                    }

                    currentContent = restoreDataAttributes(currentContent); // Restore attributes
                    currentContent = convertAllEntitiesToNumeric(currentContent); // Ensure entities are correct after all operations

                    monacoEditorInstance.setValue(currentContent);
                    htmlOutputContent = currentContent;
                    applyEntityHighlighting();
                }

                closeModalAndReEnableButtons(); // Cleanup and re-enable immediately

                // Provide visual feedback for the button after successful insert
                triggeringButton.textContent = 'Inserted!';
                triggeringButton.classList.add('bg-green-500', 'hover:bg-green-600');
                triggeringButton.classList.remove('bg-zinc-700', 'hover:bg-zinc-600');
                // The disabled state is managed by updateAllInteractiveButtonStates()
                setTimeout(() => {
                    triggeringButton.textContent = capturedOriginalText; // Use the captured variable
                    triggeringButton.classList.remove('bg-green-500', 'hover:bg-green-600');
                    triggeringButton.classList.add('bg-zinc-700', 'hover:bg-zinc-600');
                }, 1500);
            });
        }

        /**
         * Displays a modal dialog for Auto-ID options.
         * @param {HTMLElement} triggeringButton - The button that opened this modal.
         * @param {string} originalButtonText - The original text of the triggering button.
         */
        function showAutoIdModal(triggeringButton, originalButtonText) {
            const autoIdContentHtml = `
                <div class="flex flex-col space-y-4">
                    <div>
                        <span class="text-sm font-medium text-gray-200 mr-2">Choose elements to ID:</span>
                        <div class="space-y-2 mt-2">
                            <!-- Section Toggle -->
                            <div class="toggle-switch-container">
                                <label class="toggle-switch is-checked" for="toggleSectionsId">
                                    <input type="checkbox" id="toggleSectionsId" checked>
                                    <span class="toggle-switch-slider"></span>
                                </label>
                                <span class="toggle-switch-label text-white text-sm">Sections</span>
                            </div>
                            <!-- Headings Toggle -->
                            <div class="toggle-switch-container">
                                <label class="toggle-switch is-checked" for="toggleHeadingsId">
                                    <input type="checkbox" id="toggleHeadingsId" checked>
                                    <span class="toggle-switch-slider"></span>
                                </label>
                                <span class="toggle-switch-label text-white text-sm">Headings</span>
                            </div>
                            <!-- Tables Toggle -->
                            <div class="toggle-switch-container">
                                <label class="toggle-switch is-checked" for="toggleTablesId">
                                    <input type="checkbox" id="toggleTablesId" checked>
                                    <span class="toggle-switch-slider"></span>
                                </label>
                                <span class="toggle-switch-label text-white text-sm">Tables (outside figures)</span>
                            </div>
                            <!-- Figure Tables Toggle -->
                            <div class="toggle-switch-container">
                                <label class="toggle-switch is-checked" for="toggleFigureTablesId">
                                    <input type="checkbox" id="toggleFigureTablesId" checked>
                                    <span class="toggle-switch-slider"></span>
                                </label>
                                <span class="toggle-switch-label text-white text-sm">Figure Tables (inside figures)</span>
                            </div>
                        </div>
                    </div>
                </div>
            `;

            const modalOverlay = document.createElement('div');
            modalOverlay.className = 'modal-overlay';
            modalOverlay.innerHTML = `
                <div class="modal-content">
                    <h3>Auto-ID Options</h3>
                    <div id="modalBody">${autoIdContentHtml}</div>
                    <div class="flex justify-end mt-4 space-x-2">
                        <button id="modalCancelAutoIdBtn" class="px-4 py-2 bg-gray-600 text-white rounded-md hover:bg-gray-700">Cancel</button>
                        <button id="modalApplyAutoIdBtn" class="px-4 py-2 bg-blue-500 text-white rounded-md hover:bg-blue-600">Apply IDs</button>
                    </div>
                </div>
            `;
            document.body.appendChild(modalOverlay);

            // Function to clean up and re-enable buttons
            function closeModalAndReEnableButtons() {
                modalOverlay.remove();
                triggeringButton.removeAttribute('data-temp-active'); // Crucial: Remove flag
                triggeringButton.textContent = originalButtonText; // Revert immediately
                triggeringButton.classList.remove('bg-green-500', 'hover:bg-green-600');
                triggeringButton.classList.add('bg-zinc-700', 'hover:bg-zinc-600');
                updateAllInteractiveButtonStates(); // Re-enable all buttons
            }

            document.getElementById('modalCancelAutoIdBtn').addEventListener('click', closeModalAndReEnableButtons);

            // Get references to elements within the newly created modal
            const toggleSectionsId = document.getElementById('toggleSectionsId');
            const toggleHeadingsId = document.getElementById('toggleHeadingsId');
            const toggleTablesId = document.getElementById('toggleTablesId');
            const toggleFigureTablesId = document.getElementById('toggleFigureTablesId');
            const modalApplyAutoIdBtn = document.getElementById('modalApplyAutoIdBtn');

            // Event listeners for pill switches
            [toggleSectionsId, toggleHeadingsId, toggleTablesId, toggleFigureTablesId].forEach(toggle => {
                toggle.addEventListener('change', (event) => {
                    const parentLabel = event.target.closest('.toggle-switch');
                    if (event.target.checked) {
                        parentLabel.classList.add('is-checked');
                    } else {
                        parentLabel.classList.remove('is-checked');
                    }
                });
            });

            modalApplyAutoIdBtn.addEventListener('click', () => {
                const options = {
                    idSections: toggleSectionsId.checked,
                    idHeadings: toggleHeadingsId.checked,
                    idTables: toggleTablesId.checked,
                    idFigureTables: toggleFigureTablesId.checked
                };

                if (monacoEditorInstance) {
                    let currentContent = monacoEditorInstance.getValue();
                    currentContent = protectDataAttributes(currentContent);
                    currentContent = applyAutoId(currentContent, options); // Pass options to applyAutoId
                    currentContent = restoreDataAttributes(currentContent);
                    currentContent = convertAllEntitiesToNumeric(currentContent);
                    monacoEditorInstance.setValue(currentContent);
                    htmlOutputContent = currentContent;
                    applyEntityHighlighting();

                    closeModalAndReEnableButtons(); // Cleanup and re-enable immediately

                    // Capture originalButtonText in a local constant for the setTimeout closure
                    const capturedOriginalText = originalButtonText;

                    // Provide visual feedback for the main Auto-ID button
                    triggeringButton.textContent = 'ID\'d!';
                    triggeringButton.classList.add('bg-green-500', 'hover:bg-green-600');
                    triggeringButton.classList.remove('bg-zinc-700', 'hover:bg-zinc-600');
                    // The disabled state is managed by updateAllInteractiveButtonStates()
                    setTimeout(() => {
                        triggeringButton.textContent = capturedOriginalText; // Revert to initial text
                        triggeringButton.classList.remove('bg-green-500', 'hover:bg-green-600');
                        triggeringButton.classList.add('bg-zinc-700', 'hover:bg-zinc-600');
                    }, 1500);
                }
            });
        }


        // Initialize and set up event listeners on window load
        window.onload = function() {
            console.log("Parent window.onload triggered.");
            // Initial setup: Ensure rich text panel is visible and code panel is hidden
            richtextOutputPanel.classList.add('panel-visible');
            codePanel.classList.add('panel-hidden');

            // Set initial button styles based on default view (richtext)
            // The "Go to HTML" button is visible initially, so its color depends on the Mso toggle.
            // The "Go to Rich-Text" button is hidden initially, so it should have its default blue color.
            toggleEditorViewBtnCode.classList.add('bg-sky-700', 'hover:bg-sky-800');
            toggleEditorViewBtnCode.classList.remove('bg-sky-700', 'hover:bg-sky-800', 'bg-zinc-700', 'hover:bg-zinc-600');
            updateGoToHtmlButtonColor(); // Call to set initial color for "Go to HTML" button


            // Initialize Monaco Editor
            require.config({ paths: { 'vs': 'https://cdn.jsdelivr.net/npm/monaco-editor@0.49.0/min/vs' } });
            require(['vs/editor/editor.main'], function () {
                monacoEditorInstance = monaco.editor.create(monacoEditorContainer, { // Use monacoEditorContainer here
                    value: htmlOutputContent, // Set initial content
                    language: 'html',
                    theme: 'vs-dark', // Or 'hc-black'
                    automaticLayout: true, // Important for responsiveness
                    minimap: { enabled: false },
                    fontSize: 14,
                    tabSize: 4,
                    insertSpaces: true,
                    // Additional options for better UX
                    scrollBeyondLastLine: false,
                    wordWrap: 'on',
                    wrappingIndent: 'same',
                });
                console.log("Monaco editor initialized.");

                // Update htmlOutputContent on Monaco content change
                monacoEditorInstance.onDidChangeModelContent(() => {
                    htmlOutputContent = monacoEditorInstance.getValue();
                    applyEntityHighlighting(); // Re-apply highlighting on content change
                });

                // Apply initial highlighting after Monaco is created
                applyEntityHighlighting();

                // Ensure Monaco refreshes layout on window resize
                window.addEventListener('resize', debouncedMonacoLayout);

                // Monaco Resizer Logic
                let isResizing = false;
                let initialMonacoWidth; // Keep track of pixel widths for calculations
                let initialSidebarWidth;
                let initialMouseX;

                monacoResizer.addEventListener('mousedown', (e) => {
                    isResizing = true;
                    initialMonacoWidth = monacoEditorContainer.offsetWidth;
                    initialSidebarWidth = sidebar.offsetWidth;
                    initialMouseX = e.clientX;
                    document.addEventListener('mousemove', onMouseMove);
                    document.addEventListener('mouseup', onMouseUp);
                    document.body.style.cursor = 'ew-resize';
                    document.body.style.userSelect = 'none';
                });

                function onMouseMove(e) {
                    if (!isResizing) return;
                    const dx = e.clientX - initialMouseX;

                    let newMonacoWidth = initialMonacoWidth + dx;
                    let newSidebarWidth = initialSidebarWidth - dx;

                    const minWidth = 200; // Minimum size in pixels for each panel
                    
                    // Ensure minimum widths
                    if (newMonacoWidth < minWidth) {
                        newMonacoWidth = minWidth;
                        // Adjust sidebar width to maintain total space if Monaco hits min
                        newSidebarWidth = initialMonacoWidth + initialSidebarWidth - newMonacoWidth;
                    }
                    if (newSidebarWidth < minWidth) {
                        newMonacoWidth = minWidth;
                        // Adjust Monaco width to maintain total space if Monaco hits min
                        newMonacoWidth = initialMonacoWidth + initialSidebarWidth - newMonacoWidth;
                    }

                    // Apply the new widths directly to flex-basis
                    monacoEditorContainer.style.flexBasis = `${newMonacoWidth}px`;
                    sidebar.style.flexBasis = `${newSidebarWidth}px`;

                    // No explicit layout call needed here for Monaco, automaticLayout should handle it.
                }

                function onMouseUp() {
                    isResizing = false;
                    document.removeEventListener('mousemove', onMouseMove);
                    document.removeEventListener('mouseup', onMouseUp);
                    document.body.style.cursor = 'default';
                    document.body.style.userSelect = '';
                    // After resizing stops, call layout once to ensure final state is correct and stable.
                    if (monacoEditorInstance) {
                        monacoEditorInstance.layout();
                    }
                }
            });

            copyCodeBtn.addEventListener('click', async () => {
                const codeContent = monacoEditorInstance ? monacoEditorInstance.getValue() : '';
                try {
                    const tempTextArea = document.createElement('textarea');
                    tempTextArea.value = codeContent;
                    document.body.appendChild(tempTextArea);
                    tempTextArea.select();
                    document.execCommand('copy');
                    document.body.removeChild(tempTextArea);
                    const originalText = copyCodeBtn.textContent;
                    copyCodeBtn.textContent = 'Copied!';
                    copyCodeBtn.classList.add('bg-green-500', 'hover:bg-green-600');
                    copyCodeBtn.classList.remove('bg-zinc-700', 'hover:bg-zinc-600');
                    copyCodeBtn.disabled = true; // Disable the button
                    copyCodeBtn.setAttribute('data-temp-active', 'true'); // Mark as active
                    updateAllInteractiveButtonStates(); // Update all buttons
                    setTimeout(() => {
                        copyCodeBtn.textContent = originalText;
                        copyCodeBtn.classList.remove('bg-green-500', 'hover:bg-green-600');
                        copyCodeBtn.classList.add('bg-zinc-700', 'hover:bg-zinc-600');
                        copyCodeBtn.disabled = false; // Re-enable the button
                        copyCodeBtn.removeAttribute('data-temp-active'); // Unmark as active
                        updateAllInteractiveButtonStates(); // Update all buttons
                    }, 1500);
                } catch (err) {
                    console.error('Failed to copy text: ', err);
                }
            });

            autoFormatBtn.addEventListener('click', () => {
                if (monacoEditorInstance) {
                    let currentContent = monacoEditorInstance.getValue();
                    // Do NOT decodeHtmlEntities here. Protect attributes directly from Monaco's value.
                    currentContent = protectDataAttributes(currentContent); // Protect attributes (string replacement)

                    // Use js_beautify to format the HTML content
                    let formattedContent = html_beautify(currentContent, {
                        indent_size: 4, // You can customize indentation size
                        space_in_paren: true // Example option
                    });

                    formattedContent = restoreDataAttributes(formattedContent); // Restore attributes (string replacement)
                    formattedContent = convertAllEntitiesToNumeric(formattedContent); // Re-encode after formatting

                    monacoEditorInstance.setValue(formattedContent);
                    applyEntityHighlighting(); // Re-apply highlighting after formatting

                    const originalText = autoFormatBtn.textContent;
                    autoFormatBtn.textContent = 'Formatted!';
                    autoFormatBtn.classList.add('bg-green-500', 'hover:bg-green-600');
                    autoFormatBtn.classList.remove('bg-red-700', 'hover:bg-red-800');
                    autoFormatBtn.disabled = true; // Disable the button
                    autoFormatBtn.setAttribute('data-temp-active', 'true'); // Mark as active
                    updateAllInteractiveButtonStates(); // Update all buttons
                    setTimeout(() => {
                        autoFormatBtn.textContent = originalText;
                        autoFormatBtn.classList.remove('bg-green-500', 'hover:bg-green-600');
                        autoFormatBtn.classList.add('bg-red-700', 'hover:bg-red-800');
                        autoFormatBtn.disabled = false; // Re-enable the button
                        autoFormatBtn.removeAttribute('data-temp-active'); // Unmark as active
                        updateAllInteractiveButtonStates(); // Update all buttons
                    }, 1500);
                }
            });

            // New Auto-Encode button event listener
            autoEncodeBtn.addEventListener('click', () => {
                if (monacoEditorInstance) {
                    let currentContent = monacoEditorInstance.getValue();
                    // Do NOT decodeHtmlEntities here. Protect attributes directly from Monaco's value.
                    currentContent = protectDataAttributes(currentContent); // Protect attributes (string replacement)

                    let encodedContent = convertAllEntitiesToNumeric(currentContent); // Apply the encoding

                    encodedContent = restoreDataAttributes(encodedContent); // Restore attributes (string replacement)
                    // convertAllEntitiesToNumeric is the LAST step here, so no need to call it again after restore.
                    // This is intentional as this button's purpose is to ensure all entities are numeric.

                    monacoEditorInstance.setValue(encodedContent);
                    htmlOutputContent = encodedContent; // Keep the main content variable updated
                    applyEntityHighlighting(); // Re-apply highlighting after encoding

                    const originalText = autoEncodeBtn.textContent;
                    autoEncodeBtn.textContent = 'Encoded!';
                    autoEncodeBtn.classList.add('bg-green-500', 'hover:bg-green-600');
                    autoEncodeBtn.classList.remove('bg-red-700', 'hover:bg-red-800');
                    autoEncodeBtn.disabled = true; // Disable the button
                    autoEncodeBtn.setAttribute('data-temp-active', 'true'); // Mark as active
                    updateAllInteractiveButtonStates(); // Update all buttons
                    setTimeout(() => {
                        autoEncodeBtn.textContent = originalText;
                        autoEncodeBtn.classList.remove('bg-green-500', 'hover:bg-green-600');
                        autoEncodeBtn.classList.add('bg-red-700', 'hover:bg-red-800');
                        autoEncodeBtn.disabled = false; // Re-enable the button
                        autoEncodeBtn.removeAttribute('data-temp-active'); // Unmark as active
                        updateAllInteractiveButtonStates(); // Update all buttons
                    }, 1500);
                }
            });

            exportHtmlBtn.addEventListener('click', () => {
                const htmlContent = monacoEditorInstance ? monacoEditorInstance.getValue() : '';
                const blob = new Blob([htmlContent], { type: 'text/html' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'index.html';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                const originalText = exportHtmlBtn.textContent;
                exportHtmlBtn.textContent = 'Exported!';
                exportHtmlBtn.classList.add('bg-green-500', 'hover:bg-green-600');
                exportHtmlBtn.classList.remove('bg-red-700', 'hover:bg-red-800');
                exportHtmlBtn.disabled = true; // Disable the button
                exportHtmlBtn.setAttribute('data-temp-active', 'true'); // Mark as active
                updateAllInteractiveButtonStates(); // Update all buttons
                setTimeout(() => {
                    exportHtmlBtn.textContent = originalText;
                    exportHtmlBtn.classList.remove('bg-green-500', 'hover:bg-green-600');
                    exportHtmlBtn.classList.add('bg-red-700', 'hover:bg-red-800');
                    exportHtmlBtn.disabled = false; // Re-enable the button
                    exportHtmlBtn.removeAttribute('data-temp-active'); // Unmark as active
                    updateAllInteractiveButtonStates(); // Update all buttons
                }, 1500);
            });

            importHtmlBtn.addEventListener('click', () => htmlFileInput.click());
            htmlFileInput.addEventListener('change', (event) => {
                const file = event.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        const importedContent = e.target.result;
                        if (monacoEditorInstance) {
                            monacoEditorInstance.setValue(importedContent);
                            htmlOutputContent = importedContent; // Update stored content
                            applyEntityHighlighting(); // Re-apply highlighting after import
                        }
                        const originalText = importHtmlBtn.textContent;
                        importHtmlBtn.textContent = 'Imported!';
                        importHtmlBtn.classList.add('bg-green-500', 'hover:bg-green-600');
                        importHtmlBtn.classList.remove('bg-purple-700', 'hover:bg-purple-800');
                        importHtmlBtn.disabled = true; // Disable the button
                        importHtmlBtn.setAttribute('data-temp-active', 'true'); // Mark as active
                        updateAllInteractiveButtonStates(); // Update all buttons
                        setTimeout(() => {
                            importHtmlBtn.textContent = originalText;
                            importHtmlBtn.classList.remove('bg-green-500', 'hover:bg-green-600');
                            importHtmlBtn.classList.add('bg-purple-700', 'hover:bg-purple-800');
                            importHtmlBtn.disabled = false; // Re-enable the button
                            importHtmlBtn.removeAttribute('data-temp-active');
                            updateAllInteractiveButtonStates();
                        }, 1500);
                    };
                    reader.onerror = () => {
                        // Error handling for file read removed.
                    };
                    reader.readAsText(file);
                }
            });

            // Event listeners for the new individual toggle buttons
            toggleEditorViewBtnRichText.addEventListener('click', toggleEditorView);
            toggleEditorViewBtnCode.addEventListener('click', toggleEditorView);

            // Clear All button event listener
            clearAllBtn.addEventListener('click', () => {
                if (monacoEditorInstance) {
                    monacoEditorInstance.setValue(''); // Clear Monaco content
                    htmlOutputContent = ''; // Clear stored content
                    applyEntityHighlighting(); // Re-apply highlighting after clearing
                }
                const originalText = clearAllBtn.textContent;
                clearAllBtn.textContent = 'Cleared!';
                clearAllBtn.classList.add('bg-green-500', 'hover:bg-green-600');
                clearAllBtn.classList.remove('bg-zinc-700', 'hover:bg-zinc-600');
                clearAllBtn.disabled = true; // Disable the button
                clearAllBtn.setAttribute('data-temp-active', 'true'); // Mark as active
                updateAllInteractiveButtonStates(); // Update all buttons
                setTimeout(() => {
                    clearAllBtn.textContent = originalText;
                    clearAllBtn.classList.remove('bg-green-500', 'hover:bg-green-600');
                    clearAllBtn.classList.add('bg-zinc-700', 'hover:bg-zinc-600');
                    clearAllBtn.disabled = false; // Re-enable the button
                    clearAllBtn.removeAttribute('data-temp-active'); // Unmark as active
                    updateAllInteractiveButtonStates();
                }, 1500);
            });

            // Initial content for the iframe
            const iframeDocument = default_ifr.contentDocument || default_ifr.contentWindow.document;
            iframeDocument.open();
            iframeDocument.write(`
                <!DOCTYPE html>
                <html lang="en">
                <head>
                    <meta charset="UTF-8">
                    <meta name="viewport" content="width=device-width, initial-scale=1.0">
                    <title>Rich Editor</title>
                    <script src="https://cdn.jsdelivr.net/npm/hugerte@1/hugerte.min.js"><\/script>
                    <script src="https://cdn.tailwindcss.com"><\/script>
                    <style>
                        html, body {
                            height: 100%; /* Ensure html and body take full height */
                            margin: 0;
                            /* Removed padding from html, body to avoid height calculation issues */
                            box-sizing: border-box; /* Include padding in height calculations for all elements */
                        }
                        body {
                            font-family: sans-serif;
                            background-color: #ffffff; /* White background for iframe body */
                            color: #333;
                            display: flex; /* Use flexbox for body to make form fill height */
                            flex-direction: column;
                            padding: 1rem; /* Add padding to the body of the iframe */
                        }
                        form {
                            height: 100%;
                            display: flex;
                            flex-direction: column;
                        }
                        textarea {
                            width: 100%;
                            flex-grow: 1;
                            border: 1px solid #ccc;
                            border-radius: 0.5rem;
                            padding: 0.75rem;
                            font-size: 1rem;
                            resize: none; /* Prevent manual resizing */
                            box-sizing: border-box; /* Include padding in width/height */
                        }
                        /* Style for HugeRTE container */
                        .tox.tox-tinymce { /* Use .tox.tox-tinymce as HugeRTE uses TinyMCE classes */
                            height: 100% !important; /* Force full height */
                            display: flex; /* Make it a flex container */
                            flex-direction: column; /* Stack its children vertically */
                        }
                        .tox-editor-container {
                            flex-grow: 1; /* Allow the editor area to grow */
                            display: flex;
                            flex-direction: column;
                        }
                        .tox-edit-area {
                            flex-grow: 1; /* Allow the editing area to grow */
                            display: flex;
                            flex-direction: column;
                        }
                        .tox-edit-area__iframe {
                            flex-grow: 1; /* Make the actual iframe within TinyMCE fill space */
                        }
                        /* Class for time tags to prevent wrapping */
                        .nowrap {
                            white-space: nowrap;
                        }
                    </style>
                </head>
                <body>
                    <form method="post">
                        <textarea id="richEditor"></textarea>
                    </form>
                    <script type="text/javascript">
                        console.log("Iframe script started executing.");
                        // Global variable to hold the HugeRTE editor instance
                        let richTextEditorInstance;
                        // Flag to prevent infinite loop when updating HugeRTE from CodeMirror
                        let isUpdatingFromCodeMirror = false;

                        /**
                         * Function to set the content of the HugeRTE editor.
                         * This is called from the parent window.
                         */
                        window.setRichEditorContent = function(content) {
                            // console.log("Iframe: setRichEditorContent called by parent.");
                            if (richTextEditorInstance && !isUpdatingFromCodeMirror) {
                                isUpdatingFromCodeMirror = true;
                                richTextEditorInstance.setContent(content);
                                richTextEditorInstance.focus(); // Re-focus the rich editor after content update
                                // console.log('Iframe: HugeRTE updated from parent.');
                                isUpdatingFromCodeMirror = false;
                            } else {
                                console.warn('Iframe: HugeRTE editor not yet initialized or isUpdatingFromCodeMirror is true. Content will be set once ready.');
                            }
                        };

                        /**
                         * Function to get the content from the HugeRTE editor.
                         * This is called from the parent window.
                         */
                        window.getRichEditorContent = function() {
                            // console.log("Iframe: getRichEditorContent called by parent.");
                            if (richTextEditorInstance) {
                                const content = richTextEditorInstance.getContent();
                                // console.log("Iframe: HugeRTE content requested by parent.");
                                return content;
                            } else {
                                console.warn('Iframe: HugeRTE editor not yet initialized. Cannot get content.');
                                return '';
                            }
                        };

                        /**
                         * HugeRTE init
                         */
                        if (typeof hugerte === 'undefined') {
                            console.error("Iframe: HugeRTE library not loaded!");
                        }
                        else {
                            console.log("Iframe: HugeRTE library loaded. Initializing editor.");
                            hugerte.init({
                                selector: '#richEditor',
                                toolbar: 'undo redo styles bold italic alignleft aligncenter alignright numlist bullist link table',
                                plugins: [ 'table', 'lists', 'link' ],
                                height: '100%', // Explicitly set height for TinyMCE
                                tab_focus: false, // Allow tab to indent instead of changing focus
                                formats: { // Define custom formats for alignment to use classes
                                    alignleft: { selector: 'p,h1,h2,h3,h4,h5,h6,td,th,div,ul,ol,li,table,img', classes: 'text-left', exact: true },
                                    aligncenter: { selector: 'p,h1,h2,h3,h4,h5,h6,td,th,div,ul,ol,li,table,img', classes: 'text-center', exact: true },
                                    alignright: { selector: 'p,h1,h2,h3,h4,h5,h6,td,th,div,ul,ol,li,table,img', classes: 'text-right', exact: true },
                                },
                                init_instance_callback: function(editorInstance) {
                                    console.log('Iframe: HugeRTE editor initialized inside iframe.');
                                    richTextEditorInstance = editorInstance; // Store the instance globally
                                    // Expose the instance to the parent window
                                    if (window.parent) {
                                        window.parent.richTextEditorInstanceFromIframe = editorInstance;
                                        console.log("Iframe: HugeRTE instance exposed to parent.");
                                    }

                                    // Handle Tab key for indentation and outdentation, especially for lists
                                    editorInstance.on('keydown', (event) => {
                                        if (event.key === 'Tab') {
                                            event.preventDefault(); // Prevent default tab behavior (focus change)
                                            // No content modification (no spaces, no styles)
                                            editorInstance.focus(); // Explicitly refocus the editor after command
                                        }
                                    });

                                    // Initial content sync when editor loads
                                    console.log('Iframe: HugeRTE editor ready.');
                                    // Set initial content if parent already has some
                                    if (window.parent.richTextContent) {
                                        editorInstance.setContent(window.parent.richTextContent);
                                        console.log("Iframe: Initial HugeRTE content set from parent.");
                                    }
                                }
                            });
                        }
                    <\/script>
                </body>
                </html>
            `);
            iframeDocument.close();

            // After the iframe content is loaded and the editor is initialized within it,
            // the iframe's script will assign its editor instance to window.parent.richTextEditorInstanceFromIframe
            // We can then pick it up here.
            default_ifr.onload = () => {
                console.log("Parent: Iframe finished loading.");
                if (default_ifr.contentWindow && default_ifr.contentWindow.richTextEditorInstanceFromIframe) {
                    richTextEditorInstanceFromIframe = default_ifr.contentWindow.richTextEditorInstanceFromIframe;
                    console.log("Parent: HugeRTE instance captured by parent.");
                } else {
                    console.warn("Parent: Could not capture HugeRTE instance from iframe. Is HugeRTE initializing correctly inside?");
                }
            };

            // Event listeners for Auto-Clean MSO when switching toggles
            toggleAutoCleanMsoOnSwitchRichText.addEventListener('change', (event) => {
                const isChecked = event.target.checked;
                const parentLabel = event.target.closest('.toggle-switch');
                if (isChecked) {
                    parentLabel.classList.add('is-checked');
                } else {
                    parentLabel.classList.remove('is-checked');
                }
                toggleAutoCleanMsoOnSwitchCode.checked = isChecked; // Sync state
                toggleAutoCleanMsoOnSwitchCode.closest('.toggle-switch').classList.toggle('is-checked', isChecked);
                console.log(`Auto-Clean MSO on RichText switch is now: ${isChecked ? 'ON' : 'OFF'}`);
                updateGoToHtmlButtonColor(); // Update button color
                updateCleanMsoButtonState(); // Update Clean Mso button state
            });

            toggleAutoCleanMsoOnSwitchCode.addEventListener('change', (event) => {
                const isChecked = event.target.checked;
                const parentLabel = event.target.closest('.toggle-switch');
                if (isChecked) {
                    parentLabel.classList.add('is-checked');
                } else {
                    parentLabel.classList.remove('is-checked');
                }
                toggleAutoCleanMsoOnSwitchRichText.checked = isChecked; // Sync state
                toggleAutoCleanMsoOnSwitchRichText.closest('.toggle-switch').classList.toggle('is-checked', isChecked);
                console.log(`Auto-Clean MSO on Code switch is now: ${isChecked ? 'ON' : 'OFF'}`);
                // No button color update needed here as it's the "Go to Rich-Text" button
                updateCleanMsoButtonState(); // Update Clean Mso button state
            });


            // Set Time Tags button functionality
                timeTagsBtn.addEventListener('click', () => {
                    if (monacoEditorInstance) {
                        let content = monacoEditorInstance.getValue();
                        // Do NOT decodeHtmlEntities here. Protect attributes directly from Monaco's value.
                        content = protectDataAttributes(content); // Protect attributes (string replacement)

                        // Apply NBSP placeholders before any regex/DOM operations that might affect spaces
                        content = applyNBSPPlaceholders(content);

                        const parser = new DOMParser();
                        const doc = parser.parseFromString(content, 'text/html');
                        const body = doc.body;

                        // Step 1: Remove existing <time> tags and extract their text content
                        const existingTimeElements = doc.querySelectorAll('time');
                        existingTimeElements.forEach(timeEl => {
                            // Replace the <time> element with its text content
                            const textNode = doc.createTextNode(timeEl.textContent);
                            if (timeEl.parentNode) {
                                timeEl.parentNode.replaceChild(textNode, timeEl);
                            }
                        });

                        // Now, `body.innerHTML` contains the HTML with all <time> tags removed.
                        // This is the content we will re-process for tagging.
                        let contentToProcess = body.innerHTML;

                        // Month mapping for conversion to numeric format
                        const monthMap = {
                            'january': '01', 'jan': '01', 'janvier': '01',
                            'february': '02', 'feb': '02', 'fÃ©vrier': '02',
                            'march': '03', 'mar': '03', 'mars': '03',
                            'april': '04', 'apr': '04', 'avril': '04',
                            'may': '05', 'mai': '05',
                            'june': '06', 'jun': '06', 'juin': '06',
                            'july': '07', 'jul': '07', 'juillet': '07',
                            'august': '08', 'aug': '08', 'aoÃ»t': '08',
                            'september': '09', 'sep': '09', 'septembre': '09',
                            'october': '10', 'oct': '10', 'octobre': '10',
                            'november': '11', 'nov': '11', 'novembre': '11',
                            'december': '12', 'dec': '12', 'dÃ©cembre': '12'
                        };

                        function getMonthNumber(monthName) {
                            return monthMap[monthName.toLowerCase()] || null;
                        }

                        // Sort month keys by length in descending order to prioritize longer matches (e.g., 'mars' over 'mar')
                        const sortedMonthKeys = Object.keys(monthMap).sort((a, b) => b.length - a.length);
                        const monthPattern = sortedMonthKeys.map(m => m.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&')).join('|');
                        // Use the simplified NBSP placeholder in the regex
                        const spaceOrNBSPChar = `(?:\\s|${NBSP_PLACEHOLDER})+`;

                        // Regex for ISO-MM-DD
                        const regexIsoDateFull = /(?<!\d)(\d{4}-(?:0[1-9]|1[0-2])-(?:0[1-9]|[12]\d|3[01]))(?!\d)/g;

                        // Regex for Month Day, Year (e.g., March 20, 2023)
                        const regexMonthDayYear = new RegExp(`(?<!\\d)(${monthPattern})${spaceOrNBSPChar}(\\d{1,2}),?${spaceOrNBSPChar}(\\d{4})(?!\\d)`, 'i');
                        // Regex for Day Month Year (e.g., 20 March 2023, le 20 mars 2023)
                        const regexDayMonthYear = new RegExp(`(?<!\\d)(?:(?:le|the)${spaceOrNBSPChar})?(\\d{1,2})${spaceOrNBSPChar}(${monthPattern}),?${spaceOrNBSPChar}(\\d{4})(?!\\d)`, 'i');

                        // NEW: Regex for Month Day (no year) - e.g., March 31
                        // Negative lookahead `(?!\d|${spaceOrNBSPChar}\d{4})` ensures no digit or 4-digit year follows.
                        // `(?!-)` prevents tagging numeric dates like 03-31
                        const regexMonthDayNoYear = new RegExp(`(?<!\\d)(${monthPattern})${spaceOrNBSPChar}(\\d{1,2})(?!\\d|${spaceOrNBSPChar}\\d{4})(?!-)`, 'i');

                        // NEW: Regex for Day Month (no year) - e.g., 31 mars, le 31 mars
                        // Negative lookahead `(?!\d|${spaceOrNBSPChar}\\d{4})` ensures no digit or 4-digit year follows.
                        // `(?!-)` prevents tagging numeric dates like 31-03
                        const regexDayMonthNoYear = new RegExp(`(?<!\\d)(?:(?:le|the)${spaceOrNBSPChar})?(\\d{1,2})${spaceOrNBSPChar}(${monthPattern})(?!\\d|${spaceOrNBSPChar}\\d{4})(?!-)`, 'i');


                        // Re-parse the content to allow traversal of the updated DOM
                        const reParsedDoc = parser.parseFromString(contentToProcess, 'text/html');
                        const reParsedBody = reParsedDoc.body;

                        // Collect all text nodes to process first, then iterate and modify.
                        const textNodesToModify = [];
                        const walker = reParsedDoc.createTreeWalker(
                            reParsedBody,
                            NodeFilter.SHOW_TEXT,
                            {
                                acceptNode: function(node) {
                                    let parent = node.parentNode;
                                    while (parent) {
                                        const tagName = parent.tagName ? parent.tagName.toLowerCase() : '';
                                        if (tagName === 'script' || tagName === 'style' || tagName === 'time') {
                                            return NodeFilter.FILTER_REJECT; // Reject if inside these tags
                                        }
                                        parent = parent.parentNode;
                                    }
                                    return NodeFilter.FILTER_ACCEPT; // Accept other text nodes
                                }
                            },
                            false
                        );

                        let currentNode;
                        while (currentNode = walker.nextNode()) {
                            textNodesToModify.push(currentNode);
                        }

                        // Now iterate through the collected nodes and apply modifications
                        textNodesToModify.forEach(textNode => {
                            let text = textNode.nodeValue;
                            let currentText = text;

                            let allMatches = [];
                            const patternsToTest = [
                                { name: 'IsoDateFull', regex: regexIsoDateFull, handler: (match) => {
                                    // Full ISO date: Bamber-MM-DD
                                    const [fullMatch, yearMonthDay] = match;
                                    return yearMonthDay;
                                }, priority: 3 }, // Highest priority for full dates
                                { name: 'DayMonthYear', regex: regexDayMonthYear, handler: (match) => {
                                    // Day Month Year: e.g., 20 March 2023, le 20 mars 2023
                                    const [, day, month, year] = match;
                                    const monthNum = getMonthNumber(month);
                                    if (!monthNum || parseInt(day) < 1 || parseInt(day) > 31) return null;
                                    return `${year}-${monthNum}-${String(day).padStart(2, '0')}`;
                                }, priority: 2 },
                                { name: 'MonthDayYear', regex: regexMonthDayYear, handler: (match) => {
                                    // Month Day Year: e.g., March 20, 2023
                                    const [, month, day, year] = match;
                                    const monthNum = getMonthNumber(month);
                                    if (!monthNum || parseInt(day) < 1 || parseInt(day) > 31) return null;
                                    return `${year}-${monthNum}-${String(day).padStart(2, '0')}`;
                                }, priority: 2 },
                                // NEW: Month Day (no year)
                                { name: 'MonthDayNoYear', regex: regexMonthDayNoYear, handler: (match) => {
                                    const [, month, day] = match;
                                    const monthNum = getMonthNumber(month);
                                    if (!monthNum || parseInt(day) < 1 || parseInt(day) > 31) return null;
                                    return `${monthNum}-${String(day).padStart(2, '0')}`; // Modified to MM-DD
                                }, priority: 1 }, // Lower priority than full dates
                                // NEW: Day Month (no year)
                                { name: 'DayMonthNoYear', regex: regexDayMonthNoYear, handler: (match) => {
                                    const [, day, month] = match;
                                    const monthNum = getMonthNumber(month);
                                    if (!monthNum || parseInt(day) < 1 || parseInt(day) > 31) return null;
                                    return `${monthNum}-${String(day).padStart(2, '0')}`; // Modified to MM-DD
                                }, priority: 1 } // Lower priority than full dates
                            ];

                            patternsToTest.forEach(pattern => {
                                let localRegex = new RegExp(pattern.regex.source, pattern.regex.flags);
                                // Ensure 'g' flag is always present for iterative matching
                                if (!localRegex.flags.includes('g')) {
                                    localRegex = new RegExp(localRegex.source, localRegex.flags + 'g');
                                }

                                let match;
                                while ((match = localRegex.exec(currentText)) !== null) {
                                    const datetimeValue = pattern.handler(match);
                                    if (datetimeValue) {
                                        allMatches.push({
                                            start: match.index,
                                            end: match.index + match[0].length,
                                            original: match[0],
                                            datetime: datetimeValue,
                                            priority: pattern.priority
                                        });
                                    }
                                }
                            });

                            // Sort by start position, then by priority (descending)
                            allMatches.sort((a, b) => {
                                if (a.start !== b.start) {
                                    return a.start - b.start;
                                }
                                return b.priority - a.priority; // Higher priority first for overlapping matches
                            });

                            let nonOverlappingMatches = [];
                            // Process the sorted matches to remove overlaps, prioritizing higher priority matches
                            if (allMatches.length > 0) {
                                nonOverlappingMatches.push(allMatches[0]);
                                for (let i = 1; i < allMatches.length; i++) {
                                    const currentMatch = allMatches[i];
                                    const lastAddedMatch = nonOverlappingMatches[nonOverlappingMatches.length - 1];

                                    // Check for overlap
                                    if (currentMatch.start >= lastAddedMatch.end) {
                                        // No overlap, add the current match
                                        nonOverlappingMatches.push(currentMatch);
                                    } else {
                                        // Overlap detected. Keep the higher priority match.
                                        // If priorities are equal, keep the longer match.
                                        if (currentMatch.priority > lastAddedMatch.priority ||
                                            (currentMatch.priority === lastAddedMatch.priority && currentMatch.original.length > lastAddedMatch.original.length)) {
                                            nonOverlappingMatches[nonOverlappingMatches.length - 1] = currentMatch;
                                        }
                                    }
                                }
                            }


                            if (nonOverlappingMatches.length > 0) {
                                let resultParts = [];
                                let currentIndex = 0;
                                nonOverlappingMatches.forEach(match => {
                                    resultParts.push(currentText.substring(currentIndex, match.start));
                                    // Add class="nowrap" here
                                    resultParts.push(`<time class="nowrap" datetime="${match.datetime}">${match.original}</time>`);
                                    currentIndex = match.end;
                                });
                                resultParts.push(currentText.substring(currentIndex));
                                const newHtmlContent = resultParts.join('');

                                const fragment = reParsedDoc.createRange().createContextualFragment(newHtmlContent);
                                if (textNode.parentNode) {
                                    textNode.parentNode.replaceChild(fragment, textNode);
                                }
                            }
                        });

                        let finalHtml = reParsedBody.innerHTML;
                        finalHtml = revertNBSPPlaceholders(finalHtml); // Revert placeholders

                        finalHtml = restoreDataAttributes(finalHtml); // Restore attributes (string replacement)
                        finalHtml = convertAllEntitiesToNumeric(finalHtml); // Re-encode after processing

                        monacoEditorInstance.setValue(finalHtml);

                        // Update button feedback
                        const originalText = timeTagsBtn.textContent;
                        timeTagsBtn.textContent = 'Tagged!';
                        timeTagsBtn.classList.add('bg-green-500', 'hover:bg-green-600');
                        timeTagsBtn.classList.remove('bg-zinc-700', 'hover:bg-zinc-600'); // Changed from bg-gray-700
                        timeTagsBtn.disabled = true; // Disable the button
                        timeTagsBtn.setAttribute('data-temp-active', 'true'); // Mark as active
                        updateAllInteractiveButtonStates(); // Update all buttons
                        setTimeout(() => {
                            timeTagsBtn.textContent = originalText;
                            timeTagsBtn.classList.remove('bg-green-500', 'hover:bg-green-600');
                            timeTagsBtn.classList.add('bg-zinc-700', 'hover:bg-zinc-600'); // Changed from bg-gray-700
                            timeTagsBtn.disabled = false; // Re-enable the button
                            timeTagsBtn.removeAttribute('data-temp-active'); // Unmark as active
                            updateAllInteractiveButtonStates(); // Update all buttons
                        }, 1500);
                    }
                });

            // Fix FN ID's button event listener
            fixFnIdsBtn.addEventListener('click', () => {
                if (monacoEditorInstance) {
                    let content = monacoEditorInstance.getValue();
                    // Do NOT decodeHtmlEntities here. Protect attributes directly from Monaco's value.
                    content = protectDataAttributes(content); // Protect attributes (string replacement)

                    content = applyNBSPPlaceholders(content); // Apply placeholders

                    const parser = new DOMParser();
                    const doc = parser.parseFromString(content, 'text/html');

                    // Map to store lists of <sup> elements for each baseId (e.g., 'fn1')
                    const baseIdToSupElements = new Map();

                    // First pass: Collect all <sup> elements with IDs ending in -rf
                    const supElements = doc.querySelectorAll('sup[id$="-rf"]');
                    supElements.forEach(sup => {
                        const originalId = sup.id;
                        const baseId = originalId.replace(/-rf$/, ''); // Get 'fn1' from 'fn1-rf'

                        if (!baseIdToSupElements.has(baseId)) {
                            baseIdToSupElements.set(baseId, []);
                        }
                        baseIdToSupElements.get(baseId).push(sup);
                    });

                    const idMapping = {}; // Map from original sup ID to the new canonical target ID for links

                    // Second pass: Rectify IDs and build the idMapping
                    for (const [baseId, supList] of baseIdToSupElements.entries()) {
                        let canonicalTargetId = supList[0].id; // Default to the first sup's original ID

                        if (supList.length > 1) {
                            // If duplicates exist, we'll assign new sequential IDs to sups
                            // and the canonical target for links will be the first one's new ID.
                            canonicalTargetId = `${baseId}-rf-0`; // The new ID for the first instance
                            supList.forEach((sup, index) => {
                                const newSupId = `${baseId}-rf-${index}`;
                                sup.id = newSupId; // Update the ID of the <sup> element
                            });
                        }
                        // Now, map all original sup IDs for this baseId to the determined canonicalTargetId
                        supList.forEach(sup => {
                            idMapping[sup.id] = canonicalTargetId; // This maps the *new* sup.id to the canonical target
                        });
                        // Need to also map the *original* IDs to the canonical target, as links might still point to them
                        // This handles cases where a link might point to 'fn1-rf' and we want it to go to 'fn1-rf-0'
                        if (supList.length > 1) {
                            idMapping[`${baseId}-rf`] = canonicalTargetId;
                        }
                    }

                    // Third pass: Update <a> tags with corresponding hrefs
                    const links = doc.querySelectorAll('a[href^="#"]');
                    links.forEach(link => {
                        let href = link.getAttribute('href');
                        const anchor = href.substring(1); // Remove the '#'

                        // If the anchor is in our mapping, update the href
                        if (idMapping.hasOwnProperty(anchor)) {
                            link.setAttribute('href', `#${idMapping[anchor]}`);
                        } else {
                            // If the anchor is an original ID that became canonical (e.g., 'fn1-rf' when no duplicates)
                            // and it's not explicitly in idMapping because it's not renamed, ensure it links to itself.
                            // This case is implicitly handled if targetIdForLinks was the original ID.
                        }
                    });

                    let finalHtml = doc.body.innerHTML;
                    finalHtml = revertNBSPPlaceholders(finalHtml); // Revert placeholders

                    finalHtml = restoreDataAttributes(finalHtml); // Restore attributes (string replacement)
                    finalHtml = convertAllEntitiesToNumeric(finalHtml); // Re-encode after processing

                    monacoEditorInstance.setValue(finalHtml); // Use monacoEditorInstance here

                    const originalText = fixFnIdsBtn.textContent;
                    fixFnIdsBtn.textContent = 'Fixed!';
                    fixFnIdsBtn.classList.add('bg-green-500', 'hover:bg-green-600');
                    fixFnIdsBtn.classList.remove('bg-zinc-700', 'hover:bg-zinc-600');
                    fixFnIdsBtn.disabled = true; // Disable the button
                    fixFnIdsBtn.setAttribute('data-temp-active', 'true'); // Mark as active
                    updateAllInteractiveButtonStates(); // Update all buttons
                    setTimeout(() => {
                        fixFnIdsBtn.textContent = originalText;
                        fixFnIdsBtn.classList.remove('bg-green-500', 'hover:bg-green-600');
                        fixFnIdsBtn.classList.add('bg-zinc-700', 'hover:bg-zinc-600');
                        fixFnIdsBtn.disabled = false;
                        fixFnIdsBtn.removeAttribute('data-temp-active'); // Unmark as active
                        updateAllInteractiveButtonStates(); // Update all buttons
                    }, 1500);
                }
            });


            // Clean MSO button event listener
            cleanMsoBtn.addEventListener('click', () => {
                if (monacoEditorInstance) {
                    let currentContent = monacoEditorInstance.getValue();
                    currentContent = protectDataAttributes(currentContent); // Protect attributes

                    // Apply Clean Mso Lists
                    currentContent = applyCleanLists(currentContent);
                    console.log("Clean MSO Lists applied.");
                    // Apply Clean Mso Tables
                    currentContent = applyCleanTablesBasic(currentContent);
                    console.log("Clean Mso Tables applied.");
                    // Apply Clean Mso Code (includes IMGs now)
                    currentContent = applyCleanMsoCode(currentContent);
                    console.log("Clean Mso Code (including IMGs) applied.");
                    // Apply URL cleaning
                    currentContent = applyUrlCleaning(currentContent);
                    console.log("Clean URLs applied.");
                    // Apply Clean Spaces
                    currentContent = applyAutoSpacing(currentContent);
                    console.log("Clean Spaces applied.");

                    currentContent = restoreDataAttributes(currentContent); // Restore attributes
                    currentContent = convertAllEntitiesToNumeric(currentContent); // Ensure entities are correct after all operations

                    monacoEditorInstance.setValue(currentContent);
                    htmlOutputContent = currentContent;
                    applyEntityHighlighting();

                    const originalText = cleanMsoBtn.textContent;
                    cleanMsoBtn.textContent = 'Cleaned!';
                    cleanMsoBtn.classList.add('bg-green-500', 'hover:bg-green-600');
                    cleanMsoBtn.classList.remove('bg-blue-700', 'hover:bg-blue-800');
                    cleanMsoBtn.disabled = true;
                    cleanMsoBtn.setAttribute('data-temp-active', 'true');
                    updateAllInteractiveButtonStates(); // Update all buttons
                    setTimeout(() => {
                        cleanMsoBtn.textContent = originalText;
                        cleanMsoBtn.classList.remove('bg-green-500', 'hover:bg-green-600');
                        cleanMsoBtn.classList.add('bg-blue-700', 'hover:bg-blue-800');
                        cleanMsoBtn.disabled = false;
                        cleanMsoBtn.removeAttribute('data-temp-active');
                        updateAllInteractiveButtonStates(); // Update all buttons
                    }, 1500);
                }
            });

            // Clean URLs button event listener
            cleanUrlsBtn.addEventListener('click', () => {
                if (monacoEditorInstance) {
                    let currentContent = monacoEditorInstance.getValue();
                    currentContent = protectDataAttributes(currentContent);
                    currentContent = applyUrlCleaning(currentContent);
                    currentContent = restoreDataAttributes(currentContent);
                    currentContent = convertAllEntitiesToNumeric(currentContent);
                    monacoEditorInstance.setValue(currentContent);
                    htmlOutputContent = currentContent;
                    applyEntityHighlighting();

                    const originalText = cleanUrlsBtn.textContent;
                    cleanUrlsBtn.textContent = 'Cleaned!';
                    cleanUrlsBtn.classList.add('bg-green-500', 'hover:bg-green-600');
                    cleanUrlsBtn.classList.remove('bg-zinc-700', 'hover:bg-zinc-600');
                    cleanUrlsBtn.disabled = true;
                    cleanUrlsBtn.setAttribute('data-temp-active', 'true');
                    updateAllInteractiveButtonStates(); // Update all buttons
                    setTimeout(() => {
                        cleanUrlsBtn.textContent = originalText;
                        cleanUrlsBtn.classList.remove('bg-green-500', 'hover:bg-green-600');
                        cleanUrlsBtn.classList.add('bg-zinc-700', 'hover:bg-zinc-600');
                        cleanUrlsBtn.disabled = false;
                        cleanUrlsBtn.removeAttribute('data-temp-active');
                        updateAllInteractiveButtonStates();
                    }, 1500);
                }
            });

            // Clean Spaces button event listener
            cleanSpacesBtn.addEventListener('click', () => {
                if (monacoEditorInstance) {
                    let currentContent = monacoEditorInstance.getValue();
                    currentContent = protectDataAttributes(currentContent);
                    currentContent = applyNBSPPlaceholders(currentContent); // Apply placeholders before spacing cleanup
                    currentContent = applyAutoSpacing(currentContent);
                    currentContent = revertNBSPPlaceholders(currentContent); // Revert placeholders after spacing cleanup
                    currentContent = restoreDataAttributes(currentContent);
                    currentContent = convertAllEntitiesToNumeric(currentContent);
                    monacoEditorInstance.setValue(currentContent);
                    htmlOutputContent = currentContent;
                    applyEntityHighlighting();

                    const originalText = cleanSpacesBtn.textContent;
                    cleanSpacesBtn.textContent = 'Cleaned!';
                    cleanSpacesBtn.classList.add('bg-green-500', 'hover:bg-green-600');
                    cleanSpacesBtn.classList.remove('bg-zinc-700', 'hover:bg-zinc-600');
                    cleanSpacesBtn.disabled = true;
                    cleanSpacesBtn.setAttribute('data-temp-active', 'true');
                    updateAllInteractiveButtonStates(); // Update all buttons
                    setTimeout(() => {
                        cleanSpacesBtn.textContent = originalText;
                        cleanSpacesBtn.classList.remove('bg-green-500', 'hover:bg-green-600');
                        cleanSpacesBtn.classList.add('bg-zinc-700', 'hover:bg-zinc-600');
                        cleanSpacesBtn.disabled = false;
                        cleanSpacesBtn.removeAttribute('data-temp-active');
                        updateAllInteractiveButtonStates();
                    }, 1500);
                }
            });

            // Clean Single Breaks button event listener
            cleanSingleBreaksBtn.addEventListener('click', () => {
                if (monacoEditorInstance) {
                    let currentContent = monacoEditorInstance.getValue();
                    currentContent = protectDataAttributes(currentContent);
                    currentContent = applyNBSPPlaceholders(currentContent); // Apply placeholders before break cleanup
                    currentContent = applyCleanSingleBreaks(currentContent);
                    currentContent = revertNBSPPlaceholders(currentContent); // Revert placeholders after break cleanup
                    currentContent = restoreDataAttributes(currentContent);
                    currentContent = convertAllEntitiesToNumeric(currentContent);
                    monacoEditorInstance.setValue(currentContent);
                    htmlOutputContent = currentContent;
                    applyEntityHighlighting();

                    const originalText = cleanSingleBreaksBtn.textContent;
                    cleanSingleBreaksBtn.textContent = 'Cleaned!';
                    cleanSingleBreaksBtn.classList.add('bg-green-500', 'hover:bg-green-600');
                    cleanSingleBreaksBtn.classList.remove('bg-zinc-700', 'hover:bg-zinc-600');
                    cleanSingleBreaksBtn.disabled = true;
                    cleanSingleBreaksBtn.setAttribute('data-temp-active', 'true');
                    updateAllInteractiveButtonStates(); // Update all buttons
                    setTimeout(() => {
                        cleanSingleBreaksBtn.textContent = originalText;
                        cleanSingleBreaksBtn.classList.remove('bg-green-500', 'hover:bg-green-600');
                        cleanSingleBreaksBtn.classList.add('bg-zinc-700', 'hover:bg-zinc-600');
                        cleanSingleBreaksBtn.disabled = false;
                        cleanSingleBreaksBtn.removeAttribute('data-temp-active');
                        updateAllInteractiveButtonStates();
                    }, 1500);
                }
            });

            // Clean Formatting Tags button event listener
            cleanFormattingTagsBtn.addEventListener('click', () => {
                if (monacoEditorInstance) {
                    let currentContent = monacoEditorInstance.getValue();
                    currentContent = protectDataAttributes(currentContent);
                    currentContent = applyCleanFormattingTags(currentContent);
                    currentContent = restoreDataAttributes(currentContent);
                    currentContent = convertAllEntitiesToNumeric(currentContent);
                    monacoEditorInstance.setValue(currentContent);
                    htmlOutputContent = currentContent;
                    applyEntityHighlighting();

                    const originalText = cleanFormattingTagsBtn.textContent;
                    cleanFormattingTagsBtn.textContent = 'Cleaned!';
                    cleanFormattingTagsBtn.classList.add('bg-green-500', 'hover:bg-green-600');
                    cleanFormattingTagsBtn.classList.remove('bg-zinc-700', 'hover:bg-zinc-600');
                    cleanFormattingTagsBtn.disabled = true;
                    cleanFormattingTagsBtn.setAttribute('data-temp-active', 'true');
                    updateAllInteractiveButtonStates(); // Update all buttons
                    setTimeout(() => {
                        cleanFormattingTagsBtn.textContent = originalText;
                        cleanFormattingTagsBtn.classList.remove('bg-green-500', 'hover:bg-green-600');
                        cleanFormattingTagsBtn.classList.add('bg-zinc-700', 'hover:bg-zinc-600');
                        cleanFormattingTagsBtn.disabled = false;
                        cleanFormattingTagsBtn.removeAttribute('data-temp-active');
                        updateAllInteractiveButtonStates();
                    }, 1500);
                }
            });

            // Auto-Level Headings button event listener
            autoLevelHeadingsBtn.addEventListener('click', () => {
                if (monacoEditorInstance) {
                    let currentContent = monacoEditorInstance.getValue();
                    currentContent = protectDataAttributes(currentContent);
                    currentContent = applyAutoLevelHeadings(currentContent);
                    currentContent = restoreDataAttributes(currentContent);
                    currentContent = convertAllEntitiesToNumeric(currentContent);
                    monacoEditorInstance.setValue(currentContent);
                    htmlOutputContent = currentContent;
                    applyEntityHighlighting();
                    autoFormatBtn.click(); // Call Auto-Indent at the end

                    const originalText = autoLevelHeadingsBtn.textContent;
                    autoLevelHeadingsBtn.textContent = 'Leveled!';
                    autoLevelHeadingsBtn.classList.add('bg-green-500', 'hover:bg-green-600');
                    autoLevelHeadingsBtn.classList.remove('bg-zinc-700', 'hover:bg-zinc-600');
                    autoLevelHeadingsBtn.disabled = true;
                    autoLevelHeadingsBtn.setAttribute('data-temp-active', 'true');
                    updateAllInteractiveButtonStates(); // Update all buttons
                    setTimeout(() => {
                        autoLevelHeadingsBtn.textContent = originalText;
                        autoLevelHeadingsBtn.classList.remove('bg-green-500', 'hover:bg-green-600');
                        autoLevelHeadingsBtn.classList.add('bg-zinc-700', 'hover:bg-zinc-600');
                        autoLevelHeadingsBtn.disabled = false;
                        autoLevelHeadingsBtn.removeAttribute('data-temp-active');
                        updateAllInteractiveButtonStates();
                    }, 1500);
                }
            });

            // Auto-Section button event listener
            autoSectionBtn.addEventListener('click', () => {
                if (monacoEditorInstance) {
                    let currentContent = monacoEditorInstance.getValue();
                    currentContent = protectDataAttributes(currentContent);
                    currentContent = applyAutoSectioning(currentContent);
                    currentContent = restoreDataAttributes(currentContent);
                    currentContent = convertAllEntitiesToNumeric(currentContent);
                    monacoEditorInstance.setValue(currentContent);
                    htmlOutputContent = currentContent;
                    applyEntityHighlighting();
                    autoFormatBtn.click(); // Call Auto-Indent at the end

                    const originalText = autoSectionBtn.textContent;
                    autoSectionBtn.textContent = 'Sectioned!';
                    autoSectionBtn.classList.add('bg-green-500', 'hover:bg-green-600');
                    autoSectionBtn.classList.remove('bg-zinc-700', 'hover:bg-zinc-600');
                    autoSectionBtn.disabled = true;
                    autoSectionBtn.setAttribute('data-temp-active', 'true');
                    updateAllInteractiveButtonStates(); // Update all buttons
                    setTimeout(() => {
                        autoSectionBtn.textContent = originalText;
                        autoSectionBtn.classList.remove('bg-green-500', 'hover:bg-green-600');
                        autoSectionBtn.classList.add('bg-zinc-700', 'hover:bg-zinc-600');
                        autoSectionBtn.disabled = false;
                        autoSectionBtn.removeAttribute('data-temp-active');
                        updateAllInteractiveButtonStates();
                    }, 1500);
                }
            });

            // Auto-ID button event listener
            autoIdBtn.addEventListener('click', () => {
                const originalText = autoIdBtn.textContent;
                autoIdBtn.textContent = 'Opening...';
                autoIdBtn.classList.add('bg-green-500', 'hover:bg-green-600');
                autoIdBtn.classList.remove('bg-zinc-700', 'hover:bg-zinc-600');
                autoIdBtn.setAttribute('data-temp-active', 'true'); // Set the flag
                updateAllInteractiveButtonStates(); // Disable all buttons
                showAutoIdModal(autoIdBtn, originalText); // Pass original text to the modal
            });

            // Colophon button event listener
            colophonBtn.addEventListener('click', () => {
                const originalText = colophonBtn.textContent;
                colophonBtn.textContent = 'Opening...';
                colophonBtn.classList.add('bg-green-500', 'hover:bg-green-600');
                colophonBtn.classList.remove('bg-zinc-700', 'hover:bg-zinc-600');
                colophonBtn.setAttribute('data-temp-active', 'true'); // Set the flag
                updateAllInteractiveButtonStates(); // Disable all buttons

                const colophonHtmlContent = `
                    <div class="flex flex-col space-y-4">
                        <div>
                            <span class="text-sm font-medium text-gray-200 mr-2">Language:</span>
                            <div class="button-group inline-flex">
                                <button id="langEnglishBtn" class="px-3 py-1 text-sm bg-gray-700 text-white rounded-md hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-opacity-50 font-bold">English</button>
                                <button id="langFrenchBtn" class="px-3 py-1 text-sm bg-gray-700 text-white rounded-md hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-opacity-50 font-bold">French</button>
                            </div>
                        </div>
                        <div>
                            <span class="text-sm font-medium text-gray-200 mr-2">Monarch:</span>
                            <div class="button-group inline-flex">
                                <button id="monarchKingBtn" class="px-3 py-1 text-sm bg-gray-700 text-white rounded-md hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-opacity-50 font-bold">King</button>
                                <button id="monarchQueenBtn" class="px-3 py-1 text-sm bg-gray-700 text-white rounded-md hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-opacity-50 font-bold">Queen</button>
                            </div>
                        </div>
                        <div>
                            <span class="text-sm font-medium text-gray-200 mr-2">Identifier:</span>
                            <div class="button-group inline-flex">
                                <button id="idISBNBtn" class="px-3 py-1 text-sm bg-gray-700 text-white rounded-md hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-opacity-50 font-bold">ISBN</button>
                                <button id="idISSNBtn" class="px-3 py-1 text-sm bg-gray-700 text-white rounded-md hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-opacity-50 font-bold">ISSN</button>
                            </div>
                        </div>
                        <div>
                            <label for="colophonYear" class="block text-sm font-medium text-gray-200">Year (optional):</label>
                            <input type="number" id="colophonYear" class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500" placeholder="${new Date().getFullYear()}" min="1900" max="2100">
                        </div>
                        <div>
                            <label for="colophonNumber" class="block text-sm font-medium text-gray-200">Number (optional, e.g., for ISBN/ISSN):</label>
                            <input type="text" id="colophonNumber" class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500" placeholder="###-##-####-#" pattern="[0-9X-]*">
                        </div>
                    </div>
                `;
                showModal('Insert Colophon', colophonHtmlContent, colophonBtn, originalText); // Pass original text
            });

            // New: Footnote List button event listener
            footnoteListBtn.addEventListener('click', () => {
                const originalText = footnoteListBtn.textContent;
                footnoteListBtn.textContent = 'Opening...';
                footnoteListBtn.classList.add('bg-green-500', 'hover:bg-green-600');
                footnoteListBtn.classList.remove('bg-zinc-700', 'hover:bg-zinc-600');
                footnoteListBtn.setAttribute('data-temp-active', 'true'); // Set the flag
                updateAllInteractiveButtonStates(); // Disable all buttons
                showFootnoteModal(footnoteListBtn, originalText); // Pass original text
            });


            // Initial call to set the state of the Clean Mso button on load
            updateCleanMsoButtonState();
        };
    </script>
</body>
</html>
