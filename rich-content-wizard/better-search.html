<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Monaco Editor with Find & Replace</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a202c;
        }
        #editor-container {
            border: 1px solid #4a5568;
            border-radius: 0.5rem;
            overflow: hidden;
        }
        /* Modal Styles */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .modal-content {
            background-color: #2d3748; /* bg-gray-800 */
            padding: 2rem;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            max-width: 80%;
            max-height: 80%;
            overflow-y: auto;
            color: white;
            position: relative;
        }
        .modal-close-button {
            position: absolute;
            top: 1rem;
            right: 1rem;
            background: none;
            border: none;
            font-size: 1.5rem;
            color: #cbd5e0; /* text-gray-400 */
            cursor: pointer;
        }
        .message-box {
            position: fixed;
            top: 1rem;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            padding: 1rem 2rem;
            font-weight: bold;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            animation: fadeInOut 4s ease-in-out forwards;
            color: white;
            background-color: #38a169; /* Default to green for success */
        }
        .message-box.error {
            background-color: #f56565; /* Red for errors */
        }
        @keyframes fadeInOut {
            0% { opacity: 0; transform: translateX(-50%) scale(0.9); }
            10% { opacity: 1; transform: translateX(-50%) scale(1); }
            90% { opacity: 1; transform: translateX(-50%) scale(1); }
            100% { opacity: 0; transform: translateX(-50%) scale(0.9); }
        }
        /* Custom class for highlighting a single match when "Highlight all" is off */
        .find-highlight {
            background-color: rgba(255, 255, 0, 0.6);
            color: #000000 !important;
        }
        /* Custom class for highlighting all matches in magenta */
        .highlight-all-magenta {
            background-color: rgba(255, 0, 255, 0.5);
            color: #ffffff !important;
        }
        /* Custom class for highlighting the CURRENT match when "Highlight all" is ON */
        .find-current-match-highlight {
            box-shadow: 0 0 0 2px #f97316; /* Bright orange outline */
            background-color: rgba(255, 165, 0, 0.8); /* More opaque orange background */
            z-index: 10; /* Higher z-index for layering, though Monaco handles layering */
        }
        /* Custom class for highlighting the entire ID tag block with a subtle border */
        .id-highlight {
            border: 1px solid rgba(74, 144, 226, 0.5); /* Muted blue border */
            border-radius: 4px;
        }
        /* New CSS for Regex active border */
        .regex-active-border {
            border: 2px solid #3498db; /* A distinct blue color */
        }
    </style>
    <!-- Monaco Editor CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.27.0/min/vs/loader.min.js"></script>
</head>
<body class="p-4 flex flex-col items-center">

    <!-- Regex Guide Modal -->
    <div id="regex-guide-modal" class="modal hidden">
        <div class="modal-content">
            <button class="modal-close-button" id="close-regex-guide">&times;</button>
            <h2 class="text-2xl font-bold mb-4">Regular Expression (Regex) Guide</h2>
            <p class="mb-4">Regular expressions are patterns used to match character combinations in strings. Here are some common metacharacters:</p>
            <ul class="list-disc list-inside space-y-2">
                <li><code class="font-bold">.</code> : Matches any single character (except newline).</li>
                <li><code class="font-bold">\d</code> : Matches any digit (0-9).</li>
                <li><code class="font-bold">\D</code> : Matches any non-digit character.</li>
                <li><code class="font-bold">\w</code> : Matches any word character (alphanumeric and underscore).</li>
                <li><code class="font-bold">\W</code> : Matches any non-word character.</li>
                <li><code class="font-bold">\s</code> : Matches any whitespace character (space, tab, newline).</li>
                <li><code class="font-bold">\S</code> : Matches any non-whitespace character.</li>
                <li><code class="font-bold">\b</code> : Matches a word boundary.</li>
                <li><code class="font-bold">\B</code> : Matches a non-word boundary.</li>
                <li><code class="font-bold">^</code> : Matches the beginning of the string.</li>
                <li><code class="font-bold">$</code> : Matches the end of the string.</li>
                <li><code class="font-bold">*</code> : Matches the previous character zero or more times.</li>
                <li><code class="font-bold">+</code> : Matches the previous character one or more times.</li>
                <li><code class="font-bold">?</code> : Matches the previous character zero or one time (also for non-greedy matching).</li>
                <li><code class="font-bold">{n}</code> : Matches the previous character exactly 'n' times.</li>
                <li><code class="font-bold">{n,}</code> : Matches the previous character 'n' or more times.</li>
                <li><code class="font-bold">{n,m}</code> : Matches the previous character between 'n' and 'm' times.</li>
                <li><code class="font-bold">[abc]</code> : Matches any one of the characters inside the brackets.</li>
                <li><code class="font-bold">[^abc]</code> : Matches any character NOT inside the brackets.</li>
                <li><code class="font-bold">(x|y)</code> : Matches either 'x' or 'y'.</li>
                <li><code class="font-bold">(...)</code> : Capturing group.</li>
                <li><code class="font-bold">\n</code> : Backreference to the n-th capturing group.</li>
                <li><code class="font-bold">|</code> : OR operator.</li>
                <li><code class="font-bold">\\</code> : Escapes a special character (e.g., `\.` to match a literal dot).</li>
            </ul>
        </div>
    </div>

    <!-- Controls for Find & Replace -->
    <div class="w-full max-w-4xl p-4 mb-4 bg-gray-800 rounded-lg shadow-lg flex flex-col space-y-4">
        <!-- Dropdowns and Checkboxes -->
        <div class="flex flex-wrap items-center space-x-4">
            <!-- ID Dropdown -->
            <select
                id="target-id-dropdown"
                class="w-32 p-3 rounded-md bg-gray-900 text-white font-mono focus:outline-none focus:ring-2 focus:ring-blue-500 transition duration-200"
            >
                <option value="all">All ID's</option>
            </select>
            <!-- Tag Dropdown -->
            <select
                id="target-tag-dropdown"
                class="w-32 p-3 rounded-md bg-gray-900 text-white font-mono focus:outline-none focus:ring-2 focus:ring-blue-500 transition duration-200"
            >
                <option value="all">All Tags</option>
            </select>
            <!-- Checkbox Options moved to the right of the dropdowns -->
            <div class="flex items-center space-x-4 text-white ml-auto">
                <!-- REGEX Checkbox -->
                <label for="enable-regex" class="flex items-center space-x-2">
                    <input type="checkbox" id="enable-regex" class="form-checkbox h-5 w-5 text-blue-600 rounded">
                    <span>REGEX</span>
                </label>
                <!-- Match Case Checkbox -->
                <label for="match-case" class="flex items-center space-x-2">
                    <input type="checkbox" id="match-case" class="form-checkbox h-5 w-5 text-blue-600 rounded">
                    <span>Match case</span>
                </label>
                <!-- Highlight all Checkbox -->
                <label for="highlight-all" class="flex items-center space-x-2">
                    <input type="checkbox" id="highlight-all" class="form-checkbox h-5 w-5 text-blue-600 rounded">
                    <span>Highlight all</span>
                </label>
                
            </div>
        </div>
        
        <!-- Sequencing Options -->
        <div
            id="sequence-container"
            class="flex flex-wrap items-center space-x-4 text-white overflow-hidden max-h-40 opacity-100 transition-all duration-300 ease-in-out"
        >
            <!-- Sequence Checkbox -->
            <label for="sequence" class="flex items-center space-x-2">
                <input type="checkbox" id="sequence" class="form-checkbox h-5 w-5 text-blue-600 rounded">
                <span>Sequence <span class="text-gray-300 text-sm">(To use: Insert <strong><code>{$#+}</code></strong> OR <strong><code>{$#-}</code></strong> in replace field)</span></span>
            </label>
            <!-- Range Inputs -->
            <div id="sequence-range-container" class="flex items-center space-x-2 flex-grow justify-end opacity-0 pointer-events-none transition-opacity duration-300 ease-in-out">
                <label for="start-index">Start:</label>
                <input
                    type="number"
                    id="start-index"
                    value="1"
                    class="w-20 p-2 rounded-md bg-gray-900 text-white font-mono focus:outline-none focus:ring-2 focus:ring-blue-500"
                >
                <label for="end-index">End:</label>
                <input
                    type="number"
                    id="end-index"
                    placeholder="all"
                    class="w-20 p-2 rounded-md bg-gray-900 text-white font-mono placeholder-gray-500 focus:outline-none focus:ring-2 focus:ring-blue-500"
                >
            </div>
        </div>

        <!-- Inputs and Buttons are now in separate rows -->
        <div class="flex flex-col space-y-4">
            <!-- Find/Replace Inputs -->
            <div class="flex flex-col md:flex-row items-center space-y-4 md:space-y-0 md:space-x-4">
                <input
                    id="find-input"
                    type="text"
                    placeholder="Find"
                    class="w-full flex-1 p-3 rounded-md bg-gray-900 text-white font-mono placeholder-gray-500 focus:outline-none focus:ring-2 focus:ring-blue-500 transition duration-200"
                >
                <input
                    id="replace-input"
                    type="text"
                    placeholder="Replace"
                    class="w-full flex-1 p-3 rounded-md bg-gray-900 text-white font-mono placeholder-gray-500 focus:outline-none focus:ring-2 focus:ring-blue-500 transition duration-200"
                >
            </div>
            <!-- Action Buttons -->
            <div class="flex flex-wrap justify-between items-center space-x-2">
                <div class="flex items-center space-x-2">
                    <button
                        id="find-next-button"
                        class="px-3 py-1 text-sm bg-blue-600 text-white rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50 font-bold"
                    >
                        Next &#x2193;
                    </button>
                    <button
                        id="find-previous-button"
                        class="px-3 py-1 text-sm bg-blue-600 text-white rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50 font-bold"
                    >
                        &#x2191; Previous
                    </button>
                    <!-- REGEX Guide Button moved here -->
                    <button
                        id="regex-guide-button"
                        class="px-3 py-1 text-sm bg-gray-600 text-white rounded-md hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-opacity-50 font-bold"
                    >
                        Regex Guide
                    </button>
                </div>
                <div class="flex items-center space-x-2">
                    <button
                        id="replace-one-button"
                        class="px-3 py-1 text-sm bg-blue-600 text-white rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50 font-bold"
                    >
                        Replace
                    </button>
                    <button
                        id="replace-all-button"
                        class="px-3 py-1 text-sm bg-blue-600 text-white rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50 font-bold"
                    >
                        Replace All
                    </button>
                </div>
            </div>
            <!-- Match Count / Status Message -->
            <div class="w-full text-center mt-2">
                <span id="match-count" class="text-white text-sm">Type something...</span>
            </div>
        </div>
    </div>

    <!-- Monaco Editor Container -->
    <div id="editor-container" class="w-full max-w-4xl h-[60vh] bg-gray-900 rounded-lg shadow-lg"></div>

    <script>
        // Use require.js to load the Monaco Editor
        require.config({ paths: { 'vs': 'https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.27.0/min/vs' }});

        // Custom message box function (kept for potential future debugging, but not called in UI)
        function showMessageBox(message, isError = false) {
            const msgBox = document.getElementById('message-box');
            msgBox.textContent = message;
            msgBox.classList.remove('hidden');
            if (isError) {
                msgBox.classList.add('error');
            } else {
                msgBox.classList.remove('error');
            }
            setTimeout(() => {
                msgBox.classList.add('hidden');
            }, 3000); // Hide after 3 seconds
        }
        
        // Helper function to escape a string for use in a regular expression
        function escapeRegExp(string) {
            return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'); // $& means the whole matched string
        }

        // Initialize Monaco when the loader is ready
        require(['vs/editor/editor.main'], function() {
            // Get references to the DOM elements
            const editorContainer = document.getElementById('editor-container');
            const findInput = document.getElementById('find-input');
            const replaceInput = document.getElementById('replace-input');
            const findNextButton = document.getElementById('find-next-button');
            const findPreviousButton = document.getElementById('find-previous-button');
            const replaceOneButton = document.getElementById('replace-one-button');
            const replaceAllButton = document.getElementById('replace-all-button');
            const tagDropdown = document.getElementById('target-tag-dropdown');
            const idDropdown = document.getElementById('target-id-dropdown');
            const enableRegexCheckbox = document.getElementById('enable-regex');
            const matchCaseCheckbox = document.getElementById('match-case');
            const highlightAllCheckbox = document.getElementById('highlight-all');
            const sequenceCheckbox = document.getElementById('sequence');
            const sequenceContainer = document.getElementById('sequence-container');
            const sequenceRangeContainer = document.getElementById('sequence-range-container');
            const startIndexInput = document.getElementById('start-index');
            const endIndexInput = document.getElementById('end-index');
            const matchCountSpan = document.getElementById('match-count'); // New element for count
            const regexGuideButton = document.getElementById('regex-guide-button'); // New button
            const regexGuideModal = document.getElementById('regex-guide-modal'); // New modal
            const closeRegexGuideButton = document.getElementById('close-regex-guide'); // New close button

            // Store the current decorations in a single array
            let allDecorations = [];
            let allMatches = [];
            let currentMatchIndex = -1;
            let currentFindText = '';
            let currentSelectedId = 'all';
            let currentSelectedTag = 'all';
            let currentIsRegex = false; // Changed default to false
            let currentMatchCase = false;
            
            // Create the editor instance with initial HTML content
            const editor = monaco.editor.create(editorContainer, {
                value: [
                    '<!DOCTYPE html>',
                    '<html lang="en">',
                    '<head>',
                    '    <title>Hello, World!</title>',
                    '</head>',
                    '<body>',
                    '    <ul id="my-list" class="my-list">',
                    '        <li class="item-5">Item One</li>',
                    '        <li class="item-4">Item Two</li>',
                    '        <li class="item-3">Item Three</li>',
                    '        <li class="item-2">Item Four</li>',
                    '        <li class="item-1">Item Five</li>',
                    '    </ul>',
                    '    <p id="description-1" class="description-1">This is a description 1.</p>',
                    '    <div id="another-list-container">',
                    '        <ul id="another-list">',
                    '            <li class="item-5">Item A</li>',
                    '            <li class="item-4">Item B</li>',
                    '            <li class="item-3">Item C</li>',
                    '        </ul>',
                    '    </div>',
                    '</body>',
                    '</html>'
                ].join('\n'),
                language: 'html', // Set language to HTML
                theme: 'vs-dark',
                automaticLayout: true,
                roundedSelection: true,
                scrollBeyondLastLine: false,
                readOnly: false,
                fontSize: 16,
            });

            /**
             * Populates the dropdown menu with unique HTML tags from the editor's content.
             * Preserves the currently selected tag if it still exists.
             */
            function populateTagDropdown() {
                const currentSelection = tagDropdown.value; // Store current selection
                const editorValue = editor.getValue();
                const tagRegex = /<(\w+)(?=\s|>)/g;
                const uniqueTags = new Set();
                let match;

                while ((match = tagRegex.exec(editorValue)) !== null) {
                    uniqueTags.add(match[1]);
                }

                tagDropdown.innerHTML = '';
                const defaultOption = document.createElement('option');
                defaultOption.value = 'all';
                defaultOption.textContent = 'All Tags';
                tagDropdown.appendChild(defaultOption);

                const sortedTags = [...uniqueTags].sort();

                sortedTags.forEach(tag => {
                    const option = document.createElement('option');
                    option.value = tag;
                    option.textContent = `<${tag}>`;
                    tagDropdown.appendChild(option);
                });

                // Restore previous selection if it's still a valid option
                if (Array.from(tagDropdown.options).some(option => option.value === currentSelection)) {
                    tagDropdown.value = currentSelection;
                } else {
                    tagDropdown.value = 'all'; // Fallback if old selection is gone
                }
            }
            
            /**
             * Populates the dropdown menu with unique HTML IDs from the editor's content.
             * Preserves the currently selected ID if it still exists.
             */
            function populateIdDropdown() {
                const currentSelection = idDropdown.value; // Store current selection
                const editorValue = editor.getValue();
                const idRegex = /id="([^"]+)"/g;
                const uniqueIds = [];
                const seenIds = new Set();

                let match;
                while ((match = idRegex.exec(editorValue)) !== null) {
                    const id = match[1];
                    if (!seenIds.has(id)) {
                        uniqueIds.push(id);
                        seenIds.add(id);
                    }
                }

                idDropdown.innerHTML = '';
                const defaultOption = document.createElement('option');
                defaultOption.value = 'all';
                defaultOption.textContent = 'All ID\'s';
                idDropdown.appendChild(defaultOption);

                uniqueIds.forEach(id => {
                    const option = document.createElement('option');
                    option.value = id;
                    option.textContent = `#${id}`;
                    idDropdown.appendChild(option);
                });

                // Restore previous selection if it's still a valid option
                if (Array.from(idDropdown.options).some(option => option.value === currentSelection)) {
                    idDropdown.value = currentSelection;
                } else {
                    idDropdown.value = 'all'; // Fallback if old selection is gone
                }
            }

            // Populate the dropdowns initially
            populateTagDropdown();
            populateIdDropdown();

            // Update the dropdowns whenever the editor content changes
            editor.onDidChangeModelContent(() => {
                populateTagDropdown();
                populateIdDropdown();
                // When model content changes, always force a reset to re-index matches
                resetSearchState(true);
            });
            
            // Function to handle the visibility of the sequence options container
            function toggleSequenceVisibility() {
                if (enableRegexCheckbox.checked) {
                    sequenceContainer.classList.remove('max-h-0', 'opacity-0', 'pointer-events-none');
                    sequenceContainer.classList.add('max-h-40', 'opacity-100');
                } else {
                    sequenceContainer.classList.remove('max-h-40', 'opacity-0', 'pointer-events-none');
                    sequenceContainer.classList.add('max-h-0', 'opacity-0', 'pointer-events-none');
                }
            }

            // Toggle visibility of the sequence range inputs based on the sequence checkbox
            sequenceCheckbox.addEventListener('change', () => {
                if (sequenceCheckbox.checked) {
                    sequenceRangeContainer.classList.remove('opacity-0', 'pointer-events-none');
                } else {
                    sequenceRangeContainer.classList.add('opacity-0', 'pointer-events-none');
                }
            });

            // Function to toggle the regex active border
            function toggleRegexBorder() {
                if (enableRegexCheckbox.checked) {
                    findInput.classList.add('regex-active-border');
                    replaceInput.classList.add('regex-active-border');
                } else {
                    findInput.classList.remove('regex-active-border');
                    replaceInput.classList.remove('regex-active-border');
                }
            }

            // Toggle visibility of the entire sequence container based on the regex checkbox
            enableRegexCheckbox.addEventListener('change', () => {
                toggleSequenceVisibility();
                toggleRegexBorder(); // Call the new function
                resetSearchState(true); // Also reset search state
            });
            
            // Initial check for sequence container visibility and regex border
            toggleSequenceVisibility();
            toggleRegexBorder(); // Call on initial load

            /**
             * Generates a context string based on selected ID and Tag.
             * @returns {string} The context string (e.g., "in selected #my-id only").
             */
            function getContextString() {
                const selectedId = idDropdown.value;
                const selectedTag = tagDropdown.value;
                let contextText = '';

                if (selectedId !== 'all' && selectedTag !== 'all') {
                    contextText = ` in selected <span class="text-blue-400 font-bold">#${selectedId}</span> and <span class="text-purple-400 font-bold">&lt;${selectedTag}&gt;</span> tags only`;
                } else if (selectedId !== 'all') {
                    contextText = ` in selected <span class="text-blue-400 font-bold">#${selectedId}</span> only`;
                } else if (selectedTag !== 'all') {
                    contextText = ` in selected <span class="text-purple-400 font-bold">&lt;${selectedTag}&gt;</span> tags only`;
                }
                return contextText;
            }


            /**
             * Finds and returns a list of all matches based on the current search criteria.
             * @returns {monaco.editor.FindMatch[]} An array of found matches.
             */
            function findMatches() {
                const findText = findInput.value;
                if (!findText) return [];

                const selectedId = idDropdown.value;
                const selectedTag = tagDropdown.value;
                const isRegex = enableRegexCheckbox.checked;
                const matchCase = matchCaseCheckbox.checked;
                const isCaseSensitive = matchCase;
                const model = editor.getModel();
                const editorValue = model.getValue();
                let matches = [];
                let searchScopeRange = null;

                // 1. Determine the overall search scope based on selected ID
                if (selectedId !== 'all') {
                    const idRegex = new RegExp(`<([a-z]+)[^>]*id="${selectedId}"[^>]*>[\\s\\S]*?<\\/\\1>`, 'i');
                    const idMatch = idRegex.exec(editorValue);
                    if (idMatch) {
                        const startPos = model.getPositionAt(idMatch.index);
                        const endPos = model.getPositionAt(idMatch.index + idMatch[0].length);
                        searchScopeRange = new monaco.Range(startPos.lineNumber, startPos.column, endPos.lineNumber, endPos.column);
                    } else {
                        return []; // No ID found, no matches possible
                    }
                }

                // 2. If a tag is selected, refine the search within those tags
                if (selectedTag !== 'all') {
                    const contentToSearch = searchScopeRange ? model.getValueInRange(searchScopeRange) : editorValue;
                    const tagRegex = new RegExp(`<${selectedTag}([^>]*)>([\\s\\S]*?)</${selectedTag}>`, 'g' + (isCaseSensitive ? '' : 'i'));
                    
                    let match;
                    while ((match = tagRegex.exec(contentToSearch)) !== null) {
                        const startIndexInContent = match.index;
                        const absoluteStartOffset = (searchScopeRange ? model.getOffsetAt(new monaco.Position(searchScopeRange.startLineNumber, searchScopeRange.startColumn)) : 0) + startIndexInContent;
                        
                        let rangeToSearch;
                        // Always search the entire tag block (including attributes and tag names)
                        const startPos = model.getPositionAt(absoluteStartOffset);
                        const endPos = model.getPositionAt(absoluteStartOffset + match[0].length);
                        rangeToSearch = new monaco.Range(startPos.lineNumber, startPos.column, endPos.lineNumber, endPos.column);
                        
                        const findMatchesInTag = model.findMatches(findText, rangeToSearch, isRegex, isCaseSensitive, null, true);
                        matches.push(...findMatchesInTag);
                    }
                } else {
                    // Search in the full range (either ID scope or whole document)
                    matches = model.findMatches(findText, searchScopeRange, isRegex, isCaseSensitive, null, true);
                }

                return matches;
            }

            /**
             * Updates all decorations (ID highlight and find matches) based on the current state.
             */
            function updateDecorations() {
                const newDecorations = [];
                const selectedId = idDropdown.value;
                const editorValue = editor.getModel().getValue();

                // Add ID highlight if an ID is selected
                if (selectedId !== 'all') {
                    const idRegex = new RegExp(`<([a-z]+)[^>]*id="${selectedId}"[^>]*>[\\s\\S]*?<\\/\\1>`, 'i');
                    const idMatch = idRegex.exec(editorValue);
                    if (idMatch) {
                        const startPos = editor.getModel().getPositionAt(idMatch.index);
                        const endPos = editor.getModel().getPositionAt(idMatch.index + idMatch[0].length);
                        newDecorations.push({
                            range: new monaco.Range(startPos.lineNumber, startPos.column, endPos.lineNumber, endPos.column),
                            options: { inlineClassName: 'id-highlight' }
                        });
                    }
                }
                
                // Removed tag highlighting logic as per user request.

                // Add find highlights based on the 'Highlight all' checkbox and current match index
                if (allMatches.length > 0) {
                    if (highlightAllCheckbox.checked) {
                        // Highlight all matches in magenta
                        allMatches.forEach(match => {
                            newDecorations.push({
                                range: match.range,
                                options: { inlineClassName: 'highlight-all-magenta' }
                            });
                        });
                        // Then, add a more specific decoration for the current match
                        if (currentMatchIndex !== -1) {
                            newDecorations.push({
                                range: allMatches[currentMatchIndex].range,
                                options: { inlineClassName: 'find-current-match-highlight' }
                            });
                        }
                    } else if (currentMatchIndex !== -1) {
                        // Highlight only the current match in yellow
                        newDecorations.push({
                            range: allMatches[currentMatchIndex].range,
                            options: { inlineClassName: 'find-highlight' }
                        });
                    }

                    // For "Find Next" and "Find Previous" buttons, scroll to and show a message for the current match.
                    if (currentMatchIndex !== -1) {
                         editor.revealRangeInCenterIfOutsideViewport(allMatches[currentMatchIndex].range, 0);
                         const position = allMatches[currentMatchIndex].range.getStartPosition();
                         editor.setPosition(position);
                         
                         matchCountSpan.innerHTML = `${currentMatchIndex + 1} of ${allMatches.length}${getContextString()}`;
                    }
                } else {
                    const matchCase = matchCaseCheckbox.checked;
                    let statusMessage = "No matches";
                    let optionsDescription = [];

                    if (findInput.value === '') {
                        matchCountSpan.innerHTML = "Type something...";
                        allDecorations = editor.deltaDecorations(allDecorations, newDecorations);
                        return;
                    }

                    if (matchCase) {
                        optionsDescription.push("case-sensitive");
                    }
                    
                    if (optionsDescription.length > 0) {
                        statusMessage = `No ${optionsDescription.join(' ')} matches`;
                    }
                    matchCountSpan.innerHTML = `${statusMessage}${getContextString()}`;
                }

                // Apply all decorations in one go
                allDecorations = editor.deltaDecorations(allDecorations, newDecorations);
            }

            /**
             * Resets the search state and decorations when search criteria change,
             * or forces a re-index if 'force' is true.
             */
            function resetSearchState(force = false) {
                const newFindText = findInput.value;
                const newSelectedId = idDropdown.value;
                const newSelectedTag = tagDropdown.value;
                const newIsRegex = enableRegexCheckbox.checked;
                const newMatchCase = matchCaseCheckbox.checked;

                const criteriaChanged = (
                    newFindText !== currentFindText ||
                    newSelectedId !== currentSelectedId ||
                    newSelectedTag !== currentSelectedTag ||
                    newIsRegex !== currentIsRegex ||
                    newMatchCase !== currentMatchCase
                );

                if (force || criteriaChanged) {
                    currentFindText = newFindText;
                    currentSelectedId = newSelectedId;
                    currentSelectedTag = newSelectedTag;
                    currentIsRegex = newIsRegex;
                    currentMatchCase = newMatchCase;

                    allMatches = findMatches();
                    currentMatchIndex = -1; // Reset index when criteria change or forced re-index

                    if (allMatches.length > 0 && newFindText !== '') {
                        currentMatchIndex = 0; // Select first match if any
                    }
                }
                
                updateDecorations();
            }

            // Helper function to process replacement text for a single match
            function processReplacement(originalMatchText, replaceText, isRegex, isSequencing, sequenceCurrentValue) {
                let finalReplacement = replaceText;

                // Handle sequencing
                if (isSequencing) {
                    if (finalReplacement.includes('{$#+}')) {
                        finalReplacement = finalReplacement.replaceAll('{$#+}', sequenceCurrentValue.toString());
                    } else if (finalReplacement.includes('{$#-}' )) {
                        finalReplacement = finalReplacement.replaceAll('{$#-}', sequenceCurrentValue.toString());
                    }
                }

                // Handle backreferences ($1, $2, etc.) and $& if regex is enabled
                if (isRegex) {
                    const findText = findInput.value;
                    const matchCase = matchCaseCheckbox.checked;
                    const pattern = isRegex ? findText : escapeRegExp(findText);
                    const regexForGroups = new RegExp(pattern, matchCase ? '' : 'i'); // Non-global for exec

                    const groupMatch = regexForGroups.exec(originalMatchText);

                    if (groupMatch) {
                        finalReplacement = finalReplacement.replaceAll('$&', groupMatch[0] || '');
                        for (let i = 1; i < groupMatch.length; i++) {
                            const placeholder = `$${i}`;
                            finalReplacement = finalReplacement.replaceAll(placeholder, groupMatch[i] || '');
                        }
                    }
                }
                return finalReplacement;
            }

            // Event listeners for UI elements
            findNextButton.addEventListener('click', () => {
                resetSearchState();
                if (allMatches.length > 0) {
                    currentMatchIndex = (currentMatchIndex + 1) % allMatches.length;
                    updateDecorations();
                } else {
                    // Message already handled by updateDecorations
                }
            });

            findPreviousButton.addEventListener('click', () => {
                resetSearchState();
                if (allMatches.length > 0) {
                    currentMatchIndex = (currentMatchIndex - 1 + allMatches.length) % allMatches.length;
                    updateDecorations();
                } else {
                    // Message already handled by updateDecorations
                }
            });

            // Logic for the new "Replace" button
            replaceOneButton.addEventListener('click', () => {
                const findText = findInput.value;
                const replaceText = replaceInput.value;
                const isRegex = enableRegexCheckbox.checked;
                const isSequencing = sequenceCheckbox.checked && (replaceText.includes('{$#+}') || replaceText.includes('{$#-}') );
                let startIndex = parseInt(startIndexInput.value, 10);

                if (!findText) {
                    updateDecorations();
                    return;
                }

                if (isSequencing && isNaN(startIndex)) {
                    showMessageBox("Please enter a valid number for 'Start' index when sequencing.", true);
                    return;
                }

                // Ensure matches are found and a current match is selected
                if (allMatches.length === 0 || currentMatchIndex === -1 || currentMatchIndex >= allMatches.length) {
                    resetSearchState();
                    if (allMatches.length === 0) {
                        updateDecorations();
                        return;
                    }
                }
                
                const matchToReplace = allMatches[currentMatchIndex];
                const originalMatchRange = matchToReplace.range;
                const originalMatchText = editor.getModel().getValueInRange(originalMatchRange);
                
                // Process the replacement text for this single instance
                const processedReplaceText = processReplacement(
                    originalMatchText,
                    replaceText,
                    isRegex,
                    isSequencing,
                    startIndex // Pass the current start index for processing
                );

                // Perform the replacement
                editor.executeEdits(
                    null,
                    [{
                        range: originalMatchRange, // Use the original range
                        text: processedReplaceText,
                        forceMoveMarkers: true
                    }]
                );
                
                // If sequencing, update the start index for the next operation
                if (isSequencing) {
                    if (replaceText.includes('{$#+}')) {
                        startIndexInput.value = (startIndex + 1).toString();
                    } else if (replaceText.includes('{$#-}' )) {
                        startIndexInput.value = (startIndex - 1).toString();
                    }
                }

                // Store the end position of the replaced range before re-finding matches
                const oldEndPosition = originalMatchRange.getEndPosition();

                // Re-find all matches as the document content has changed and force reset state
                resetSearchState(true);

                let newCurrentMatchIndex = -1;

                // Try to find the first match that starts at or after the old end position
                for (let i = 0; i < allMatches.length; i++) {
                    const newMatchRange = allMatches[i].range;
                    // Use monaco.Position.compare() for robust position comparison
                    if (monaco.Position.compare(newMatchRange.getStartPosition(), oldEndPosition) >= 0) {
                        newCurrentMatchIndex = i;
                        break;
                    }
                }

                if (newCurrentMatchIndex !== -1) {
                    currentMatchIndex = newCurrentMatchIndex;
                } else if (allMatches.length > 0) {
                    // If no match found at or after the old end position, wrap around to the first match
                    currentMatchIndex = 0;
                } else {
                    // No matches left in the document
                    currentMatchIndex = -1;
                }
                
                allDecorations = editor.deltaDecorations(allDecorations, []); // Clear old decorations
                updateDecorations(); // Apply new decorations and update message
            });

            idDropdown.addEventListener('change', () => resetSearchState(true)); 
            tagDropdown.addEventListener('change', () => resetSearchState(true)); 
            matchCaseCheckbox.addEventListener('change', () => resetSearchState(true)); 
            highlightAllCheckbox.addEventListener('change', updateDecorations);
            findInput.addEventListener('input', () => resetSearchState(true)); 

            // The original replace button is now Replace All
            replaceAllButton.addEventListener('click', () => {
                const findText = findInput.value;
                const replaceText = replaceInput.value;
                const selectedTag = tagDropdown.value;
                const selectedId = idDropdown.value;
                const isRegex = enableRegexCheckbox.checked;
                const matchCase = matchCaseCheckbox.checked;
                const isSequencing = sequenceCheckbox.checked && (replaceText.includes('{$#+}') || replaceText.includes('{$#-}') );

                if (!findText) {
                    updateDecorations();
                    return;
                }

                if (isSequencing && isNaN(parseInt(startIndexInput.value, 10))) {
                    showMessageBox("Please enter a valid number for 'Start' index when sequencing.", true);
                    return;
                }
                
                // Get all matches based on current search criteria
                let matchesToReplace = findMatches(); 
                
                if (matchesToReplace.length === 0) {
                    updateDecorations();
                    return;
                }

                const edits = [];
                let replacementCount = 0;
                let sequenceCounter = parseInt(startIndexInput.value, 10);
                const endIndex = parseInt(endIndexInput.value, 10);

                const pattern = isRegex ? findText : escapeRegExp(findText);

                // Iterate through matches and prepare edit operations
                matchesToReplace.forEach((match, index) => {
                    // Calculate the sequence value for this specific match
                    const currentMatchSequenceValue = sequenceCounter + index; 

                    let finalReplacement = replaceText;

                    // Handle sequencing for replace all
                    if (isSequencing) {
                        if (!isNaN(endIndex) && currentMatchSequenceValue > endIndex) {
                            // Skip this replacement if it's outside the sequence range
                            return; 
                        }
                        if (finalReplacement.includes('{$#+}')) {
                            finalReplacement = finalReplacement.replaceAll('{$#+}', currentMatchSequenceValue.toString());
                        } else if (finalReplacement.includes('{$#-}' )) {
                            finalReplacement = finalReplacement.replaceAll('{$#-}', currentMatchSequenceValue.toString());
                        }
                    }

                    // Handle backreferences ($1, $2, etc.) and $& if regex is enabled
                    if (isRegex) {
                        const originalMatchText = editor.getModel().getValueInRange(match.range);
                        // Create a new regex instance for just this match to get groups
                        // Ensure the regex is not global for exec to work correctly for groups on a single match
                        const regexForGroups = new RegExp(pattern, matchCase ? '' : 'i');
                        const groupMatch = regexForGroups.exec(originalMatchText);

                        if (groupMatch) { 
                            // Replace $& (entire matched string)
                            finalReplacement = finalReplacement.replaceAll('$&', groupMatch[0] || '');

                            // Replace $1, $2, etc. (capturing groups)
                            for (let i = 1; i < groupMatch.length; i++) { 
                                const placeholder = `$${i}`;
                                finalReplacement = finalReplacement.replaceAll(placeholder, groupMatch[i] || '');
                            }
                        }
                    }

                    edits.push({
                        range: match.range,
                        text: finalReplacement
                    });
                    replacementCount++;
                });

                if (replacementCount === 0) {
                    updateDecorations();
                    return;
                }

                // Apply all edits in a single operation for undo/redo
                editor.getModel().pushEditOperations(
                    [], // No previous selections
                    edits,
                    () => null // No new selection needed after replace all
                );

                // Update the display message
                matchCountSpan.innerHTML = `Replaced ${replacementCount} occurrences.`;

                // Reset search state and decorations
                resetSearchState(true); // Force reset state after replace all
            });

            // Event listeners for the Regex Guide modal
            regexGuideButton.addEventListener('click', () => {
                regexGuideModal.classList.remove('hidden');
            });

            closeRegexGuideButton.addEventListener('click', () => {
                regexGuideModal.classList.add('hidden');
            });

            // Close modal if clicked outside content
            regexGuideModal.addEventListener('click', (event) => {
                if (event.target === regexGuideModal) {
                    regexGuideModal.classList.add('hidden');
                }
            });
        });
    </script>
</body>
</html>
