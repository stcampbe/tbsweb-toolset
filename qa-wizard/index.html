<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BeforeYouPost™ - QA/Prototype Wizard</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- js-beautify for auto-indent -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/js-beautify/1.14.0/beautify-html.min.js"></script>
    <style>
        /* Custom styles for the editor */
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden; /* Prevent overall body scroll */
        }

        body {
            font-family: 'Inter', sans-serif;
            display: flex;
            flex-direction: column; /* Stack header and main content vertically */
            background-color: #1a202c; /* Dark background */
            color: #ffffff;
        }

        /* New header for the QA Wizard title */
        .qa-wizard-header {
            padding: 1rem;
            display: flex; /* Use flexbox for alignment */
            align-items: center; /* Vertically align items */
            gap: 1rem; /* Space between title and buttons */
            flex-wrap: wrap; /* Allow wrapping on smaller screens */
        }

        .qa-wizard-header h1 {
            font-size: 1.25rem; /* text-4xl */
            font-weight: bold;
            color: #ffffff;
            margin-right: auto; /* Push buttons to the right */
        }

        /* Container for sidebar and editor panel */
        .main-content-area {
            display: flex;
            flex-grow: 1; /* Allow this area to take up remaining vertical space */
            padding: 0 1rem 1rem 1rem; /* Padding on sides and bottom */
            gap: 1rem;
            width: 100%;
            box-sizing: border-box;
            overflow: hidden; /* Prevent horizontal scroll in this container */
        }


        .code-panel {
            background-color: #2d3748;
            border-radius: 0.75rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            padding: 1rem;
            display: flex;
            flex-direction: column; /* Stack editor and results vertically */
            min-width: 200px;
            height: 100%; /* Fill available height in main-content-area */
            box-sizing: border-box;
            overflow: hidden; /* Prevent content inside from overflowing its own boundaries */
            flex-grow: 1; /* Ensure it takes up available space */
        }

        /* Monaco Editor Container */
        #monacoEditorContainer {
            border: 1px solid #4a5568;
            border-radius: 0.5rem;
            width: 100%;
            flex-grow: 1; /* Allow editor to grow and fill space */
            min-height: 200px; /* Minimum height for editor */
            margin-bottom: 1rem; /* Space between editor and results */
        }

        /* Validation Results Section */
        #validationResultsContainer {
            /* Removed fixed height and overflow from here */
            background-color: transparent; /* Let the inner div handle the background */
            border-radius: 0.75rem;
            /* margin-top: 1rem; -- moved to monacoEditorContainer */
            color: #ffffff;
            flex-shrink: 0; /* Prevent results from shrinking */
            display: flex; /* Use flexbox for results and sidebar */
            min-height: 50px; /* Minimum height for the container */
        }

        #validationResults {
            padding: 0.5rem;
            border-radius: 0.5rem;
            font-size: 0.875rem;
            line-height: 1.5;
            flex-grow: 1; /* Allow results to take up remaining space */
            height: 200px; /* Fixed height for results area */
            overflow-y: auto; /* Enable scrolling for results */
            /* Default background for validation results */
            background-color: #f9fafb; /* bg-gray-50 */
            color: #4a5568; /* text-gray-700 */
            border: 1px solid #e2e8f0; /* border-gray-200 */
        }

        /* Specific styles for validation results based on success/error */
        #validationResults.bg-green-100 {
            background-color: #d1fae5;
            color: #065f46;
            border: 1px solid #34d399;
        }
        #validationResults.bg-red-100 {
            background-color: #fee2e2;
            color: #991b1b;
            border: 1px solid #f87171;
        }

        /* Styling for clickable error list items */
        #validationResults ul li {
            cursor: pointer;
            padding: 4px 0;
            transition: background-color 0.2s ease;
        }

        #validationResults ul li:hover {
            background-color: rgba(255, 255, 255, 0.1);
            text-decoration: underline;
        }

        /* Monaco Editor custom highlight style for clicked line */
        .monaco-editor .highlighted-line {
            background-color: rgba(100, 149, 237, 0.4); /* Muted cornflower blue, more subtle */
            border-radius: 4px;
        }

        /* Monaco Editor custom highlight style for HTML entities */
        .monaco-editor .entity-highlight {
            color: yellow; /* Changed from background-color to color */
            border-radius: 2px;
        }

        /* Toggle Switch Styles (copied from index.html) */
        .toggle-switch-container {
            display: flex;
            align-items: center;
            padding: 0.25rem 0; /* Reduced vertical padding */
            gap: 0.5rem; /* Space between toggle and label */
            justify-content: flex-start; /* Align contents to the start */
            background-color: #475569; /* Medium slate for background */
            border-radius: 0.5rem; /* Rounded corners */
            padding: 0.5rem 0.75rem; /* Padding inside the container */
        }

        .toggle-switch-label {
            color: #CBD5E1; /* Light slate for label text */
            font-size: 0.9rem;
            flex-shrink: 1; /* Allow label to shrink */
            min-width: 0; /* Allow text to wrap within the label */
        }

        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 44px; /* Width of the pill */
            height: 24px; /* Height of the pill */
            border-radius: 12px; /* Half of height for pill shape */
            background-color: #64748B; /* Grayish slate for off state */
            cursor: pointer;
            transition: background-color 0.3s ease;
            flex-shrink: 0; /* Prevent the switch from shrinking */
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-switch-slider {
            position: absolute;
            content: "";
            height: 20px; /* Height of the inner circle */
            width: 20px; /* Width of the inner circle */
            left: 2px; /* Initial position for off state */
            bottom: 2px;
            background-color: #ffffff; /* Circle color */
            border-radius: 50%;
            transition: transform 0.3s ease;
        }

        /* Checked state styles (applied to the .toggle-switch label itself) */
        .toggle-switch.is-checked {
            background-color: #22c55e; /* Green for on state */
        }

        .toggle-switch.is-checked .toggle-switch-slider {
            transform: translateX(20px); /* Move circle to the right */
        }

        /* Styling for disabled button */
        button:disabled {
            background-color: #4a4a4a !important; /* Darker gray for disabled state, use !important to override other styles */
            cursor: not-allowed !important;
            opacity: 0.6 !important;
        }

        /* Modal styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .modal-content {
            background-color: #2d3748;
            padding: 2rem;
            border-radius: 0.75rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            color: #ffffff;
            text-align: left; /* Left align content */
            max-width: 90%;
            width: 400px;
            position: relative; /* For absolute positioning of close button */
        }

        .modal-content h3 {
            font-size: 1.5rem;
            font-weight: bold;
            margin-bottom: 1rem;
            text-align: left; /* Ensure title is left aligned */
        }

        .modal-content p {
            margin-bottom: 1.5rem;
        }

        .modal-content button {
            color: white;
            border-radius: 0.5rem;
            font-weight: bold;
            transition: background-color 0.2s ease;
        }

        .modal-content button:hover {
            background-color: #3182ce; /* Blue-600 */
        }

        /* Preview Modal Specific Styles */
        #previewModal .modal-content {
            width: 98%; /* Wider for better preview */
            max-width: 1500px; /* Max width for large screens */
            height: 95%; /* Taller for better preview */
            display: flex;
            flex-direction: column;
            overflow: hidden; /* Prevent modal content from scrolling, iframe handles it */
            padding: 1.5rem; /* Reduced padding for modal content */
        }

        #previewModal .modal-content .modal-header-controls {
            display: flex;
            align-items: center; /* Vertically align items */
            /* Removed justify-content: space-between; to allow title and buttons to be close */
            margin-bottom: 0.75rem; /* Reduced space below header */
            flex-wrap: wrap;
        }

        #previewModal .modal-content h3 {
            font-size: 1.25rem; /* Slightly smaller title */
            text-align: left; /* Keep title left-aligned */
            margin-bottom: 0; /* Adjusted for inline elements */
            /* Removed flex-grow: 1; to prevent it from pushing buttons too far */
            margin-right: 0.75rem; /* Space between title and buttons */
        }

        #previewModal iframe {
            width: 100%;
            height: 100%;
            border: 1px solid #4a5568;
            border-radius: 0.5rem;
            background-color: #ffffff;
            flex-grow: 1; /* Allow iframe to take available space */
        }

        /* Customize section styles for modal */
        #previewModal .customize-section {
            background-color: #3b455a;
            border-radius: 0.5rem;
            padding: 0.75rem; /* Reduced padding */
            margin-bottom: 0.75rem; /* Reduced margin */
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        #previewModal .customize-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
        }

        #previewModal .customize-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out;
        }

        #previewModal .customize-content.expanded {
            max-height: 500px; /* Adjust as needed to fit content */
            transition: max-height 0.5s ease-in;
            padding-top: 0.5rem;
        }

        #previewModal .customize-header svg {
            transition: transform 0.3s ease;
        }

        #previewModal .customize-header.expanded svg {
            transform: rotate(180deg);
        }

        /* Button group styles for modal customize section (from index.html) */
        #previewModal .button-group {
            display: flex;
            width: 100%; /* Make it span full width */
            border-radius: 0.5rem; /* rounded-md */
            box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05); /* shadow-sm */
            border: 1px solid #4a5568; /* Darker border for button group */
            flex-wrap: wrap; /* Keep for responsiveness on smaller screens */
        }

        #previewModal .button-group button {
            flex: 1; /* Make buttons take up equal space */
            border-radius: 0; /* Remove individual button rounded corners */
            border: none; /* Remove individual button borders */
            margin: 0; /* Remove individual button margins */
            padding: 0.5rem 0.75rem; /* Consistent padding */
            font-size: 0.875rem; /* text-sm */
            line-height: 1.25rem; /* leading-5 */
            position: relative; /* For z-index if needed */
            color: #ffffff; /* White text for all buttons */
            font-weight: bold; /* Make buttons bold */
        }

        #previewModal .button-group button:hover {
            background-color: #3182ce; /* Blue-600 */
        }

        /* Adjust border between buttons in the main button groups */
        #previewModal .button-group:not(.no-border-buttons) button:not(:last-child) {
            border-right: 1px solid rgba(74, 85, 104, 0.5); /* Darker separator between buttons */
        }
        #previewModal .button-group.no-border-buttons button:not(:last-child) {
            border-right: none; /* Remove border for this specific group */
        }

        /* Specific styling for the byline and URL/Image source button groups */
        #previewModal .button-group.individual-rounded-buttons {
            border: none; /* Remove group border */
            box-shadow: none; /* Remove group shadow */
            width: auto; /* Allow the group to size to content */
            gap: 0.5rem; /* Add gap between individual buttons */
        }

        #previewModal .button-group.individual-rounded-buttons button {
            flex: none; /* Do not make buttons take equal space */
            border-radius: 0.5rem; /* Ensure rounded corners */
            border: 1px solid #4a5568; /* Add individual button border */
            padding: 0.5rem 0.75rem; /* Consistent padding */
        }
        /* Remove right border for individual rounded buttons */
        #previewModal .button-group.individual-rounded-buttons button:not(:last-child) {
            border-right: 1px solid #4a5568; /* Keep individual border */
        }

        #previewModal .button-group button:first-child {
            border-top-left-radius: 0.5rem;
            border-bottom-left-radius: 0.5rem;
        }

        #previewModal .button-group button:last-child {
            border-top-right-radius: 0.5rem;
            border-bottom-right-radius: 0.5rem;
        }

        #previewModal .button-group button.active:hover {
            z-index: 1; /* Bring hovered button to front to show full border/shadow */
			background-color: #3182ce !important;
        }
		#previewModal .button-group button.active:hover {
            z-index: 1; /* Bring hovered button to front to show full border/shadow */
			background-color: #3182ce !important;
        }

        /* Active states for buttons in modal, matching QA Wizard */
        #previewModal .button-group button.active {
			color: white !important;
			background-color: #4a5568 !important;
		}
        /* Specific active state for WET4 button */
        #previewModal #modalWetGcdsToggleBtn.active {
            background-color: #2563eb !important; /* Blue-600 for WET4 active */
            border-color: #2563eb !important;
        }
        #previewModal #modalWetGcdsToggleBtn.hover {
            background-color: #2563eb !important; /* Blue-600 for WET4 active */
            border-color: #2563eb !important;
        }
        /* Specific active state for GCDS/WET+ button */
        #previewModal #modalWetGcdsToggleBtn[class*="indigo-600"].active {
            background-color: #4f46e5 !important; /* Indigo-600 for GCDS/WET+ active */
            border-color: #4f46e5 !important;
        }

        /* Specific styling for the Sections and Headings buttons in modal */
        #previewModal #modalToggleSectionsBtn,
        #previewModal #modalToggleHeadingsBtn {
            flex: none; /* Override flex: 1; for these specific buttons */
            width: auto; /* Allow buttons to size based on content */
            border: 1px solid #4a5568; /* Add border back for individual buttons */
            border-radius: 0.5rem; /* Add rounded corners back for individual buttons */
            padding: 0.3rem 0.6rem; /* Reduced padding */
            font-size: 0.75rem; /* Smaller font size */
        }
        #previewModal #modalToggleSectionsBtn.active,
        #previewModal #modalToggleHeadingsBtn.active {
            background-color: #facc15 !important; /* Tailwind yellow-400 */
            color: #1f2937 !important; /* Dark gray for text */
            border-color: #facc15 !important;
        }
        /* Default state for Sections/Headings buttons */
        #previewModal #modalToggleSectionsBtn,
        #previewModal #modalToggleHeadingsBtn {
            background-color: #374151; /* Tailwind gray-700 */
            color: #ffffff;
        }
        #previewModal #modalToggleSectionsBtn:hover,
        #previewModal #modalToggleHeadingsBtn:hover {
            background-color: #4b5563; /* Tailwind gray-600 */
        }

        /* Input and Label styles for modal */
        #previewModal input[type="text"] {
            background-color: #4a5568; /* Darker background for input */
            color: #ffffff; /* White text for input */
            border-color: #4a5568; /* Darker border for input */
            border-radius: 0.5rem; /* rounded-md */
            padding: 0.5rem 0.75rem; /* Consistent padding */
            font-size: 0.875rem; /* text-sm */
            line-height: 1.25rem; /* leading-5 */
        }
        #previewModal input[type="text"]::placeholder {
            color: #a0aec0; /* Lighter placeholder text */
        }
        #previewModal label {
            color: #cbd5e0; /* Lighter gray for labels */
        }

        /* Styles for Prev/Next buttons in modal */
        #modalPreviewFindPrevBtn,
        #modalPreviewFindNextBtn {
            padding: 0.25rem 0.5rem !important; /* px-2 py-1 */
            font-size: 0.75rem !important; /* text-xs */
            background-color: #2563eb !important;
            color: #ffffff !important; /* White text */
            border-radius: 0.375rem !important; /* rounded-md */
            transition: background-color 0.2s ease;
        }
        #modalPreviewFindPrevBtn:hover,
        #modalPreviewFindNextBtn:hover {
            background-color: #3182ce !important; /* Blue-600 */
        }

        /* Styles for WET4, EN, FR buttons in modal header */
        #modalWetGcdsToggleBtn,
        #modalLangEnBtn, /* Apply to both EN and FR buttons */
        #modalLangFrBtn {
            padding: 0.3rem 0.6rem; /* Reduced padding */
            font-size: 0.75rem; /* Smaller font size */
        }
        /* EN/FR active state */
        #modalLangEnBtn.active,
        #modalLangFrBtn.active {
            background-color: #2563eb !important; /* Indigo-600 for active state */
            color: white !important;
            border-color: #2563eb !important;
        }

        /* EN/FR hover state */
        #modalLangEnBtn:hover,
        #modalLangFrBtn:hover {
            background-color: #3182ce !important; /* Blue-600 */
        }

        /* "X" Close Button styling */
        #closePreviewModalBtn {
            background-color: transparent; /* Make it transparent by default */
            color: #cbd5e0; /* Lighter gray for the X symbol */
            border: none;
            transition: background-color 0.2s ease, color 0.2s ease;
            cursor: pointer;
            border-radius: 50%; /* Make it round */
            display: flex;
            align-items: center;
            justify-content: center;
            width: 2rem; /* w-8 */
            height: 2rem; /* h-8 */
            font-size: 1.5rem; /* text-2xl */
            font-weight: bold;
            line-height: none; /* Remove extra line height */
            padding: 0; /* Remove padding */
        }
        #closePreviewModalBtn:hover {
            background-color: rgba(255, 255, 255, 0.1); /* Subtle background on hover */
            color: #ffffff; /* White on hover */
        }

        /* Sidebar for validation controls */
        .validation-sidebar {
            width: 180px; /* Fixed width for the sidebar */
            background-color: #2d3748;
            border-radius: 0.75rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            padding: 1rem;
            display: flex;
            flex-direction: column;
            gap: 1rem;
            flex-shrink: 0; /* Prevent sidebar from shrinking */
            height: 100%; /* Fill available height in main-content-area */
        }
    </style>
</head>
<body>
    <!-- QA Wizard Title Header -->
    <header class="qa-wizard-header">
        <h1 class="text-left">BeforeYouPost™ - QA/Prototype Wizard</h1>
        <a href="/tbsweb-toolset/content-wizard/" class="px-3 py-1 text-sm bg-blue-600 text-white rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50 font-bold">Content Wizard</a>
        <a href="/tbwweb-toolset/table-wizard/" class="px-3 py-1 text-sm bg-blue-600 text-white rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50 font-bold">Table Wizard</a>
        <a href="#" class="px-3 py-1 text-sm text-white rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50 font-bold bg-gray-400 cursor-not-allowed opacity-60" disabled="">QA Wizard</a>
    </header>

    <!-- Main content area: Sidebar + Editor Panel -->
    <div class="main-content-area">
        

        <div class="code-panel">
            <!-- Removed the h2 "QA Wizard" from here -->
            <div class="mb-4 flex flex-wrap"> <!-- Adjusted justify-content -->
                <div class="inline-flex rounded-md shadow-sm" role="group">
                    <!-- Removed Paste Code button -->
                    <button id="copyCodeBtn" class="px-4 py-1 text-sm bg-gray-700 text-white rounded-l-md hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-opacity-50 font-semibold">
                        Copy Code
                    </button>
                    <button id="clearAllBtn" class="px-4 py-1 text-sm bg-gray-700 text-white rounded-r-md hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-opacity-50 font-bold">
                        Clear All
                    </button>
                </div>
                <div class="inline-flex space-x-2 ml-2">
                    <button id="importHtmlBtn" class="px-3 py-1 text-sm bg-purple-600 text-white rounded-md hover:bg-purple-700 focus:outline-none focus:ring-2 focus:ring-purple-500 focus:ring-opacity-50 font-bold">Import HTML</button>
                    <button id="exportHtmlBtn" class="px-3 py-1 text-sm bg-red-600 text-white rounded-md hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-opacity-50 font-bold">Export HTML</button>
                    <input type="file" id="htmlFileInput" accept=".html" style="display: none;">
                </div>
            </div>

            <div id="monacoEditorContainer"></div>

            <!-- Validation Results Section - Always visible at the bottom -->
            <div id="validationResultsContainer">
                <div id="validationResults" class="bg-gray-50 p-4 border border-gray-200 rounded-lg min-h-[50px] text-gray-700 text-sm leading-relaxed">
                    <p class="text-gray-500">Type HTML above to see validation results here.</p>
                </div>
            </div>
        </div>
        <!-- Right Sidebar for Validation Controls -->
        <div class="validation-sidebar">
            
            <button id="previewBtn" class="px-3 py-1 text-sm bg-green-600 text-white rounded-md hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-opacity-50 font-bold">
                        View Preview
                    </button>
            <!-- Auto-Check Toggle -->
            <div class="toggle-switch-container">
                <label class="toggle-switch is-checked" for="toggleAutoCheckOnSwitch">
                    <input type="checkbox" id="toggleAutoCheckOnSwitch" checked>
                    <span class="toggle-switch-slider"></span>
                </label>
                <span class="toggle-switch-label text-white text-xs">Auto-Validate</span>
            </div>
            <!-- Validate Button -->
            <button id="validateNowBtn" class="px-3 py-1 text-sm bg-blue-700 text-white rounded-md hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50 font-bold" disabled>
                Validate
            </button>
            <button id="cleanSpacesBtn" class="px-3 py-1 text-sm bg-gray-700 text-white rounded-md hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-opacity-50 font-bold">Clean Spaces</button>
            <button id="cleanUrlsBtn" class="px-3 py-1 text-sm bg-gray-700 text-white rounded-md hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-opacity-50 font-bold">Clean URLs</button>
            <button id="timeTagsBtn" class="px-3 py-1 text-sm bg-gray-700 text-white rounded-md hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-opacity-50 font-bold">Time Tags</button>
            <button id="fixFnIdsBtn" class="px-3 py-1 text-sm bg-gray-700 text-white rounded-md hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-opacity-50 font-bold">Fix FN ID's</button>
            <button id="colophonBtn" class="px-3 py-1 text-sm bg-gray-700 text-white rounded-md hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-opacity-50 font-bold">Colophon</button>
            <button id="autoEncodeBtn" class="px-4 py-1 text-sm bg-red-600 text-white rounded-md hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-opacity-50 font-semibold">
                    Auto-Encode
                </button>
                <button id="autoFormatBtn" class="px-4 py-1 text-sm bg-red-600 text-white rounded-md hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-opacity-50 font-semibold">
                    Auto-Indent
                </button>
                
        </div>
    </div>

    <!-- Preview Modal Structure -->
    <div id="previewModal" class="modal-overlay hidden">
        <div class="modal-content">
            <!-- "X" Close Button -->
            
            <button id="closePreviewModalBtn" class="absolute top-4 right-4">
                &times;
            </button>

            <!-- Header with Title and Language/Framework Toggles -->
            <div class="modal-header-controls">
                <h3 class="text-xl font-semibold text-white">Live Preview</h3>
                <div class="inline-flex space-x-1"> <!-- Removed ml-auto -->
                    <button id="modalWetGcdsToggleBtn" class="px-2 py-1 text-sm bg-blue-600 text-white rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50 font-bold">WET4</button>
                    <button id="modalLangEnBtn" class="px-2 py-1 text-sm bg-gray-700 text-white rounded-md hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-opacity-50 font-bold">EN</button>
                    <button id="modalLangFrBtn" class="px-2 py-1 text-sm bg-gray-700 text-white rounded-md hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-opacity-50 font-bold">FR</button>
                    <button id="exportPrototypeBtn" class="px-2 py-1 text-sm bg-red-600 text-white rounded-md hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-opacity-50 font-bold">Export Prototype</button>
                </div>
            </div>

            <!-- Customize Section in Modal -->
            <div class="customize-section">
                <div id="modalCustomizeHeader" class="customize-header">
                    <h3 class="text-lg font-semibold text-white">Customize</h3>
                    <svg id="modalCustomizeToggleIcon" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" class="w-5 h-5 text-white">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M19.5 8.25l-7.5 7.5-7.5-7.5" />
                    </svg>
                </div>
                <div id="modalCustomizeContent" class="customize-content">
                    <div class="flex flex-col space-y-2 w-full mb-4">
                        <div class="flex flex-col items-start w-full">
                            <div class="button-group flex-wrap w-full">
                                <button id="modalToggleContainerBtn" class="bg-gray-700 text-white focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-opacity-50">Custom Width</button>
                                <button id="modalToggleTitleBtn" class="bg-gray-700 text-white focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-opacity-50">Hide Title</button>
                                <button id="modalToggleCssBtn" class="bg-gray-700 text-white rounded-md hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-opacity-50">Disable CSS</button>
                            </div>
                        </div>
                    </div>
                    <div class="mb-4" id="modalH1TitleInputContainer">
                        <input type="text" id="modalH1TitleInput" class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500" placeholder="e.g., My Custom ENG Title">
                    </div>
                    <div class="flex flex-col space-y-2 w-full">
                        <div class="flex flex-row flex-wrap justify-center sm:justify-start w-full mt-2 space-x-4">
                            <div class="flex flex-col items-start mt-2 sm:mt-0">
                                <span class="text-sm font-medium text-gray-200 mb-1">Byline:</span>
                                <div class="button-group individual-rounded-buttons flex-wrap justify-center sm:justify-start">
                                    <button id="modalNoneBylineBtn" class="bg-gray-700 text-white rounded-md hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-opacity-50">None</button>
                                    <button id="modalEnglishBylineBtn" class="bg-gray-700 text-white rounded-md hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-opacity-50">English</button>
                                    <button id="modalFrenchBylineBtn" class="bg-gray-700 text-white rounded-md hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-opacity-50">French</button>
                                </div>
                            </div>
                            <div class="flex flex-col items-start">
                                <span class="text-sm font-medium text-gray-200 mb-1">Image source:</span>
                                <div class="button-group individual-rounded-buttons flex-wrap justify-center sm:justify-start">
                                    <button id="modalLocalImagesBtn" class="bg-gray-700 text-white rounded-md hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-opacity-50">Local</button>
                                    <button id="modalPreviewImagesBtn" class="bg-gray-700 text-white rounded-md hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-opacity-50" title="Users MUST be on TBS network">Preview</button>
                                    <button id="modalToggleLiveImagesBtn" class="bg-gray-700 text-white rounded-md hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-opacity-50">Live</button>
                                </div>
                            </div>
                            <div class="flex flex-col items-start mt-2 sm:mt-0">
                                <span class="text-sm font-medium text-gray-200 mb-1">URL source:</span>
                                <div class="button-group individual-rounded-buttons flex-wrap justify-center sm:justify-start">
                                    <button id="modalLocalUrlsBtn" class="bg-gray-700 text-white rounded-md hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-opacity-50">Local</button>
                                    <button id="modalPreviewUrlsBtn" class="bg-gray-700 text-white rounded-md hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-opacity-50" title="Users MUST be on TBS network">Preview</button>
                                    <button id="modalToggleLiveUrlsBtn" class="bg-gray-700 text-white rounded-md hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-opacity-50">Live</button>
                                </div>
                            </div>
                            <!-- New Breakpoint buttons -->
                            <div class="flex flex-col items-start mt-2 sm:mt-0">
                                <span class="text-sm font-medium text-gray-200 mb-1">Breakpoint:</span>
                                <div class="button-group individual-rounded-buttons flex-wrap justify-center sm:justify-start">
                                    <button id="modalBreakpointXsBtn" class="bg-gray-700 text-white rounded-md hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-opacity-50">XS</button>
                                    <button id="modalBreakpointSmBtn" class="bg-gray-700 text-white rounded-md hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-opacity-50">SM</button>
                                    <button id="modalBreakpointMdBtn" class="bg-gray-700 text-white rounded-md hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-opacity-50">MD</button>
                                    <button id="modalBreakpointFullBtn" class="bg-gray-700 text-white rounded-md hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-opacity-50">Full</button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <iframe id="modalPreviewFrame" title="Live HTML Preview"></iframe>

            <!-- Search and Section/Headings Toggles (moved below iframe) -->
            <div class="mt-auto pt-4 flex flex-col space-y-2 w-full">
                <div class="flex items-center space-x-2 w-full flex-wrap">
                    <input type="text" id="modalPreviewSearchInput" placeholder="Find in preview..." class="px-2 py-1 text-sm border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500 flex-grow">
                    <button id="modalPreviewFindPrevBtn" class="px-3 py-1 text-sm bg-blue-500 text-white rounded-md hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50 font-bold">Prev</button>
                    <button id="modalPreviewFindNextBtn" class="px-3 py-1 text-sm bg-blue-500 text-white rounded-md hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50 font-bold">Next</button>
                    <button id="modalToggleSectionsBtn" class="px-3 py-1 text-sm bg-gray-700 text-white rounded-md hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-opacity-50 font-bold">Sections</button>
                    <button id="modalToggleHeadingsBtn" class="px-3 py-1 text-sm bg-gray-700 text-white rounded-md hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-opacity-50 font-bold">Headings</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Monaco Editor Loader -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.29.1/min/vs/loader.min.js"></script>
    <script>
        let editor;
        let htmlModel;
        let currentLineDecorations = []; // To manage Monaco decorations for line highlighting
        let currentEntityDecorations = []; // To manage Monaco decorations for entity highlighting

        // Get button references
        // Removed pasteCodeBtn
        const autoEncodeBtn = document.getElementById('autoEncodeBtn');
        const autoFormatBtn = document.getElementById('autoFormatBtn');
        const copyCodeBtn = document.getElementById('copyCodeBtn');
        const importHtmlBtn = document.getElementById('importHtmlBtn');
        const exportHtmlBtn = document.getElementById('exportHtmlBtn');
        const clearAllBtn = document.getElementById('clearAllBtn'); // New Clear All button
        const htmlFileInput = document.getElementById('htmlFileInput');
        const validationResultsDiv = document.getElementById('validationResults');

        // New elements for Auto-Check feature
        const toggleAutoCheckOnSwitch = document.getElementById('toggleAutoCheckOnSwitch');
        const validateNowBtn = document.getElementById('validateNowBtn');
        let isAutoCheckEnabled = true; // Default to ON

        // New Preview button and modal elements
        const previewBtn = document.getElementById('previewBtn');
        const previewModal = document.getElementById('previewModal');
        const modalPreviewFrame = document.getElementById('modalPreviewFrame');
        const closePreviewModalBtn = document.getElementById('closePreviewModalBtn');
        const exportPrototypeBtn = document.getElementById('exportPrototypeBtn'); // New Export Prototype button

        // New Sidebar Buttons
        const cleanSpacesBtn = document.getElementById('cleanSpacesBtn');
        const cleanUrlsBtn = document.getElementById('cleanUrlsBtn');
        const timeTagsBtn = document.getElementById('timeTagsBtn');
        const fixFnIdsBtn = document.getElementById('fixFnIdsBtn');
        const colophonBtn = document.getElementById('colophonBtn'); // New Colophon button

        // All interactive buttons for disabling/enabling
        const allInteractiveButtons = [
            copyCodeBtn,
            importHtmlBtn,
            exportHtmlBtn,
            clearAllBtn,
            previewBtn,
            validateNowBtn,
            cleanSpacesBtn,
            cleanUrlsBtn,
            timeTagsBtn,
            fixFnIdsBtn,
            colophonBtn, // Add colophon button here
            autoEncodeBtn,
            autoFormatBtn
        ];

        // Modal Preview Controls (new references)
        const modalCustomizeHeader = document.getElementById('modalCustomizeHeader');
        const modalCustomizeContent = document.getElementById('modalCustomizeContent');
        const modalCustomizeToggleIcon = document.getElementById('modalCustomizeToggleIcon');
        const modalToggleContainerBtn = document.getElementById('modalToggleContainerBtn');
        const modalToggleTitleBtn = document.getElementById('modalToggleTitleBtn');
        const modalToggleCssBtn = document.getElementById('modalToggleCssBtn');
        const modalH1TitleInput = document.getElementById('modalH1TitleInput');
        const modalH1TitleInputContainer = document.getElementById('modalH1TitleInputContainer');
        const modalNoneBylineBtn = document.getElementById('modalNoneBylineBtn');
        const modalEnglishBylineBtn = document.getElementById('modalEnglishBylineBtn');
        const modalFrenchBylineBtn = document.getElementById('modalFrenchBylineBtn');
        const modalLocalImagesBtn = document.getElementById('modalLocalImagesBtn');
        const modalPreviewImagesBtn = document.getElementById('modalPreviewImagesBtn');
        const modalToggleLiveImagesBtn = document.getElementById('modalToggleLiveImagesBtn');
        const modalLocalUrlsBtn = document.getElementById('modalLocalUrlsBtn');
        const modalPreviewUrlsBtn = document.getElementById('modalPreviewUrlsBtn');
        const modalToggleLiveUrlsBtn = document.getElementById('modalToggleLiveUrlsBtn'); // Corrected ID here
        const modalPreviewSearchInput = document.getElementById('modalPreviewSearchInput');
        const modalPreviewFindPrevBtn = document.getElementById('modalPreviewFindPrevBtn');
        const modalPreviewFindNextBtn = document.getElementById('modalPreviewFindNextBtn');
        const modalToggleSectionsBtn = document.getElementById('modalToggleSectionsBtn');
        const modalToggleHeadingsBtn = document.getElementById('modalToggleHeadingsBtn');
        const modalWetGcdsToggleBtn = document.getElementById('modalWetGcdsToggleBtn');
        const modalLangEnBtn = document.getElementById('modalLangEnBtn');
        const modalLangFrBtn = document.getElementById('modalLangFrBtn');
        // New breakpoint buttons
        const modalBreakpointXsBtn = document.getElementById('modalBreakpointXsBtn'); // New XS button
        const modalBreakpointSmBtn = document.getElementById('modalBreakpointSmBtn');
        const modalBreakpointMdBtn = document.getElementById('modalBreakpointMdBtn');
        const modalBreakpointFullBtn = document.getElementById('modalBreakpointFullBtn');


        // State variables for Preview Modal (mirroring main preview) - THESE NOW PERSIST
        let modalShowSections = false;
        let modalShowHeadings = false;
        let modalUseContainerDiv = true;
        let modalShowTitle = true;
        let modalImageSourceMode = 'local';
        let modalBylineMode = 'none';
        let modalIsCustomizeExpanded = false; // This should probably be reset or managed by the modal itself
        let modalEnableCss = true;
        let modalUrlSourceMode = 'local';
        let modalCurrentLanguage = 'en';
        let modalCurrentFramework = 'wet'; // Default framework: 'wet', 'gcds', or 'wet+'
        let modalH1TitleEn = '';
        let modalH1TitleFr = '';
        let modalLastSearchTerm = ''; // For modal's internal search
        let modalCurrentBreakpoint = 'full'; // Default breakpoint: 'full', 'xs', 'sm', 'md', 'lg'


        // Define placeholders globally for &nbsp; and &#160;
        const NBSP_ENTITY_PLACEHOLDER = '__NBSP_ENTITY_PLACEHOLDER__';
        const NUMERIC_NBSP_ENTITY_PLACEHOLDER = '__NUMERIC_NBSP_ENTITY_PLACEHOLDER__';
        const LITERAL_NBSP_CHAR_PLACEHOLDER = '__LITERAL_NBSP_CHAR_PLACEHOLDER__'; // For \u00A0


        // Sets of elements for HTML validation
        const selfClosingTags = new Set([
            'area', 'base', 'br', 'col', 'embed', 'hr', 'img', 'input',
            'link', 'meta', 'param', 'source', 'track', 'wbr'
        ]);

        const deprecatedTags = new Set([
            'acronym', 'applet', 'basefont', 'big', 'center', 'dir', 'font',
            'frame', 'frameset', 'noframes', 'strike', 'tt', 'u'
        ]);

        const blockElements = new Set([
            'address', 'article', 'aside', 'blockquote', 'canvas', 'dd', 'div', 'dl', 'dt',
            'fieldset', 'figcaption', 'figure', 'footer', 'form', 'h1', 'h2', 'h3', 'h4',
            'h5', 'h6', 'header', 'hr', 'li', 'main', 'nav', 'noscript', 'ol', 'p',
            'pre', 'section', 'table', 'tfoot', 'ul', 'video'
        ]);

        const inlineElements = new Set([
            'a', 'abbr', 'b', 'bdo', 'br', 'button', 'cite', 'code',
            'dfn', 'em', 'i', 'img', 'input', 'kbd', 'label', 'map', 'object', 'q',
            'samp', 'script', 'select', 'small', 'span', 'strong', 'sub', 'sup',
            'textarea', 'time', 'var'
        ]);

        const mediaSizingElements = new Set([
            'img', 'iframe', 'video', 'canvas', 'object', 'embed'
        ]);

        const targetValidElements = new Set(['a', 'form']);

        // Tags to completely ignore during validation (e.g., for custom XML-like tags within HTML)
        const ignoredTags = new Set([
            'doc' // User requested to ignore <doc> tag
        ]);

        function isBlockElement(tagName) {
            return blockElements.has(tagName);
        }

        function isInlineElement(tagName) {
            return inlineElements.has(tagName);
        }

        function isWithinAnyRange(index, ranges) {
            for (const range of ranges) {
                if (index >= range.start && index <= range.end) {
                    return true;
                }
            }
            return false;
        }

        function isStartOfValidTag(index, tagRanges) {
            for (const range of tagRanges) {
                if (index === range.start) {
                    return true;
                }
            }
            return false;
        }

        function isEndOfValidTag(index, tagRanges) {
            for (const range of tagRanges) {
                if (index === range.end) {
                    return true;
                }
            }
            return false;
        }

        /**
         * Debounce function to limit how often a function is called.
         * @param {Function} func - The function to debounce.
         * @param {number} delay - The delay in milliseconds.
         * @returns {Function} The debounced function.
         */
        function debounce(func, delay) {
            let timeout;
            return function(...args) {
                const context = this;
                clearTimeout(timeout);
                timeout = setTimeout(() => func.apply(context, args), delay);
            };
        }

        /**
         * Highlights HTML entities in the Monaco editor.
         */
        function highlightHtmlEntities() {
            const model = editor.getModel();
            const text = model.getValue();
            // Regex to match common HTML entities (named and numeric)
            const entityRegex = /&[a-zA-Z]+;|&#[0-9]+;|&#x[0-9a-fA-F]+;/g;
            let match;
            const newDecorations = [];

            while ((match = entityRegex.exec(text)) !== null) {
                const startPosition = model.getPositionAt(match.index);
                const endPosition = model.getPositionAt(match.index + match[0].length);
                newDecorations.push({
                    range: new monaco.Range(startPosition.lineNumber, startPosition.column, endPosition.lineNumber, endPosition.column),
                    options: {
                        inlineClassName: 'entity-highlight',
                        hoverMessage: { value: `HTML Entity: ${match[0]}` }
                    }
                });
            }

            currentEntityDecorations = editor.deltaDecorations(currentEntityDecorations, newDecorations);
        }

        /**
         * Converts common character entities and named entities to their numeric HTML entity equivalents.
         * This function operates on an HTML string, parsing it to a temporary DOM, modifying text nodes,
         * and then serializing it back to a string, ensuring numeric entities are preserved.
         * It also handles preserving the XML declaration if present at the beginning.
         * @param {string} htmlString - The HTML string to process.
         * @returns {string} The processed HTML string with numeric entities.
         */
        function convertAllEntitiesToNumeric(htmlString) {
            let xmlDeclaration = '';
            let contentToProcess = htmlString;

            // Regex to find <?xml ...?> at the very beginning of the string, optionally with leading whitespace
            const xmlDeclRegex = /^\s*(<\?xml[^>]*\?>)/i;
            const match = htmlString.match(xmlDeclRegex);

            if (match) {
                xmlDeclaration = match[1]; // Capture the full XML declaration
                contentToProcess = htmlString.substring(match[0].length); // Get content after the declaration
            }

            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = contentToProcess; // Process only the HTML content

            const walker = document.createTreeWalker(
                tempDiv,
                NodeFilter.SHOW_TEXT,
                {
                    acceptNode: function(textNode) {
                        let parent = textNode.parentNode;
                        while (parent) {
                            const tagName = parent.tagName ? parent.tagName.toLowerCase() : '';
                            if (tagName === 'script' || tagName === 'style' || tagName === 'time') {
                                return NodeFilter.FILTER_REJECT;
                            }
                            parent = parent.parentNode;
                        }
                        return NodeFilter.FILTER_ACCEPT;
                    }
                },
                false
            );

            let currentNode;
            const textNodesToProcess = [];
            while (currentNode = walker.nextNode()) {
                textNodesToProcess.push(currentNode);
            }

            textNodesToProcess.forEach(textNode => {
                let text = textNode.nodeValue;
                // Replace specific named entities/characters with their numeric character references
                text = text.replace(/’/g, '&#8217;');    // literal ’
                text = text.replace(/&rsquo;/g, '&#8217;'); // &rsquo;
                text = text.replace(/“/g, '&#8220;');    // literal “
                text = text.replace(/&ldquo;/g, '&#8220;'); // &ldquo;
                text = text.replace(/”/g, '&#8221;');    // literal ”
                text = text.replace(/&rdquo;/g, '&#8221;'); // &rdquo;
                text = text.replace(/«/g, '&#171;');    // literal «
                text = text.replace(/&laquo;/g, '&#171;'); // &laquo;
                text = text.replace(/»/g, '&#187;');    // literal »
                text = text.replace(/&raquo;/g, '&#187;'); // &raquo;
                text = text.replace(/\u00A0/g, '&#160;'); // This converts literal NBSP char to numeric entity
                text = text.replace(/&nbsp;/g, '&#160;'); // This handles named NBSP entity to numeric

                textNode.nodeValue = text;
            });

            let processedHtml = tempDiv.innerHTML; // This re-serializes characters to entities

            // Final string-based replacements to ensure numeric entities are explicitly present
            processedHtml = processedHtml.replace(/&nbsp;/g, '&#160;');
            processedHtml = processedHtml.replace(/&rsquo;/g, '&#8217;');
            processedHtml = processedHtml.replace(/&ldquo;/g, '&#8220;');
            processedHtml = processedHtml.replace(/&rdquo;/g, '&#8221;');
            processedHtml = processedHtml.replace(/&laquo;/g, '&#171;');
            processedHtml = processedHtml.replace(/&raquo;/g, '&#187;');

            // Handle double encoding if it occurs (e.g., &amp;#160; -> &#160;)
            processedHtml = processedHtml.replace(/&amp;#(\d+);/g, '&#$1;');

            return xmlDeclaration + processedHtml; // Prepend the XML declaration back
        }

        /**
         * Helper function to apply placeholders for &nbsp; and &#160; and literal non-breaking space character.
         * @param {string} htmlString - The HTML string to process.
         * @returns {string} The HTML string with placeholders.
         */
        function applyNBSPPlaceholders(htmlString) {
            // Order matters: replace numeric first, then named, then literal char
            htmlString = htmlString.replace(/&#160;/g, NUMERIC_NBSP_ENTITY_PLACEHOLDER);
            htmlString = htmlString.replace(/&nbsp;/g, NBSP_ENTITY_PLACEHOLDER);
            htmlString = htmlString.replace(/\u00A0/g, LITERAL_NBSP_CHAR_PLACEHOLDER); // Handle literal non-breaking space character
            return htmlString;
        }

        /**
         * Helper function to revert placeholders back to their original &nbsp; or &#160; forms.
         * @param {string} htmlString - The HTML string with placeholders.
         * @returns {string} The HTML string with original entities restored.
         */
        function revertNBSPPlaceholders(htmlString) {
            htmlString = htmlString.replace(new RegExp(NBSP_ENTITY_PLACEHOLDER, 'g'), '&nbsp;');
            htmlString = htmlString.replace(new RegExp(NUMERIC_NBSP_ENTITY_PLACEHOLDER, 'g'), '&#160;');
            htmlString = htmlString.replace(new RegExp(LITERAL_NBSP_CHAR_PLACEHOLDER, 'g'), '\u00A0'); // Revert literal char
            return htmlString;
        }

        /**
         * Applies URL cleaning to HTML content.
         * Converts specific absolute URLs to relative paths and removes target/rel attributes from <a> tags.
         * Also removes <a> tags that ONLY contain a name attribute (i.e., no href).
         * @param {string} htmlString - The HTML content to clean.
         * @returns {string} The cleaned HTML content.
         */
        function applyUrlCleaning(htmlString) {
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = htmlString;

            const urlMappings = [
                { old: 'https://canada-preview.adobecqms.net/en/treasury-board-secretariat', new: '/content/canadasite/en/treasury-board-secretariat' },
                { old: 'https://canada-preview.adobecqms.net/fr/secretariat-conseil-tresor', new: '/content/canadasite/fr/secretariat-conseil-tresor' },
                { old: 'https://canada-preview.adobecqms.net/en/government', new: '/content/canadasite/en/government' },
                { old: 'https://canada-preview.adobecqms.net/fr/gouvernement', new: '/content/canadasite/fr/gouvernement' },
                { old: 'https://www.canada.ca/en/treasury-board-secretariat', new: '/content/canadasite/en/treasury-board-secretariat' },
                { old: 'https://www.canada.ca/fr/secretariat-conseil-tresor', new: '/content/canadasite/fr/secretaria-conseil-tresor' },
                { old: 'https://www.canada.ca/en/government', new: '/content/canadasite/en/government' },
                { old: 'https://www.canada.ca/fr/gouvernement', new: '/content/canadasite/fr/gouvernement' }
            ];

            // Patterns to prepend with /content/canadasite
            const prependPatterns = [
                '/en/treasury-board-secretariat', 'en/treasury-board-secretariat',
                '/fr/secretariat-conseil-tresor', 'fr/secretariat-conseil-tresor',
                '/en/government', 'en/government',
                '/fr/gouvernement', 'fr/gouvernement'
            ];

            const aElements = tempDiv.querySelectorAll('a');
            aElements.forEach(a => {
                let href = a.getAttribute('href');
                const name = a.getAttribute('name');

                // Case 1: Remove <a> tags that ONLY contain a name attribute (no href)
                if (name && !href) {
                    const parent = a.parentNode;
                    if (parent) {
                        // Move children out of the <a> tag
                        while (a.firstChild) {
                            parent.insertBefore(a.firstChild, a);
                        }
                        // Remove the <a> tag itself
                        parent.removeChild(a);
                    }
                    return; // Skip further processing for this <a> tag
                }

                // Case 2: Process <a> tags with href
                if (href) {
                    // Handle Outlook Safelinks
                    if (href.startsWith('https://can01.safelinks.protection.outlook.com')) {
                        try {
                            const urlObj = new URL(href);
                            const actualUrlParam = urlObj.searchParams.get('url');
                            if (actualUrlParam) {
                                // Decode the actual URL parameter to get the clean link
                                href = decodeURIComponent(actualUrlParam);
                                a.setAttribute('href', href);
                            }
                        } catch (e) {
                            console.error("Error parsing Outlook Safelink URL:", e);
                            // Fallback: If parsing fails, keep the original safelink or remove it
                            // For now, we'll just keep the original href if parsing fails.
                        }
                    }

                    // Rule: Prepend /content/canadasite to specific relative links
                    let prepended = false;
                    for (const pattern of prependPatterns) {
                        if (href.startsWith(pattern)) {
                            if (href.startsWith('/')) {
                                href = '/content/canadasite' + href;
                            } else {
                                href = '/content/canadasite/' + href;
                            }
                            a.setAttribute('href', href);
                            prepended = true;
                            break; // Stop after the first match
                        }
                    }

                    // If already prepended, skip other URL conversions for this link
                    if (prepended) {
                        // Remove target attribute
                        if (a.hasAttribute('target')) {
                            a.removeAttribute('target');
                        }

                        // Remove rel attribute
                        if (a.hasAttribute('rel')) {
                            a.removeAttribute('rel');
                        }
                        return;
                    }

                    // Specific handling for "/content/canadasite" or "/content/dam" links
                    if (href.includes('/content/canadasite') || href.includes('/content/dam')) {
                        const contentPath = href.includes('/content/canadasite') ? '/content/canadasite' : '/content/dam';
                        const contentIndex = href.indexOf(contentPath);
                        if (contentIndex !== 0) {
                            href = href.substring(contentIndex);
                        }
                        a.setAttribute('href', href);
                    } else {
                        // Convert other URLs using existing mappings
                        for (const mapping of urlMappings) {
                            if (href.startsWith(mapping.old)) {
                                href = href.replace(mapping.old, mapping.new);
                                a.setAttribute('href', href);
                                break; // Stop after the first match
                            }
                        }
                    }
                }

                // Remove target attribute
                if (a.hasAttribute('target')) {
                    a.removeAttribute('target');
                }

                // Remove rel attribute
                if (a.hasAttribute('rel')) {
                    a.removeAttribute('rel');
                }
            });

            return tempDiv.innerHTML;
        }

        /**
         * Validates HTML content.
         * @param {string} fullHtmlCode - The full HTML code from the editor.
         */
        async function validateHtmlContent(fullHtmlCode) {
            const validationResultsDiv = document.getElementById('validationResults');
            let htmlCodeToValidate = fullHtmlCode;
            let bodyContentOffsetIndex = 0; // The starting index of the body content within the full HTML

            // Try to extract content within <body> tags
            const bodyMatch = fullHtmlCode.match(/<body[^>]*>([\s\S]*?)<\/body>/i);
            if (bodyMatch && bodyMatch[1]) {
                htmlCodeToValidate = bodyMatch[1];
                // Calculate the starting index of the matched body content in the full HTML
                bodyContentOffsetIndex = fullHtmlCode.indexOf(bodyMatch[1], bodyMatch.index);
            } else {
                // If no body tags are found, treat the entire content as body content.
                htmlCodeToValidate = fullHtmlCode;
                bodyContentOffsetIndex = 0;
            }

            const errors = [];

            // Clear any existing line highlight in Monaco
            currentLineDecorations = editor.deltaDecorations(currentLineDecorations, []);

            // Show loading state immediately
            validationResultsDiv.classList.remove('bg-green-100', 'text-green-800', 'border-green-300', 'bg-red-100', 'text-red-800', 'border-red-300');
            validationResultsDiv.classList.add('bg-gray-50', 'text-gray-700', 'border-gray-200'); /* Reset to default gray */
            validationResultsDiv.innerHTML = '<p class="text-gray-500 text-center">Validating HTML... please wait.</p>';
            // Allow browser to render the loading state before starting heavy work
            await new Promise(resolve => setTimeout(resolve, 50));

            try {
                const parser = new DOMParser();

                let isXmlLikeDoc = false;
                const trimmedCode = fullHtmlCode.trim();
                // Check for <?xml declaration at the very beginning of the string, optionally with leading whitespace
                if (trimmedCode.startsWith('<?xml')) {
                    // Check if <doc> is the primary wrapper after the XML declaration
                    // This regex looks for <doc> at the start of the content after <?xml...?> and </doc> at the end
                    const docWrapperRegex = /^\s*<\?xml[^>]*\?>\s*<doc[^>]*>[\s\S]*<\/doc>\s*$/i;
                    if (docWrapperRegex.test(trimmedCode)) {
                        isXmlLikeDoc = true;
                    }
                }

                // If it's an XML-like document structure, enforce numerical entities
                if (isXmlLikeDoc) {
                    const namedEntityRegex = /&([a-zA-Z]+);/g; // Matches named entities like &nbsp;
                    let hasNamedEntities = false;
                    namedEntityRegex.lastIndex = 0; // Reset regex lastIndex for consistent behavior
                    while (namedEntityRegex.exec(fullHtmlCode) !== null) {
                        hasNamedEntities = true;
                        break; // Found at least one, no need to check further
                    }

                    if (hasNamedEntities) {
                        errors.push({
                            message: `XML Encoding Error: Named HTML entities are present. Convert to numerical entities.`,
                            lineNumber: 'N/A' // Generic error, not tied to a specific line
                        });
                    }
                }


                const tempDoc = parser.parseFromString(htmlCodeToValidate, 'text/html');

                const validAnchors = new Set();
                tempDoc.querySelectorAll('[id]').forEach(el => {
                    if (el.id) {
                        validAnchors.add(el.id);
                    }
                });
                tempDoc.querySelectorAll('[name]').forEach(el => {
                    const nameAttr = el.getAttribute('name');
                    if (nameAttr) {
                        validAnchors.add(nameAttr);
                    }
                });

                // FIX: Corrected regex to look for `id=` instead of `idid=`
                const idRegex = /\bid\s*=\s*(["'])(.*?)\1/g;
                const foundIds = new Map();

                let idMatch;
                idRegex.lastIndex = 0;
                while ((idMatch = idRegex.exec(htmlCodeToValidate)) !== null) {
                    const idValue = idMatch[2];
                    const absoluteIndex = bodyContentOffsetIndex + idMatch.index;
                    const idLineNumber = editor.getModel().getPositionAt(absoluteIndex).lineNumber;
                    const idInfo = { lineNumber: idLineNumber, index: absoluteIndex };

                    if (foundIds.has(idValue)) {
                        foundIds.get(idValue).push(idInfo);
                    } else {
                        foundIds.set(idValue, [idInfo]);
                    }
                }

                for (const [idValue, idInfos] of foundIds.entries()) {
                    if (idInfos.length > 1) {
                        errors.push({
                            message: `Duplicate ID: "${idValue}" found on lines: ${idInfos.map(info => info.lineNumber).join(', ')}.`,
                            lineNumber: idInfos[0].lineNumber
                        });
                    }
                }

                const liElements = tempDoc.querySelectorAll('li');
                liElements.forEach(li => {
                    if (li.parentNode && li.parentNode.tagName.toLowerCase() === 'li') {
                        const liOuterHtml = li.outerHTML;
                        let liIndexInBodyContent = htmlCodeToValidate.indexOf(liOuterHtml);
                        if (liIndexInBodyContent === -1) {
                            liIndexInBodyContent = htmlCodeToValidate.indexOf(`<${li.tagName.toLowerCase()}`);
                        }
                        if (liIndexInBodyContent !== -1) {
                            const absoluteLiIndex = bodyContentOffsetIndex + liIndexInBodyContent;
                            const liLineNumber = editor.getModel().getPositionAt(absoluteLiIndex).lineNumber;
                            errors.push({
                                message: `Line ${liLineNumber}: Improper list nesting: &lt;li&gt; cannot be directly nested within another &lt;li&gt;. It must be inside a &lt;ul&gt; or &lt;ol&gt;.`,
                                lineNumber: liLineNumber
                            });
                        }
                    }
                });

                const tagBoundaries = [];
                // Regex to capture HTML tags and processing instructions like <?xml ...?>
                const fullTagAndPIRegex = /<\/?[\w-]+(?:\s+[^>]*?)?>|<\?[\s\S]*?\?>/g;
                fullTagAndPIRegex.lastIndex = 0;
                let tagMatchForBoundaries; // Declare tagMatchForBoundaries here
                while ((tagMatchForBoundaries = fullTagAndPIRegex.exec(htmlCodeToValidate)) !== null) {
                    tagBoundaries.push({
                        start: tagMatchForBoundaries.index,
                        end: tagMatchForBoundaries[0].length > 0 ? tagMatchForBoundaries[0].length > 0 ? tagMatchForBoundaries.index + tagMatchForBoundaries[0].length - 1 : tagMatchForBoundaries.index : tagMatchForBoundaries.index
                    });
                }

                const entityBoundaries = [];
                const entityRegex = /&(?:[a-zA-Z]+|#\d+);/g;
                let entityMatch;
                entityRegex.lastIndex = 0;
                while ((entityMatch = entityRegex.exec(htmlCodeToValidate)) !== null) {
                    entityBoundaries.push({
                        start: entityMatch.index,
                        end: entityMatch.index + entityMatch[0].length - 1
                    });
                }

                const commentRegex = /\<!--[\s\S]*?-->/g;
                let commentMatch;
                commentRegex.lastIndex = 0;
                const commentBoundaries = [];
                while ((commentMatch = commentRegex.exec(htmlCodeToValidate)) !== null) {
                    commentBoundaries.push({
                        start: commentMatch.index,
                        end: commentMatch.index + commentMatch[0].length - 1
                    });
                }

                for (let i = 0; i < htmlCodeToValidate.length; i++) {
                    const char = htmlCodeToValidate[i];
                    const absoluteCharIndex = bodyContentOffsetIndex + i;
                    const lineNumber = editor.getModel().getPositionAt(absoluteCharIndex).lineNumber;

                    if (isWithinAnyRange(i, commentBoundaries)) {
                        continue;
                    }

                    // Check for processing instructions like <?xml ...?>
                    const piMatch = htmlCodeToValidate.substring(i).match(/^\<\?xml\s[\s\S]*?\?\>/i);
                    if (piMatch && piMatch.index === 0) { // If it's a processing instruction at the current index
                        i += piMatch[0].length - 1; // Skip past the entire processing instruction
                        continue;
                    }

                    if (char === '<') {
                        const isTagStart = isStartOfValidTag(i, tagBoundaries); // Fixed: Changed tagBoundCodes to tagBoundaries
                        const isEntityPart = isWithinAnyRange(i, entityBoundaries);

                        if (!isTagStart && !isEntityPart) {
                            let context = htmlCodeToValidate.substring(i, Math.min(i + 20, htmlCodeToValidate.length)).split('\n')[0].
                                trim();
                            errors.push({
                                message: `Line ${lineNumber}: Orphan '<' found. Possible malformed tag or extra character near: "${context}..."`,
                                lineNumber: lineNumber
                            });
                        }
                    } else if (char === '>') {
                        const isTagEnd = isEndOfValidTag(i, tagBoundaries); // Fixed: Changed tagBoundCodes to tagBoundaries
                        const isEntityPart = isWithinAnyRange(i, entityBoundaries);

                        if (!isTagEnd && !isEntityPart) {
                            let contextStart = Math.max(0, i - 20);
                            let context = htmlCodeToValidate.substring(contextStart, i + 1).split('\n').pop().
                                trim();
                            errors.push({
                                message: `Line ${lineNumber}: Orphan '>' found. Possible malformed tag or extra character near: "...${context}"`,
                                lineNumber: lineNumber
                            });
                        }
                    }
                }

                // Corrected regex to capture attributes string as match[2] and self-closing slash as match[3]
                const tagRegexForValidation = /<\/?([a-zA-Z0-9]+)(\s+[^>]*?)?(\/?)>/g;
                tagRegexForValidation.lastIndex = 0;
                const tagStack = [];

                let match;
                while ((match = tagRegexForValidation.exec(htmlCodeToValidate)) !== null) {
                    const fullTag = match[0];
                    const tagName = match[1].toLowerCase();
                    // Capture attributes string and trim any leading space
                    const attributesString = (match[2] || '').trim();
                    const isSelfClosingSyntax = match[3] === '/';

                    const absoluteMatchIndex = bodyContentOffsetIndex + match.index;
                    const lineNumber = editor.getModel().getPositionAt(absoluteMatchIndex).lineNumber;

                    if (isWithinAnyRange(match.index, commentBoundaries)) {
                        continue;
                    }

                    // Ignore tags specified in `ignoredTags` set
                    if (ignoredTags.has(tagName)) {
                        // If it's an opening tag, push a placeholder to balance the stack if needed,
                        // but don't apply other validation rules.
                        if (!fullTag.startsWith('</') && !isSelfClosingSyntax) {
                            tagStack.push({ tagName: tagName, lineNumber: lineNumber, ignored: true });
                        } else if (fullTag.startsWith('</')) {
                            // For closing ignored tags, try to pop a matching ignored tag
                            let found = false;
                            for (let i = tagStack.length - 1; i >= 0; i--) {
                                if (tagStack[i].tagName === tagName && tagStack[i].ignored) {
                                    tagStack.splice(i, 1); // Remove it
                                    found = true;
                                    break;
                                }
                            }
                            if (!found) {
                                // If no matching ignored tag found on stack, it's an unmatched closing tag
                                errors.push({
                                    message: `Line ${lineNumber}: Unmatched closing tag: &lt;/${tagName}&gt;. (Ignored tag)`,
                                    lineNumber: lineNumber
                                });
                            }
                        }
                        continue; // Skip all other validation for ignored tags
                    }


                    if (fullTag.startsWith('</')) {
                        if (tagStack.length === 0) {
                            errors.push({
                                message: `Line ${lineNumber}: Unmatched closing tag: &lt;/${tagName}&gt;`,
                                lineNumber: lineNumber
                            });
                        } else {
                            const lastOpenTag = tagStack.pop();
                            if (lastOpenTag.tagName !== tagName) {
                                errors.push({
                                    message: `Line ${lineNumber}: Mismatched closing tag: Expected &lt;/${lastOpenTag.tagName}&gt; (opened on line ${lastOpenTag.lineNumber}), but found &lt;/${tagName}&gt;.`,
                                    lineNumber: lineNumber
                                });
                            }
                        }
                    } else {
                        // Check for specific nesting rules
                        const parentTag = tagStack.length > 0 ? tagStack[tagStack.length - 1] : null;

                        if (tagName === 'chapter' && (!parentTag || parentTag.tagName !== 'chapters')) {
                            errors.push({
                                message: `Line ${lineNumber}: &lt;chapter&gt; tag must be directly nested within a &lt;chapters&gt; tag.`,
                                lineNumber: lineNumber
                            });
                        }
                        if (tagName === 'clause' && (!parentTag || parentTag.tagName !== 'clauses')) {
                            errors.push({
                                message: `Line ${lineNumber}: &lt;clause&gt; tag must be directly nested within a &lt;clauses&gt; tag.`,
                                lineNumber: lineNumber
                            });
                        }
                        if (tagName === 'appendix') {
                            // Check if <appendix> is within <appendices> at least once (initial nesting)
                            // Or if it's within another <appendix> (allowed nesting)
                            if (!parentTag || (parentTag.tagName !== 'appendices' && parentTag.tagName !== 'appendix')) {
                                errors.push({
                                    message: `Line ${lineNumber}: &lt;appendix&gt; tag must be directly nested within an &lt;appendices&gt; tag or another &lt;appendix&gt; tag.`,
                                  lineNumber: lineNumber
                                });
                            }
                        }


                        // New check: <appendices> or <appendix> should not be within <chapters>
                        if (tagName === 'appendices' || tagName === 'appendix') {
                            for (let i = tagStack.length - 1; i >= 0; i--) {
                                const ancestorTag = tagStack[i];
                                if (ancestorTag.tagName === 'chapters' || ancestorTag.tagName === 'chapter') {
                                    errors.push({
                                        message: `Line ${lineNumber}: Invalid nesting: &lt;${tagName}&gt; cannot be nested within &lt;${ancestorTag.tagName}&gt; (opened on line ${ancestorTag.lineNumber}). Appendices should be outside chapters.`,
                                        lineNumber: lineNumber
                                    });
                                    break; // Found an invalid ancestor, no need to check further up the stack
                                }
                            }
                        }


                        if (isSelfClosingSyntax && !selfClosingTags.has(tagName)) {
                            errors.push({
                                message: `Line ${lineNumber}: Invalid self-closing syntax for &lt;${tagName}&gt;. This tag should not be self-closed with '/>'.`,
                                lineNumber: lineNumber
                            });
                        }

                        if (deprecatedTags.has(tagName)) {
                            errors.push({
                                message: `Line ${lineNumber}: Deprecated tag: &lt;${tagName}&gt;. Consider using modern alternatives.`,
                                lineNumber: lineNumber
                            });
                        }

                        if (tagName === 'img') {
                            if (!/\balt\b/i.test(attributesString)) {
                                errors.push({
                                    message: `Line ${lineNumber}: &lt;img&gt; tag is missing the required 'alt' attribute for accessibility.`,
                                    lineNumber: lineNumber
                                });
                            }
                            if (!/\bsrc\b/i.test(attributesString)) {
                                errors.push({
                                    message: `Line ${lineNumber}: &lt;img&gt; tag is missing the required 'src' attribute.`,
                                    lineNumber: lineNumber
                                });
                            }
                        } else if (tagName === 'th') {
                            // Corrected logic: Check if EITHER scope OR id is present
                            if (!/\bscope\b/i.test(attributesString) && !/\bid\b/i.test(attributesString)) {
                                errors.push({
                                    message: `Line ${lineNumber}: &lt;th&gt; tag should have either a 'scope' or an 'id' attribute for accessibility.`,
                                    lineNumber: lineNumber
                                });
                            }
                        } else if (tagName === 'tr') {
                            if (/\bcolspan\b/i.test(attributesString) || /\browspan\b/i.test(attributesString)) {
                                errors.push({
                                    message: `Line ${lineNumber}: Invalid attribute: 'colspan' or 'rowspan' found on a &lt;tr&gt; tag. These attributes are only valid on &lt;th&gt; or &lt;td&gt; tags.`,
                                    lineNumber: lineNumber
                                });
                            }
                        }

                        if (/\balign\b/i.test(attributesString)) {
                            errors.push({
                                message: `Line ${lineNumber}: Deprecated attribute: 'align' found on &lt;${tagName}&gt;. Use CSS for alignment instead.`,
                                lineNumber: lineNumber
                            });
                        }

                        if ((/\bwidth\b/i.test(attributesString) || /\bheight\b/i.test(attributesString)) && !mediaSizingElements.has(tagName)) {
                            errors.push({
                                message: `Line ${lineNumber}: Improper attribute: 'width' or 'height' found on &lt;${tagName}&gt;. Consider using CSS for sizing this element.`,
                                lineNumber: lineNumber
                            });
                        }

                        if (/\btarget\b/i.test(attributesString) && !targetValidElements.has(tagName)) {
                            errors.push({
                                message: `Line ${lineNumber}: Improper attribute: 'target' found on &lt;${tagName}&gt;. The 'target' attribute is only valid on &lt;a&gt; or &lt;form&gt; tags.`,
                                lineNumber: lineNumber
                            });
                        }

                        if (tagName === 'a') {
                            const hrefMatch = attributesString.match(/\bhref\s*=\s*(["'])(.*?)\1/i);
                            if (hrefMatch) {
                                const href = hrefMatch[2];
                                if (href.startsWith('#') && href.length > 1) {
                                    const anchorId = href.substring(1);
                                    if (!validAnchors.has(anchorId)) {
                                        errors.push({
                                            message: `Line ${lineNumber}: Broken anchor link: &lt;a href="#${anchorId}"&gt; points to a non-existent ID or name attribute.`,
                                            lineNumber: lineNumber
                                        });
                                    }
                                }
                            }
                        }

                        if (tagStack.length > 0) {
                            const parentTag = tagStack[tagStack.length - 1];
                            // Only check nesting if parent is not an ignored tag
                            if (!parentTag.ignored && isInlineElement(parentTag.tagName) && isBlockElement(tagName)) {
                                errors.push({
                                    message: `Line ${lineNumber}: Invalid nesting: Block-level element &lt;${tagName}&gt; cannot be nested inside inline element &lt;${parentTag.tagName}&gt; (opened on line ${parentTag.lineNumber}).`,
                                    lineNumber: lineNumber
                                });
                            }
                        }

                        if (!selfClosingTags.has(tagName) && !isSelfClosingSyntax) {
                            tagStack.push({ tagName: tagName, lineNumber: lineNumber, index: absoluteMatchIndex });
                        }
                    }
                }

                while (tagStack.length > 0) {
                    const unclosedTag = tagStack.pop();
                    // Only report unclosed errors for non-ignored tags
                    if (!unclosedTag.ignored) {
                        errors.push({
                            message: `Line ${unclosedTag.lineNumber}: Unclosed tag: &lt;${unclosedTag.tagName}&gt;.`,
                            lineNumber: unclosedTag.lineNumber
                        });
                    }
                }
                return isXmlLikeDoc; // Return this to be used for button state
            } catch (e) {
                console.error("Error during HTML validation:", e);
                errors.push({
                    message: `An unexpected error occurred during HTML validation: ${e.message}. Please check your HTML for severe syntax issues.`,
                    lineNumber: 'N/A'
                });
                return false; // Assume not XML-like on error
            } finally {
                displayValidationResults(errors);
                highlightHtmlEntities(); // Always highlight HTML entities in HTML mode
            }
        }

        /**
         * Displays validation results in the UI.
         * @param {Array} errors - Array of error objects.
         */
        function displayValidationResults(errors) {
            const validationResultsDiv = document.getElementById('validationResults');
            validationResultsDiv.innerHTML = '';

            if (errors.length === 0) {
                validationResultsDiv.classList.remove('bg-red-100', 'text-red-800', 'border-red-300', 'bg-gray-50', 'text-gray-700', 'border-gray-200');
                validationResultsDiv.classList.add('bg-green-100', 'text-green-800', 'border-green-300');
                validationResultsDiv.innerHTML = '<p class="font-semibold text-center">🎉 Valid! No further adjustment needed. 🎉</p>';
            } else {
                validationResultsDiv.classList.remove('bg-green-100', 'text-green-800', 'border-green-300', 'bg-gray-50', 'text-gray-700', 'border-gray-200');
                validationResultsDiv.classList.add('bg-red-100', 'text-red-800', 'border-red-300');
                const errorList = document.createElement('ul');
                errorList.classList.add('list-disc', 'pl-5');
                errors.forEach(error => {
                    const listItem = document.createElement('li');
                    listItem.innerHTML = error.message;
                    // Only add data-lineNumber if it's a valid number for highlighting
                    if (typeof error.lineNumber === 'number') {
                        listItem.dataset.lineNumber = error.lineNumber;
                    }
                    errorList.appendChild(listItem);
                });
                validationResultsDiv.appendChild(errorList);
            }
            console.log("Validation errors:", errors); // For debugging
        }

        /**
         * Handles clicks on the validation error list items to highlight the line in Monaco.
         * @param {Event} event - The click event.
         */
        function handleResultClick(event) {
            const listItem = event.target.closest('li[data-line-number]');
            if (listItem) {
                const lineNumber = parseInt(listItem.dataset.lineNumber, 10);

                // Clear previous line decorations
                currentLineDecorations = editor.deltaDecorations(currentLineDecorations, []);

                // Apply new decoration for the clicked line
                currentLineDecorations = editor.deltaDecorations(currentLineDecorations, [
                    {
                        range: new monaco.Range(lineNumber, 1, lineNumber, editor.getModel().getLineMaxColumn(lineNumber)),
                        options: {
                            className: 'highlighted-line',
                            isOverviewRuler: true, // Show in overview ruler
                            overviewRulerLane: monaco.editor.OverviewRulerLane.Full,
                            overviewRulerColor: 'rgba(100, 149, 237, 0.6)' // Match the line highlight color
                        }
                    }
                ]);

                editor.revealLineInCenter(lineNumber);
                editor.focus();
            }
        }

        /**
         * Updates the disabled state of the "Validate" button based on the "Auto-Check" toggle.
         */
        function updateValidateButtonState() {
            if (toggleAutoCheckOnSwitch.checked) {
                validateNowBtn.disabled = true;
                validateNowBtn.classList.remove('bg-blue-700', 'hover:bg-blue-600');
                validateNowBtn.classList.add('bg-blue-400', 'cursor-not-allowed', 'opacity-60');
            } else {
                validateNowBtn.disabled = false;
                validateNowBtn.classList.remove('bg-blue-400', 'cursor-not-allowed', 'opacity-60');
                validateNowBtn.classList.add('bg-blue-700', 'hover:bg-blue-600');
            }
        }

        /**
         * Updates the disabled state of the "Preview" button based on whether the content is XML-like.
         * @param {boolean} isXmlLike - True if the content is detected as XML-like, false otherwise.
         */
        function updatePreviewButtonState(isXmlLike) {
            previewBtn.disabled = isXmlLike;
            if (isXmlLike) {
                previewBtn.classList.remove('bg-green-600', 'hover:bg-green-700');
                previewBtn.classList.add('bg-gray-400', 'cursor-not-allowed', 'opacity-60');
            } else {
                previewBtn.classList.remove('bg-gray-400', 'cursor-not-allowed', 'opacity-60');
                previewBtn.classList.add('bg-green-600', 'hover:bg-green-700');
            }
        }

        /**
         * Generates the full HTML content for the preview.
         * This function is now comprehensive and handles all preview options.
         * @param {object} options - Options for generating HTML (e.g., showSections, enableCss, etc.)
         * @param {boolean} forExport - If true, removes highlight CSS.
         * @returns {string} The complete HTML string.
         */
        function generateFullHtml(options, forExport = false) {
            const bodyContent = editor.getValue();
            let customH1Title = (options.currentLanguage === 'en' ? options.h1TitleEn : options.h1TitleFr).trim();

            if (customH1Title === '') {
                customH1Title = (options.currentLanguage === 'en') ? 'Canada.ca Page Title (EN)' : 'Titre de la page Canada.ca (FR)';
            }
            const pageTitle = customH1Title;

            let dynamicTitleHtml = '';
            if (options.showTitle) {
                if (options.currentFramework === 'wet' || options.currentFramework === 'wet+') {
                    dynamicTitleHtml = `<h1 property="name" id="wb-cont">${customH1Title}</h1>`;
                } else if (options.currentFramework === 'gcds') {
                    dynamicTitleHtml = `<gcds-heading tag="h1">${customH1Title}</gcds-heading>`;
                }
            }

            let bylineHtml = '';
            if (options.bylineMode === 'english') {
                if (options.currentFramework === 'wet' || options.currentFramework === 'wet+') {
                    bylineHtml = '<p class="gc-byline"><strong>From: <a href="/en/treasury-board-secretariat.html">Treasury Board of Canada of Canada Secretariat</a></strong></p>';
                } else if (options.currentFramework === 'gcds') {
                    bylineHtml = `<gcds-text><strong>From: <gcds-link href="/en/treasury-board-secretariat.html">Treasury Board of Canada of Canada Secretariat</gcds-link></strong></gcds-text>`;
                }
            } else if (options.bylineMode === 'french') {
                if (options.currentFramework === 'wet' || options.currentFramework === 'wet+') {
                    bylineHtml = '<p class="gc-byline"><strong>De : <a href="/fr/secretariat-conseil-tresor.html">Secrétariat du Conseil du Trésor du Canada</a></strong></p>';
                } else if (options.currentFramework === 'gcds') {
                    bylineHtml = `<gcds-text><strong>De : <gcds-link href="/fr/secretariat-conseil-tresor.html">Secrétariat du Conseil du Conseil du Trésor du Canada</gcds-link></strong></gcds-text>`;
                }
            }

            let h1AndBylineSection = `${dynamicTitleHtml}${bylineHtml}`;
            if ((options.currentFramework === 'gcds') && (dynamicTitleHtml || bylineHtml)) {
                h1AndBylineSection = `<section>${h1AndBylineSection}</section>`;
            }

            let contentToInject = options.useContainerDiv ? `<div class="container">${h1AndBylineSection}${bodyContent}</div>` : `${h1AndBylineSection}${bodyContent}`;

            const parser = new DOMParser();
            const tempDoc = parser.parseFromString(contentToInject, 'text/html');

            const localPrefixes = [
                '/content/canadasite/en/treasury-board-secretariat',
                '/content/canadasite/fr/secretariat-conseil-tresor',
                '/content/canadasite/en/government',
                '/content/canadasite/fr/gouvernement'
            ];

            const previewPrefixes = [
                'https://canada-preview.adobecqms.net/en/treasury-board-secretariat',
                'https://canada-preview.adobecqms.net/fr/secretariat-conseil-tresor',
                'https://canada-preview.adobecqms.net/en/government',
                'https://canada-preview.adobecqms.net/fr/gouvernement'
            ];

            const livePrefixes = [
                'https://www.canada.ca/en/treasury-board-secretariat',
                'https://www.canada.ca/fr/secretariat-conseil-tresor',
                'https://www.canada.ca/en/government',
                'https://www.canada.ca/fr/gouvernement'
            ];

            function replaceUrlPrefix(url, currentPrefixes, targetPrefixes) {
                for (let i = 0; i < currentPrefixes.length; i++) {
                    if (url.startsWith(currentPrefixes[i])) {
                        return targetPrefixes[i] + url.substring(currentPrefixes[i].length);
                    }
                }
                return url;
            }

            const images = tempDoc.querySelectorAll('img');
            images.forEach(img => {
                let src = img.getAttribute('src');
                if (src && !src.startsWith('http://') && !src.startsWith('https://') && !src.startsWith('//')) {
                    let baseUrl = '';
                    if (options.imageSourceMode === 'preview') baseUrl = 'https://canada-preview.adobecqms.net';
                    else if (options.imageSourceMode === 'live') baseUrl = 'https://www.canada.ca';
                    if (baseUrl) img.setAttribute('src', `${baseUrl}${src.startsWith('/') ? '' : '/'}${src}`);
                }
            });

            const links = tempDoc.querySelectorAll('a');
            links.forEach(link => {
                let href = link.getAttribute('href');
                if (href) {
                    if (href.startsWith('/') || href.startsWith('http://') || href.startsWith('https://')) {
                        if (options.urlSourceMode === 'local') {
                            href = replaceUrlPrefix(href, previewPrefixes, localPrefixes);
                            href = replaceUrlPrefix(href, livePrefixes, localPrefixes);
                        } else if (options.urlSourceMode === 'preview') {
                            href = replaceUrlPrefix(href, localPrefixes, previewPrefixes);
                            href = replaceUrlPrefix(href, livePrefixes, previewPrefixes);
                        } else if (options.urlSourceMode === 'live') {
                            href = replaceUrlPrefix(href, localPrefixes, livePrefixes);
                            href = replaceUrlPrefix(href, previewPrefixes, livePrefixes);
                        }
                        link.setAttribute('href', href);
                    }
                }
            });

            contentToInject = tempDoc.body.innerHTML;

            const bodyClassParts = [];
            // ONLY add highlight classes if not for export
            if (!forExport && options.showSections) {
                bodyClassParts.push('show-sections-outline');
            }
            if (!forExport && options.showHeadings) {
                bodyClassParts.push('show-headings-outline');
            }
            const bodyClass = bodyClassParts.filter(Boolean).join(' ');

            let cssLinks = '';
            if (options.enableCss) {
                if (options.currentFramework === 'wet') {
                    cssLinks = `
                        <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.4/css/all.css">
                        <link rel="stylesheet" href="https://www.canada.ca/etc/designs/canada/wet-boew/css/theme.min.css">
                    `;
                } else if (options.currentFramework === 'gcds') {
                    cssLinks = `
                        <link rel="stylesheet" href="https://cdn.design-system.alpha.canada.ca/@cdssnc/gcds-utility@latest/dist/gcds-utility.min.css">
                        <link rel="stylesheet" href="https://cdn.design-system.alpha.canada.ca/@cdssnc/gcds-components@latest/dist/gcds/gcds.css">
                    `;
                } else if (options.currentFramework === 'wet+') {
                    cssLinks = `
                        <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.4/css/all.css">
                        <link rel="stylesheet" href="https://www.canada.ca/etc/designs/canada/wet-boew/css/theme.min.css">
                        <link rel="stylesheet" href="https://cdn.design-system.alpha.canada.ca/@cdssnc/gcds-components@latest/dist/gcds/gcds.css">
                    `;
                }
            }

            let jsScripts = '';
            if (options.currentFramework === 'wet') {
                jsScripts = `
                    <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.2.4/jquery.min.js"><\/script>
                    <script src="https://www.canada.ca/etc/designs/canada/wet-boew/js/wet-boew.min.js"><\/script>
                    <script src="https://www.canada.ca/etc/designs/canada/wet-boew/js/theme.min.js"><\/script>
                `;
            } else if (options.currentFramework === 'gcds') {
                jsScripts = `
                    <script type="module" src="https://cdn.design-system.alpha.canada.ca/@cdssnc/gcds-components@latest/dist/gcds/gcds.esm.js"><\/script>
                    <script nomodule src="https://cdn.design-system.alpha.canada.ca/@cdssnc/gcds-components@latest/dist/gcds/gcds.js"><\/script>
                `;
            } else if (options.currentFramework === 'wet+') {
                jsScripts = `
                    <script type="module" src="https://cdn.design-system.alpha.canada.ca/@cdssnc/gcds-components@latest/dist/gcds/gcds.esm.js"><\/script>
                    <script nomodule src="https://cdn.design-system.alpha.canada.ca/@cdssnc/gcds-components@latest/dist/gcds/gcds.js"><\/script>
                    <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.2.4/jquery.min.js"><\/script>
                    <script src="https://www.canada.ca/etc/designs/canada/wet-boew/js/wet-boew.min.js"><\/script>
                    <script src="https://www.canada.ca/etc/designs/canada/wet-boew/js/theme.min.js"><\/script>
                `;
            }

            let mainContentWrapper = '';
            if (options.currentFramework === 'wet' || options.currentFramework === 'wet+') {
                mainContentWrapper = `
                    <main property="mainContentOfPage" resource="#wb-main" typeof="WebPageElement">
                        ${contentToInject}
                    </main>
                `;
            } else if (options.currentFramework === 'gcds') {
                mainContentWrapper = `
                    <gcds-container id="main-content" main-container size="xl" centered tag="main">
                        ${contentToInject}
                    </gcds-container>
                `;
            }

            return `
<!DOCTYPE html>
<html class="no-js" lang="${options.currentLanguage}" dir="ltr">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${pageTitle}</title>
    ${cssLinks}
    <style>
        body { text-align: left; font-family: 'Noto Sans', sans-serif; }
        /* Only include highlight CSS if not for export */
        ${!forExport ? `
        .show-sections-outline section { border: 2px dashed #007bff; padding: 10px; margin-bottom: 10px; box-sizing: border-box; }
        .show-sections-outline section:hover { background-color: rgba(0, 123, 255, 0.1); }

        /* Heading highlighting styles */
        .show-headings-outline h1,
        .show-headings-outline gcds-heading[tag="h1"] {
            border: 2px solid #FF0000; /* Red */
            background-color: rgba(255, 0, 0, 0.1);
            padding: 5px;
            margin-bottom: 5px;
            box-sizing: border-box;
        }
        .show-headings-outline h2,
        .show-headings-outline gcds-heading[tag="h2"] {
            border: 2px solid #FF7F00; /* Orange */
            background-color: rgba(255, 127, 0, 0.1);
            padding: 5px;
            margin-bottom: 5px;
            box-sizing: border-box;
        }
        .show-headings-outline h3,
        .show-heading[tag="h3"] {
            border: 2px solid #FFFF00; /* Yellow */
            background-color: rgba(255, 255, 0, 0.1);
            padding: 5px;
            margin-bottom: 5px;
            box-sizing: border-sizing;
        }
        .show-headings-outline h4,
        .show-headings-outline gcds-heading[tag="h4"] {
            border: 2px solid #00FF00; /* Lime Green */
            background-color: rgba(0, 255, 0, 0.1);
            padding: 5px;
            margin-bottom: 5px;
            box-sizing: border-box;
        }
        .show-headings-outline h5,
        .show-headings-outline gcds-heading[tag="h5"] {
            border: 2px solid #0000FF; /* Blue */
            background-color: rgba(0, 0, 255, 0.1);
            padding: 5px;
            margin-bottom: 5px;
            box-sizing: border-box;
        }
        .show-headings-outline h6,
        .show-headings-outline gcds-heading[tag="h6"] {
            border: 2px solid #4B0082; /* Indigo */
            background-color: rgba(75, 0, 130, 0.1);
            padding: 5px;
            margin-bottom: 5px;
            box-sizing: border-box;
        }

        .show-headings-outline h1:hover,
        .show-headings-outline h2:hover,
        .show-headings-outline h3:hover,
        .show-headings-outline h4:hover,
        .show-headings-outline h5:hover,
        .show-headings-outline h6:hover,
        .show-headings-outline gcds-heading[tag]:hover {
            opacity: 0.8; /* Slight opacity change on hover */
        }
        ` : ''}
        .table tbody tr.active { background-color: #e0f2f7; }
        .nowrap { white-space: nowrap; } /* For time tags */
    </style>
</head>
<body class="${bodyClass}">
    ${mainContentWrapper}
    ${jsScripts}
</body>
</html>`;
        }

        /**
         * Updates the content of the modal iframe.
         * This function now takes the modal-specific state variables.
         */
        function updateModalPreview() {
            const previewOptions = {
                showSections: modalShowSections,
                showHeadings: modalShowHeadings,
                useContainerDiv: modalUseContainerDiv,
                showTitle: modalShowTitle,
                imageSourceMode: modalImageSourceMode,
                bylineMode: modalBylineMode,
                enableCss: modalEnableCss,
                urlSourceMode: modalUrlSourceMode,
                currentLanguage: modalCurrentLanguage,
                currentFramework: modalCurrentFramework,
                h1TitleEn: modalH1TitleEn,
                h1TitleFr: modalH1TitleFr
            };
            const fullHtml = generateFullHtml(previewOptions);
            const iframeDocument = modalPreviewFrame.contentDocument || modalPreviewFrame.contentWindow.document;
            iframeDocument.open();
            iframeDocument.write(fullHtml);
            iframeDocument.close();

            // Apply breakpoint width to the iframe based on WET-BOEW common breakpoints
            let iframeWidth = '100%';
            switch (modalCurrentBreakpoint) {
                case 'xs': iframeWidth = '375px'; break; // Adjusted for small portrait phone
                case 'sm': iframeWidth = '640px'; break; // Adjusted for small tablet/larger phone landscape
                case 'md': iframeWidth = '992px'; break; // Min width for MD
                case 'full': iframeWidth = '100%'; break;
            }
            modalPreviewFrame.style.width = iframeWidth;
            // Center the iframe if it's not full width
            modalPreviewFrame.style.margin = (iframeWidth === '100%') ? '0 auto' : '0 auto';
        }

        /**
         * Shows the preview modal with the current editor content.
         */
        function showPreviewModal() {
            previewModal.classList.remove('hidden');
            // NO LONGER RESETTING MODAL STATE VARIABLES HERE. They persist globally.

            // Update modal UI controls to reflect initial state
            updateModalSettingsButtonStates();
            updateModalBylineButtonStates();
            updateModalImageSourceButtonStates();
            updateModalUrlSourceButtonStates();
            updateModalSectionHeadingButtonStates();
            updateModalWetGcdsButtonState();
            updateModalLanguageButtonStates();
            updateModalBreakpointButtonStates(); // Update breakpoint buttons
            // Set initial visibility of H1 title input container in modal
            modalH1TitleInputContainer.style.display = modalShowTitle ? 'block' : 'none';
            // Set initial value for H1 title input from persisted global variables
            modalH1TitleInput.value = (modalCurrentLanguage === 'en') ? modalH1TitleEn : modalH1TitleFr;

            updateModalPreview();
        }

        /**
         * Updates the disabled state of all interactive buttons.
         * Buttons are disabled if any button has 'data-temp-active' set to 'true'.
         */
        function updateAllInteractiveButtonStates() {
            const anyTempMessageActive = allInteractiveButtons.some(btn => btn.getAttribute('data-temp-active') === 'true');

            allInteractiveButtons.forEach(btn => {
                // If a button itself has 'data-temp-active', it means its modal is open, so it should be disabled.
                // Otherwise, it's disabled if ANY other button has 'data-temp-active'.
                btn.disabled = btn.getAttribute('data-temp-active') === 'true' || anyTempMessageActive;
            });
        }


        /**
         * Displays a modal dialog with a given message and interactive elements.
         * @param {string} title - The title of the modal.
         * @param {string} contentHtml - The HTML content for the modal body.
         * @param {HTMLElement} triggeringButton - The button that opened this modal.
         * @param {string} originalButtonText - The original text of the triggering button before "Opening...".
         */
        function showModal(title, contentHtml, triggeringButton, originalButtonText) {
            const modalOverlay = document.createElement('div');
            modalOverlay.className = 'modal-overlay';
            modalOverlay.innerHTML = `
                <div class="modal-content">
                    <h3>${title}</h3>
                    <div id="modalBody">${contentHtml}</div>
                    <div class="flex justify-end mt-4 space-x-2">
                        <button id="modalCancelBtn" class="px-4 py-2 bg-gray-600 text-white rounded-md hover:bg-gray-700">Cancel</button>
                        <button id="modalInsertBtn" class="px-4 py-2 bg-green-600 text-white rounded-md hover:bg-green-700">Insert</button>
                    </div>
                </div>
            `;
            document.body.appendChild(modalOverlay);

            // Close modal on outside click
            modalOverlay.addEventListener('click', (event) => {
                if (event.target === modalOverlay) {
                    closeModalAndReEnableButtons();
                }
            });

            // Function to clean up and re-enable buttons
            function closeModalAndReEnableButtons() {
                modalOverlay.remove();
                triggeringButton.removeAttribute('data-temp-active'); // Crucial: Remove flag
                // Directly revert the button text and color here
                triggeringButton.textContent = originalButtonText;
                triggeringButton.classList.remove('bg-green-500', 'hover:bg-green-600');
                triggeringButton.classList.add('bg-gray-700', 'hover:bg-gray-600'); // Revert to default gray
                updateAllInteractiveButtonStates(); // Re-enable all buttons
            }

            document.getElementById('modalCancelBtn').addEventListener('click', closeModalAndReEnableButtons);

            // Get references to elements within the newly created modal
            const langEnglishBtn = document.getElementById('langEnglishBtn');
            const langFrenchBtn = document.getElementById('langFrenchBtn');
            const monarchKingBtn = document.getElementById('monarchKingBtn');
            const monarchQueenBtn = document.getElementById('monarchQueenBtn');
            const idISBNBtn = document.getElementById('idISBNBtn');
            const idISSNBtn = document.getElementById('idISSNBtn');
            const colophonYearInput = document.getElementById('colophonYear');
            const colophonNumberInput = document.getElementById('colophonNumber'); // Reference for the number input
            const modalInsertBtn = document.getElementById('modalInsertBtn');

            let selectedLanguage = 'English'; // Default to English
            let selectedMonarch = 'King'; // Default
            let selectedIdentifier = 'ISBN'; // Default

            // Function to update button active state
            function updateButtonActiveState(buttons, activeBtn) {
                buttons.forEach(btn => {
                    btn.classList.remove('active', 'bg-indigo-600');
                    btn.classList.add('bg-gray-600', 'hover:bg-gray-500');
                });
                activeBtn.classList.add('active', 'bg-indigo-600');
                activeBtn.classList.remove('bg-gray-600', 'hover:bg-gray-500');
            }

            // Initial active states
            updateButtonActiveState([langEnglishBtn, langFrenchBtn], langEnglishBtn);
            updateButtonActiveState([monarchKingBtn, monarchQueenBtn], monarchKingBtn);
            updateButtonActiveState([idISBNBtn, idISSNBtn], idISBNBtn);

            // Event listeners for language buttons
            langEnglishBtn.addEventListener('click', () => {
                selectedLanguage = 'English';
                updateButtonActiveState([langEnglishBtn, langFrenchBtn], langEnglishBtn);
            });

            langFrenchBtn.addEventListener('click', () => {
                selectedLanguage = 'French';
                updateButtonActiveState([langEnglishBtn, langFrenchBtn], langFrenchBtn);
            });

            // Event listeners for Monarch toggle
            monarchKingBtn.addEventListener('click', () => {
                selectedMonarch = 'King';
                updateButtonActiveState([monarchKingBtn, monarchQueenBtn], monarchKingBtn);
            });

            monarchQueenBtn.addEventListener('click', () => {
                selectedMonarch = 'Queen';
                updateButtonActiveState([monarchKingBtn, monarchQueenBtn], monarchQueenBtn);
            });

            // Event listeners for ISBN/ISSN toggle
            idISBNBtn.addEventListener('click', () => {
                selectedIdentifier = 'ISBN';
                updateButtonActiveState([idISBNBtn, idISSNBtn], idISBNBtn);
            });

            idISSNBtn.addEventListener('click', () => {
                selectedIdentifier = 'ISSN';
                updateButtonActiveState([idISBNBtn, idISSNBtn], idISSNBtn);
            });

            // Year input validation
            colophonYearInput.addEventListener('input', (event) => {
                const input = event.target;
                // Remove any non-digit characters
                input.value = input.value.replace(/\D/g, '');
                // Truncate to 4 digits if longer
                if (input.value.length > 4) {
                    input.value = input.value.substring(0, 4);
                }
            });

            // Insert button logic
            modalInsertBtn.addEventListener('click', async () => { // Made async for validation
                const currentYear = new Date().getFullYear();
                const year = colophonYearInput.value || currentYear;
                const number = colophonNumberInput.value || '###';
                let colophonHtmlContent = `<section id="colophon">\n<p class="mrgn-tp-lg text-center small">© `;

                if (selectedLanguage === 'English') {
                    if (selectedMonarch === 'King') {
                        colophonHtmlContent += `His Majesty the King in Right of Canada, represented by the President of the Treasury Board, ${year},<br>${selectedIdentifier}:&#160;${number}</p>\n</section>`;
                    } else { // Queen
                        colophonHtmlContent += `Her Majesty the Queen in Right of Canada, represented by the President of the Treasury Board, ${year},<br>${selectedIdentifier}:&#160;${number}</p>\n</section>`;
                    }
                } else { // French
                    if (selectedMonarch === 'King') {
                        colophonHtmlContent += `Sa Majesté le Roi du chef du Canada, représenté par le président du Conseil du Trésor, ${year},<br>${selectedIdentifier}&#160;:&#160;${number}</p>\n</section>`;
                    } else { // Queen
                        colophonHtmlContent += `Sa Majesté la Reine du chef du Canada, représentée par le président du Conseil du Conseil du Trésor, ${year},<br>${selectedIdentifier}&#160;:&#160;${number}</p>\n</section>`;
                    }
                }

                // Insert the generated HTML into the Monaco editor
                if (editor) {
                    let currentContent = editor.getValue();

                    // Append the new colophon HTML
                    currentContent += colophonHtmlContent;

                    editor.setValue(currentContent);
                    highlightHtmlEntities(); // Fixed: Changed applyEntityHighlighting to highlightHtmlEntities

                    if (isAutoCheckEnabled) { // Re-validate if auto-check is on
                        const isXmlLike = await validateHtmlContent(editor.getValue()); // Await validation
                        updatePreviewButtonState(isXmlLike); // Update preview button state
                    }
                }

                closeModalAndReEnableButtons(); // Cleanup and re-enable immediately

                // Capture originalButtonText in a local constant for the setTimeout closure
                const capturedOriginalText = originalButtonText;

                // Provide visual feedback for the triggering button only after successful insert
                triggeringButton.textContent = 'Inserted!';
                triggeringButton.classList.add('bg-green-500', 'hover:bg-green-600');
                triggeringButton.classList.remove('bg-gray-700', 'hover:bg-gray-600'); // Revert to default gray
                // The disabled state is managed by updateAllInteractiveButtonStates()
                setTimeout(() => {
                    triggeringButton.textContent = capturedOriginalText; // Revert to initial text
                    triggeringButton.classList.remove('bg-green-500', 'hover:bg-green-600');
                    triggeringButton.classList.add('bg-gray-700', 'hover:bg-gray-600'); // Revert to default gray
                }, 1500);
            });
        }


        // Functions to update button states for the MODAL preview controls
        function updateModalSettingsButtonStates() {
            const settingsButtons = [modalToggleContainerBtn, modalToggleTitleBtn, modalToggleCssBtn];
            settingsButtons.forEach(btn => {
                btn.classList.remove('active', 'bg-indigo-600', 'hover:bg-indigo-700', 'bg-gray-600', 'hover:bg-gray-700', 'bg-red-600', 'hover:bg-red-700');
                btn.classList.add('bg-gray-700', 'hover:bg-gray-600');
            });

            if (modalUseContainerDiv) {
                modalToggleContainerBtn.classList.add('active', 'bg-indigo-600', 'hover:bg-indigo-700');
                modalToggleContainerBtn.classList.remove('bg-gray-700', 'hover:bg-gray-600');
            } else {
                modalToggleContainerBtn.classList.add('bg-gray-700', 'hover:bg-gray-600');
            }
            if (modalShowTitle) {
                modalToggleTitleBtn.classList.add('active', 'bg-indigo-600', 'hover:bg-indigo-700');
                modalToggleTitleBtn.classList.remove('bg-gray-700', 'hover:bg-gray-600');
            } else {
                modalToggleTitleBtn.classList.add('bg-gray-700', 'hover:bg-gray-600');
            }
            if (modalEnableCss) {
                modalToggleCssBtn.classList.add('bg-gray-700', 'hover:bg-gray-600');
                modalToggleCssBtn.textContent = 'Disable CSS';
            } else {
                modalToggleCssBtn.classList.add('bg-red-600', 'hover:bg-red-700');
                modalToggleCssBtn.textContent = 'Enable CSS';
            }
        }

        function updateModalBylineButtonStates() {
            const bylineButtons = [modalNoneBylineBtn, modalEnglishBylineBtn, modalFrenchBylineBtn];
            bylineButtons.forEach(btn => {
                btn.classList.remove('active', 'bg-indigo-600', 'hover:bg-indigo-700', 'bg-gray-600', 'hover:bg-gray-700');
                btn.classList.add('bg-gray-700', 'hover:bg-gray-600');
            });

            if (modalBylineMode === 'none') {
                modalNoneBylineBtn.classList.add('active', 'bg-indigo-600', 'hover:bg-indigo-700');
                modalNoneBylineBtn.classList.remove('bg-gray-700', 'hover:bg-gray-600');
            } else if (modalBylineMode === 'english') {
                modalEnglishBylineBtn.classList.add('active', 'bg-indigo-600', 'hover:bg-indigo-700');
                modalEnglishBylineBtn.classList.remove('bg-gray-700', 'hover:bg-gray-600');
            } else if (modalBylineMode === 'french') {
                modalFrenchBylineBtn.classList.add('active', 'bg-indigo-600', 'hover:bg-indigo-700');
                modalFrenchBylineBtn.classList.remove('bg-gray-700', 'hover:bg-gray-600');
            }
            // Ensure correct byline button visibility based on modalCurrentLanguage
            modalEnglishBylineBtn.style.display = (modalCurrentLanguage === 'en') ? 'inline-block' : 'none';
            modalFrenchBylineBtn.style.display = (modalCurrentLanguage === 'fr') ? 'inline-block' : 'none';
            modalNoneBylineBtn.style.display = 'inline-block'; // Always show None
        }

        function updateModalImageSourceButtonStates() {
            const imageSourceButtons = [modalLocalImagesBtn, modalPreviewImagesBtn, modalToggleLiveImagesBtn];
            imageSourceButtons.forEach(btn => {
                btn.classList.remove('active', 'bg-indigo-600', 'hover:bg-indigo-700', 'bg-gray-600', 'hover:bg-gray-700');
                btn.classList.add('bg-gray-700', 'hover:bg-gray-600');
            });

            if (modalImageSourceMode === 'local') {
                modalLocalImagesBtn.classList.add('active', 'bg-indigo-600', 'hover:bg-indigo-700');
                modalLocalImagesBtn.classList.remove('bg-gray-700', 'hover:bg-gray-600');
            } else if (modalImageSourceMode === 'preview') {
                modalPreviewImagesBtn.classList.add('active', 'bg-indigo-600', 'hover:bg-indigo-700');
                modalPreviewImagesBtn.classList.remove('bg-gray-700', 'hover:bg-gray-600');
            } else if (modalImageSourceMode === 'live') {
                modalToggleLiveImagesBtn.classList.add('active', 'bg-indigo-600', 'hover:bg-indigo-700');
                modalToggleLiveImagesBtn.classList.remove('bg-gray-700', 'hover:bg-gray-600');
            }
        }

        function updateModalUrlSourceButtonStates() {
            const urlSourceButtons = [modalLocalUrlsBtn, modalPreviewUrlsBtn, modalToggleLiveUrlsBtn];
            urlSourceButtons.forEach(btn => {
                btn.classList.remove('active', 'bg-indigo-600', 'hover:bg-indigo-700', 'bg-gray-600', 'hover:bg-gray-700');
                btn.classList.add('bg-gray-700', 'hover:bg-gray-600');
            });

            if (modalUrlSourceMode === 'local') {
                modalLocalUrlsBtn.classList.add('active', 'bg-indigo-600', 'hover:bg-indigo-700');
                modalLocalUrlsBtn.classList.remove('bg-gray-700', 'hover:bg-gray-600');
            } else if (modalUrlSourceMode === 'preview') {
                modalPreviewUrlsBtn.classList.add('active', 'bg-indigo-600', 'hover:bg-indigo-700');
                modalPreviewUrlsBtn.classList.remove('bg-gray-700', 'hover:bg-gray-600');
            } else if (modalUrlSourceMode === 'live') {
                modalToggleLiveUrlsBtn.classList.add('active', 'bg-indigo-600', 'hover:bg-indigo-700');
                modalToggleLiveUrlsBtn.classList.remove('bg-gray-700', 'hover:bg-gray-600');
            }
        }

        function updateModalSectionHeadingButtonStates() {
            if (modalShowSections) {
                modalToggleSectionsBtn.classList.add('active'); /* Use active class for yellow */
                modalToggleSectionsBtn.classList.remove('bg-gray-700', 'text-white', 'hover:bg-gray-600');
            } else {
                modalToggleSectionsBtn.classList.remove('active');
                modalToggleSectionsBtn.classList.add('bg-gray-700', 'text-white', 'hover:bg-gray-600');
            }
            if (modalShowHeadings) {
                modalToggleHeadingsBtn.classList.add('active'); /* Use active class for yellow */
                modalToggleHeadingsBtn.classList.remove('bg-gray-700', 'text-white', 'hover:bg-gray-600');
            } else {
                modalToggleHeadingsBtn.classList.remove('active');
                modalToggleHeadingsBtn.classList.add('bg-gray-700', 'text-white', 'hover:bg-gray-600');
            }
        }

        function updateModalWetGcdsButtonState() {
            modalWetGcdsToggleBtn.classList.remove('bg-blue-600', 'hover:bg-blue-700', 'bg-indigo-600', 'hover:bg-indigo-700', 'active');
            modalWetGcdsToggleBtn.classList.remove('font-bold', 'underline');

            if (modalCurrentFramework === 'wet') {
                modalWetGcdsToggleBtn.classList.add('active', 'bg-blue-600', 'hover:bg-blue-700');
                modalWetGcdsToggleBtn.textContent = 'WET4';
            } else if (modalCurrentFramework === 'gcds') {
                modalWetGcdsToggleBtn.classList.add('active', 'bg-indigo-600', 'hover:bg-indigo-700');
                modalWetGcdsToggleBtn.textContent = 'GCDS';
            } else if (modalCurrentFramework === 'wet+') {
                modalWetGcdsToggleBtn.classList.add('active', 'bg-indigo-600', 'hover:bg-indigo-700');
                modalWetGcdsToggleBtn.innerHTML = '<strong><u>WET+</u></strong>';
            }
        }

        function updateModalLanguageButtonStates() {
            // Remove active classes from both first
            modalLangEnBtn.classList.remove('active', 'bg-indigo-600', 'hover:bg-indigo-700');
            modalLangFrBtn.classList.remove('active', 'bg-indigo-600', 'hover:bg-indigo-700');

            // Apply default inactive styles
            modalLangEnBtn.classList.add('bg-gray-700', 'hover:bg-gray-600');
            modalLangFrBtn.classList.add('bg-gray-700', 'hover:bg-gray-600');

            // Apply active styles to the currently selected language button
            if (modalCurrentLanguage === 'en') {
                modalLangEnBtn.classList.add('active', 'bg-indigo-600', 'hover:bg-indigo-700');
                modalH1TitleInput.placeholder = 'e.g., My Custom ENG Title';
                modalH1TitleInput.value = modalH1TitleEn;
            } else {
                modalLangFrBtn.classList.add('active', 'bg-indigo-600', 'hover:bg-indigo-700');
                modalH1TitleInput.placeholder = 'e.g., My Custom FRA Title';
                modalH1TitleInput.value = modalH1TitleFr;
            }
            updateModalBylineButtonStates(); // Re-render byline buttons based on new bylineMode
        }

        function updateModalBreakpointButtonStates() {
            const breakpointButtons = [modalBreakpointXsBtn, modalBreakpointSmBtn, modalBreakpointMdBtn, modalBreakpointFullBtn]; // Removed modalBreakpointLgBtn
            breakpointButtons.forEach(btn => {
                btn.classList.remove('active', 'bg-indigo-600', 'hover:bg-indigo-700');
                btn.classList.add('bg-gray-700', 'hover:bg-gray-600');
            });

            if (modalCurrentBreakpoint === 'xs') {
                modalBreakpointXsBtn.classList.add('active', 'bg-indigo-600', 'hover:bg-indigo-700');
            } else if (modalCurrentBreakpoint === 'sm') {
                modalBreakpointSmBtn.classList.add('active', 'bg-indigo-600', 'hover:bg-indigo-700');
            } else if (modalCurrentBreakpoint === 'md') {
                modalBreakpointMdBtn.classList.add('active', 'bg-indigo-600', 'hover:bg-indigo-700');
            } else if (modalCurrentBreakpoint === 'full') {
                modalBreakpointFullBtn.classList.add('active', 'bg-indigo-600', 'hover:bg-indigo-700');
            }
        }


        // Initialize Monaco Editor and set up event listeners on window load
        window.onload = function() {
            // Configure Monaco loader
            require.config({ paths: { 'vs': 'https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.29.1/min/vs' } });
            require(['vs/editor/editor.main'], function() {
                const monacoEditorContainer = document.getElementById('monacoEditorContainer');

                // Initialize HTML model with empty content
                htmlModel = monaco.editor.createModel(
                    ``, // Removed placeholder code
                    'html'
                );

                // Create the editor with the HTML model
                editor = monaco.editor.create(monacoEditorContainer, {
                    model: htmlModel, // Start with HTML model
                    theme: 'vs-dark',
                    automaticLayout: true,
                    minimap: { enabled: true },
                    wordWrap: 'on' // Enable word wrap
                });

                // Event listener for clicking on validation results to highlight line
                validationResultsDiv.addEventListener('click', handleResultClick);

                // Automatic debounced validation and entity highlighting on editor content change
                const debouncedValidateAndHighlight = debounce(async () => { // Made async to await validation result
                    if (isAutoCheckEnabled) { // Only run validation if auto-check is enabled
                        const isXmlLike = await validateHtmlContent(editor.getValue());
                        updatePreviewButtonState(isXmlLike); // Update preview button state after validation
                    }
                }, 500);
                editor.onDidChangeModelContent(debouncedValidateAndHighlight);

                // Initial validation and highlighting on load
                // Call validateHtmlContent and then update the preview button state
                validateHtmlContent(editor.getValue()).then(isXmlLike => {
                    updatePreviewButtonState(isXmlLike);
                });
                highlightHtmlEntities();
                updateValidateButtonState(); // Initial state for validate button

                // Monaco handles its own resizing with automaticLayout: true, but a manual refresh
                // can still be useful if the container itself changes size in ways Monaco doesn't detect.
                window.addEventListener('resize', () => {
                    editor.layout(); // Tell Monaco to re-layout
                });

                // --- Add event listeners for main editor buttons ---

                // Auto-Check Toggle listener
                toggleAutoCheckOnSwitch.addEventListener('change', async (event) => { // Made async
                    isAutoCheckEnabled = event.target.checked;
                    const parentLabel = event.target.closest('.toggle-switch');
                    if (isAutoCheckEnabled) {
                        parentLabel.classList.add('is-checked');
                        const isXmlLike = await validateHtmlContent(editor.getValue()); // Await validation
                        updatePreviewButtonState(isXmlLike); // Update preview button state
                    } else {
                        parentLabel.classList.remove('is-checked');
                    }
                    updateValidateButtonState(); // Update validate button state
                });

                // Validate Now button listener
                validateNowBtn.addEventListener('click', async () => { // Made async
                    const isXmlLike = await validateHtmlContent(editor.getValue()); // Await validation
                    updatePreviewButtonState(isXmlLike); // Update preview button state
                    const originalText = validateNowBtn.textContent;
                    validateNowBtn.textContent = 'Validated!';
                    validateNowBtn.classList.add('bg-green-500', 'hover:bg-green-600');
                    validateNowBtn.classList.remove('bg-blue-700', 'hover:bg-blue-600');
                    validateNowBtn.disabled = true; // Disable temporarily
                    validateNowBtn.setAttribute('data-temp-active', 'true');
                    updateAllInteractiveButtonStates();
                    setTimeout(() => {
                        validateNowBtn.textContent = originalText;
                        validateNowBtn.classList.remove('bg-green-500', 'hover:bg-green-600');
                        validateNowBtn.classList.add('bg-blue-700', 'hover:bg-blue-600');
                        validateNowBtn.disabled = false; // Re-enable the button
                        validateNowBtn.removeAttribute('data-temp-active');
                        updateAllInteractiveButtonStates();
                        updateValidateButtonState(); // Re-enable based on toggle
                    }, 1500);
                });

                // Preview button listener
                previewBtn.addEventListener('click', showPreviewModal);
                
                // Close preview modal on outside click
                previewModal.addEventListener('click', (event) => {
                    if (event.target === previewModal) {
                        previewModal.classList.add('hidden');
                    }
                });

                closePreviewModalBtn.addEventListener('click', () => {
                    previewModal.classList.add('hidden');
                });

                // Escape key to close modal
                document.addEventListener('keydown', (event) => {
                    if (event.key === 'Escape' && !previewModal.classList.contains('hidden')) {
                        closePreviewModalBtn.click();
                    }
                });

                // Auto-Encode button
                autoEncodeBtn.addEventListener('click', async () => { // Made async
                    if (editor) {
                        const originalText = autoEncodeBtn.textContent;
                        const model = editor.getModel();
                        const fullRange = model.getFullModelRange();
                        let htmlContent = model.getValue();
                        let encodedHtml = convertAllEntitiesToNumeric(htmlContent);

                        // Push the edit operation to the undo/redo stack
                        editor.pushUndoStop(); // Start an undo stop
                        model.pushEditOperations(
                            [], // No selections to change
                            [{
                                range: fullRange,
                                text: encodedHtml
                            }],
                            () => null // No new selection needed
                        );
                        editor.pushUndoStop(); // End an undo stop

                        autoEncodeBtn.textContent = 'Encoded!';
                        autoEncodeBtn.classList.add('bg-green-500', 'hover:bg-green-600');
                        autoEncodeBtn.classList.remove('bg-red-600', 'hover:bg-red-700');
                        autoEncodeBtn.disabled = true; // Disable the button
                        autoEncodeBtn.setAttribute('data-temp-active', 'true'); // Mark as active
                        updateAllInteractiveButtonStates(); // Update all buttons
                        setTimeout(() => {
                            autoEncodeBtn.textContent = originalText;
                            autoEncodeBtn.classList.remove('bg-green-500', 'hover:bg-green-600');
                            autoEncodeBtn.classList.add('bg-red-600', 'hover:bg-red-700');
                            autoEncodeBtn.disabled = false; // Re-enable the button
                            autoEncodeBtn.removeAttribute('data-temp-active'); // Unmark as active
                            updateAllInteractiveButtonStates(); // Update all buttons
                        }, 1500);
                        if (isAutoCheckEnabled) { // Re-validate if auto-check is on
                            const isXmlLike = await validateHtmlContent(editor.getValue()); // Await validation
                            updatePreviewButtonState(isXmlLike); // Update preview button state
                        }
                    }
                });

                // Auto-Indent button
                autoFormatBtn.addEventListener('click', async () => { // Made async
                    if (editor && typeof html_beautify === 'function') {
                        const originalText = autoFormatBtn.textContent;
                        const model = editor.getModel();
                        const fullRange = model.getFullModelRange();
                        const formattedCode = html_beautify(model.getValue(), { indent_size: 4, indent_char: ' ' });

                        // Push the edit operation to the undo/redo stack
                        editor.pushUndoStop(); // Start an undo stop
                        model.pushEditOperations(
                            [], // No selections to change
                            [{
                                range: fullRange,
                                text: formattedCode
                            }],
                            () => null // No new selection needed
                        );
                        editor.pushUndoStop(); // End an undo stop

                        autoFormatBtn.textContent = 'Formatted!';
                        autoFormatBtn.classList.add('bg-green-500', 'hover:bg-green-600');
                        autoFormatBtn.classList.remove('bg-red-600', 'hover:bg-red-700');
                        autoFormatBtn.disabled = true; // Disable the button
                        autoFormatBtn.setAttribute('data-temp-active', 'true'); // Mark as active
                        updateAllInteractiveButtonStates(); // Update all buttons
                        setTimeout(() => {
                            autoFormatBtn.textContent = originalText;
                            autoFormatBtn.classList.remove('bg-green-500', 'hover:bg-green-600');
                            autoFormatBtn.classList.add('bg-red-600', 'hover:bg-red-700');
                            autoFormatBtn.disabled = false; // Re-enable the button
                            autoFormatBtn.removeAttribute('data-temp-active'); // Unmark as active
                            updateAllInteractiveButtonStates(); // Update all buttons
                        }, 1500);
                        if (isAutoCheckEnabled) { // Re-validate if auto-check is on
                            const isXmlLike = await validateHtmlContent(editor.getValue()); // Await validation
                            updatePreviewButtonState(isXmlLike); // Update preview button state
                        }
                    } else {
                        console.error('js-beautify library not loaded.');
                        // In a real app, you might show a user-friendly message here instead of console.error
                    }
                });

                // Copy Code button
                copyCodeBtn.addEventListener('click', async () => {
                    if (editor) {
                        const originalText = copyCodeBtn.textContent;
                        const codeContent = editor.getValue();
                        try {
                            // Use document.execCommand('copy') for broader iframe compatibility
                            const tempTextArea = document.createElement('textarea');
                            tempTextArea.value = codeContent;
                            document.body.appendChild(tempTextArea);
                            tempTextArea.select();
                            document.execCommand('copy');
                            document.body.removeChild(tempTextArea);

                            copyCodeBtn.textContent = 'Copied!';
                            copyCodeBtn.classList.add('bg-green-500', 'hover:bg-green-600');
                            copyCodeBtn.classList.remove('bg-gray-700', 'hover:bg-gray-600');
                            copyCodeBtn.disabled = true; // Disable the button
                            copyCodeBtn.setAttribute('data-temp-active', 'true'); // Mark as active
                            updateAllInteractiveButtonStates(); // Update all buttons
                            setTimeout(() => {
                                copyCodeBtn.textContent = originalText;
                                copyCodeBtn.classList.remove('bg-green-500', 'hover:bg-green-600');
                                copyCodeBtn.classList.add('bg-gray-700', 'hover:bg-gray-600');
                                copyCodeBtn.disabled = false; // Re-enable the button
                                copyCodeBtn.removeAttribute('data-temp-active'); // Unmark as active
                                updateAllInteractiveButtonStates(); // Update all buttons
                            }, 1500);
                        } catch (err) {
                            console.error('Failed to copy text: ', err);
                            // Provide user feedback without alert()
                            copyCodeBtn.textContent = 'Copy Failed!';
                            copyCodeBtn.classList.add('bg-red-500', 'hover:bg-red-600');
                            copyCodeBtn.classList.remove('bg-gray-700', 'hover:bg-gray-600');
                            copyCodeBtn.disabled = false; // Re-enable the button
                            copyCodeBtn.removeAttribute('data-temp-active'); // Unmark as active
                            updateAllInteractiveButtonStates(); // Update all buttons
                            setTimeout(() => {
                                copyCodeBtn.textContent = originalText;
                                copyCodeBtn.classList.remove('bg-red-500', 'hover:bg-red-600');
                                copyCodeBtn.classList.add('bg-gray-700', 'hover:bg-gray-600');
                            }, 1500);
                        }
                    }
                });

                // Removed Paste Code button listener

                // Export HTML button
                exportHtmlBtn.addEventListener('click', () => {
                    if (editor) {
                        const originalText = exportHtmlBtn.textContent;
                        const htmlContent = editor.getValue();
                        const blob = new Blob([htmlContent], { type: 'text/html' });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = 'exported_html.html'; // Default filename
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        URL.revokeObjectURL(url);

                        exportHtmlBtn.textContent = 'Exported!';
                        exportHtmlBtn.classList.add('bg-green-500', 'hover:bg-green-600');
                        exportHtmlBtn.classList.remove('bg-red-600', 'hover:bg-red-700');
                        exportHtmlBtn.disabled = true; // Disable the button
                        exportHtmlBtn.setAttribute('data-temp-active', 'true'); // Mark as active
                        updateAllInteractiveButtonStates(); // Update all buttons
                        setTimeout(() => {
                            exportHtmlBtn.textContent = originalText;
                            exportHtmlBtn.classList.remove('bg-green-500', 'hover:bg-green-600');
                            exportHtmlBtn.classList.add('bg-red-600', 'hover:bg-red-700');
                            exportHtmlBtn.disabled = false; // Re-enable the button
                            exportHtmlBtn.removeAttribute('data-temp-active'); // Unmark as active
                            updateAllInteractiveButtonStates(); // Update all buttons
                        }, 1500);
                    }
                });

                // Clear All button
                clearAllBtn.addEventListener('click', async () => {
                    if (editor) {
                        const originalText = clearAllBtn.textContent;
                        editor.setValue(''); // Clear the editor content
                        clearAllBtn.textContent = 'Cleared!';
                        clearAllBtn.classList.add('bg-green-500', 'hover:bg-green-600');
                        clearAllBtn.classList.remove('bg-gray-700', 'hover:bg-gray-600');
                        clearAllBtn.disabled = true; // Disable the button
                        clearAllBtn.setAttribute('data-temp-active', 'true'); // Mark as active
                        updateAllInteractiveButtonStates(); // Update all buttons
                        setTimeout(() => {
                            clearAllBtn.textContent = originalText;
                            clearAllBtn.classList.remove('bg-green-500', 'hover:bg-green-600');
                            clearAllBtn.classList.add('bg-gray-700', 'hover:bg-gray-600');
                            clearAllBtn.disabled = false; // Re-enable the button
                            clearAllBtn.removeAttribute('data-temp-active'); // Unmark as active
                            updateAllInteractiveButtonStates();
                        }, 1500);
                        if (isAutoCheckEnabled) { // Re-validate if auto-check is on
                            const isXmlLike = await validateHtmlContent(editor.getValue()); // Await validation
                            updatePreviewButtonState(isXmlLike); // Update preview button state
                        }
                    }
                });

                // Import HTML button
                importHtmlBtn.addEventListener('click', () => htmlFileInput.click());
                htmlFileInput.addEventListener('change', async (event) => { // Made async
                    const file = event.target.files[0];
                    if (file) {
                        const originalText = importHtmlBtn.textContent;
                        const reader = new FileReader();
                        reader.onload = async (e) => { // Made async
                            editor.setValue(e.target.result);
                            importHtmlBtn.textContent = 'Imported!';
                            importHtmlBtn.classList.add('bg-green-500', 'hover:bg-green-600');
                            importHtmlBtn.classList.remove('bg-purple-600', 'hover:bg-purple-700');
                            importHtmlBtn.disabled = true; // Disable the button
                            importHtmlBtn.setAttribute('data-temp-active', 'true'); // Mark as active
                            updateAllInteractiveButtonStates(); // Update all buttons
                            setTimeout(() => {
                                importHtmlBtn.textContent = originalText;
                                importHtmlBtn.classList.remove('bg-green-500', 'hover:bg-green-600');
                                importHtmlBtn.classList.add('bg-purple-600', 'hover:bg-purple-700');
                                htmlFileInput.value = null; // Clear the input so same file can be imported again
                                importHtmlBtn.removeAttribute('data-temp-active');
                                updateAllInteractiveButtonStates();
                            }, 1500);
                            if (isAutoCheckEnabled) { // Re-validate if auto-check is on
                                const isXmlLike = await validateHtmlContent(editor.getValue()); // Await validation
                                updatePreviewButtonState(isXmlLike); // Update preview button state
                            }
                        };
                        reader.onerror = () => {
                            console.error('Error reading file.');
                            // Provide user feedback without alert()
                            importHtmlBtn.textContent = 'Import Failed!';
                            importHtmlBtn.classList.add('bg-red-500', 'hover:bg-red-600');
                            importHtmlBtn.classList.remove('bg-purple-600', 'hover:bg-purple-700');
                            importHtmlBtn.disabled = false; // Re-enable the button
                            importHtmlBtn.removeAttribute('data-temp-active'); // Unmark as active
                            updateAllInteractiveButtonStates(); // Update all buttons
                            setTimeout(() => {
                                importHtmlBtn.textContent = originalText;
                                importHtmlBtn.classList.remove('bg-red-500', 'hover:bg-red-600');
                                importHtmlBtn.classList.add('bg-purple-600', 'hover:bg-purple-700');
                            }, 1500);
                        };
                        reader.readAsText(file);
                    }
                });

                // --- Add event listeners for MODAL preview controls ---

                modalCustomizeHeader.addEventListener('click', () => {
                    modalIsCustomizeExpanded = !modalIsCustomizeExpanded;
                    modalCustomizeContent.classList.toggle('expanded', modalIsCustomizeExpanded);
                    modalCustomizeHeader.classList.toggle('expanded', modalIsCustomizeExpanded);
                });

                modalToggleContainerBtn.addEventListener('click', () => {
                    modalUseContainerDiv = !modalUseContainerDiv;
                    modalToggleContainerBtn.textContent = modalUseContainerDiv ? 'Custom Width' : 'Default Width';
                    updateModalSettingsButtonStates();
                    updateModalPreview();
                });

                modalToggleTitleBtn.addEventListener('click', () => {
                    modalShowTitle = !modalShowTitle;
                    modalToggleTitleBtn.textContent = modalShowTitle ? 'Hide Title' : 'Show Title';
                    updateModalSettingsButtonStates();
                    modalH1TitleInputContainer.style.display = modalShowTitle ? 'block' : 'none';
                    updateModalPreview();
                });

                modalToggleCssBtn.addEventListener('click', () => {
                    modalEnableCss = !modalEnableCss;
                    updateModalSettingsButtonStates(); // This function also updates the text
                    updateModalPreview();
                });

                modalH1TitleInput.addEventListener('input', () => {
                    if (modalCurrentLanguage === 'en') {
                        modalH1TitleEn = modalH1TitleInput.value;
                    } else {
                        modalH1TitleFr = modalH1TitleInput.value;
                    }
                    updateModalPreview();
                });

                modalNoneBylineBtn.addEventListener('click', () => { modalBylineMode = 'none'; updateModalBylineButtonStates(); updateModalPreview(); });
                modalEnglishBylineBtn.addEventListener('click', () => { modalBylineMode = 'english'; updateModalBylineButtonStates(); updateModalPreview(); });
                modalFrenchBylineBtn.addEventListener('click', () => { modalBylineMode = 'french'; updateModalBylineButtonStates(); updateModalPreview(); });

                modalLocalImagesBtn.addEventListener('click', () => { modalImageSourceMode = 'local'; updateModalImageSourceButtonStates(); updateModalPreview(); });
                modalPreviewImagesBtn.addEventListener('click', () => { modalImageSourceMode = 'preview'; updateModalImageSourceButtonStates(); updateModalPreview(); });
                modalToggleLiveImagesBtn.addEventListener('click', () => { modalImageSourceMode = 'live'; updateModalImageSourceButtonStates(); updateModalPreview(); });

                modalLocalUrlsBtn.addEventListener('click', () => { modalUrlSourceMode = 'local'; updateModalUrlSourceButtonStates(); updateModalPreview(); });
                modalPreviewUrlsBtn.addEventListener('click', () => { modalUrlSourceMode = 'preview'; updateModalUrlSourceButtonStates(); updateModalPreview(); });
                modalToggleLiveUrlsBtn.addEventListener('click', () => { modalUrlSourceMode = 'live'; updateModalUrlSourceButtonStates(); updateModalPreview(); });

                modalToggleSectionsBtn.addEventListener('click', () => {
                    modalShowSections = !modalShowSections;
                    updateModalSectionHeadingButtonStates();
                    updateModalPreview();
                });

                modalToggleHeadingsBtn.addEventListener('click', () => {
                    modalShowHeadings = !modalShowHeadings;
                    updateModalSectionHeadingButtonStates();
                    updateModalPreview();
                });

                modalWetGcdsToggleBtn.addEventListener('click', () => {
                    if (modalCurrentFramework === 'wet') {
                        modalCurrentFramework = 'gcds';
                    } else if (modalCurrentFramework === 'gcds') {
                        modalCurrentFramework = 'wet+';
                    } else if (modalCurrentFramework === 'wet+') {
                        modalCurrentFramework = 'wet';
                    }
                    updateModalWetGcdsButtonState();
                    updateModalPreview();
                });

                modalLangEnBtn.addEventListener('click', () => {
                    // Auto-switch byline if not 'none'
                    if (modalBylineMode === 'french') {
                        modalBylineMode = 'english';
                    } else if (modalBylineMode === 'english') {
                        // If already English, keep it English (or if 'none', keep 'none')
                    }
                    modalCurrentLanguage = 'en';
                    updateModalLanguageButtonStates();
                    updateModalPreview();
                });

                modalLangFrBtn.addEventListener('click', () => {
                    // Auto-switch byline if not 'none'
                    if (modalBylineMode === 'english') {
                        modalBylineMode = 'french';
                    } else if (modalBylineMode === 'french') {
                        // If already French, keep it French (or if 'none', keep 'none')
                    }
                    modalCurrentLanguage = 'fr';
                    updateModalLanguageButtonStates();
                    updateModalPreview();
                });

                // Breakpoint button listeners
                modalBreakpointXsBtn.addEventListener('click', () => { modalCurrentBreakpoint = 'xs'; updateModalBreakpointButtonStates(); updateModalPreview(); });
                modalBreakpointSmBtn.addEventListener('click', () => { modalCurrentBreakpoint = 'sm'; updateModalBreakpointButtonStates(); updateModalPreview(); });
                modalBreakpointMdBtn.addEventListener('click', () => { modalCurrentBreakpoint = 'md'; updateModalBreakpointButtonStates(); updateModalPreview(); });
                // Removed modalBreakpointLgBtn.addEventListener
                modalBreakpointFullBtn.addEventListener('click', () => { modalCurrentBreakpoint = 'full'; updateModalBreakpointButtonStates(); updateModalPreview(); });


                // Modal Search Functionality
                function performModalPreviewSearch(searchForward = true) {
                    const searchTerm = modalPreviewSearchInput.value;
                    if (!searchTerm || !modalPreviewFrame.contentWindow) return;
                    const iframeWindow = modalPreviewFrame.contentWindow;

                    // Only reset the search if the search term has changed
                    if (searchTerm !== modalLastSearchTerm) {
                        iframeWindow.getSelection().removeAllRanges(); // Clear previous highlights/selections
                        if (searchForward) {
                            iframeWindow.scrollTo(0, 0); // Start from the top for forward search
                        } else {
                            // For backward search, start from the bottom if it's a new term
                            iframeWindow.scrollTo(0, iframeWindow.document.body.scrollHeight);
                        }
                        modalLastSearchTerm = searchTerm;
                    }

                    // Perform the find operation.
                    // The 'wrapAround' parameter being true means it will continue from the other end
                    // if it reaches the end of the document in the current direction.
                    // The 'find' method automatically advances the selection if a match is found.
                    let found = iframeWindow.find(searchTerm, false, !searchForward, true, false, false, false);

                    if (!found) {
                        console.log(`Search term "${searchTerm}" not found in modal preview.`);
                    }
                    modalPreviewSearchInput.focus();
                }

                modalPreviewFindNextBtn.addEventListener('click', () => performModalPreviewSearch(true));
                modalPreviewFindPrevBtn.addEventListener('click', () => performModalPreviewSearch(false));
                modalPreviewSearchInput.addEventListener('keydown', (event) => {
                    if (event.key === 'Enter') { event.preventDefault(); performModalPreviewSearch(true); }
                });

                // Export Prototype button functionality
                exportPrototypeBtn.addEventListener('click', () => {
                    if (modalPreviewFrame.contentDocument) {
                        const originalText = exportPrototypeBtn.textContent;
                        // Generate HTML specifically for export (without highlight CSS)
                        const prototypeHtml = generateFullHtml({
                            showSections: false, // Ensure these are false for export
                            showHeadings: false, // Ensure these are false for export
                            useContainerDiv: modalUseContainerDiv,
                            showTitle: modalShowTitle,
                            imageSourceMode: modalImageSourceMode,
                            bylineMode: modalBylineMode,
                            enableCss: modalEnableCss,
                            urlSourceMode: modalUrlSourceMode,
                            currentLanguage: modalCurrentLanguage,
                            currentFramework: modalCurrentFramework,
                            h1TitleEn: modalH1TitleEn,
                            h1TitleFr: modalH1TitleFr
                        }, true); // Pass true for forExport

                        const blob = new Blob([prototypeHtml], { type: 'text/html' });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = 'prototype.html'; // Default filename for the prototype
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        URL.revokeObjectURL(url);

                        exportPrototypeBtn.textContent = 'Exported!';
                        exportPrototypeBtn.classList.add('bg-green-500', 'hover:bg-green-600');
                        exportPrototypeBtn.classList.remove('bg-red-600', 'hover:bg-red-700');
                        setTimeout(() => {
                            exportPrototypeBtn.textContent = originalText;
                            exportPrototypeBtn.classList.remove('bg-green-500', 'hover:bg-green-600');
                            exportPrototypeBtn.classList.add('bg-red-600', 'hover:bg-red-700');
                        }, 1500);
                    } else {
                        console.error('Could not access iframe content for export.');
                        // Provide user feedback without alert()
                        exportPrototypeBtn.textContent = 'Export Failed!';
                        exportPrototypeBtn.classList.add('bg-red-500', 'hover:bg-red-600');
                        exportPrototypeBtn.classList.remove('bg-red-600', 'hover:bg-red-700');
                        setTimeout(() => {
                            exportPrototypeBtn.textContent = originalText;
                            exportPrototypeBtn.classList.remove('bg-red-500', 'hover:bg-red-600');
                            exportPrototypeBtn.classList.add('bg-red-600', 'hover:bg-red-700');
                        }, 1500);
                    }
                });

                // Clean Spaces button functionality
                cleanSpacesBtn.addEventListener('click', async () => {
                    if (editor) {
                        const originalText = cleanSpacesBtn.textContent;
                        const model = editor.getModel();
                        const fullRange = model.getFullModelRange();
                        let originalCode = model.getValue();

                        // Step 1: Replace non-breaking space entities and literal non-breaking space characters with placeholders
                        let processedCode = applyNBSPPlaceholders(originalCode);

                        // Step 2: Clean normal spaces:
                        // Remove spaces before/after placeholders, but keep the placeholders.
                        // This regex targets one or more normal spaces (\s+) that are immediately followed by a placeholder
                        // OR immediately preceded by a placeholder.
                        processedCode = processedCode.replace(/\s+(__NBSP_ENTITY_PLACEHOLDER__|__NUMERIC_NBSP_ENTITY_PLACEHOLDER__|__LITERAL_NBSP_CHAR_PLACEHOLDER__)/g, '$1');
                        processedCode = processedCode.replace(/(__NBSP_ENTITY_PLACEHOLDER__|__NUMERIC_NBSP_ENTITY_PLACEHOLDER__|__LITERAL_NBSP_CHAR_PLACEHOLDER__)\s+/g, '$1');

                        // Split by lines to handle trimming and multiple internal spaces per line
                        const lines = processedCode.split('\n');
                        const processedLines = [];

                        for (let line of lines) {
                            // Trim leading/trailing normal whitespace from the line
                            line = line.trim();
                            // Replace multiple internal normal whitespace characters with a single normal space
                            line = line.replace(/ {2,}/g, ' '); // Only target multiple normal spaces

                            // Only add non-empty lines to the result
                            if (line.length > 0) {
                                processedLines.push(line);
                            }
                        }

                        // Join the processed lines with a single newline character
                        let finalCleanedContent = processedLines.join('\n');

                        // Step 3: Revert placeholders back to their original non-breaking space entities
                        finalCleanedContent = revertNBSPPlaceholders(finalCleanedContent);

                        editor.pushUndoStop(); // Start an undo stop
                        model.pushEditOperations(
                            [], // No selections to change
                            [{
                                range: fullRange,
                                text: finalCleanedContent
                            }],
                            () => null // No new selection needed
                        );
                        editor.pushUndoStop(); // End an undo stop

                        cleanSpacesBtn.textContent = 'Cleaned!';
                        cleanSpacesBtn.classList.add('bg-green-500', 'hover:bg-green-600');
                        cleanSpacesBtn.classList.remove('bg-gray-700', 'hover:bg-gray-600');
                        cleanSpacesBtn.disabled = true; // Disable the button
                        cleanSpacesBtn.setAttribute('data-temp-active', 'true'); // Mark as active
                        updateAllInteractiveButtonStates(); // Update all buttons
                        setTimeout(() => {
                            cleanSpacesBtn.textContent = originalText;
                            cleanSpacesBtn.classList.remove('bg-green-500', 'hover:bg-green-600');
                            cleanSpacesBtn.classList.add('bg-gray-700', 'hover:bg-gray-600');
                            cleanSpacesBtn.disabled = false; // Re-enable the button
                            cleanSpacesBtn.removeAttribute('data-temp-active'); // Unmark as active
                            updateAllInteractiveButtonStates(); // Update all buttons
                        }, 1500);
                        if (isAutoCheckEnabled) {
                            const isXmlLike = await validateHtmlContent(editor.getValue());
                            updatePreviewButtonState(isXmlLike);
                        }
                    }
                });

                // Clean URLs button functionality
                cleanUrlsBtn.addEventListener('click', async () => {
                    if (editor) {
                        const originalText = cleanUrlsBtn.textContent;
                        const model = editor.getModel();
                        const fullRange = model.getFullModelRange();
                        let htmlContent = model.getValue();
                        let cleanedHtml = applyUrlCleaning(htmlContent);

                        editor.pushUndoStop();
                        model.pushEditOperations(
                            [],
                            [{
                                range: fullRange,
                                text: cleanedHtml
                            }],
                            () => null
                        );
                        editor.pushUndoStop();

                        cleanUrlsBtn.textContent = 'Cleaned!';
                        cleanUrlsBtn.classList.add('bg-green-500', 'hover:bg-green-600');
                        cleanUrlsBtn.classList.remove('bg-gray-700', 'hover:bg-gray-600');
                        cleanUrlsBtn.disabled = true; // Disable the button
                        cleanUrlsBtn.setAttribute('data-temp-active', 'true'); // Mark as active
                        updateAllInteractiveButtonStates(); // Update all buttons
                        setTimeout(() => {
                            cleanUrlsBtn.textContent = originalText;
                            cleanUrlsBtn.classList.remove('bg-green-500', 'hover:bg-green-600');
                            cleanUrlsBtn.classList.add('bg-gray-700', 'hover:bg-gray-600');
                            cleanUrlsBtn.disabled = false; // Re-enable the button
                            cleanUrlsBtn.removeAttribute('data-temp-active'); // Unmark as active
                            updateAllInteractiveButtonStates(); // Update all buttons
                        }, 1500);
                        if (isAutoCheckEnabled) {
                            const isXmlLike = await validateHtmlContent(editor.getValue());
                            updatePreviewButtonState(isXmlLike);
                        }
                    }
                });

                // Time Tags button functionality
                timeTagsBtn.addEventListener('click', async () => {
                    if (editor) {
                        const originalText = timeTagsBtn.textContent;
                        const model = editor.getModel();
                        const fullRange = model.getFullModelRange();
                        let originalHtml = model.getValue();
                        originalHtml = applyNBSPPlaceholders(originalHtml); // Apply placeholders

                        const parser = new DOMParser();
                        const doc = parser.parseFromString(originalHtml, 'text/html');
                        const body = doc.body;

                        // Step 1: Remove existing <time> tags and extract their text content
                        const existingTimeElements = doc.querySelectorAll('time');
                        existingTimeElements.forEach(timeEl => {
                            const textNode = doc.createTextNode(timeEl.textContent);
                            timeEl.parentNode.replaceChild(textNode, timeEl);
                        });

                        let contentToProcess = body.innerHTML;

                        const monthMap = {
                            'january': '01', 'jan': '01', 'janvier': '01',
                            'february': '02', 'feb': '02', 'février': '02',
                            'march': '03', 'mar': '03', 'mars': '03',
                            'april': '04', 'apr': '04', 'avril': '04',
                            'may': '05', 'mai': '05',
                            'june': '06', 'jun': '06', 'juin': '06',
                            'july': '07', 'jul': '07', 'juillet': '07',
                            'august': '08', 'aug': '08', 'août': '08',
                            'september': '09', 'sep': '09', 'septembre': '09',
                            'october': '10', 'oct': '10', 'octobre': '10',
                            'november': '11', 'nov': '11', 'novembre': '11',
                            'december': '12', 'dec': '12', 'décembre': '12'
                        };

                        function getMonthNumber(monthName) {
                            return monthMap[monthName.toLowerCase()] || null;
                        }

                        const sortedMonthKeys = Object.keys(monthMap).sort((a, b) => b.length - a.length);
                        const monthPattern = sortedMonthKeys.map(m => m.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&')).join('|');
                        const spaceOrNBSPChar = `(?:\\s|\\u00A0|&nbsp;|&#160;|${NBSP_ENTITY_PLACEHOLDER}|${NUMERIC_NBSP_ENTITY_PLACEHOLDER}|${LITERAL_NBSP_CHAR_PLACEHOLDER})+`;

                        const regexIsoDateFull = /(?<!\d)(\d{4}-(?:0[1-9]|1[0-2])-(?:0[1-9]|[12]\d|3[01]))(?!\d)/g;
                        const regexMonthDayYear = new RegExp(`(?<!\\d)(\\b${monthPattern}\\b)${spaceOrNBSPChar}(\\d{1,2}),?${spaceOrNBSPChar}(\\d{4})(?!\\d)`, 'i');
                        const regexDayMonthYear = new RegExp(`(?<!\\d)(?:(?:le|the)${spaceOrNBSPChar})?(\\d{1,2})${spaceOrNBSPChar}(\\b${monthPattern}\\b),?${spaceOrNBSPChar}(\\d{4})(?!\\d)`, 'i');
                        // Corrected regex for Month Day (no year) to be more robust
                        const regexMonthDayNoYear = new RegExp(`(?<!\\d)(\\b${monthPattern}\\b)${spaceOrNBSPChar}(\\d{1,2})(?!\\d|${spaceOrNBSPChar}\\d{4}|-)`, 'i');
                        // Corrected regex for Day Month (no year) to be more robust
                        const regexDayMonthNoYear = new RegExp(`(?<!\\d)(?:(?:le|the)${spaceOrNBSPChar})?(\\d{1,2})${spaceOrNBSPChar}(\\b${monthPattern}\\b)(?!\\d|${spaceOrNBSPChar}\\d{4}|-)`, 'i');
                        const regexMonthYear = new RegExp(`(?<!\\d)(\\b${monthPattern}\\b)${spaceOrNBSPChar}(\\d{4})(?!\\d)`, 'i');

                        const reParsedDoc = parser.parseFromString(contentToProcess, 'text/html');
                        const reParsedBody = reParsedDoc.body;

                        const textNodesToModify = [];
                        const walker = reParsedDoc.createTreeWalker(
                            reParsedBody,
                            NodeFilter.SHOW_TEXT,
                            {
                                acceptNode: function(node) {
                                    let parent = node.parentNode;
                                    while (parent) {
                                        const tagName = parent.tagName ? parent.tagName.toLowerCase() : '';
                                        if (tagName === 'script' || tagName === 'style' || tagName === 'time') {
                                            return NodeFilter.FILTER_REJECT;
                                        }
                                        parent = parent.parentNode;
                                    }
                                    return NodeFilter.FILTER_ACCEPT;
                                }
                            },
                            false
                        );

                        let currentNode;
                        while (currentNode = walker.nextNode()) {
                            textNodesToModify.push(currentNode);
                        }

                        textNodesToModify.forEach(textNode => {
                            let text = textNode.nodeValue;
                            let currentText = text;

                            let allMatches = [];
                            const patternsToTest = [
                                { name: 'IsoDateFull', regex: regexIsoDateFull, handler: (match) => {
                                    const [fullMatch, yearMonthDay] = match;
                                    return yearMonthDay;
                                }, priority: 4 },
                                { name: 'DayMonthYear', regex: regexDayMonthYear, handler: (match) => {
                                    const [, day, month, year] = match;
                                    const monthNum = getMonthNumber(month);
                                    if (!monthNum || parseInt(day) < 1 || parseInt(day) > 31) return null;
                                    return `${year}-${monthNum}-${String(day).padStart(2, '0')}`;
                                }, priority: 3 },
                                { name: 'MonthDayYear', regex: regexMonthDayYear, handler: (match) => {
                                    const [, month, day, year] = match;
                                    const monthNum = getMonthNumber(month);
                                    if (!monthNum || parseInt(day) < 1 || parseInt(day) > 31) return null;
                                    return `${year}-${monthNum}-${String(day).padStart(2, '0')}`;
                                }, priority: 3 },
                                { name: 'MonthYear', regex: regexMonthYear, handler: (match) => {
                                    const [, month, year] = match;
                                    const monthNum = getMonthNumber(month);
                                    if (!monthNum) return null;
                                    return `${year}-${monthNum}`;
                                }, priority: 2 },
                                { name: 'MonthDayNoYear', regex: regexMonthDayNoYear, handler: (match) => {
                                    const [, month, day] = match;
                                    const monthNum = getMonthNumber(month);
                                    if (!monthNum || parseInt(day) < 1 || parseInt(day) > 31) return null;
                                    // For dates without year, we can't provide a full ISO date.
                                    // A common practice is to use MM-DD format, or just the original string.
                                    // For now, let's use MM-DD, as it's a valid partial date for <time>.
                                    return `${monthNum}-${String(day).padStart(2, '0')}`;
                                }, priority: 1 },
                                { name: 'DayMonthNoYear', regex: regexDayMonthNoYear, handler: (match) => {
                                    const [, day, month] = match;
                                    const monthNum = getMonthNumber(month);
                                    if (!monthNum || parseInt(day) < 1 || parseInt(day) > 31) return null;
                                    return `${monthNum}-${String(day).padStart(2, '0')}`;
                                }, priority: 1 }
                            ];

                            patternsToTest.forEach(pattern => {
                                let localRegex = new RegExp(pattern.regex.source, pattern.regex.flags);
                                if (!localRegex.flags.includes('g')) {
                                    localRegex = new RegExp(localRegex.source, localRegex.flags + 'g');
                                }

                                let match;
                                while ((match = localRegex.exec(currentText)) !== null) {
                                    const datetimeValue = pattern.handler(match);
                                    if (datetimeValue) {
                                        allMatches.push({
                                            start: match.index,
                                            end: match.index + match[0].length,
                                            original: match[0],
                                            datetime: datetimeValue,
                                            priority: pattern.priority
                                        });
                                    }
                                }
                            });

                            allMatches.sort((a, b) => {
                                // Sort by start index ascending
                                if (a.start !== b.start) {
                                    return a.start - b.start;
                                }
                                // If start index is the same, prioritize higher priority patterns first
                                if (b.priority !== a.priority) {
                                    return b.priority - a.priority;
                                }
                                // Then by longer original string length (more specific matches)
                                return b.original.length - a.original.length;
                            });

                            let finalMatches = [];
                            let lastEnd = -1;

                            for (const match of allMatches) {
                                // If the current match starts after or at the end of the last accepted match, it's non-overlapping
                                if (match.start >= lastEnd) {
                                    finalMatches.push(match);
                                    lastEnd = match.end;
                                }
                            }

                            if (finalMatches.length > 0) {
                                let resultParts = [];
                                let currentIndex = 0;
                                finalMatches.forEach(match => {
                                    resultParts.push(currentText.substring(currentIndex, match.start));
                                    resultParts.push(`<time class="nowrap" datetime="${match.datetime}">${match.original}</time>`);
                                    currentIndex = match.end;
                                });
                                resultParts.push(currentText.substring(currentIndex));
                                const newHtmlContent = resultParts.join('');

                                const fragment = reParsedDoc.createRange().createContextualFragment(newHtmlContent);
                                textNode.parentNode.replaceChild(fragment, textNode);
                            }
                        });

                        let finalHtml = reParsedBody.innerHTML;
                        finalHtml = revertNBSPPlaceholders(finalHtml); // Revert placeholders

                        editor.pushUndoStop();
                        model.pushEditOperations(
                            [],
                            [{
                                range: fullRange,
                                text: finalHtml
                            }],
                            () => null
                        );
                        editor.pushUndoStop();

                        timeTagsBtn.textContent = 'Tagged!';
                        timeTagsBtn.classList.add('bg-green-500', 'hover:bg-green-600');
                        timeTagsBtn.classList.remove('bg-gray-700', 'hover:bg-gray-600');
                        timeTagsBtn.disabled = true; // Disable the button
                        timeTagsBtn.setAttribute('data-temp-active', 'true'); // Mark as active
                        updateAllInteractiveButtonStates(); // Update all buttons
                        setTimeout(() => {
                            timeTagsBtn.textContent = originalText;
                            timeTagsBtn.classList.remove('bg-green-500', 'hover:bg-green-600');
                            timeTagsBtn.classList.add('bg-gray-700', 'hover:bg-gray-600');
                            timeTagsBtn.disabled = false; // Re-enable the button
                            timeTagsBtn.removeAttribute('data-temp-active'); // Unmark as active
                            updateAllInteractiveButtonStates(); // Update all buttons
                        }, 1500);
                        if (isAutoCheckEnabled) {
                            const isXmlLike = await validateHtmlContent(editor.getValue());
                            updatePreviewButtonState(isXmlLike);
                        }
                    }
                });

                // Fix FN ID's button functionality
                fixFnIdsBtn.addEventListener('click', async () => {
                    if (editor) {
                        const originalText = fixFnIdsBtn.textContent;
                        const model = editor.getModel();
                        const fullRange = model.getFullModelRange();
                        let htmlContent = model.getValue();
                        htmlContent = applyNBSPPlaceholders(htmlContent); // Apply placeholders

                        const parser = new DOMParser();
                        const doc = parser.parseFromString(htmlContent, 'text/html');

                        const baseIdToSupElements = new Map();

                        const supElements = doc.querySelectorAll('sup[id$="-rf"]');
                        supElements.forEach(sup => {
                            const originalId = sup.id;
                            const baseId = originalId.replace(/-rf$/, '');

                            if (!baseIdToSupElements.has(baseId)) {
                                baseIdToSupElements.set(baseId, []);
                            }
                            baseIdToSupElements.get(baseId).push(sup);
                        });

                        const idMapping = {};

                        for (const [baseId, supList] of baseIdToSupElements.entries()) {
                            let canonicalTargetId = supList[0].id;

                            if (supList.length > 1) {
                                canonicalTargetId = `${baseId}-rf-0`;
                                supList.forEach((sup, index) => {
                                    const newSupId = `${baseId}-rf-${index}`;
                                    sup.id = newSupId;
                                });
                            }
                            supList.forEach(sup => {
                                idMapping[sup.id] = canonicalTargetId;
                            });
                            if (supList.length > 1) {
                                idMapping[`${baseId}-rf`] = canonicalTargetId;
                            }
                        }

                        const links = doc.querySelectorAll('a[href^="#"]');
                        links.forEach(link => {
                            let href = link.getAttribute('href');
                            const anchor = href.substring(1);

                            if (idMapping.hasOwnProperty(anchor)) {
                                link.setAttribute('href', `#${idMapping[anchor]}`);
                            }
                        });

                        let finalHtml = doc.body.innerHTML;
                        finalHtml = revertNBSPPlaceholders(finalHtml); // Revert placeholders

                        editor.pushUndoStop();
                        model.pushEditOperations(
                            [],
                            [{
                                range: fullRange,
                                text: finalHtml
                            }],
                            () => null
                        );
                        editor.pushUndoStop();

                        fixFnIdsBtn.textContent = 'Fixed!';
                        fixFnIdsBtn.classList.add('bg-green-500', 'hover:bg-green-600');
                        fixFnIdsBtn.classList.remove('bg-gray-700', 'hover:bg-gray-600');
                        fixFnIdsBtn.disabled = true; // Disable the button
                        fixFnIdsBtn.setAttribute('data-temp-active', 'true'); // Mark as active
                        updateAllInteractiveButtonStates(); // Update all buttons
                        setTimeout(() => {
                            fixFnIdsBtn.textContent = originalText;
                            fixFnIdsBtn.classList.remove('bg-green-500', 'hover:bg-green-600');
                            fixFnIdsBtn.classList.add('bg-gray-700', 'hover:bg-gray-600');
                            fixFnIdsBtn.disabled = false; // Re-enable the button
                            fixFnIdsBtn.removeAttribute('data-temp-active'); // Unmark as active
                            updateAllInteractiveButtonStates(); // Update all buttons
                        }, 1500);
                        if (isAutoCheckEnabled) {
                            const isXmlLike = await validateHtmlContent(editor.getValue());
                            updatePreviewButtonState(isXmlLike);
                        }
                    }
                });

                // Colophon button event listener
            colophonBtn.addEventListener('click', () => {
                const originalText = colophonBtn.textContent;
                colophonBtn.textContent = 'Opening...';
                colophonBtn.classList.add('bg-green-500', 'hover:bg-green-600');
                colophonBtn.classList.remove('bg-gray-700', 'hover:bg-gray-600'); // Changed from slate to gray
                colophonBtn.setAttribute('data-temp-active', 'true'); // Set the flag
                updateAllInteractiveButtonStates(); // Disable all buttons

                const colophonHtmlContent = `
                    <div class="flex flex-col space-y-4">
                        <div>
                            <span class="text-sm font-medium text-gray-200 mr-2">Language:</span>
                            <div class="button-group inline-flex space-x-1">
                                <button id="langEnglishBtn" class="px-2 py-0.5 text-sm bg-gray-600 text-white rounded-md hover:bg-gray-500 focus:outline-none focus:ring-2 focus:ring-slate-500 focus:ring-opacity-50 font-bold">English</button>
                                <button id="langFrenchBtn" class="px-2 py-0.5 text-sm bg-gray-600 text-white rounded-md hover:bg-gray-500 focus:outline-none focus:ring-2 focus:ring-slate-500 focus:ring-opacity-50 font-bold">French</button>
                            </div>
                        </div>
                        <div>
                            <span class="text-sm font-medium text-gray-200 mr-2">Monarch:</span>
                            <div class="button-group inline-flex space-x-1">
                                <button id="monarchKingBtn" class="px-2 py-0.5 text-sm bg-gray-600 text-white rounded-md hover:bg-gray-500 focus:outline-none focus:ring-2 focus:ring-slate-500 focus:ring-opacity-50 font-bold">King</button>
                                <button id="monarchQueenBtn" class="px-2 py-0.5 text-sm bg-gray-600 text-white rounded-md hover:bg-gray-500 focus:outline-none focus:ring-2 focus:ring-slate-500 focus:ring-opacity-50 font-bold">Queen</button>
                            </div>
                        </div>
                        <div>
                            <span class="text-sm font-medium text-gray-200 mr-2">Identifier Type:</span>
                            <div class="button-group inline-flex space-x-1">
                                <button id="idISBNBtn" class="px-2 py-0.5 text-sm bg-gray-600 text-white rounded-md hover:bg-gray-500 focus:outline-none focus:ring-2 focus:ring-slate-500 focus:ring-opacity-50 font-bold">ISBN</button>
                                <button id="idISSNBtn" class="px-2 py-0.5 text-sm bg-gray-600 text-white rounded-md hover:bg-gray-500 focus:outline-none focus:ring-2 focus:ring-slate-500 focus:ring-opacity-50 font-bold">ISSN</button>
                            </div>
                        </div>
                        <div>
                            <label for="colophonYear" class="block text-sm font-medium text-gray-200">Year (optional, defaults to current year):</label>
                            <input type="number" id="colophonYear" class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500 bg-gray-700" placeholder="e.g., 2024" min="1900" max="2100">
                        </div>
                        <div>
                            <label for="colophonNumber" class="block text-sm font-medium text-gray-200">Identifier Number (optional, defaults to ###):</label>
                            <input type="text" id="colophonNumber" class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500 bg-gray-700" placeholder="e.g., 123-456-789-X">
                        </div>
                    </div>
                `;
                showModal('Insert Colophon', colophonHtmlContent, colophonBtn, originalText); // Pass original text
            });

            // Add browser warning for unsaved changes
            window.onbeforeunload = function() {
                // You can add a condition here if you only want to warn if the editor content is not empty
                if (editor && editor.getValue().trim() !== '') {
                    return "You have unsaved changes. Are you sure you want to leave?";
                }
                // If you return nothing or undefined, the browser will not show a warning.
            };
            });
        };
    </script>
</body>
</html>
