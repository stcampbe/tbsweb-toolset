<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HTML/XML Validator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- js-beautify for auto-indent -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/js-beautify/1.14.0/beautify-html.min.js"></script>
    <style>
        /* Custom styles for the editor */
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }

        body {
            font-family: 'Inter', sans-serif;
            display: flex;
            flex-direction: column;
            background-color: #1a202c; /* Dark background */
            color: #ffffff;
        }
        .editor-container {
            display: flex;
            flex-grow: 1;
            padding: 1rem;
            gap: 1rem;
            margin: 0;
            width: 100%;
            height: calc(100% - 2rem);
            box-sizing: border-box;
            overflow: hidden;
        }
        .code-panel {
            background-color: #2d3748;
            border-radius: 0.75rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            padding: 1rem;
            display: flex;
            flex-direction: column; /* Stack editor and results vertically */
            min-width: 200px;
            height: 100%;
            box-sizing: border-box;
            overflow: hidden;
            flex-grow: 1; /* Ensure it takes up available space */
        }

        /* Monaco Editor Container */
        #monacoEditorContainer {
            border: 1px solid #4a5568;
            border-radius: 0.5rem;
            width: 100%;
            flex-grow: 1; /* Allow editor to grow and fill space */
            min-height: 200px; /* Minimum height for editor */
        }

        /* Validation Results Section */
        #validationResultsContainer {
            background-color: #2d3748;
            border-radius: 0.75rem;
            margin-top: 1rem; /* Space between editor and results */
            height: 200px; /* Fixed height for results */
            color: #ffffff;
            overflow-y: auto; /* Enable scrolling for results */
            flex-shrink: 0; /* Prevent results from shrinking */
        }

        #validationResults {
            padding: 0.5rem;
            border-radius: 0.5rem;
            font-size: 0.875rem;
            line-height: 1.5;
			height: 200px;
        }

        /* Specific styles for validation results based on success/error */
        #validationResults.bg-green-100 {
            background-color: #d1fae5;
            color: #065f46;
            border: 1px solid #34d399;
        }
        #validationResults.bg-red-100 {
            background-color: #fee2e2;
            color: #991b1b;
            border: 1px solid #f87171;
        }

        /* Styling for clickable error list items */
        #validationResults ul li {
            cursor: pointer;
            padding: 4px 0;
            transition: background-color 0.2s ease;
        }

        #validationResults ul li:hover {
            background-color: rgba(255, 255, 255, 0.1);
            text-decoration: underline;
        }

        /* Monaco Editor custom highlight style for clicked line */
        .monaco-editor .highlighted-line {
            background-color: rgba(100, 149, 237, 0.4); /* Muted cornflower blue, more subtle */
            border-radius: 4px;
        }

        /* Monaco Editor custom highlight style for HTML entities */
        .monaco-editor .entity-highlight {
            color: yellow; /* Changed from background-color to color */
            border-radius: 2px;
        }

        /* Toggle Switch Styles (copied from index.html) */
        .toggle-switch-container {
            display: flex;
            align-items: center;
            padding: 0.25rem 0; /* Reduced vertical padding */
            gap: 0.5rem; /* Space between toggle and label */
            justify-content: flex-start; /* Align contents to the start */
            background-color: #475569; /* Medium slate for background */
            border-radius: 0.5rem; /* Rounded corners */
            padding: 0.5rem 0.75rem; /* Padding inside the container */
        }

        .toggle-switch-label {
            color: #CBD5E1; /* Light slate for label text */
            font-size: 0.9rem;
            flex-shrink: 1; /* Allow label to shrink */
            min-width: 0; /* Allow text to wrap within the label */
        }

        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 44px; /* Width of the pill */
            height: 24px; /* Height of the pill */
            border-radius: 12px; /* Half of height for pill shape */
            background-color: #64748B; /* Grayish slate for off state */
            cursor: pointer;
            transition: background-color 0.3s ease;
            flex-shrink: 0; /* Prevent the switch from shrinking */
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-switch-slider {
            position: absolute;
            content: "";
            height: 20px; /* Height of the inner circle */
            width: 20px; /* Width of the inner circle */
            left: 2px; /* Initial position for off state */
            bottom: 2px;
            background-color: #ffffff; /* Circle color */
            border-radius: 50%;
            transition: transform 0.3s ease;
        }

        /* Checked state styles (applied to the .toggle-switch label itself) */
        .toggle-switch.is-checked {
            background-color: #22c55e; /* Green for on state */
        }

        .toggle-switch.is-checked .toggle-switch-slider {
            transform: translateX(20px); /* Move circle to the right */
        }

        /* Styling for disabled button */
        button:disabled {
            background-color: #4a4a4a !important; /* Darker gray for disabled state, use !important to override other styles */
            cursor: not-allowed !important;
            opacity: 0.6 !important;
        }

        /* Modal styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .modal-content {
            background-color: #2d3748;
            padding: 2rem;
            border-radius: 0.75rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            color: #ffffff;
            text-align: left; /* Left align content */
            max-width: 90%;
            width: 400px;
            position: relative; /* For absolute positioning of close button */
        }

        .modal-content h3 {
            font-size: 1.5rem;
            font-weight: bold;
            margin-bottom: 1rem;
            text-align: left; /* Ensure title is left aligned */
        }

        .modal-content p {
            margin-bottom: 1.5rem;
        }

        .modal-content button {
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            font-weight: bold;
            transition: background-color 0.2s ease;
        }

        .modal-content button:hover {
            background-color: #3182ce; /* Blue-600 */
        }

        /* Preview Modal Specific Styles */
        #previewModal .modal-content {
            width: 98%; /* Wider for better preview */
            max-width: 1500px; /* Max width for large screens */
            height: 95%; /* Taller for better preview */
            display: flex;
            flex-direction: column;
            overflow: hidden; /* Prevent modal content from scrolling, iframe handles it */
            padding: 1.5rem; /* Reduced padding for modal content */
        }

        #previewModal .modal-content .modal-header-controls {
            display: flex;
            align-items: center; /* Vertically align items */
            /* Removed justify-content: space-between; to allow title and buttons to be close */
            margin-bottom: 0.75rem; /* Reduced space below header */
            flex-wrap: wrap;
        }

        #previewModal .modal-content h3 {
            font-size: 1.25rem; /* Slightly smaller title */
            text-align: left; /* Keep title left-aligned */
            margin-bottom: 0; /* Adjusted for inline elements */
            /* Removed flex-grow: 1; to prevent it from pushing buttons too far */
            margin-right: 0.75rem; /* Space between title and buttons */
        }

        #previewModal iframe {
            width: 100%;
            height: 100%;
            border: 1px solid #4a5568;
            border-radius: 0.5rem;
            background-color: #ffffff;
            flex-grow: 1; /* Allow iframe to take available space */
        }

        /* Customize section styles for modal */
        #previewModal .customize-section {
            background-color: #3b455a;
            border-radius: 0.5rem;
            padding: 0.75rem; /* Reduced padding */
            margin-bottom: 0.75rem; /* Reduced margin */
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        #previewModal .customize-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
        }

        #previewModal .customize-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out;
        }

        #previewModal .customize-content.expanded {
            max-height: 500px; /* Adjust as needed to fit content */
            transition: max-height 0.5s ease-in;
            padding-top: 0.5rem;
        }

        #previewModal .customize-header svg {
            transition: transform 0.3s ease;
        }

        #previewModal .customize-header.expanded svg {
            transform: rotate(180deg);
        }

        /* Button group styles for modal customize section (from index.html) */
        #previewModal .button-group {
            display: flex;
            width: 100%; /* Make it span full width */
            border-radius: 0.5rem; /* rounded-md */
            box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05); /* shadow-sm */
            border: 1px solid #4a5568; /* Darker border for button group */
            flex-wrap: wrap; /* Keep for responsiveness on smaller screens */
        }

        #previewModal .button-group button {
            flex: 1; /* Make buttons take up equal space */
            border-radius: 0; /* Remove individual button rounded corners */
            border: none; /* Remove individual button borders */
            margin: 0; /* Remove individual button margins */
            padding: 0.5rem 0.75rem; /* Consistent padding */
            font-size: 0.875rem; /* text-sm */
            line-height: 1.25rem; /* leading-5 */
            position: relative; /* For z-index if needed */
            color: #ffffff; /* White text for all buttons */
            font-weight: bold; /* Make buttons bold */
        }

        #previewModal .button-group button:hover {
            background-color: #3182ce; /* Blue-600 */
        }

        /* Adjust border between buttons in the main button groups */
        #previewModal .button-group:not(.no-border-buttons) button:not(:last-child) {
            border-right: 1px solid rgba(74, 85, 104, 0.5); /* Darker separator between buttons */
        }
        #previewModal .button-group.no-border-buttons button:not(:last-child) {
            border-right: none; /* Remove border for this specific group */
        }

        /* Specific styling for the byline and URL/Image source button groups */
        #previewModal .button-group.individual-rounded-buttons {
            border: none; /* Remove group border */
            box-shadow: none; /* Remove group shadow */
            width: auto; /* Allow the group to size to content */
            gap: 0.5rem; /* Add gap between individual buttons */
        }

        #previewModal .button-group.individual-rounded-buttons button {
            flex: none; /* Do not make buttons take equal space */
            border-radius: 0.5rem; /* Ensure rounded corners */
            border: 1px solid #4a5568; /* Add individual button border */
            padding: 0.5rem 0.75rem; /* Consistent padding */
        }
        /* Remove right border for individual rounded buttons */
        #previewModal .button-group.individual-rounded-buttons button:not(:last-child) {
            border-right: 1px solid #4a5568; /* Keep individual border */
        }

        #previewModal .button-group button:first-child {
            border-top-left-radius: 0.5rem;
            border-bottom-left-radius: 0.5rem;
        }

        #previewModal .button-group button:last-child {
            border-top-right-radius: 0.5rem;
            border-bottom-right-radius: 0.5rem;
        }

        #previewModal .button-group button:hover {
            z-index: 1; /* Bring hovered button to front to show full border/shadow */
			background-color: #3182ce !important;
        }
		#previewModal .button-group button.active:hover {
            z-index: 1; /* Bring hovered button to front to show full border/shadow */
			background-color: #3182ce !important;
        }

        /* Active states for buttons in modal, matching QA Wizard */
        #previewModal .button-group button.active {
			color: white !important;
			background-color: #4a5568 !important;
		}
        /* Specific active state for WET4 button */
        #previewModal #modalWetGcdsToggleBtn.active {
            background-color: #2563eb !important; /* Blue-600 for WET4 active */
            border-color: #2563eb !important;
        }
        #previewModal #modalWetGcdsToggleBtn.hover {
            background-color: #2563eb !important; /* Blue-600 for WET4 active */
            border-color: #2563eb !important;
        }
        /* Specific active state for GCDS/WET+ button */
        #previewModal #modalWetGcdsToggleBtn[class*="indigo-600"].active {
            background-color: #4f46e5 !important; /* Indigo-600 for GCDS/WET+ active */
            border-color: #4f46e5 !important;
        }

        /* Specific styling for the Sections and Headings buttons in modal */
        #previewModal #modalToggleSectionsBtn,
        #previewModal #modalToggleHeadingsBtn {
            flex: none; /* Override flex: 1; for these specific buttons */
            width: auto; /* Allow buttons to size based on content */
            border: 1px solid #4a5568; /* Add border back for individual buttons */
            border-radius: 0.5rem; /* Add rounded corners back for individual buttons */
            padding: 0.3rem 0.6rem; /* Reduced padding */
            font-size: 0.75rem; /* Smaller font size */
        }
        #previewModal #modalToggleSectionsBtn.active,
        #previewModal #modalToggleHeadingsBtn.active {
            background-color: #facc15 !important; /* Tailwind yellow-400 */
            color: #1f2937 !important; /* Dark gray for text */
            border-color: #facc15 !important;
        }
        /* Default state for Sections/Headings buttons */
        #previewModal #modalToggleSectionsBtn,
        #previewModal #modalToggleHeadingsBtn {
            background-color: #374151; /* Tailwind gray-700 */
            color: #ffffff;
        }
        #previewModal #modalToggleSectionsBtn:hover,
        #previewModal #modalToggleHeadingsBtn:hover {
            background-color: #4b5563; /* Tailwind gray-600 */
        }

        /* Input and Label styles for modal */
        #previewModal input[type="text"] {
            background-color: #4a5568; /* Darker background for input */
            color: #ffffff; /* White text for input */
            border-color: #4a5568; /* Darker border for input */
            border-radius: 0.5rem; /* rounded-md */
            padding: 0.5rem 0.75rem; /* Consistent padding */
            font-size: 0.875rem; /* text-sm */
            line-height: 1.25rem; /* leading-5 */
        }
        #previewModal input[type="text"]::placeholder {
            color: #a0aec0; /* Lighter placeholder text */
        }
        #previewModal label {
            color: #cbd5e0; /* Lighter gray for labels */
        }

        /* Styles for Prev/Next buttons in modal */
        #modalPreviewFindPrevBtn,
        #modalPreviewFindNextBtn {
            padding: 0.25rem 0.5rem !important; /* px-2 py-1 */
            font-size: 0.75rem !important; /* text-xs */
            background-color: #2563eb !important;
            color: #ffffff !important; /* White text */
            border-radius: 0.375rem !important; /* rounded-md */
            transition: background-color 0.2s ease;
        }
        #modalPreviewFindPrevBtn:hover,
        #modalPreviewFindNextBtn:hover {
background-color: #3182ce !important; /* Blue-600 */        }

        /* Styles for WET4, EN, FR buttons in modal header */
        #previewModal #modalWetGcdsToggleBtn,
        #modalLangEnBtn, /* Apply to both EN and FR buttons */
        #modalLangFrBtn {
            padding: 0.3rem 0.6rem; /* Reduced padding */
            font-size: 0.75rem; /* Smaller font size */
        }
        /* EN/FR active state */
        #modalLangEnBtn.active,
        #modalLangFrBtn.active {
            background-color: #2563eb !important; /* Indigo-600 for active state */
            color: white !important;
            border-color: #2563eb !important;
        }

        /* EN/FR hover state */
        #modalLangEnBtn:hover,
        #modalLangFrBtn:hover {
            background-color: #3182ce !important; /* Blue-600 */
        }

        

        /* "X" Close Button styling */
        #closePreviewModalBtn {
            background-color: transparent; /* Make it transparent by default */
            color: #cbd5e0; /* Lighter gray for the X symbol */
            border: none;
            transition: background-color 0.2s ease, color 0.2s ease;
            cursor: pointer;
            border-radius: 50%; /* Make it round */
            display: flex;
            align-items: center;
            justify-content: center;
            width: 2rem; /* w-8 */
            height: 2rem; /* h-8 */
            font-size: 1.5rem; /* text-2xl */
            font-weight: bold;
            line-height: none; /* Remove extra line height */
            padding: 0; /* Remove padding */
        }
        #closePreviewModalBtn:hover {
            background-color: rgba(255, 255, 255, 0.1); /* Subtle background on hover */
            color: #ffffff; /* White on hover */
        }
    </style>
</head>
<body>
    <div class="editor-container">
        <div class="code-panel">
            <div class="flex items-center justify-between mb-4 flex-wrap">
                <h2 class="text-xl font-semibold text-white">HTML/XML Validator</h2>
                <div class="inline-flex space-x-2 ml-auto">
                    <button id="importHtmlBtn" class="px-3 py-1 text-sm bg-purple-600 text-white rounded-md hover:bg-purple-700 focus:outline-none focus:ring-2 focus:ring-purple-500 focus:ring-opacity-50 font-bold">Import HTML</button>
                    <button id="exportHtmlBtn" class="px-3 py-1 text-sm bg-red-600 text-white rounded-md hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-opacity-50 font-bold">Export HTML</button>
                    <input type="file" id="htmlFileInput" accept=".html" style="display: none;">
                </div>
            </div>

            <div id="monacoEditorContainer"></div>

            <!-- Editor Action Buttons -->
            <div class="mt-4 flex justify-center space-x-2 flex-wrap">
                <!-- Auto-Check Toggle -->
                <div class="toggle-switch-container">
                    <label class="toggle-switch is-checked" for="toggleAutoCheckOnSwitch">
                        <input type="checkbox" id="toggleAutoCheckOnSwitch" checked>
                        <span class="toggle-switch-slider"></span>
                    </label>
                    <span class="toggle-switch-label text-white text-sm">Auto-Check</span>
                </div>
                <!-- Validate Button -->
                <button id="validateNowBtn" class="px-3 py-1 text-sm bg-gray-700 text-white rounded-md hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-opacity-50 font-bold" disabled>
                    Validate
                </button>
                <!-- Preview Button -->
                <button id="previewBtn" class="px-3 py-1 text-sm bg-green-600 text-white rounded-md hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-opacity-50 font-bold">
                    Preview
                </button>
                <button id="autoEncodeBtn" class="px-4 py-2 text-sm bg-red-600 text-white rounded-md hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-opacity-50 font-semibold">
                    Auto-Encode
                </button>
                <button id="autoFormatBtn" class="px-4 py-2 text-sm bg-red-600 text-white rounded-md hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-opacity-50 font-semibold">
                    Auto-Indent
                </button>
                <button id="copyCodeBtn" class="px-4 py-2 text-sm bg-gray-700 text-white rounded-md hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-opacity-50 font-semibold">
                    Copy Code
                </button>
            </div>

            <!-- Validation Results Section - Always visible at the bottom -->
            <div id="validationResultsContainer">
                <div id="validationResults" class="bg-gray-50 p-4 border border-gray-200 rounded-lg min-h-[50px] text-gray-700 text-sm leading-relaxed">
                    <p class="text-gray-500">Type HTML above to see validation results here.</p>
                </div>
            </div>
        </div>
    </div>

    <!-- Preview Modal Structure -->
    <div id="previewModal" class="modal-overlay hidden">
        <div class="modal-content">
            <!-- "X" Close Button -->
            <button id="closePreviewModalBtn" class="absolute top-4 right-4">
                &times;
            </button>

            <!-- Header with Title and Language/Framework Toggles -->
            <div class="modal-header-controls">
                <h3 class="text-xl font-semibold text-white">Live Preview</h3>
                <div class="inline-flex space-x-1"> <!-- Removed ml-auto -->
                    <button id="modalWetGcdsToggleBtn" class="px-2 py-1 text-xs bg-blue-600 text-white rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50 font-bold">WET4</button>
                    <button id="modalLangEnBtn" class="px-2 py-1 text-xs bg-gray-700 text-white rounded-md hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-opacity-50 font-bold">EN</button>
                    <button id="modalLangFrBtn" class="px-2 py-1 text-xs bg-gray-700 text-white rounded-md hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-opacity-50 font-bold">FR</button>
                </div>
            </div>

            <!-- Customize Section in Modal -->
            <div class="customize-section">
                <div id="modalCustomizeHeader" class="customize-header">
                    <h3 class="text-lg font-semibold text-white">Customize</h3>
                    <svg id="modalCustomizeToggleIcon" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" class="w-5 h-5 text-white">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M19.5 8.25l-7.5 7.5-7.5-7.5" />
                    </svg>
                </div>
                <div id="modalCustomizeContent" class="customize-content">
                    <div class="flex flex-col space-y-2 w-full mb-4">
                        <div class="flex flex-col items-start w-full">
                            <div class="button-group flex-wrap w-full">
                                <button id="modalToggleContainerBtn" class="bg-gray-700 text-white focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-opacity-50">Custom Width</button>
                                <button id="modalToggleTitleBtn" class="bg-gray-700 text-white focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-opacity-50">Hide Title</button>
                                <button id="modalToggleCssBtn" class="bg-gray-700 text-white rounded-md hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-opacity-50">Disable CSS</button>
                            </div>
                        </div>
                    </div>
                    <div class="mb-4" id="modalH1TitleInputContainer">
                        <input type="text" id="modalH1TitleInput" class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500" placeholder="e.g., My Custom ENG Title">
                    </div>
                    <div class="flex flex-col space-y-2 w-full">
                        <div class="flex flex-row flex-wrap justify-center sm:justify-start w-full mt-2 space-x-4">
                            <div class="flex flex-col items-start mt-2 sm:mt-0">
                                <span class="text-sm font-medium text-gray-200 mb-1">Byline:</span>
                                <div class="button-group individual-rounded-buttons flex-wrap justify-center sm:justify-start">
                                    <button id="modalNoneBylineBtn" class="bg-gray-700 text-white rounded-md hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-opacity-50">None</button>
                                    <button id="modalEnglishBylineBtn" class="bg-gray-700 text-white rounded-md hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-opacity-50">English</button>
                                    <button id="modalFrenchBylineBtn" class="bg-gray-700 text-white rounded-md hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-opacity-50">French</button>
                                </div>
                            </div>
                            <div class="flex flex-col items-start">
                                <span class="text-sm font-medium text-gray-200 mb-1">Image source:</span>
                                <div class="button-group individual-rounded-buttons flex-wrap justify-center sm:justify-start">
                                    <button id="modalLocalImagesBtn" class="bg-gray-700 text-white rounded-md hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-opacity-50">Local</button>
                                    <button id="modalPreviewImagesBtn" class="bg-gray-700 text-white rounded-md hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-opacity-50" title="Users MUST be on TBS network">Preview</button>
                                    <button id="modalToggleLiveImagesBtn" class="bg-gray-700 text-white rounded-md hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-opacity-50">Live</button>
                                </div>
                            </div>
                            <div class="flex flex-col items-start mt-2 sm:mt-0">
                                <span class="text-sm font-medium text-gray-200 mb-1">URL source:</span>
                                <div class="button-group individual-rounded-buttons flex-wrap justify-center sm:justify-start">
                                    <button id="modalLocalUrlsBtn" class="bg-gray-700 text-white rounded-md hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-opacity-50">Local</button>
                                    <button id="modalPreviewUrlsBtn" class="bg-gray-700 text-white rounded-md hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-opacity-50" title="Users MUST be on TBS network">Preview</button>
                                    <button id="modalToggleLiveUrlsBtn" class="bg-gray-700 text-white rounded-md hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-opacity-50">Live</button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <iframe id="modalPreviewFrame" title="Live HTML Preview"></iframe>

            <!-- Search and Section/Headings Toggles (moved below iframe) -->
            <div class="mt-auto pt-4 flex flex-col space-y-2 w-full">
                <div class="flex items-center space-x-2 w-full flex-wrap">
                    <input type="text" id="modalPreviewSearchInput" placeholder="Find in preview..." class="px-2 py-1 text-sm border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500 flex-grow">
                    <button id="modalPreviewFindPrevBtn" class="px-3 py-1 text-sm bg-blue-500 text-white rounded-md hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50 font-bold">Prev</button>
                    <button id="modalPreviewFindNextBtn" class="px-3 py-1 text-sm bg-blue-500 text-white rounded-md hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50 font-bold">Next</button>
                    <button id="modalToggleSectionsBtn" class="px-3 py-1 text-sm bg-gray-700 text-white rounded-md hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-opacity-50 font-bold">Sections</button>
                    <button id="modalToggleHeadingsBtn" class="px-3 py-1 text-sm bg-gray-700 text-white rounded-md hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-opacity-50 font-bold">Headings</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Monaco Editor Loader -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.29.1/min/vs/loader.min.js"></script>
    <script>
        let editor;
        let htmlModel;
        let currentLineDecorations = []; // To manage Monaco decorations for line highlighting
        let currentEntityDecorations = []; // To manage Monaco decorations for entity highlighting

        // Get button references
        const autoEncodeBtn = document.getElementById('autoEncodeBtn');
        const autoFormatBtn = document.getElementById('autoFormatBtn');
        const copyCodeBtn = document.getElementById('copyCodeBtn');
        const importHtmlBtn = document.getElementById('importHtmlBtn');
        const exportHtmlBtn = document.getElementById('exportHtmlBtn');
        const htmlFileInput = document.getElementById('htmlFileInput');
        const validationResultsDiv = document.getElementById('validationResults');

        // New elements for Auto-Check feature
        const toggleAutoCheckOnSwitch = document.getElementById('toggleAutoCheckOnSwitch');
        const validateNowBtn = document.getElementById('validateNowBtn');
        let isAutoCheckEnabled = true; // Default to ON

        // New Preview button and modal elements
        const previewBtn = document.getElementById('previewBtn');
        const previewModal = document.getElementById('previewModal');
        const modalPreviewFrame = document.getElementById('modalPreviewFrame');
        const closePreviewModalBtn = document.getElementById('closePreviewModalBtn');

        // Modal Preview Controls (new references)
        const modalCustomizeHeader = document.getElementById('modalCustomizeHeader');
        const modalCustomizeContent = document.getElementById('modalCustomizeContent');
        const modalCustomizeToggleIcon = document.getElementById('modalCustomizeToggleIcon');
        const modalToggleContainerBtn = document.getElementById('modalToggleContainerBtn');
        const modalToggleTitleBtn = document.getElementById('modalToggleTitleBtn');
        const modalToggleCssBtn = document.getElementById('modalToggleCssBtn');
        const modalH1TitleInput = document.getElementById('modalH1TitleInput');
        const modalH1TitleInputContainer = document.getElementById('modalH1TitleInputContainer');
        const modalNoneBylineBtn = document.getElementById('modalNoneBylineBtn');
        const modalEnglishBylineBtn = document.getElementById('modalEnglishBylineBtn');
        const modalFrenchBylineBtn = document.getElementById('modalFrenchBylineBtn');
        const modalLocalImagesBtn = document.getElementById('modalLocalImagesBtn');
        const modalPreviewImagesBtn = document.getElementById('modalPreviewImagesBtn');
        const modalToggleLiveImagesBtn = document.getElementById('modalToggleLiveImagesBtn');
        const modalLocalUrlsBtn = document.getElementById('modalLocalUrlsBtn');
        const modalPreviewUrlsBtn = document.getElementById('modalPreviewUrlsBtn');
        const modalToggleLiveUrlsBtn = document.getElementById('modalToggleLiveUrlsBtn');
        const modalPreviewSearchInput = document.getElementById('modalPreviewSearchInput');
        const modalPreviewFindPrevBtn = document.getElementById('modalPreviewFindPrevBtn');
        const modalPreviewFindNextBtn = document.getElementById('modalPreviewFindNextBtn');
        const modalToggleSectionsBtn = document.getElementById('modalToggleSectionsBtn');
        const modalToggleHeadingsBtn = document.getElementById('modalToggleHeadingsBtn');
        const modalWetGcdsToggleBtn = document.getElementById('modalWetGcdsToggleBtn');
        const modalLangEnBtn = document.getElementById('modalLangEnBtn');
        const modalLangFrBtn = document.getElementById('modalLangFrBtn');


        // State variables for Preview Modal (mirroring main preview)
        let modalShowSections = false;
        let modalShowHeadings = false;
        let modalUseContainerDiv = true;
        let modalShowTitle = true;
        let modalImageSourceMode = 'local';
        let modalBylineMode = 'none';
        let modalIsCustomizeExpanded = false;
        let modalEnableCss = true;
        let modalUrlSourceMode = 'local';
        let modalCurrentLanguage = 'en';
        let modalCurrentFramework = 'wet'; // Default framework: 'wet', 'gcds', or 'wet+'
        let modalH1TitleEn = '';
        let modalH1TitleFr = '';
        let modalLastSearchTerm = ''; // For modal's internal search


        // Sets of elements for HTML validation
        const selfClosingTags = new Set([
            'area', 'base', 'br', 'col', 'embed', 'hr', 'img', 'input',
            'link', 'meta', 'param', 'source', 'track', 'wbr'
        ]);

        const deprecatedTags = new Set([
            'acronym', 'applet', 'basefont', 'big', 'center', 'dir', 'font',
            'frame', 'frameset', 'noframes', 'strike', 'tt', 'u'
        ]);

        const blockElements = new Set([
            'address', 'article', 'aside', 'blockquote', 'canvas', 'dd', 'div', 'dl', 'dt',
            'fieldset', 'figcaption', 'figure', 'footer', 'form', 'h1', 'h2', 'h3', 'h4',
            'h5', 'h6', 'header', 'hr', 'li', 'main', 'nav', 'noscript', 'ol', 'p',
            'pre', 'section', 'table', 'tfoot', 'ul', 'video'
        ]);

        const inlineElements = new Set([
            'a', 'abbr', 'b', 'bdo', 'br', 'button', 'cite', 'code',
            'dfn', 'em', 'i', 'img', 'input', 'kbd', 'label', 'map', 'object', 'q',
            'samp', 'script', 'select', 'small', 'span', 'strong', 'sub', 'sup',
            'textarea', 'time', 'var'
        ]);

        const mediaSizingElements = new Set([
            'img', 'iframe', 'video', 'canvas', 'object', 'embed'
        ]);

        const targetValidElements = new Set(['a', 'form']);

        // Tags to completely ignore during validation (e.g., for custom XML-like tags within HTML)
        const ignoredTags = new Set([
            'doc' // User requested to ignore <doc> tag
        ]);

        function isBlockElement(tagName) {
            return blockElements.has(tagName);
        }

        function isInlineElement(tagName) {
            return inlineElements.has(tagName);
        }

        function isWithinAnyRange(index, ranges) {
            for (const range of ranges) {
                if (index >= range.start && index <= range.end) {
                    return true;
                }
            }
            return false;
        }

        function isStartOfValidTag(index, tagRanges) {
            for (const range of tagRanges) {
                if (index === range.start) {
                    return true;
                }
            }
            return false;
        }

        function isEndOfValidTag(index, tagRanges) {
            for (const range of tagRanges) {
                if (index === range.end) {
                    return true;
                }
            }
            return false;
        }

        /**
         * Debounce function to limit how often a function is called.
         * @param {Function} func - The function to debounce.
         * @param {number} delay - The delay in milliseconds.
         * @returns {Function} The debounced function.
         */
        function debounce(func, delay) {
            let timeout;
            return function(...args) {
                const context = this;
                clearTimeout(timeout);
                timeout = setTimeout(() => func.apply(context, args), delay);
            };
        }

        /**
         * Highlights HTML entities in the Monaco editor.
         */
        function highlightHtmlEntities() {
            const model = editor.getModel();
            const text = model.getValue();
            // Regex to match common HTML entities (named and numeric)
            const entityRegex = /&[a-zA-Z]+;|&#[0-9]+;|&#x[0-9a-fA-F]+;/g;
            let match;
            const newDecorations = [];

            while ((match = entityRegex.exec(text)) !== null) {
                const startPosition = model.getPositionAt(match.index);
                const endPosition = model.getPositionAt(match.index + match[0].length);
                newDecorations.push({
                    range: new monaco.Range(startPosition.lineNumber, startPosition.column, endPosition.lineNumber, endPosition.column),
                    options: {
                        inlineClassName: 'entity-highlight',
                        hoverMessage: { value: `HTML Entity: ${match[0]}` }
                    }
                });
            }

            currentEntityDecorations = editor.deltaDecorations(currentEntityDecorations, newDecorations);
        }

        /**
         * Converts common character entities and named entities to their numeric HTML entity equivalents.
         * This function operates on an HTML string, parsing it to a temporary DOM, modifying text nodes,
         * and then serializing it back to a string, ensuring numeric entities are preserved.
         * It also handles preserving the XML declaration if present at the beginning.
         * @param {string} htmlString - The HTML string to process.
         * @returns {string} The processed HTML string with numeric entities.
         */
        function convertAllEntitiesToNumeric(htmlString) {
            let xmlDeclaration = '';
            let contentToProcess = htmlString;

            // Regex to find <?xml ...?> at the very beginning of the string, optionally with leading whitespace
            const xmlDeclRegex = /^\s*(<\?xml[^>]*\?>)/i;
            const match = htmlString.match(xmlDeclRegex);

            if (match) {
                xmlDeclaration = match[1]; // Capture the full XML declaration
                contentToProcess = htmlString.substring(match[0].length); // Get content after the declaration
            }

            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = contentToProcess; // Process only the HTML content

            const walker = document.createTreeWalker(
                tempDiv,
                NodeFilter.SHOW_TEXT,
                {
                    acceptNode: function(textNode) {
                        let parent = textNode.parentNode;
                        while (parent) {
                            const tagName = parent.tagName ? parent.tagName.toLowerCase() : '';
                            if (tagName === 'script' || tagName === 'style' || tagName === 'time') {
                                return NodeFilter.FILTER_REJECT;
                            }
                            parent = parent.parentNode;
                        }
                        return NodeFilter.FILTER_ACCEPT;
                    }
                },
                false
            );

            let currentNode;
            const textNodesToProcess = [];
            while (currentNode = walker.nextNode()) {
                textNodesToProcess.push(currentNode);
            }

            textNodesToProcess.forEach(textNode => {
                let text = textNode.nodeValue;
                // Replace specific named entities/characters with their numeric character references
                text = text.replace(/’/g, '&#8217;');    // literal ’
                text = text.replace(/&rsquo;/g, '&#8217;'); // &rsquo;
                text = text.replace(/“/g, '&#8220;');    // literal “
                text = text.replace(/&ldquo;/g, '&#8220;'); // &ldquo;
                text = text.replace(/”/g, '&#8221;');    // literal ”
                text = text.replace(/&rdquo;/g, '&#8221;'); // &rdquo;
                text = text.replace(/«/g, '&#171;');    // literal «
                text = text.replace(/&laquo;/g, '&#171;'); // &laquo;
                text = text.replace(/»/g, '&#187;');    // literal »
                text = text.replace(/&raquo;/g, '&#187;'); // &raquo;
                text = text.replace(/\u00A0/g, '&#160;'); // This converts literal NBSP char to numeric entity
                text = text.replace(/&nbsp;/g, '&#160;'); // This handles named NBSP entity to numeric

                textNode.nodeValue = text;
            });

            let processedHtml = tempDiv.innerHTML; // This re-serializes characters to entities

            // Final string-based replacements to ensure numeric entities are explicitly present
            processedHtml = processedHtml.replace(/&nbsp;/g, '&#160;');
            processedHtml = processedHtml.replace(/&rsquo;/g, '&#8217;');
            processedHtml = processedHtml.replace(/&ldquo;/g, '&#8220;');
            processedHtml = processedHtml.replace(/&rdquo;/g, '&#8221;');
            processedHtml = processedHtml.replace(/&laquo;/g, '&#171;');
            processedHtml = processedHtml.replace(/&raquo;/g, '&#187;');

            // Handle double encoding if it occurs (e.g., &amp;#160; -> &#160;)
            processedHtml = processedHtml.replace(/&amp;#(\d+);/g, '&#$1;');

            return xmlDeclaration + processedHtml; // Prepend the XML declaration back
        }

        /**
         * Validates HTML content.
         * @param {string} fullHtmlCode - The full HTML code from the editor.
         */
        async function validateHtmlContent(fullHtmlCode) {
            const validationResultsDiv = document.getElementById('validationResults');
            let htmlCodeToValidate = fullHtmlCode;
            let bodyContentOffsetIndex = 0; // The starting index of the body content within the full HTML

            // Try to extract content within <body> tags
            const bodyMatch = fullHtmlCode.match(/<body[^>]*>([\s\S]*?)<\/body>/i);
            if (bodyMatch && bodyMatch[1]) {
                htmlCodeToValidate = bodyMatch[1];
                // Calculate the starting index of the matched body content in the full HTML
                bodyContentOffsetIndex = fullHtmlCode.indexOf(bodyMatch[1], bodyMatch.index);
            } else {
                // If no body tags are found, treat the entire content as body content.
                htmlCodeToValidate = fullHtmlCode;
                bodyContentOffsetIndex = 0;
            }

            const errors = [];

            // Clear any existing line highlight in Monaco
            currentLineDecorations = editor.deltaDecorations(currentLineDecorations, []);

            // Show loading state immediately
            validationResultsDiv.classList.remove('bg-green-100', 'text-green-800', 'border-green-300', 'bg-red-100', 'text-red-800', 'border-red-300');
            validationResultsDiv.innerHTML = '<p class="text-gray-500 text-center">Validating HTML... please wait.</p>';
            // Allow browser to render the loading state before starting heavy work
            await new Promise(resolve => setTimeout(resolve, 50));

            try {
                const parser = new DOMParser();

                let isXmlLikeDoc = false;
                const trimmedCode = fullHtmlCode.trim();
                // Check for <?xml declaration at the very beginning of the document
                if (trimmedCode.startsWith('<?xml')) {
                    // Check if <doc> is the primary wrapper after the XML declaration
                    // This regex looks for <doc> at the start of the content after <?xml...?> and </doc> at the end
                    const docWrapperRegex = /^\s*<\?xml[^>]*\?>\s*<doc[^>]*>[\s\S]*<\/doc>\s*$/i;
                    if (docWrapperRegex.test(trimmedCode)) {
                        isXmlLikeDoc = true;
                    }
                }

                // If it's an XML-like document structure, enforce numerical entities
                if (isXmlLikeDoc) {
                    const namedEntityRegex = /&([a-zA-Z]+);/g; // Matches named entities like &nbsp;
                    let hasNamedEntities = false;
                    namedEntityRegex.lastIndex = 0; // Reset regex lastIndex for consistent behavior
                    while (namedEntityRegex.exec(fullHtmlCode) !== null) {
                        hasNamedEntities = true;
                        break; // Found at least one, no need to check further
                    }

                    if (hasNamedEntities) {
                        errors.push({
                            message: `XML Encoding Error: Named HTML entities are present. Convert to numerical entities.`,
                            lineNumber: 'N/A' // Generic error, not tied to a specific line
                        });
                    }
                }


                const tempDoc = parser.parseFromString(htmlCodeToValidate, 'text/html');

                const validAnchors = new Set();
                tempDoc.querySelectorAll('[id]').forEach(el => {
                    if (el.id) {
                        validAnchors.add(el.id);
                    }
                });
                tempDoc.querySelectorAll('[name]').forEach(el => {
                    const nameAttr = el.getAttribute('name');
                    if (nameAttr) {
                        validAnchors.add(nameAttr);
                    }
                });

                const idRegex = /\bid\s*=\s*(["'])(.*?)\1/g;
                const foundIds = new Map();

                let idMatch;
                idRegex.lastIndex = 0;
                while ((idMatch = idRegex.exec(htmlCodeToValidate)) !== null) {
                    const idValue = idMatch[2];
                    const absoluteIndex = bodyContentOffsetIndex + idMatch.index;
                    const idLineNumber = editor.getModel().getPositionAt(absoluteIndex).lineNumber;
                    const idInfo = { lineNumber: idLineNumber, index: absoluteIndex };

                    if (foundIds.has(idValue)) {
                        foundIds.get(idValue).push(idInfo);
                    } else {
                        foundIds.set(idValue, [idInfo]);
                    }
                }

                for (const [idValue, idInfos] of foundIds.entries()) {
                    if (idInfos.length > 1) {
                        errors.push({
                            message: `Duplicate ID: "${idValue}" found on lines: ${idInfos.map(info => info.lineNumber).join(', ')}.`,
                            lineNumber: idInfos[0].lineNumber
                        });
                    }
                }

                const liElements = tempDoc.querySelectorAll('li');
                liElements.forEach(li => {
                    if (li.parentNode && li.parentNode.tagName.toLowerCase() === 'li') {
                        const liOuterHtml = li.outerHTML;
                        let liIndexInBodyContent = htmlCodeToValidate.indexOf(liOuterHtml);
                        if (liIndexInBodyContent === -1) {
                            liIndexInBodyContent = htmlCodeToValidate.indexOf(`<${li.tagName.toLowerCase()}`);
                        }
                        if (liIndexInBodyContent !== -1) {
                            const absoluteLiIndex = bodyContentOffsetIndex + liIndexInBodyContent;
                            const liLineNumber = editor.getModel().getPositionAt(absoluteLiIndex).lineNumber;
                            errors.push({
                                message: `Line ${liLineNumber}: Improper list nesting: &lt;li&gt; cannot be directly nested within another &lt;li&gt;. It must be inside a &lt;ul&gt; or &lt;ol&gt;.`,
                                lineNumber: liLineNumber
                            });
                        }
                    }
                });

                const tagBoundaries = [];
                // Regex to capture HTML tags and processing instructions like <?xml ...?>
                const fullTagAndPIRegex = /<\/?[\w-]+(?:\s+[^>]*?)?>|<\?[\s\S]*?\?>/g;
                let tagMatchForBoundaries;
                fullTagAndPIRegex.lastIndex = 0;
                while ((tagMatchForBoundaries = fullTagAndPIRegex.exec(htmlCodeToValidate)) !== null) {
                    tagBoundaries.push({
                        start: tagMatchForBoundaries.index,
                        end: tagMatchForBoundaries[0].length > 0 ? tagMatchForBoundaries.index + tagMatchForBoundaries[0].length - 1 : tagMatchForBoundaries.index
                    });
                }

                const entityBoundaries = [];
                const entityRegex = /&(?:[a-zA-Z]+|#\d+);/g;
                let entityMatch;
                entityRegex.lastIndex = 0;
                while ((entityMatch = entityRegex.exec(htmlCodeToValidate)) !== null) {
                    entityBoundaries.push({
                        start: entityMatch.index,
                        end: entityMatch.index + entityMatch[0].length - 1
                    });
                }

                const commentRegex = /<!--[\s\S]*?-->/g;
                let commentMatch;
                commentRegex.lastIndex = 0;
                const commentBoundaries = [];
                while ((commentMatch = commentRegex.exec(htmlCodeToValidate)) !== null) {
                    commentBoundaries.push({
                        start: commentMatch.index,
                        end: commentMatch.index + commentMatch[0].length - 1
                    });
                }

                for (let i = 0; i < htmlCodeToValidate.length; i++) {
                    const char = htmlCodeToValidate[i];
                    const absoluteCharIndex = bodyContentOffsetIndex + i;
                    const lineNumber = editor.getModel().getPositionAt(absoluteCharIndex).lineNumber;

                    if (isWithinAnyRange(i, commentBoundaries)) {
                        continue;
                    }

                    // Check for processing instructions like <?xml ...?>
                    const piMatch = htmlCodeToValidate.substring(i).match(/^\<\?xml\s[\s\S]*?\?\>/i);
                    if (piMatch && piMatch.index === 0) { // If it's a processing instruction at the current index
                        i += piMatch[0].length - 1; // Skip past the entire processing instruction
                        continue;
                    }

                    if (char === '<') {
                        const isTagStart = isStartOfValidTag(i, tagBoundaries);
                        const isEntityPart = isWithinAnyRange(i, entityBoundaries);

                        if (!isTagStart && !isEntityPart) {
                            let context = htmlCodeToValidate.substring(i, Math.min(i + 20, htmlCodeToValidate.length)).split('\n')[0].
                                trim();
                            errors.push({
                                message: `Line ${lineNumber}: Orphan '<' found. Possible malformed tag or extra character near: "${context}..."`,
                                lineNumber: lineNumber
                            });
                        }
                    } else if (char === '>') {
                        const isTagEnd = isEndOfValidTag(i, tagBoundaries);
                        const isEntityPart = isWithinAnyRange(i, entityBoundaries);

                        if (!isTagEnd && !isEntityPart) {
                            let contextStart = Math.max(0, i - 20);
                            let context = htmlCodeToValidate.substring(contextStart, i + 1).split('\n').pop().
                                trim();
                            errors.push({
                                message: `Line ${lineNumber}: Orphan '>' found. Possible malformed tag or extra character near: "...${context}"`,
                                lineNumber: lineNumber
                            });
                        }
                    }
                }

                // Corrected regex to capture attributes string as match[2] and self-closing slash as match[3]
                const tagRegexForValidation = /<\/?([a-zA-Z0-9]+)(\s+[^>]*?)?(\/?)>/g;
                tagRegexForValidation.lastIndex = 0;
                const tagStack = [];

                let match;
                while ((match = tagRegexForValidation.exec(htmlCodeToValidate)) !== null) {
                    const fullTag = match[0];
                    const tagName = match[1].toLowerCase();
                    // Capture attributes string and trim any leading space
                    const attributesString = (match[2] || '').trim();
                    const isSelfClosingSyntax = match[3] === '/';

                    const absoluteMatchIndex = bodyContentOffsetIndex + match.index;
                    const lineNumber = editor.getModel().getPositionAt(absoluteMatchIndex).lineNumber;

                    if (isWithinAnyRange(match.index, commentBoundaries)) {
                        continue;
                    }

                    // Ignore tags specified in `ignoredTags` set
                    if (ignoredTags.has(tagName)) {
                        // If it's an opening tag, push a placeholder to balance the stack if needed,
                        // but don't apply other validation rules.
                        if (!fullTag.startsWith('</') && !isSelfClosingSyntax) {
                            tagStack.push({ tagName: tagName, lineNumber: lineNumber, ignored: true });
                        } else if (fullTag.startsWith('</')) {
                            // For closing ignored tags, try to pop a matching ignored tag
                            let found = false;
                            for (let i = tagStack.length - 1; i >= 0; i--) {
                                if (tagStack[i].tagName === tagName && tagStack[i].ignored) {
                                    tagStack.splice(i, 1); // Remove it
                                    found = true;
                                    break;
                                }
                            }
                            if (!found) {
                                // If no matching ignored tag found on stack, it's an unmatched closing tag
                                errors.push({
                                    message: `Line ${lineNumber}: Unmatched closing tag: &lt;/${tagName}&gt;. (Ignored tag)`,
                                    lineNumber: lineNumber
                                });
                            }
                        }
                        continue; // Skip all other validation for ignored tags
                    }


                    if (fullTag.startsWith('</')) {
                        if (tagStack.length === 0) {
                            errors.push({
                                message: `Line ${lineNumber}: Unmatched closing tag: &lt;/${tagName}&gt;`,
                                lineNumber: lineNumber
                            });
                        } else {
                            const lastOpenTag = tagStack.pop();
                            if (lastOpenTag.tagName !== tagName) {
                                errors.push({
                                    message: `Line ${lineNumber}: Mismatched closing tag: Expected &lt;/${lastOpenTag.tagName}&gt; (opened on line ${lastOpenTag.lineNumber}), but found &lt;/${tagName}&gt;.`,
                                    lineNumber: lineNumber
                                });
                            }
                        }
                    } else {
                        // Check for specific nesting rules
                        const parentTag = tagStack.length > 0 ? tagStack[tagStack.length - 1] : null;

                        if (tagName === 'chapter' && (!parentTag || parentTag.tagName !== 'chapters')) {
                            errors.push({
                                message: `Line ${lineNumber}: &lt;chapter&gt; tag must be directly nested within a &lt;chapters&gt; tag.`,
                                lineNumber: lineNumber
                            });
                        }
                        if (tagName === 'clause' && (!parentTag || parentTag.tagName !== 'clauses')) {
                            errors.push({
                                message: `Line ${lineNumber}: &lt;clause&gt; tag must be directly nested within a &lt;clauses&gt; tag.`,
                                lineNumber: lineNumber
                            });
                        }
                        if (tagName === 'appendix') {
                            // Check if <appendix> is within <appendices> at least once (initial nesting)
                            // Or if it's within another <appendix> (allowed nesting)
                            if (!parentTag || (parentTag.tagName !== 'appendices' && parentTag.tagName !== 'appendix')) {
                                errors.push({
                                    message: `Line ${lineNumber}: &lt;appendix&gt; tag must be directly nested within an &lt;appendices&gt; tag or another &lt;appendix&gt; tag.`,
                                  lineNumber: lineNumber
                                });
                            }
                        }

                        // New check: <appendices> or <appendix> should not be within <chapters>
                        if (tagName === 'appendices' || tagName === 'appendix') {
                            for (let i = tagStack.length - 1; i >= 0; i--) {
                                const ancestorTag = tagStack[i];
                                if (ancestorTag.tagName === 'chapters' || ancestorTag.tagName === 'chapter') {
                                    errors.push({
                                        message: `Line ${lineNumber}: Invalid nesting: &lt;${tagName}&gt; cannot be nested within &lt;${ancestorTag.tagName}&gt; (opened on line ${ancestorTag.lineNumber}). Appendices should be outside chapters.`,
                                        lineNumber: lineNumber
                                    });
                                    break; // Found an invalid ancestor, no need to check further up the stack
                                }
                            }
                        }


                        if (isSelfClosingSyntax && !selfClosingTags.has(tagName)) {
                            errors.push({
                                message: `Line ${lineNumber}: Invalid self-closing syntax for &lt;${tagName}&gt;. This tag should not be self-closed with '/>'.`,
                                lineNumber: lineNumber
                            });
                        }

                        if (deprecatedTags.has(tagName)) {
                            errors.push({
                                message: `Line ${lineNumber}: Deprecated tag: &lt;${tagName}&gt;. Consider using modern alternatives.`,
                                lineNumber: lineNumber
                            });
                        }

                        if (tagName === 'img') {
                            if (!/\balt\b/i.test(attributesString)) {
                                errors.push({
                                    message: `Line ${lineNumber}: &lt;img&gt; tag is missing the required 'alt' attribute for accessibility.`,
                                    lineNumber: lineNumber
                                });
                            }
                            if (!/\bsrc\b/i.test(attributesString)) {
                                errors.push({
                                    message: `Line ${lineNumber}: &lt;img&gt; tag is missing the required 'src' attribute.`,
                                    lineNumber: lineNumber
                                });
                            }
                        } else if (tagName === 'th') {
                            // Corrected logic: Check if EITHER scope OR id is present
                            if (!/\bscope\b/i.test(attributesString) && !/\bid\b/i.test(attributesString)) {
                                errors.push({
                                    message: `Line ${lineNumber}: &lt;th&gt; tag should have either a 'scope' or an 'id' attribute for accessibility.`,
                                    lineNumber: lineNumber
                                });
                            }
                        } else if (tagName === 'tr') {
                            if (/\bcolspan\b/i.test(attributesString) || /\browspan\b/i.test(attributesString)) {
                                errors.push({
                                    message: `Line ${lineNumber}: Invalid attribute: 'colspan' or 'rowspan' found on a &lt;tr&gt; tag. These attributes are only valid on &lt;th&gt; or &lt;td&gt; tags.`,
                                    lineNumber: lineNumber
                                });
                            }
                        }

                        if (/\balign\b/i.test(attributesString)) {
                            errors.push({
                                message: `Line ${lineNumber}: Deprecated attribute: 'align' found on &lt;${tagName}&gt;. Use CSS for alignment instead.`,
                                lineNumber: lineNumber
                            });
                        }

                        if ((/\bwidth\b/i.test(attributesString) || /\bheight\b/i.test(attributesString)) && !mediaSizingElements.has(tagName)) {
                            errors.push({
                                message: `Line ${lineNumber}: Improper attribute: 'width' or 'height' found on &lt;${tagName}&gt;. Consider using CSS for sizing this element.`,
                                lineNumber: lineNumber
                            });
                        }

                        if (/\btarget\b/i.test(attributesString) && !targetValidElements.has(tagName)) {
                            errors.push({
                                message: `Line ${lineNumber}: Improper attribute: 'target' found on &lt;${tagName}&gt;. The 'target' attribute is only valid on &lt;a&gt; or &lt;form&gt; tags.`,
                                lineNumber: lineNumber
                            });
                        }

                        if (tagName === 'a') {
                            const hrefMatch = attributesString.match(/\bhref\s*=\s*(["'])(.*?)\1/i);
                            if (hrefMatch) {
                                const href = hrefMatch[2];
                                if (href.startsWith('#') && href.length > 1) {
                                    const anchorId = href.substring(1);
                                    if (!validAnchors.has(anchorId)) {
                                        errors.push({
                                            message: `Line ${lineNumber}: Broken anchor link: &lt;a href="#${anchorId}"&gt; points to a non-existent ID or name attribute.`,
                                            lineNumber: lineNumber
                                        });
                                    }
                                }
                            }
                        }

                        if (tagStack.length > 0) {
                            const parentTag = tagStack[tagStack.length - 1];
                            // Only check nesting if parent is not an ignored tag
                            if (!parentTag.ignored && isInlineElement(parentTag.tagName) && isBlockElement(tagName)) {
                                errors.push({
                                    message: `Line ${lineNumber}: Invalid nesting: Block-level element &lt;${tagName}&gt; cannot be nested inside inline element &lt;${parentTag.tagName}&gt; (opened on line ${parentTag.lineNumber}).`,
                                    lineNumber: lineNumber
                                });
                            }
                        }

                        if (!selfClosingTags.has(tagName) && !isSelfClosingSyntax) {
                            tagStack.push({ tagName: tagName, lineNumber: lineNumber, index: absoluteMatchIndex });
                        }
                    }
                }

                while (tagStack.length > 0) {
                    const unclosedTag = tagStack.pop();
                    // Only report unclosed errors for non-ignored tags
                    if (!unclosedTag.ignored) {
                        errors.push({
                            message: `Line ${unclosedTag.lineNumber}: Unclosed tag: &lt;${unclosedTag.tagName}&gt;.`,
                            lineNumber: unclosedTag.lineNumber
                        });
                    }
                }
                return isXmlLikeDoc; // Return this to be used for button state
            } catch (e) {
                console.error("Error during HTML validation:", e);
                errors.push({
                    message: `An unexpected error occurred during HTML validation: ${e.message}. Please check your HTML for severe syntax issues.`,
                    lineNumber: 'N/A'
                });
                return false; // Assume not XML-like on error
            } finally {
                displayValidationResults(errors);
                highlightHtmlEntities(); // Always highlight HTML entities in HTML mode
            }
        }

        /**
         * Displays validation results in the UI.
         * @param {Array} errors - Array of error objects.
         */
        function displayValidationResults(errors) {
            const validationResultsDiv = document.getElementById('validationResults');
            validationResultsDiv.innerHTML = '';

            if (errors.length === 0) {
                validationResultsDiv.classList.remove('bg-red-100', 'text-red-800', 'border-red-300');
                validationResultsDiv.classList.add('bg-green-100', 'text-green-800', 'border-green-300');
                validationResultsDiv.innerHTML = '<p class="font-semibold text-center">🎉 Valid! No further adjustment needed. 🎉</p>';
            } else {
                validationResultsDiv.classList.remove('bg-green-100', 'text-green-800', 'border-red-300');
                validationResultsDiv.classList.add('bg-red-100', 'text-red-800', 'border-red-300');
                const errorList = document.createElement('ul');
                errorList.classList.add('list-disc', 'pl-5');
                errors.forEach(error => {
                    const listItem = document.createElement('li');
                    listItem.innerHTML = error.message;
                    // Only add data-lineNumber if it's a valid number for highlighting
                    if (typeof error.lineNumber === 'number') {
                        listItem.dataset.lineNumber = error.lineNumber;
                    }
                    errorList.appendChild(listItem);
                });
                validationResultsDiv.appendChild(errorList);
            }
            console.log("Validation errors:", errors); // For debugging
        }

        /**
         * Handles clicks on the validation error list items to highlight the line in Monaco.
         * @param {Event} event - The click event.
         */
        function handleResultClick(event) {
            const listItem = event.target.closest('li[data-line-number]');
            if (listItem) {
                const lineNumber = parseInt(listItem.dataset.lineNumber, 10);

                // Clear previous line decorations
                currentLineDecorations = editor.deltaDecorations(currentLineDecorations, []);

                // Apply new decoration for the clicked line
                currentLineDecorations = editor.deltaDecorations(currentLineDecorations, [
                    {
                        range: new monaco.Range(lineNumber, 1, lineNumber, editor.getModel().getLineMaxColumn(lineNumber)),
                        options: {
                            className: 'highlighted-line',
                            isOverviewRuler: true, // Show in overview ruler
                            overviewRulerLane: monaco.editor.OverviewRulerLane.Full,
                            overviewRulerColor: 'rgba(100, 149, 237, 0.6)' // Match the line highlight color
                        }
                    }
                ]);

                editor.revealLineInCenter(lineNumber);
                editor.focus();
            }
        }

        /**
         * Updates the disabled state of the "Validate" button based on the "Auto-Check" toggle.
         */
        function updateValidateButtonState() {
            if (toggleAutoCheckOnSwitch.checked) {
                validateNowBtn.disabled = true;
                validateNowBtn.classList.remove('bg-gray-700', 'hover:bg-gray-600');
                validateNowBtn.classList.add('bg-gray-400', 'cursor-not-allowed', 'opacity-60');
            } else {
                validateNowBtn.disabled = false;
                validateNowBtn.classList.remove('bg-gray-400', 'cursor-not-allowed', 'opacity-60');
                validateNowBtn.classList.add('bg-gray-700', 'hover:bg-gray-600');
            }
        }

        /**
         * Updates the disabled state of the "Preview" button based on whether the content is XML-like.
         * @param {boolean} isXmlLike - True if the content is detected as XML-like, false otherwise.
         */
        function updatePreviewButtonState(isXmlLike) {
            previewBtn.disabled = isXmlLike;
            if (isXmlLike) {
                previewBtn.classList.remove('bg-green-600', 'hover:bg-green-700');
                previewBtn.classList.add('bg-gray-400', 'cursor-not-allowed', 'opacity-60');
            } else {
                previewBtn.classList.remove('bg-gray-400', 'cursor-not-allowed', 'opacity-60');
                previewBtn.classList.add('bg-green-600', 'hover:bg-green-700');
            }
        }

        /**
         * Generates the full HTML content for the preview.
         * This function is now comprehensive and handles all preview options.
         * @param {object} options - Options for generating HTML (e.g., showSections, enableCss, etc.)
         * @returns {string} The complete HTML string.
         */
        function generateFullHtml(options) {
            const bodyContent = editor.getValue();
            let customH1Title = (options.currentLanguage === 'en' ? options.h1TitleEn : options.h1TitleFr).trim();

            if (customH1Title === '') {
                customH1Title = (options.currentLanguage === 'en') ? 'Canada.ca Page Title (EN)' : 'Titre de la page Canada.ca (FR)';
            }
            const pageTitle = customH1Title;

            let dynamicTitleHtml = '';
            if (options.showTitle) {
                if (options.currentFramework === 'wet' || options.currentFramework === 'wet+') {
                    dynamicTitleHtml = `<h1 property="name" id="wb-cont">${customH1Title}</h1>`;
                } else if (options.currentFramework === 'gcds') {
                    dynamicTitleHtml = `<gcds-heading tag="h1">${customH1Title}</gcds-heading>`;
                }
            }

            let bylineHtml = '';
            if (options.bylineMode === 'english') {
                if (options.currentFramework === 'wet' || options.currentFramework === 'wet+') {
                    bylineHtml = '<p class="gc-byline"><strong>From: <a href="/en/treasury-board-secretariat.html">Treasury Board of Canada of Canada Secretariat</a></strong></p>';
                } else if (options.currentFramework === 'gcds') {
                    bylineHtml = `<gcds-text><strong>From: <gcds-link href="/en/treasury-board-secretariat.html">Treasury Board of Canada of Canada Secretariat</gcds-link></strong></gcds-text>`;
                }
            } else if (options.bylineMode === 'french') {
                if (options.currentFramework === 'wet' || options.currentFramework === 'wet+') {
                    bylineHtml = '<p class="gc-byline"><strong>De : <a href="/fr/secretariat-conseil-tresor.html">Secrétariat du Conseil du Trésor du Canada</a></strong></p>';
                } else if (options.currentFramework === 'gcds') {
                    bylineHtml = `<gcds-text><strong>De : <gcds-link href="/fr/secretariat-conseil-tresor.html">Secrétariat du Conseil du Conseil du Trésor du Canada</gcds-link></strong></gcds-text>`;
                }
            }

            let h1AndBylineSection = `${dynamicTitleHtml}${bylineHtml}`;
            if ((options.currentFramework === 'gcds') && (dynamicTitleHtml || bylineHtml)) {
                h1AndBylineSection = `<section>${h1AndBylineSection}</section>`;
            }

            let contentToInject = options.useContainerDiv ? `<div class="container">${h1AndBylineSection}${bodyContent}</div>` : `${h1AndBylineSection}${bodyContent}`;

            const parser = new DOMParser();
            const tempDoc = parser.parseFromString(contentToInject, 'text/html');

            const localPrefixes = [
                '/content/canadasite/en/treasury-board-secretariat',
                '/content/canadasite/fr/secretariat-conseil-tresor',
                '/content/canadasite/en/government',
                '/content/canadasite/fr/gouvernement'
            ];

            const previewPrefixes = [
                'https://canada-preview.adobecqms.net/en/treasury-board-secretariat',
                'https://canada-preview.adobecqms.net/fr/secretariat-conseil-tresor',
                'https://canada-preview.adobecqms.net/en/government',
                'https://canada-preview.adobecqms.net/fr/gouvernement'
            ];

            const livePrefixes = [
                'https://www.canada.ca/en/treasury-board-secretariat',
                'https://www.canada.ca/fr/secretariat-conseil-tresor',
                'https://www.canada.ca/en/government',
                'https://www.canada.ca/fr/gouvernement'
            ];

            function replaceUrlPrefix(url, currentPrefixes, targetPrefixes) {
                for (let i = 0; i < currentPrefixes.length; i++) {
                    if (url.startsWith(currentPrefixes[i])) {
                        return targetPrefixes[i] + url.substring(currentPrefixes[i].length);
                    }
                }
                return url;
            }

            const images = tempDoc.querySelectorAll('img');
            images.forEach(img => {
                let src = img.getAttribute('src');
                if (src && !src.startsWith('http://') && !src.startsWith('https://') && !src.startsWith('//')) {
                    let baseUrl = '';
                    if (options.imageSourceMode === 'preview') baseUrl = 'https://canada-preview.adobecqms.net';
                    else if (options.imageSourceMode === 'live') baseUrl = 'https://www.canada.ca';
                    if (baseUrl) img.setAttribute('src', `${baseUrl}${src.startsWith('/') ? '' : '/'}${src}`);
                }
            });

            const links = tempDoc.querySelectorAll('a');
            links.forEach(link => {
                let href = link.getAttribute('href');
                if (href) {
                    if (href.startsWith('/') || href.startsWith('http://') || href.startsWith('https://')) {
                        if (options.urlSourceMode === 'local') {
                            href = replaceUrlPrefix(href, previewPrefixes, localPrefixes);
                            href = replaceUrlPrefix(href, livePrefixes, localPrefixes);
                        } else if (options.urlSourceMode === 'preview') {
                            href = replaceUrlPrefix(href, localPrefixes, previewPrefixes);
                            href = replaceUrlPrefix(href, livePrefixes, previewPrefixes);
                        } else if (options.urlSourceMode === 'live') {
                            href = replaceUrlPrefix(href, localPrefixes, livePrefixes);
                            href = replaceUrlPrefix(href, previewPrefixes, livePrefixes);
                        }
                        link.setAttribute('href', href);
                    }
                }
            });

            contentToInject = tempDoc.body.innerHTML;

            const bodyClassParts = [];
            if (options.showSections) {
                bodyClassParts.push('show-sections-outline');
            }
            if (options.showHeadings) {
                bodyClassParts.push('show-headings-outline');
            }
            const bodyClass = bodyClassParts.filter(Boolean).join(' ');

            let cssLinks = '';
            if (options.enableCss) {
                if (options.currentFramework === 'wet') {
                    cssLinks = `
                        <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.4/css/all.css">
                        <link rel="stylesheet" href="https://www.canada.ca/etc/designs/canada/wet-boew/css/theme.min.css">
                    `;
                } else if (options.currentFramework === 'gcds') {
                    cssLinks = `
                        <link rel="stylesheet" href="https://cdn.design-system.alpha.canada.ca/@cdssnc/gcds-utility@latest/dist/gcds-utility.min.css">
                        <link rel="stylesheet" href="https://cdn.design-system.alpha.canada.ca/@cdssnc/gcds-components@latest/dist/gcds/gcds.css">
                    `;
                } else if (options.currentFramework === 'wet+') {
                    cssLinks = `
                        <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.4/css/all.css">
                        <link rel="stylesheet" href="https://www.canada.ca/etc/designs/canada/wet-boew/css/theme.min.css">
                        <link rel="stylesheet" href="https://cdn.design-system.alpha.canada.ca/@cdssnc/gcds-components@latest/dist/gcds/gcds.css">
                    `;
                }
            }

            let jsScripts = '';
            if (options.currentFramework === 'wet') {
                jsScripts = `
                    <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.2.4/jquery.min.js"><\/script>
                    <script src="https://www.canada.ca/etc/designs/canada/wet-boew/js/wet-boew.min.js"><\/script>
                    <script src="https://www.canada.ca/etc/designs/canada/wet-boew/js/theme.min.js"><\/script>
                `;
            } else if (options.currentFramework === 'gcds') {
                jsScripts = `
                    <script type="module" src="https://cdn.design-system.alpha.canada.ca/@cdssnc/gcds-components@latest/dist/gcds/gcds.esm.js"><\/script>
                    <script nomodule src="https://cdn.design-system.alpha.canada.ca/@cdssnc/gcds-components@latest/dist/gcds/gcds.js"><\/script>
                `;
            } else if (options.currentFramework === 'wet+') {
                jsScripts = `
                    <script type="module" src="https://cdn.design-system.alpha.canada.ca/@cdssnc/gcds-components@latest/dist/gcds/gcds.esm.js"><\/script>
                    <script nomodule src="https://cdn.design-system.alpha.canada.ca/@cdssnc/gcds-components@latest/dist/gcds/gcds.js"><\/script>
                    <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.2.4/jquery.min.js"><\/script>
                    <script src="https://www.canada.ca/etc/designs/canada/wet-boew/js/wet-boew.min.js"><\/script>
                    <script src="https://www.canada.ca/etc/designs/canada/wet-boew/js/theme.min.js"><\/script>
                `;
            }

            let mainContentWrapper = '';
            if (options.currentFramework === 'wet' || options.currentFramework === 'wet+') {
                mainContentWrapper = `
                    <main property="mainContentOfPage" resource="#wb-main" typeof="WebPageElement">
                        ${contentToInject}
                    </main>
                `;
            } else if (options.currentFramework === 'gcds') {
                mainContentWrapper = `
                    <gcds-container id="main-content" main-container size="xl" centered tag="main">
                        ${contentToInject}
                    </gcds-container>
                `;
            }

            return `
<!DOCTYPE html>
<html class="no-js" lang="${options.currentLanguage}" dir="ltr">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${pageTitle}</title>
    ${cssLinks}
    <style>
        body { text-align: left; font-family: 'Noto Sans', sans-serif; }
        .show-sections-outline section { border: 2px dashed #007bff; padding: 10px; margin-bottom: 10px; box-sizing: border-box; }
        .show-sections-outline section:hover { background-color: rgba(0, 123, 255, 0.1); }

        /* Heading highlighting styles */
        .show-headings-outline h1,
        .show-headings-outline gcds-heading[tag="h1"] {
            border: 2px solid #FF0000; /* Red */
            background-color: rgba(255, 0, 0, 0.1);
            padding: 5px;
            margin-bottom: 5px;
            box-sizing: border-box;
        }
        .show-headings-outline h2,
        .show-headings-outline gcds-heading[tag="h2"] {
            border: 2px solid #FF7F00; /* Orange */
            background-color: rgba(255, 127, 0, 0.1);
            padding: 5px;
            margin-bottom: 5px;
            box-sizing: border-box;
        }
        .show-headings-outline h3,
        .show-headings-outline gcds-heading[tag="h3"] {
            border: 2px solid #FFFF00; /* Yellow */
            background-color: rgba(255, 255, 0, 0.1);
            padding: 5px;
            margin-bottom: 5px;
            box-sizing: border-box;
        }
        .show-headings-outline h4,
        .show-headings-outline gcds-heading[tag="h4"] {
            border: 2px solid #00FF00; /* Lime Green */
            background-color: rgba(0, 255, 0, 0.1);
            padding: 5px;
            margin-bottom: 5px;
            box-sizing: border-box;
        }
        .show-headings-outline h5,
        .show-headings-outline gcds-heading[tag="h5"] {
            border: 2px solid #0000FF; /* Blue */
            background-color: rgba(0, 0, 255, 0.1);
            padding: 5px;
            margin-bottom: 5px;
            box-sizing: border-box;
        }
        .show-headings-outline h6,
        .show-headings-outline gcds-heading[tag="h6"] {
            border: 2px solid #4B0082; /* Indigo */
            background-color: rgba(75, 0, 130, 0.1);
            padding: 5px;
            margin-bottom: 5px;
            box-sizing: border-box;
        }

        .show-headings-outline h1:hover,
        .show-headings-outline h2:hover,
        .show-headings-outline h3:hover,
        .show-headings-outline h4:hover,
        .show-headings-outline h5:hover,
        .show-headings-outline h6:hover,
        .show-headings-outline gcds-heading[tag]:hover {
            opacity: 0.8; /* Slight opacity change on hover */
        }
        .table thead tr.active { background-color: #e0f2f7; }
    </style>
</head>
<body class="${bodyClass}">
    ${mainContentWrapper}
    ${jsScripts}
</body>
</html>`;
        }

        /**
         * Updates the content of the modal iframe.
         * This function now takes the modal-specific state variables.
         */
        function updateModalPreview() {
            const previewOptions = {
                showSections: modalShowSections,
                showHeadings: modalShowHeadings,
                useContainerDiv: modalUseContainerDiv,
                showTitle: modalShowTitle,
                imageSourceMode: modalImageSourceMode,
                bylineMode: modalBylineMode,
                enableCss: modalEnableCss,
                urlSourceMode: modalUrlSourceMode,
                currentLanguage: modalCurrentLanguage,
                currentFramework: modalCurrentFramework,
                h1TitleEn: modalH1TitleEn,
                h1TitleFr: modalH1TitleFr
            };
            const fullHtml = generateFullHtml(previewOptions);
            const iframeDocument = modalPreviewFrame.contentDocument || modalPreviewFrame.contentWindow.document;
            iframeDocument.open();
            iframeDocument.write(fullHtml);
            iframeDocument.close();
        }

        /**
         * Shows the preview modal with the current editor content.
         */
        function showPreviewModal() {
            previewModal.classList.remove('hidden');
            // Initialize modal state with current editor's content and default preview options
            // (or sync with main preview if that's a desired feature)
            modalShowSections = false;
            modalShowHeadings = false;
            modalUseContainerDiv = true;
            modalShowTitle = true;
            modalImageSourceMode = 'local';
            modalBylineMode = 'none';
            modalEnableCss = true;
            modalUrlSourceMode = 'local';
            modalCurrentLanguage = 'en';
            modalCurrentFramework = 'wet';
            modalH1TitleEn = '';
            modalH1TitleFr = '';
            modalLastSearchTerm = ''; // Reset search on modal open

            // Update modal UI controls to reflect initial state
            updateModalSettingsButtonStates();
            updateModalBylineButtonStates();
            updateModalImageSourceButtonStates();
            updateModalUrlSourceButtonStates();
            updateModalSectionHeadingButtonStates();
            updateModalWetGcdsButtonState();
            updateModalLanguageButtonStates();
            // Set initial visibility of H1 title input container in modal
            modalH1TitleInputContainer.style.display = modalShowTitle ? 'block' : 'none';
            modalH1TitleInput.value = modalH1TitleEn; // Set initial value for English

            updateModalPreview();
        }

        // Functions to update button states for the MODAL preview controls
        function updateModalSettingsButtonStates() {
            const settingsButtons = [modalToggleContainerBtn, modalToggleTitleBtn, modalToggleCssBtn];
            settingsButtons.forEach(btn => {
                btn.classList.remove('active', 'bg-indigo-600', 'hover:bg-indigo-700', 'bg-gray-600', 'hover:bg-gray-700', 'bg-red-600', 'hover:bg-red-700');
                btn.classList.add('bg-gray-700', 'hover:bg-gray-600');
            });

            if (modalUseContainerDiv) {
                modalToggleContainerBtn.classList.add('active', 'bg-indigo-600', 'hover:bg-indigo-700');
                modalToggleContainerBtn.classList.remove('bg-gray-700', 'hover:bg-gray-600');
            } else {
                modalToggleContainerBtn.classList.add('bg-gray-700', 'hover:bg-gray-600');
            }
            if (modalShowTitle) {
                modalToggleTitleBtn.classList.add('active', 'bg-indigo-600', 'hover:bg-indigo-700');
                modalToggleTitleBtn.classList.remove('bg-gray-700', 'hover:bg-gray-600');
            } else {
                modalToggleTitleBtn.classList.add('bg-gray-700', 'hover:bg-gray-600');
            }
            if (modalEnableCss) {
                modalToggleCssBtn.classList.add('bg-gray-700', 'hover:bg-gray-600');
                modalToggleCssBtn.textContent = 'Disable CSS';
            } else {
                modalToggleCssBtn.classList.add('bg-red-600', 'hover:bg-red-700');
                modalToggleCssBtn.textContent = 'Enable CSS';
            }
        }

        function updateModalBylineButtonStates() {
            const bylineButtons = [modalNoneBylineBtn, modalEnglishBylineBtn, modalFrenchBylineBtn];
            bylineButtons.forEach(btn => {
                btn.classList.remove('active', 'bg-indigo-600', 'hover:bg-indigo-700', 'bg-gray-600', 'hover:bg-gray-700');
                btn.classList.add('bg-gray-700', 'hover:bg-gray-600');
            });

            if (modalBylineMode === 'none') {
                modalNoneBylineBtn.classList.add('active', 'bg-indigo-600', 'hover:bg-indigo-700');
                modalNoneBylineBtn.classList.remove('bg-gray-700', 'hover:bg-gray-600');
            } else if (modalBylineMode === 'english') {
                modalEnglishBylineBtn.classList.add('active', 'bg-indigo-600', 'hover:bg-indigo-700');
                modalEnglishBylineBtn.classList.remove('bg-gray-700', 'hover:bg-gray-600');
            } else if (modalBylineMode === 'french') {
                modalFrenchBylineBtn.classList.add('active', 'bg-indigo-600', 'hover:bg-indigo-700');
                modalFrenchBylineBtn.classList.remove('bg-gray-700', 'hover:bg-gray-600');
            }
            // Ensure correct byline button visibility based on modalCurrentLanguage
            modalEnglishBylineBtn.style.display = (modalCurrentLanguage === 'en') ? 'inline-block' : 'none';
            modalFrenchBylineBtn.style.display = (modalCurrentLanguage === 'fr') ? 'inline-block' : 'none';
            modalNoneBylineBtn.style.display = 'inline-block'; // Always show None
        }

        function updateModalImageSourceButtonStates() {
            const imageSourceButtons = [modalLocalImagesBtn, modalPreviewImagesBtn, modalToggleLiveImagesBtn];
            imageSourceButtons.forEach(btn => {
                btn.classList.remove('active', 'bg-indigo-600', 'hover:bg-indigo-700', 'bg-gray-600', 'hover:bg-gray-700');
                btn.classList.add('bg-gray-700', 'hover:bg-gray-600');
            });

            if (modalImageSourceMode === 'local') {
                modalLocalImagesBtn.classList.add('active', 'bg-indigo-600', 'hover:bg-indigo-700');
                modalLocalImagesBtn.classList.remove('bg-gray-700', 'hover:bg-gray-600');
            } else if (modalImageSourceMode === 'preview') {
                modalPreviewImagesBtn.classList.add('active', 'bg-indigo-600', 'hover:bg-indigo-700');
                modalPreviewImagesBtn.classList.remove('bg-gray-700', 'hover:bg-gray-600');
            } else if (modalImageSourceMode === 'live') {
                modalToggleLiveImagesBtn.classList.add('active', 'bg-indigo-600', 'hover:bg-indigo-700');
                modalToggleLiveImagesBtn.classList.remove('bg-gray-700', 'hover:bg-gray-600');
            }
        }

        function updateModalUrlSourceButtonStates() {
            const urlSourceButtons = [modalLocalUrlsBtn, modalPreviewUrlsBtn, modalToggleLiveUrlsBtn];
            urlSourceButtons.forEach(btn => {
                btn.classList.remove('active', 'bg-indigo-600', 'hover:bg-indigo-700', 'bg-gray-600', 'hover:bg-gray-700');
                btn.classList.add('bg-gray-700', 'hover:bg-gray-600');
            });

            if (modalUrlSourceMode === 'local') {
                modalLocalUrlsBtn.classList.add('active', 'bg-indigo-600', 'hover:bg-indigo-700');
                modalLocalUrlsBtn.classList.remove('bg-gray-700', 'hover:bg-gray-600');
            } else if (modalUrlSourceMode === 'preview') {
                modalPreviewUrlsBtn.classList.add('active', 'bg-indigo-600', 'hover:bg-indigo-700');
                modalPreviewUrlsBtn.classList.remove('bg-gray-700', 'hover:bg-gray-600');
            } else if (modalUrlSourceMode === 'live') {
                modalToggleLiveUrlsBtn.classList.add('active', 'bg-indigo-600', 'hover:bg-indigo-700');
                modalToggleLiveUrlsBtn.classList.remove('bg-gray-700', 'hover:bg-gray-600');
            }
        }

        function updateModalSectionHeadingButtonStates() {
            if (modalShowSections) {
                modalToggleSectionsBtn.classList.add('active'); /* Use active class for yellow */
                modalToggleSectionsBtn.classList.remove('bg-gray-700', 'text-white', 'hover:bg-gray-600');
            } else {
                modalToggleSectionsBtn.classList.remove('active');
                modalToggleSectionsBtn.classList.add('bg-gray-700', 'text-white', 'hover:bg-gray-600');
            }
            if (modalShowHeadings) {
                modalToggleHeadingsBtn.classList.add('active'); /* Use active class for yellow */
                modalToggleHeadingsBtn.classList.remove('bg-gray-700', 'text-white', 'hover:bg-gray-600');
            } else {
                modalToggleHeadingsBtn.classList.remove('active');
                modalToggleHeadingsBtn.classList.add('bg-gray-700', 'text-white', 'hover:bg-gray-600');
            }
        }

        function updateModalWetGcdsButtonState() {
            modalWetGcdsToggleBtn.classList.remove('bg-blue-600', 'hover:bg-blue-700', 'bg-indigo-600', 'hover:bg-indigo-700', 'active');
            modalWetGcdsToggleBtn.classList.remove('font-bold', 'underline');

            if (modalCurrentFramework === 'wet') {
                modalWetGcdsToggleBtn.classList.add('active', 'bg-blue-600', 'hover:bg-blue-700');
                modalWetGcdsToggleBtn.textContent = 'WET4';
            } else if (modalCurrentFramework === 'gcds') {
                modalWetGcdsToggleBtn.classList.add('active', 'bg-indigo-600', 'hover:bg-indigo-700');
                modalWetGcdsToggleBtn.textContent = 'GCDS';
            } else if (modalCurrentFramework === 'wet+') {
                modalWetGcdsToggleBtn.classList.add('active', 'bg-indigo-600', 'hover:bg-indigo-700');
                modalWetGcdsToggleBtn.innerHTML = '<strong><u>WET+</u></strong>';
            }
        }

        function updateModalLanguageButtonStates() {
            // Remove active classes from both first
            modalLangEnBtn.classList.remove('active', 'bg-indigo-600', 'hover:bg-indigo-700');
            modalLangFrBtn.classList.remove('active', 'bg-indigo-600', 'hover:bg-indigo-700');

            // Apply default inactive styles
            modalLangEnBtn.classList.add('bg-gray-700', 'hover:bg-gray-600');
            modalLangFrBtn.classList.add('bg-gray-700', 'hover:bg-gray-600');

            // Apply active styles to the currently selected language button
            if (modalCurrentLanguage === 'en') {
                modalLangEnBtn.classList.add('active', 'bg-indigo-600', 'hover:bg-indigo-700');
                modalH1TitleInput.placeholder = 'e.g., My Custom ENG Title';
                modalH1TitleInput.value = modalH1TitleEn;
            } else {
                modalLangFrBtn.classList.add('active', 'bg-indigo-600', 'hover:bg-indigo-700');
                modalH1TitleInput.placeholder = 'e.g., My Custom FRA Title';
                modalH1TitleInput.value = modalH1TitleFr;
            }
            updateModalBylineButtonStates(); // Re-render byline buttons based on new bylineMode
        }


        // Initialize Monaco Editor and set up event listeners on window load
        window.onload = function() {
            // Configure Monaco loader
            require.config({ paths: { 'vs': 'https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.29.1/min/vs' } });
            require(['vs/editor/editor.main'], function() {
                const monacoEditorContainer = document.getElementById('monacoEditorContainer');

                // Initialize HTML model with empty content
                htmlModel = monaco.editor.createModel(
                    ``, // Removed placeholder code
                    'html'
                );

                // Create the editor with the HTML model
                editor = monaco.editor.create(monacoEditorContainer, {
                    model: htmlModel, // Start with HTML model
                    theme: 'vs-dark',
                    automaticLayout: true,
                    minimap: { enabled: true }
                });

                // Event listener for clicking on validation results to highlight line
                validationResultsDiv.addEventListener('click', handleResultClick);

                // Automatic debounced validation and entity highlighting on editor content change
                const debouncedValidateAndHighlight = debounce(async () => { // Made async to await validation result
                    if (isAutoCheckEnabled) { // Only run validation if auto-check is enabled
                        const isXmlLike = await validateHtmlContent(editor.getValue());
                        updatePreviewButtonState(isXmlLike); // Update preview button state after validation
                    }
                }, 500);
                editor.onDidChangeModelContent(debouncedValidateAndHighlight);

                // Initial validation and highlighting on load
                // Call validateHtmlContent and then update the preview button state
                validateHtmlContent(editor.getValue()).then(isXmlLike => {
                    updatePreviewButtonState(isXmlLike);
                });
                highlightHtmlEntities();
                updateValidateButtonState(); // Initial state for validate button

                // Monaco handles its own resizing with automaticLayout: true, but a manual refresh
                // can still be useful if the container itself changes size in ways Monaco doesn't detect.
                window.addEventListener('resize', () => {
                    editor.layout(); // Tell Monaco to re-layout
                });

                // --- Add event listeners for main editor buttons ---

                // Auto-Check Toggle listener
                toggleAutoCheckOnSwitch.addEventListener('change', async (event) => { // Made async
                    isAutoCheckEnabled = event.target.checked;
                    const parentLabel = event.target.closest('.toggle-switch');
                    if (isAutoCheckEnabled) {
                        parentLabel.classList.add('is-checked');
                        const isXmlLike = await validateHtmlContent(editor.getValue()); // Await validation
                        updatePreviewButtonState(isXmlLike); // Update preview button state
                    } else {
                        parentLabel.classList.remove('is-checked');
                    }
                    updateValidateButtonState(); // Update validate button state
                });

                // Validate Now button listener
                validateNowBtn.addEventListener('click', async () => { // Made async
                    const isXmlLike = await validateHtmlContent(editor.getValue()); // Await validation
                    updatePreviewButtonState(isXmlLike); // Update preview button state
                    const originalText = validateNowBtn.textContent;
                    validateNowBtn.textContent = 'Validated!';
                    validateNowBtn.classList.add('bg-green-500', 'hover:bg-green-600');
                    validateNowBtn.classList.remove('bg-gray-700', 'hover:bg-gray-600');
                    validateNowBtn.disabled = true; // Disable temporarily
                    setTimeout(() => {
                        validateNowBtn.textContent = originalText;
                        validateNowBtn.classList.remove('bg-green-500', 'hover:bg-green-600');
                        validateNowBtn.classList.add('bg-gray-700', 'hover:bg-gray-600');
                        updateValidateButtonState(); // Re-enable based on toggle
                    }, 1500);
                });

                // Preview button listener
                previewBtn.addEventListener('click', showPreviewModal);
                closePreviewModalBtn.addEventListener('click', () => {
                    previewModal.classList.add('hidden');
                });

                // Escape key to close modal
                document.addEventListener('keydown', (event) => {
                    if (event.key === 'Escape' && !previewModal.classList.contains('hidden')) {
                        closePreviewModalBtn.click();
                    }
                });

                // Auto-Encode button
                autoEncodeBtn.addEventListener('click', async () => { // Made async
                    if (editor) {
                        const originalText = autoEncodeBtn.textContent;
                        const model = editor.getModel();
                        const fullRange = model.getFullModelRange();
                        let htmlContent = model.getValue();
                        let encodedHtml = convertAllEntitiesToNumeric(htmlContent);

                        // Push the edit operation to the undo/redo stack
                        editor.pushUndoStop(); // Start an undo stop
                        model.pushEditOperations(
                            [], // No selections to change
                            [{
                                range: fullRange,
                                text: encodedHtml
                            }],
                            () => null // No new selection needed
                        );
                        editor.pushUndoStop(); // End an undo stop

                        autoEncodeBtn.textContent = 'Encoded!';
                        autoEncodeBtn.classList.add('bg-green-500', 'hover:bg-green-600');
                        autoEncodeBtn.classList.remove('bg-red-600', 'hover:bg-red-700');
                        setTimeout(() => {
                            autoEncodeBtn.textContent = originalText;
                            autoEncodeBtn.classList.remove('bg-green-500', 'hover:bg-green-600');
                            autoEncodeBtn.classList.add('bg-red-600', 'hover:bg-red-700');
                        }, 1500);
                        if (isAutoCheckEnabled) { // Re-validate if auto-check is on
                            const isXmlLike = await validateHtmlContent(editor.getValue()); // Await validation
                            updatePreviewButtonState(isXmlLike); // Update preview button state
                        }
                    }
                });

                // Auto-Indent button
                autoFormatBtn.addEventListener('click', async () => { // Made async
                    if (editor && typeof html_beautify === 'function') {
                        const originalText = autoFormatBtn.textContent;
                        const model = editor.getModel();
                        const fullRange = model.getFullModelRange();
                        const formattedCode = html_beautify(model.getValue(), { indent_size: 4, indent_char: ' ' });

                        // Push the edit operation to the undo/redo stack
                        editor.pushUndoStop(); // Start an undo stop
                        model.pushEditOperations(
                            [], // No selections to change
                            [{
                                range: fullRange,
                                text: formattedCode
                            }],
                            () => null // No new selection needed
                        );
                        editor.pushUndoStop(); // End an undo stop

                        autoFormatBtn.textContent = 'Formatted!';
                        autoFormatBtn.classList.add('bg-green-500', 'hover:bg-green-600');
                        autoFormatBtn.classList.remove('bg-red-600', 'hover:bg-red-700');
                        setTimeout(() => {
                            autoFormatBtn.textContent = originalText;
                            autoFormatBtn.classList.remove('bg-green-500', 'hover:bg-green-600');
                            autoFormatBtn.classList.add('bg-red-600', 'hover:bg-red-700');
                        }, 1500);
                        if (isAutoCheckEnabled) { // Re-validate if auto-check is on
                            const isXmlLike = await validateHtmlContent(editor.getValue()); // Await validation
                            updatePreviewButtonState(isXmlLike); // Update preview button state
                        }
                    } else {
                        console.error('js-beautify library not loaded.');
                        // In a real app, you might show a user-friendly message here instead of console.error
                    }
                });

                // Copy Code button
                copyCodeBtn.addEventListener('click', async () => {
                    if (editor) {
                        const originalText = copyCodeBtn.textContent;
                        const codeContent = editor.getValue();
                        try {
                            // Use document.execCommand('copy') for broader iframe compatibility
                            const tempTextArea = document.createElement('textarea');
                            tempTextArea.value = codeContent;
                            document.body.appendChild(tempTextArea);
                            tempTextArea.select();
                            document.execCommand('copy');
                            document.body.removeChild(tempTextArea);

                            copyCodeBtn.textContent = 'Copied!';
                            copyCodeBtn.classList.add('bg-green-500', 'hover:bg-green-600');
                            copyCodeBtn.classList.remove('bg-gray-700', 'hover:bg-gray-600');
                            setTimeout(() => {
                                copyCodeBtn.textContent = originalText;
                                copyCodeBtn.classList.remove('bg-green-500', 'hover:bg-green-600');
                                copyCodeBtn.classList.add('bg-gray-700', 'hover:bg-gray-600');
                            }, 1500);
                        } catch (err) {
                            console.error('Failed to copy text: ', err);
                            // Provide user feedback without alert()
                            copyCodeBtn.textContent = 'Copy Failed!';
                            copyCodeBtn.classList.add('bg-red-500', 'hover:bg-red-600');
                            copyCodeBtn.classList.remove('bg-gray-700', 'hover:bg-gray-600');
                            setTimeout(() => {
                                copyCodeBtn.textContent = originalText;
                                copyCodeBtn.classList.remove('bg-red-500', 'hover:bg-red-600');
                                copyCodeBtn.classList.add('bg-gray-700', 'hover:bg-gray-600');
                            }, 1500);
                        }
                    }
                });

                // Export HTML button
                exportHtmlBtn.addEventListener('click', () => {
                    if (editor) {
                        const originalText = exportHtmlBtn.textContent;
                        const htmlContent = editor.getValue();
                        const blob = new Blob([htmlContent], { type: 'text/html' });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = 'exported_html.html'; // Default filename
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        URL.revokeObjectURL(url);

                        exportHtmlBtn.textContent = 'Exported!';
                        exportHtmlBtn.classList.add('bg-green-500', 'hover:bg-green-600');
                        exportHtmlBtn.classList.remove('bg-red-600', 'hover:bg-red-700');
                        setTimeout(() => {
                            exportHtmlBtn.textContent = originalText;
                            exportHtmlBtn.classList.remove('bg-green-500', 'hover:bg-green-600');
                            exportHtmlBtn.classList.add('bg-red-600', 'hover:bg-red-700');
                        }, 1500);
                    }
                });

                // Import HTML button
                importHtmlBtn.addEventListener('click', () => htmlFileInput.click());
                htmlFileInput.addEventListener('change', async (event) => { // Made async
                    const file = event.target.files[0];
                    if (file) {
                        const originalText = importHtmlBtn.textContent;
                        const reader = new FileReader();
                        reader.onload = async (e) => { // Made async
                            editor.setValue(e.target.result);
                            importHtmlBtn.textContent = 'Imported!';
                            importHtmlBtn.classList.add('bg-green-500', 'hover:bg-green-600');
                            importHtmlBtn.classList.remove('bg-purple-600', 'hover:bg-purple-700');
                            setTimeout(() => {
                                importHtmlBtn.textContent = originalText;
                                importHtmlBtn.classList.remove('bg-green-500', 'hover:bg-green-600');
                                importHtmlBtn.classList.add('bg-purple-600', 'hover:bg-purple-700');
                            }, 1500);
                            if (isAutoCheckEnabled) { // Re-validate if auto-check is on
                                const isXmlLike = await validateHtmlContent(editor.getValue()); // Await validation
                                updatePreviewButtonState(isXmlLike); // Update preview button state
                            }
                        };
                        reader.onerror = () => {
                            console.error('Error reading file.');
                            // Provide user feedback without alert()
                            importHtmlBtn.textContent = 'Import Failed!';
                            importHtmlBtn.classList.add('bg-red-500', 'hover:bg-red-600');
                            importHtmlBtn.classList.remove('bg-purple-600', 'hover:bg-purple-700');
                            setTimeout(() => {
                                importHtmlBtn.textContent = originalText;
                                importHtmlBtn.classList.remove('bg-red-500', 'hover:bg-red-600');
                                importHtmlBtn.classList.add('bg-purple-600', 'hover:bg-purple-700');
                            }, 1500);
                        };
                        reader.readAsText(file);
                    }
                });

                // --- Add event listeners for MODAL preview controls ---

                modalCustomizeHeader.addEventListener('click', () => {
                    modalIsCustomizeExpanded = !modalIsCustomizeExpanded;
                    modalCustomizeContent.classList.toggle('expanded', modalIsCustomizeExpanded);
                    modalCustomizeHeader.classList.toggle('expanded', modalIsCustomizeExpanded);
                });

                modalToggleContainerBtn.addEventListener('click', () => {
                    modalUseContainerDiv = !modalUseContainerDiv;
                    modalToggleContainerBtn.textContent = modalUseContainerDiv ? 'Custom Width' : 'Default Width';
                    updateModalSettingsButtonStates();
                    updateModalPreview();
                });

                modalToggleTitleBtn.addEventListener('click', () => {
                    modalShowTitle = !modalShowTitle;
                    modalToggleTitleBtn.textContent = modalShowTitle ? 'Hide Title' : 'Show Title';
                    updateModalSettingsButtonStates();
                    modalH1TitleInputContainer.style.display = modalShowTitle ? 'block' : 'none';
                    updateModalPreview();
                });

                modalToggleCssBtn.addEventListener('click', () => {
                    modalEnableCss = !modalEnableCss;
                    updateModalSettingsButtonStates(); // This function also updates the text
                    updateModalPreview();
                });

                modalH1TitleInput.addEventListener('input', () => {
                    if (modalCurrentLanguage === 'en') {
                        modalH1TitleEn = modalH1TitleInput.value;
                    } else {
                        modalH1TitleFr = modalH1TitleInput.value;
                    }
                    updateModalPreview();
                });

                modalNoneBylineBtn.addEventListener('click', () => { modalBylineMode = 'none'; updateModalBylineButtonStates(); updateModalPreview(); });
                modalEnglishBylineBtn.addEventListener('click', () => { modalBylineMode = 'english'; updateModalBylineButtonStates(); updateModalPreview(); });
                modalFrenchBylineBtn.addEventListener('click', () => { modalBylineMode = 'french'; updateModalBylineButtonStates(); updateModalPreview(); });

                modalLocalImagesBtn.addEventListener('click', () => { modalImageSourceMode = 'local'; updateModalImageSourceButtonStates(); updateModalPreview(); });
                modalPreviewImagesBtn.addEventListener('click', () => { modalImageSourceMode = 'preview'; updateModalImageSourceButtonStates(); updateModalPreview(); });
                modalToggleLiveImagesBtn.addEventListener('click', () => { modalImageSourceMode = 'live'; updateModalImageSourceButtonStates(); updateModalPreview(); });

                modalLocalUrlsBtn.addEventListener('click', () => { modalUrlSourceMode = 'local'; updateModalUrlSourceButtonStates(); updateModalPreview(); });
                modalPreviewUrlsBtn.addEventListener('click', () => { modalUrlSourceMode = 'preview'; updateModalUrlSourceButtonStates(); updateModalPreview(); });
                modalToggleLiveUrlsBtn.addEventListener('click', () => { modalUrlSourceMode = 'live'; updateModalUrlSourceButtonStates(); updateModalPreview(); });

                modalToggleSectionsBtn.addEventListener('click', () => {
                    modalShowSections = !modalShowSections;
                    updateModalSectionHeadingButtonStates();
                    updateModalPreview();
                });

                modalToggleHeadingsBtn.addEventListener('click', () => {
                    modalShowHeadings = !modalShowHeadings;
                    updateModalSectionHeadingButtonStates();
                    updateModalPreview();
                });

                modalWetGcdsToggleBtn.addEventListener('click', () => {
                    if (modalCurrentFramework === 'wet') {
                        modalCurrentFramework = 'gcds';
                    } else if (modalCurrentFramework === 'gcds') {
                        modalCurrentFramework = 'wet+';
                    } else if (modalCurrentFramework === 'wet+') {
                        modalCurrentFramework = 'wet';
                    }
                    updateModalWetGcdsButtonState();
                    updateModalPreview();
                });

                modalLangEnBtn.addEventListener('click', () => {
                    // Auto-switch byline if not 'none'
                    if (modalBylineMode === 'french') {
                        modalBylineMode = 'english';
                    } else if (modalBylineMode === 'english') {
                        // If already English, keep it English (or if 'none', keep 'none')
                    }
                    modalCurrentLanguage = 'en';
                    updateModalLanguageButtonStates();
                    updateModalPreview();
                });

                modalLangFrBtn.addEventListener('click', () => {
                    // Auto-switch byline if not 'none'
                    if (modalBylineMode === 'english') {
                        modalBylineMode = 'french';
                    } else if (modalBylineMode === 'french') {
                        // If already French, keep it French (or if 'none', keep 'none')
                    }
                    modalCurrentLanguage = 'fr';
                    updateModalLanguageButtonStates();
                    updateModalPreview();
                });

                // Modal Search Functionality
                function performModalPreviewSearch(searchForward = true) {
                    const searchTerm = modalPreviewSearchInput.value;
                    if (!searchTerm || !modalPreviewFrame.contentWindow) return;
                    const iframeWindow = modalPreviewFrame.contentWindow;

                    // Only reset the search if the search term has changed
                    if (searchTerm !== modalLastSearchTerm) {
                        iframeWindow.getSelection().removeAllRanges(); // Clear previous highlights/selections
                        if (searchForward) {
                            iframeWindow.scrollTo(0, 0); // Start from the top for forward search
                        } else {
                            // For backward search, start from the bottom if it's a new term
                            iframeWindow.scrollTo(0, iframeWindow.document.body.scrollHeight);
                        }
                        modalLastSearchTerm = searchTerm;
                    }

                    // Perform the find operation.
                    // The 'wrapAround' parameter being true means it will continue from the other end
                    // if it reaches the end of the document in the current direction.
                    // The 'find' method automatically advances the selection if a match is found.
                    let found = iframeWindow.find(searchTerm, false, !searchForward, true, false, false, false);

                    if (!found) {
                        console.log(`Search term "${searchTerm}" not found in modal preview.`);
                    }
                    modalPreviewSearchInput.focus();
                }

                modalPreviewFindNextBtn.addEventListener('click', () => performModalPreviewSearch(true));
                modalPreviewFindPrevBtn.addEventListener('click', () => performModalPreviewSearch(false));
                modalPreviewSearchInput.addEventListener('keydown', (event) => {
                    if (event.key === 'Enter') { event.preventDefault(); performModalPreviewSearch(true); }
                });
            });
        };
    </script>
</body>
</html>
