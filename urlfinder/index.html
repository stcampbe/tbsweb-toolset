<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>LinkBuddy</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <script src="https://cdn.jsdelivr.net/npm/html-docx-js@0.3.1/dist/html-docx.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = {
      theme: {
        extend: {
          colors: {
            'wet-blue': '#0066cc',
            'wet-blue-hover': '#0052a3',
          }
        }
      }
    }
  </script>
  <style>
    /* Custom scrollbar for a cleaner look */
    ::-webkit-scrollbar {
      width: 8px;
    }
    ::-webkit-scrollbar-track {
      background: transparent; 
    }
    ::-webkit-scrollbar-thumb {
      background: #ccc; 
      border-radius: 4px;
    }
    ::-webkit-scrollbar-thumb:hover {
      background: #aaa; 
    }

    #leftPanel {
        font-family: 'Inter', sans-serif;
        background-color: #0F172A;
    }
    
  </style>
</head>
<body class="h-screen w-screen overflow-hidden bg-gray-100 text-black font-sans">
  
  <script>
    (function() {
        // --- 1. CLEANUP PHASE ---
        const existingApps = document.querySelectorAll('#app-root');
        existingApps.forEach(el => el.remove());

        if (window.appResizeMoveHandler) {
            document.removeEventListener('mousemove', window.appResizeMoveHandler);
        }
        if (window.appResizeUpHandler) {
            document.removeEventListener('mouseup', window.appResizeUpHandler);
        }

        // --- 2. HTML GENERATION PHASE ---
        const appTemplate = `
        <div id="app-root" class="main-container flex h-screen w-full gap-0">
            <div class="left-panel w-1/4 min-w-[300px] max-w-[50%] p-5 overflow-y-auto shadow-md flex flex-col z-10" id="leftPanel">
            <h1 class="text-2xl mt-0 mb-4 font-bold text-white"><i class="fa-solid fa-link"></i> LinkBuddy</h1>
            
            <div class="input-group mb-4">
                <label for="urlInput" class="block mb-1.5 text-white text-sm">Enter a Canada.ca page to search:</label>
                <div class="relative w-full">
                    <input type="text" id="urlInput" placeholder="https://www.canada.ca/..." 
                        class="w-full p-2.5 pr-10 border-2 border-zinc-600 rounded text-sm bg-[#1a1a1a] text-white box-border focus:ring-2 focus:ring-blue-500 outline-none placeholder-gray-500" autocomplete="off">
                    <button type="button" onclick="resetApp()" title="Clear and Reset" 
                            class="absolute right-2 top-1/2 transform -translate-y-1/2 text-gray-400 hover:text-red-500 transition-colors duration-200">
                        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-5 h-5">
                        <path stroke-linecap="round" stroke-linejoin="round" d="m14.74 9-.346 9m-4.788 0L9.26 9m9.968-3.21c.342.052.682.107 1.022.166m-1.022-.165L18.16 19.673a2.25 2.25 0 0 1-2.244 2.077H8.084a2.25 2.25 0 0 1-2.244-2.077L4.772 5.79m14.456 0a48.108 48.108 0 0 0-3.478-.397m-12 .562c.34-.059.68-.114 1.022-.165m0 0a48.11 48.11 0 0 1 3.478-.397m7.5 0v-.916c0-1.18-.91-2.164-2.09-2.201a51.964 51.964 0 0 0-3.32 0c-1.18.037-2.09 1.022-2.09 2.201v.916m7.5 0a48.667 48.667 0 0 0-7.5 0" />
                        </svg>
                    </button>
                </div>
            </div>
            
            <div class="flex gap-2 mb-3">
                <button type="button" onclick="fetchContent()" 
                        class="flex-1 bg-blue-600 hover:bg-blue-700 text-white font-bold py-2.5 px-5 rounded text-sm transition-colors duration-200">
                    Load Page Content
                </button>
                <button type="button" id="toggleStyleBtn" onclick="toggleViewMode()" 
                        class="hidden w-12 bg-purple-600 hover:bg-purple-700 text-white font-bold rounded text-sm flex items-center justify-center transition-colors duration-200" 
                        title="Disable CSS/JS (Raw View)">
                    <i class="fa-solid fa-ban"></i>
                </button>
            </div>
            
            <div class="flex gap-2 mb-3">
                <button type="button" id="generateManifestBtn" onclick="generateLinkManifest()" disabled 
                        class="flex-1 bg-green-600 hover:bg-green-700 disabled:bg-gray-600 disabled:text-gray-400 disabled:cursor-not-allowed text-white font-bold py-2.5 px-2 rounded text-sm transition-colors duration-200 truncate">
                    <i class="fa-solid fa-file-csv"></i> Link Manifest
                </button>
                <button type="button" id="exportWordBtn" onclick="exportToWord()" disabled 
                        class="flex-1 bg-blue-800 hover:bg-blue-900 disabled:bg-gray-600 disabled:text-gray-400 disabled:cursor-not-allowed text-white font-bold py-2.5 px-2 rounded text-sm transition-colors duration-200 truncate">
                    <i class="fa-solid fa-file-word"></i> Export .docx
                </button>
            </div>

            <div class="border border-yellow-600/50 bg-yellow-900/10 rounded-lg p-3 mb-4 mt-2 relative">
                <div class="absolute -top-3 left-3 bg-[#0F172A] px-2 text-[10px] font-bold text-yellow-500 uppercase tracking-widest border border-yellow-600/50 rounded">
                    <i class="fa-solid fa-flask"></i> Experimental Feature
                </div>

                <button type="button" id="checkBrokenBtn" onclick="toggleBrokenLinkCheck()" disabled 
                        class="w-full mt-2 bg-orange-600 hover:bg-orange-700 disabled:bg-gray-600 disabled:text-gray-400 disabled:cursor-not-allowed text-white font-bold py-2.5 px-5 rounded text-sm mb-3 transition-colors duration-200">
                    Check Broken Links
                </button>
                
                <div id="auditResultsArea" class="hidden flex flex-col gap-2 mb-1 p-3 bg-gray-800 rounded border border-gray-600">
                    <div id="auditStatus" class="text-sm text-white font-bold"></div>
                    
                    <div id="auditUnverifiedMsg" class="hidden text-xs text-yellow-400 mt-1"><i class="fa-solid fa-triangle-exclamation"></i> Unverified = Security or access error. Check manually.</div>
                    
                    <div id="auditNavButtons" class="hidden flex gap-2 mt-2">
                        <button onclick="navigateIssues('prev')" id="prevIssueBtn" disabled class="flex-1 bg-gray-600 hover:bg-gray-500 disabled:opacity-50 text-white text-xs font-bold py-2 rounded">← Prev Issue</button>
                        <button onclick="navigateIssues('next')" id="nextIssueBtn" disabled class="flex-1 bg-gray-600 hover:bg-gray-500 disabled:opacity-50 text-white text-xs font-bold py-2 rounded">Next Issue →</button>
                    </div>
                    <div id="auditActionButtons" class="hidden flex gap-2 mt-1">
                        <button onclick="exportBrokenLinks()" class="flex-1 bg-gray-700 hover:bg-gray-600 text-white text-xs font-bold py-1.5 rounded"><i class="fa-solid fa-download"></i> Export CSV</button>
                        <button onclick="clearAuditResults()" class="flex-1 bg-red-900 hover:bg-red-800 text-white text-xs font-bold py-1.5 rounded">Clear Results</button>
                    </div>
                </div>
            </div>
            <div id="error"></div>
            
            <h2 class="text-lg font-bold text-white mt-4 mb-4 pt-5 border-t-2 border-gray-600">Search & Highlight</h2>
            
            <div class="input-group mb-4">
                <label for="searchInput" class="block mb-1.5 text-white text-sm">Search for URLs (whole URL or partial):</label>
                <input type="text" id="searchInput" placeholder="e.g., tbs-sct.gc.ca" 
                    class="w-full p-2.5 border-2 border-zinc-600 rounded text-sm bg-[#1a1a1a] text-white box-border focus:ring-2 focus:ring-blue-500 outline-none placeholder-gray-500" autocomplete="off">
            </div>
            
            <button type="button" id="highlightBtn" onclick="highlightURLs()" disabled
                    class="w-full bg-blue-600 hover:bg-blue-700 disabled:bg-gray-600 disabled:text-gray-400 disabled:cursor-not-allowed text-white font-bold py-2.5 px-5 rounded text-sm mb-3 transition-colors duration-200">
                Highlight URLs
            </button>
            
            <div class="button-group flex gap-2.5 mb-2.5">
                <button type="button" id="prevBtn" onclick="navigateMatches('prev')" disabled 
                        class="flex-1 bg-blue-600 hover:bg-blue-700 disabled:bg-gray-600 disabled:text-gray-400 disabled:cursor-not-allowed text-white font-bold py-2.5 rounded text-sm transition-colors duration-200">
                ← Previous
                </button>
                <button type="button" id="nextBtn" onclick="navigateMatches('next')" disabled 
                        class="flex-1 bg-blue-600 hover:bg-blue-700 disabled:bg-gray-600 disabled:text-gray-400 disabled:cursor-not-allowed text-white font-bold py-2.5 rounded text-sm transition-colors duration-200">
                Next →
                </button>
            </div>
            
            <button type="button" id="clearHighlightsBtn" onclick="clearHighlights()" disabled
                    class="w-full bg-red-600 hover:bg-red-700 disabled:bg-gray-600 disabled:text-gray-400 disabled:cursor-not-allowed text-white font-bold py-2.5 px-5 rounded text-sm mb-3 transition-colors duration-200">
                Clear Highlights
            </button>
            
            <div id="searchMessage"></div>
            <div id="matchCounter" class="text-white text-center font-bold text-sm mt-2"></div>
            
            </div>
            
            <div class="resizer w-2 bg-gray-300 hover:bg-blue-600 cursor-col-resize relative flex-shrink-0 transition-colors duration-200 z-20" id="resizer"></div>
            
            <div class="right-panel flex-1 bg-white flex flex-col overflow-hidden">
            <iframe id="previewFrame" class="flex-1 border-none w-full bg-white h-full"></iframe>
            </div>
        </div>
        `;

        document.body.insertAdjacentHTML('beforeend', appTemplate);


        // --- 3. STATE & LOGIC ---
        let originalContent = '';
        let currentPageTitle = 'Canada.ca Page';
        let currentBaseUrl = '';
        
        // Search & Highlight State
        let allMatches = [];
        let currentMatchIndex = -1;
        let lastSearchTerm = '';
        
        // Broken Link Checker State (Separate)
        let isCheckingLinks = false;
        let stopCheckFlag = false;
        let currentAbortController = null;
        let lastBrokenLinksData = [];
        let allIssues = []; // DOM elements of broken/warning links
        let currentIssueIndex = -1;

        let isPlainView = false;
        
        // Resizer Logic
        const resizer = document.getElementById('resizer');
        const leftPanel = document.getElementById('leftPanel');
        const mainContainer = document.querySelector('.main-container');
        const previewFrame = document.getElementById('previewFrame');
        
        let isResizing = false;
        
        resizer.addEventListener('mousedown', function(e) {
          isResizing = true;
          document.body.style.cursor = 'col-resize';
          document.body.style.userSelect = 'none';
          previewFrame.style.pointerEvents = 'none';
        });
        
        window.appResizeMoveHandler = function(e) {
          if (!isResizing) return;
          const containerRect = mainContainer.getBoundingClientRect();
          const newWidth = e.clientX - containerRect.left;
          const minWidth = 200;
          const maxWidth = containerRect.width * 0.7;
          if (newWidth >= minWidth && newWidth <= maxWidth) {
            leftPanel.style.width = newWidth + 'px';
          }
        };
        
        window.appResizeUpHandler = function() {
          if (isResizing) {
            isResizing = false;
            document.body.style.cursor = '';
            document.body.style.userSelect = '';
            previewFrame.style.pointerEvents = 'auto';
          }
        };
        
        document.addEventListener('mousemove', window.appResizeMoveHandler);
        document.addEventListener('mouseup', window.appResizeUpHandler);

        // Input Listeners
        const searchInput = document.getElementById('searchInput');
        const highlightBtn = document.getElementById('highlightBtn');

        searchInput.addEventListener('input', function() {
            highlightBtn.disabled = this.value.trim().length <= 0;
        });

        searchInput.addEventListener('keydown', function(e) {
            if (e.key === 'Enter') {
                e.preventDefault();
                const currentTerm = this.value.trim();
                if (allMatches.length > 0 && currentTerm === lastSearchTerm) {
                    window.navigateMatches('next');
                } else {
                    if (!highlightBtn.disabled) {
                        window.highlightURLs();
                    }
                }
            }
        });
        
        // --- 4. GLOBAL FUNCTIONS ---
        
        window.showPlaceholder = function() {
            const previewFrame = document.getElementById('previewFrame');
            const iframeDoc = previewFrame.contentDocument || previewFrame.contentWindow.document;
            iframeDoc.open();
            iframeDoc.write(`
                <!DOCTYPE html>
                <html lang="en">
                <body style="display:flex; justify-content:center; align-items:center; height:100vh; margin:0; background-color:#f9fafb; font-family:'Segoe UI', sans-serif; color:#9ca3af;">
                    <div style="text-align:center;">
                        <div style="margin-bottom:1rem;">
                            <i class="fa-solid fa-link-slash" style="font-size:80px; color:#d1d5db;"></i>
                        </div>
                        <h2 style="margin:0 0 0.5rem 0; font-size:1.5rem; font-weight:600; color:#4b5563;">Ready to Analyze</h2>
                        <p style="margin:0; font-size:0.875rem;">Enter a Canada.ca URL on the left to begin.</p>
                    </div>
                </body>
                </html>
            `);
            iframeDoc.close();
        }

        window.resetApp = function() {
            document.getElementById('urlInput').value = '';
            document.getElementById('searchInput').value = '';
            
            const toggleBtn = document.getElementById('toggleStyleBtn');
            toggleBtn.classList.add('hidden');
            toggleBtn.classList.remove('bg-gray-600', 'hover:bg-gray-700');
            toggleBtn.classList.add('bg-purple-600', 'hover:bg-purple-700');
            toggleBtn.innerHTML = '<i class="fa-solid fa-ban"></i>';
            toggleBtn.title = "Disable CSS/JS (Raw View)";
            
            originalContent = '';
            currentPageTitle = 'Canada.ca Page';
            currentBaseUrl = '';
            
            // Reset Search
            allMatches = [];
            currentMatchIndex = -1;
            lastSearchTerm = '';
            
            // Reset Checker
            window.clearAuditResults();
            stopCheckFlag = true;
            isCheckingLinks = false;
            if (currentAbortController) currentAbortController.abort();
            
            const checkBtn = document.getElementById('checkBrokenBtn');
            checkBtn.innerText = "Check Broken Links";
            checkBtn.classList.remove('bg-red-600', 'hover:bg-red-700');
            checkBtn.classList.add('bg-orange-600', 'hover:bg-orange-700');
            checkBtn.disabled = true;

            isPlainView = false;
            window.showPlaceholder();
            
            document.getElementById('error').innerHTML = '';
            document.getElementById('searchMessage').innerHTML = '';
            document.getElementById('matchCounter').innerHTML = '';
            
            document.getElementById('generateManifestBtn').disabled = true;
            document.getElementById('exportWordBtn').disabled = true;
            document.getElementById('highlightBtn').disabled = true;
            document.getElementById('clearHighlightsBtn').disabled = true;
            document.getElementById('prevBtn').disabled = true;
            document.getElementById('nextBtn').disabled = true;
        }

        window.toggleViewMode = function() {
            const previewFrame = document.getElementById('previewFrame');
            const iframeDoc = previewFrame.contentDocument || previewFrame.contentWindow.document;
            const btn = document.getElementById('toggleStyleBtn');
            
            if (!originalContent) return;

            if (!isPlainView) {
                // Switch to Plain
                const plainHtml = generateRawHtml(originalContent);
                iframeDoc.open();
                iframeDoc.write(plainHtml);
                iframeDoc.close();
                isPlainView = true;
                btn.innerHTML = '<i class="fa-solid fa-eye"></i>';
                btn.title = "Enable CSS/JS (Standard View)";
                btn.classList.remove('bg-purple-600', 'hover:bg-purple-700');
                btn.classList.add('bg-gray-600', 'hover:bg-gray-700');
            } else {
                // Switch to Standard
                const fullHtml = generateFullHtml(originalContent, currentPageTitle);
                iframeDoc.open();
                iframeDoc.write(fullHtml);
                iframeDoc.close();
                isPlainView = false;
                btn.innerHTML = '<i class="fa-solid fa-ban"></i>';
                btn.title = "Disable CSS/JS (Raw View)";
                btn.classList.remove('bg-gray-600', 'hover:bg-gray-700');
                btn.classList.add('bg-purple-600', 'hover:bg-purple-700');
            }
            
            // Re-apply highlights if they exist
            // (Both Audit and Search highlights need to be preserved across view toggles)
            setTimeout(() => {
                if(allIssues.length > 0) reapplyAuditHighlights(iframeDoc);
                if(allMatches.length > 0) window.highlightURLs(); 
            }, 100);
        }

        // Helper to generate the Raw HTML wrapper
        function generateRawHtml(content) {
            return `
            <!DOCTYPE html>
            <html lang="en">
            <head>
                <title>Raw View - ${currentPageTitle}</title>
                <style>
                    body { font-family: sans-serif; }
                    img { max-width: 100%; height: auto; border: 1px solid #ccc; }
                    a { color: blue; text-decoration: underline; }
                    
                    /* HIGHLIGHT STYLES */
                    .highlight { background-color: #ffff00; color: #000; padding: 2px 4px; border-radius: 2px; font-weight: bold; outline: 3px solid #ff6600; }
                    .highlight-broken { background-color: #ffcccc; color: #cc0000; padding: 2px 4px; border-radius: 2px; font-weight: bold; outline: 3px solid #cc0000; }
                    .highlight-warning { background-color: #ffeebf; color: #b07000; padding: 2px 4px; border-radius: 2px; font-weight: bold; outline: 3px dashed #ff9900; }
                    
                    .highlight.current-match, 
                    .highlight-broken.current-match, 
                    .highlight-warning.current-match { 
                        background-color: #ff6600 !important; color: #fff !important; outline: 4px solid #cc0000; 
                    }
                </style>
            </head>
            <body>
                <div style="background:#eee; padding:10px; margin-bottom:20px; border-bottom:1px solid #ccc;">
                    <strong>Note:</strong> Canada.ca theme disabled. Some elements that are meant to be invisible may be visible.
                </div>
                ${content}
            </body>
            </html>`;
        }

        function fixPaths(html, baseUrl) {
          const parser = new DOMParser();
          const doc = parser.parseFromString(html, 'text/html');
          
          doc.querySelectorAll('a[href]').forEach(link => {
            const href = link.getAttribute('href');
            if (href && !href.startsWith('#')) {
              link.setAttribute('target', '_blank');
              link.setAttribute('rel', 'noopener noreferrer');
            }
            // Absolute URL resolution
            if (href && !href.startsWith('http') && !href.startsWith('//') && !href.startsWith('#') && !href.startsWith('mailto:') && !href.startsWith('tel:')) {
              try {
                const absoluteUrl = new URL(href, baseUrl).href;
                link.setAttribute('href', absoluteUrl);
              } catch (e) { }
            }
          });
          
          doc.querySelectorAll('img[src]').forEach(img => {
            const src = img.getAttribute('src');
            if (src && !src.startsWith('http') && !src.startsWith('//') && !src.startsWith('data:')) {
              try {
                const absoluteUrl = new URL(src, baseUrl).href;
                img.setAttribute('src', absoluteUrl);
              } catch (e) { }
            }
          });
          
          return doc.body.innerHTML;
        }
        
        function generateFullHtml(bodyContent, pageTitle) {
          return `
            <!DOCTYPE html>
            <html class="no-js" lang="en" dir="ltr">
            <head>
            <meta charset="utf-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <title>${pageTitle}</title>
            
            <link rel="stylesheet" href="https://use.fontawesome.com/releases/v7.0.1/css/all.css">
            <link rel="stylesheet" href="https://www.canada.ca/etc/designs/canada/wet-boew/css/theme.min.css">
            <link rel="stylesheet" href="https://cdn.design-system.alpha.canada.ca/@cdssnc/gcds-components@latest/dist/gcds/gcds.css">
            <style>
                body { text-align: left; font-family: 'Noto Sans', sans-serif;}
                
                /* HIGHLIGHTS */
                .highlight {
                background-color: #ffff00 !important;
                color: #000000 !important;
                padding: 2px 4px;
                border-radius: 2px;
                font-weight: bold;
                outline: 3px solid #ff6600;
                scroll-margin-top: 100px;
                }
                .highlight-broken {
                background-color: #ffcccc !important;
                color: #cc0000 !important;
                padding: 2px 4px;
                border-radius: 2px;
                font-weight: bold;
                outline: 3px solid #cc0000;
                scroll-margin-top: 100px;
                }
                .highlight-warning {
                background-color: #ffeebf !important;
                color: #b07000 !important;
                padding: 2px 4px;
                border-radius: 2px;
                font-weight: bold;
                outline: 3px dashed #ff9900;
                scroll-margin-top: 100px;
                }
                .current-match {
                background-color: #ff6600 !important;
                color: #ffffff !important;
                outline: 4px solid #cc0000;
                }
            </style>
            </head>
            <body>
                <div style="background:#eee; padding:10px; margin:8px; border-bottom:1px solid #ccc;">
                    <strong>Note:</strong> This content preview window may not always display the Canada.ca theme properly.
                </div>
            ${bodyContent}
            <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.2.4/jquery.min.js"><\/script>
            <script src="https://www.canada.ca/etc/designs/canada/wet-boew/js/wet-boew.min.js"><\/script>
            <script src="https://www.canada.ca/etc/designs/canada/wet-boew/js/theme.min.js"><\/script>
            </body>
            </html>`;
        }
        
        window.fetchContent = async function() {
          let url = document.getElementById('urlInput').value.trim();
          const previewFrame = document.getElementById('previewFrame');
          const errorDiv = document.getElementById('error');
          
          errorDiv.innerHTML = '';
          
          if (!url) {
            errorDiv.innerHTML = '<div class="text-red-700 bg-red-100 p-3 rounded border border-red-700 mt-3 font-bold">Please enter a URL</div>';
            return;
          }

          if (!url.startsWith('http://') && !url.startsWith('https://')) {
            url = 'https://' + url;
            document.getElementById('urlInput').value = url;
          }
          
          try {
            const urlObj = new URL(url);
            const host = urlObj.hostname.toLowerCase();
            if (!(host === 'canada.ca' || host.endsWith('.canada.ca') || host === 'gc.ca' || host.endsWith('.gc.ca') || host === 'canada-preview.adobecqms.net')) {
                errorDiv.innerHTML = '<div class="text-red-700 bg-red-100 p-3 rounded border border-red-700 mt-3 font-bold text-sm">Please enter a valid canada.ca URL</div>';
                return;
            }
          } catch(e) {
             errorDiv.innerHTML = '<div class="text-red-700 bg-red-100 p-3 rounded border border-red-700 mt-3 font-bold">Invalid URL format</div>';
             return;
          }
          
          try {
            errorDiv.innerHTML = '<div class="text-gray-300 italic text-sm mt-3">Loading content...</div>';
            
            let html = '';
            try {
                const response = await fetch(url);
                if (!response.ok) throw new Error('Direct fetch HTTP error');
                html = await response.text();
            } catch (directError) {
                console.warn('Direct fetch failed, trying proxy...');
                const proxyUrl = `https://api.allorigins.win/raw?url=${encodeURIComponent(url)}`;
                const proxyResponse = await fetch(proxyUrl);
                if (!proxyResponse.ok) throw new Error(`Failed to fetch content.`);
                html = await proxyResponse.text();
            }
            
            const parser = new DOMParser();
            const doc = parser.parseFromString(html, 'text/html');
            const mainContent = doc.querySelector('main') || doc.querySelector('[role="main"]') || doc.querySelector('#wb-cont') || doc.body; 
            
            if (mainContent) {
              currentBaseUrl = url;
              originalContent = fixPaths(mainContent.outerHTML, currentBaseUrl);
              const h1 = doc.querySelector('h1');
              currentPageTitle = h1 ? h1.textContent.trim() : 'Canada.ca Page';
              
              const fullHtml = generateFullHtml(originalContent, currentPageTitle);
              const iframeDoc = previewFrame.contentDocument || previewFrame.contentWindow.document;
              iframeDoc.open();
              iframeDoc.write(fullHtml);
              iframeDoc.close();
              
              document.getElementById('generateManifestBtn').disabled = false;
              document.getElementById('exportWordBtn').disabled = false;
              
              const toggleStyleBtn = document.getElementById('toggleStyleBtn');
              toggleStyleBtn.classList.remove('hidden');
              isPlainView = false;
              toggleStyleBtn.innerHTML = '<i class="fa-solid fa-ban"></i>';
              
              const checkBrokenBtn = document.getElementById('checkBrokenBtn');
              checkBrokenBtn.innerText = "Check Broken Links";
              checkBrokenBtn.disabled = false;

              errorDiv.innerHTML = '<div class="text-green-800 bg-green-100 p-3 rounded border border-green-800 mt-3 font-bold">Content loaded successfully!</div>';
            }
          } catch (error) {
            errorDiv.innerHTML = '<div class="text-red-700 bg-red-100 p-3 rounded border border-red-700 mt-3 font-bold">Error loading content: ' + error.message + '</div>';
          }
        }
        
        async function toBase64(url) {
            try {
                let response;
                try { response = await fetch(url, { cache: 'no-cache' }); } catch(e) { response = { ok: false }; }
                if (!response.ok) {
                    const proxyUrl = `https://api.allorigins.win/raw?url=${encodeURIComponent(url)}`;
                    response = await fetch(proxyUrl);
                }
                if (!response.ok) throw new Error('Failed to fetch');
                const blob = await response.blob();
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onloadend = () => resolve(reader.result);
                    reader.onerror = reject;
                    reader.readAsDataURL(blob);
                });
            } catch (e) { return null; }
        }

        window.exportToWord = async function() {
            const errorDiv = document.getElementById('error');
            const exportBtn = document.getElementById('exportWordBtn');
            if (!originalContent) return;

            const originalBtnText = exportBtn.innerHTML;
            exportBtn.disabled = true;
            exportBtn.innerHTML = '<i class="fa-solid fa-spinner fa-spin"></i> Processing...';

            try {
                if (typeof htmlDocx === 'undefined') throw new Error('Library missing.');

                const parser = new DOMParser();
                const doc = parser.parseFromString(originalContent, 'text/html');

                const tagsToRemove = ['script', 'style', 'link', 'meta', 'iframe', 'button', 'input', 'form', 'svg'];
                tagsToRemove.forEach(tag => doc.querySelectorAll(tag).forEach(el => el.remove()));
                
                doc.querySelectorAll('*').forEach(el => {
                    el.removeAttribute('class');
                    el.removeAttribute('id');
                    el.removeAttribute('onclick');
                    el.removeAttribute('style');
                });

                const images = doc.querySelectorAll('img');
                const imagePromises = Array.from(images).map(async (img) => {
                    const src = img.getAttribute('src');
                    if (src && !src.startsWith('data:')) {
                        const base64 = await toBase64(src);
                        if (base64) img.setAttribute('src', base64);
                    }
                });
                
                if (imagePromises.length > 0) await Promise.all(imagePromises);

                const cleanHtml = `<!DOCTYPE html><html><head><meta charset="utf-8"><title>${currentPageTitle}</title></head><body>${doc.body.innerHTML}</body></html>`;
                const blob = htmlDocx.asBlob(cleanHtml);
                const url = URL.createObjectURL(blob);
                const downloadLink = document.createElement('a');
                downloadLink.href = url;
                downloadLink.download = `${currentPageTitle.replace(/[^a-z0-9]/gi, '_').toLowerCase()}.docx`;
                document.body.appendChild(downloadLink);
                downloadLink.click();
                document.body.removeChild(downloadLink);
                URL.revokeObjectURL(url);
                
                errorDiv.innerHTML = `<div class="text-green-800 bg-green-100 p-3 rounded border border-green-800 mt-3 font-bold">Word document generated!</div>`;
            } catch (e) {
                errorDiv.innerHTML = `<div class="text-red-700 bg-red-100 p-3 rounded border border-red-700 mt-3 font-bold">Error: ${e.message}</div>`;
            } finally {
                exportBtn.disabled = false;
                exportBtn.innerHTML = originalBtnText;
            }
        }

        window.generateLinkManifest = function() {
          const previewFrame = document.getElementById('previewFrame');
          const errorDiv = document.getElementById('error');
          if (!originalContent) return;
          
          try {
            // Using a background parser for accuracy if needed, but iframe doc is fine for this
            const iframeDoc = previewFrame.contentDocument || previewFrame.contentWindow.document;
            const contentDiv = iframeDoc.body;
            
            const links = contentDiv.querySelectorAll('a[href]');
            let csvContent = '#,Link Title,URL\n';
            let count = 0;
            
            links.forEach((link, i) => {
              const href = link.getAttribute('href');
              if (href && !href.startsWith('#')) {
                const title = (link.textContent.trim() || '(No title)').replace(/"/g, '""');
                const cleanHref = href.replace(/"/g, '""');
                csvContent += `${i+1},"${title}","${cleanHref}"\n`;
                count++;
              }
            });
            
            if (count === 0) {
               errorDiv.innerHTML = '<div class="text-red-700 bg-red-100 p-3 rounded border border-red-700 mt-3 font-bold">No valid links found</div>';
               return;
            }
            
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const downloadLink = document.createElement('a');
            downloadLink.href = url;
            downloadLink.download = `link_manifest_${currentPageTitle.replace(/[^a-z0-9]/gi, '_').toLowerCase()}.csv`;
            document.body.appendChild(downloadLink);
            downloadLink.click();
            document.body.removeChild(downloadLink);
            URL.revokeObjectURL(url);
            
            errorDiv.innerHTML = `<div class="text-green-800 bg-green-100 p-3 rounded border border-green-800 mt-3 font-bold">Manifest downloaded (${count} links).</div>`;
          } catch (error) {
            errorDiv.innerHTML = '<div class="text-red-700 bg-red-100 p-3 rounded border border-red-700 mt-3 font-bold">Error: ' + error.message + '</div>';
          }
        }

        // --- DEDICATED BROKEN LINK CHECKER ---
        window.toggleBrokenLinkCheck = function() {
            if (isCheckingLinks) {
                stopCheckFlag = true;
                if (currentAbortController) currentAbortController.abort();
            } else {
                window.checkBrokenLinks();
            }
        }

        window.checkBrokenLinks = async function() {
    const checkBtn = document.getElementById('checkBrokenBtn');
    const auditArea = document.getElementById('auditResultsArea');
    const auditStatus = document.getElementById('auditStatus');
    const errorDiv = document.getElementById('error');
    
    if (!originalContent) return;

    isCheckingLinks = true;
    stopCheckFlag = false;
    currentAbortController = new AbortController();
    
    checkBtn.innerText = "STOP CHECK";
    checkBtn.classList.remove('bg-orange-600', 'hover:bg-orange-700');
    checkBtn.classList.add('bg-red-600', 'hover:bg-red-700');
    
    auditArea.classList.remove('hidden');
    auditStatus.innerText = "Initializing scan, please wait...";
    
    document.getElementById('auditUnverifiedMsg').classList.add('hidden');
    document.getElementById('auditNavButtons').classList.add('hidden');
    document.getElementById('auditActionButtons').classList.add('hidden');

    lastBrokenLinksData = [];
    allIssues = [];
    currentIssueIndex = -1;
    
    document.getElementById('prevIssueBtn').disabled = true;
    document.getElementById('nextIssueBtn').disabled = true;

    async function checkLink(url) {
        try {
            const urlObj = new URL(url);
            const hostname = urlObj.hostname.toLowerCase();
            
            // Only check www.canada.ca links - everything else is unverified
            if (hostname !== 'www.canada.ca') {
                return { broken: false, unverified: true, status: 'Unverified (subdomain)' };
            }
            
            // For www.canada.ca, try direct fetch first
            try {
                const response = await fetch(url, {
                    method: 'GET',
                    cache: 'no-store',
                    signal: currentAbortController.signal,
                    redirect: 'follow'
                });
                
                // Check the status code directly
                if (response.status === 404) {
                    return { broken: true, status: 'Broken (404)' };
                }
                if (response.status === 410) {
                    return { broken: true, status: 'Broken (410 Gone)' };
                }
                if (response.status >= 500 && response.status < 600) {
                    return { broken: true, status: `Broken (${response.status})` };
                }
                if (response.status >= 200 && response.status < 400) {
                    // Also check the content for 404 indicators
                    try {
                        const text = await response.text();
                        const lowerText = text.toLowerCase();
                        
                        // Check for 404 indicators in the page content
                        if (lowerText.includes('<title>404') || 
                            lowerText.includes('404 - page not found') ||
                            lowerText.includes('404 not found') ||
                            lowerText.includes('page cannot be found') ||
                            lowerText.includes('we could not find the page')) {
                            return { broken: true, status: 'Broken (404 page content)' };
                        }
                    } catch (e) {
                        // If we can't read the text, just go with the status code
                    }
                    
                    return { broken: false, status: 'OK' };
                }
                
                // Other status codes, mark as unverified
                return { broken: false, unverified: true, status: `Unverified (Status ${response.status})` };
                
            } catch (directError) {
                if (directError.name === 'AbortError') throw directError;
                
                // Direct fetch failed (CORS), try proxy
                try {
                    const proxyUrl = `https://api.allorigins.win/raw?url=${encodeURIComponent(url)}`;
                    const proxyResponse = await fetch(proxyUrl, {
                        signal: currentAbortController.signal,
                        cache: 'no-store'
                    });
                    
                    if (proxyResponse.status === 404 || proxyResponse.status === 410) {
                        return { broken: true, status: `Broken (${proxyResponse.status})` };
                    }
                    if (proxyResponse.status >= 500 && proxyResponse.status < 600) {
                        return { broken: true, status: `Broken (${proxyResponse.status})` };
                    }
                    if (proxyResponse.ok) {
                        // Check the actual content returned by the proxy for 404 indicators
                        try {
                            const text = await proxyResponse.text();
                            const lowerText = text.toLowerCase();
                            
                            // Check for 404 indicators in the page content
                            if (lowerText.includes('<title>404') || 
                                lowerText.includes('404 - page not found') ||
                                lowerText.includes('404 not found') ||
                                lowerText.includes('page cannot be found') ||
                                lowerText.includes('we could not find the page')) {
                                return { broken: true, status: 'Broken (404 page content)' };
                            }
                        } catch (e) {
                            // If we can't read the text, just go with the status
                        }
                        
                        return { broken: false, status: 'OK' };
                    }
                    
                    // Proxy returned non-OK status
                    return { broken: false, unverified: true, status: `Unverified (Proxy ${proxyResponse.status})` };
                    
                } catch (proxyError) {
                    if (proxyError.name === 'AbortError') throw proxyError;
                    // Both methods failed - mark as unverified
                    return { broken: false, unverified: true, status: 'Unverified (Connection error)' };
                }
            }
            
        } catch (err) {
            if (err.name === 'AbortError') throw err;
            return { broken: false, unverified: true, status: 'Unverified (Parse error)' };
        }
    }

    try {
        const parser = new DOMParser();
        const rawDoc = parser.parseFromString(originalContent, 'text/html');
        
        const rawLinks = Array.from(rawDoc.querySelectorAll('a[href]')).filter(link => {
            const href = link.getAttribute('href');
            return href && href.startsWith('http');
        });

        if (rawLinks.length === 0) {
            auditStatus.innerText = "No external links found to check.";
            isCheckingLinks = false;
            checkBtn.innerText = "Check Broken Links";
            checkBtn.classList.add('bg-orange-600'); 
            checkBtn.classList.remove('bg-red-600');
            return;
        }

        let checkedCount = 0;
        let brokenCount = 0;
        let warningCount = 0;
        
        for (let i = 0; i < rawLinks.length; i++) {
            if (stopCheckFlag) break;
            
            const link = rawLinks[i];
            const href = link.getAttribute('href');
            
            try {
                const result = await checkLink(href);
                
                if (result.broken) {
                    lastBrokenLinksData.push({
                        title: link.textContent.trim() || '(No text)',
                        url: href,
                        status: result.status
                    });
                    highlightVisibleLink(href, 'broken', result.status);
                    brokenCount++;
                } else if (result.unverified) {
                    lastBrokenLinksData.push({
                        title: link.textContent.trim() || '(No text)',
                        url: href,
                        status: result.status
                    });
                    highlightVisibleLink(href, 'warning', result.status);
                    warningCount++;
                }
                
            } catch (err) {
                if (err.name === 'AbortError') continue;
            }
            
            checkedCount++;
            if (!stopCheckFlag) {
                auditStatus.innerText = `Checking ${checkedCount}/${rawLinks.length}... (${brokenCount} broken, ${warningCount} unverified)`;
            }
            
            // Only delay for www.canada.ca checks
            const urlObj = new URL(href);
            if (urlObj.hostname.toLowerCase() === 'www.canada.ca') {
                await new Promise(resolve => setTimeout(resolve, 300));
            }
        }
        
        if (stopCheckFlag) {
            auditStatus.innerHTML = `Stopped. Checked ${checkedCount}.<br><span class="text-red-400">${brokenCount} broken</span>, <span class="text-yellow-400">${warningCount} unverified</span>.`;
        } else {
            if (brokenCount + warningCount === 0) {
                auditStatus.innerHTML = `<span class="text-green-400">Success! No broken links found.</span>`;
            } else {
                auditStatus.innerHTML = `Scan Complete.<br><span class="text-red-400">${brokenCount} broken</span>, <span class="text-yellow-400">${warningCount} unverified</span>.`;
            }
        }
        
        if (allIssues.length > 0) {
            document.getElementById('prevIssueBtn').disabled = false;
            document.getElementById('nextIssueBtn').disabled = false;
            document.getElementById('auditNavButtons').classList.remove('hidden');
            document.getElementById('auditActionButtons').classList.remove('hidden');
        }
        
        if (warningCount > 0) {
            document.getElementById('auditUnverifiedMsg').classList.remove('hidden');
        }

    } catch (e) {
        errorDiv.innerHTML = `<div class="text-red-700 bg-red-100 p-3 rounded border border-red-700 mt-3 font-bold">Error: ${e.message}</div>`;
    } finally {
        isCheckingLinks = false;
        checkBtn.innerText = "Check Broken Links";
        checkBtn.classList.remove('bg-red-600', 'hover:bg-red-700');
        checkBtn.classList.add('bg-orange-600', 'hover:bg-orange-700');
    }
}
        
        // Find links in the visible iframe that match the checked URL and highlight them
        function highlightVisibleLink(url, type, status) {
            const iframeDoc = document.getElementById('previewFrame').contentDocument;
            if(!iframeDoc) return;
            
            const visibleLinks = iframeDoc.querySelectorAll(`a[href="${url}"]`);
            visibleLinks.forEach(link => {
                const className = type === 'broken' ? 'highlight-broken' : 'highlight-warning';
                link.classList.add(className);
                link.title = status;
                
                // Add to navigation array if not already present (prevent duplicates if same link appears twice)
                if (!allIssues.includes(link)) {
                    allIssues.push(link);
                    
                    // Open details if hidden
                    let parent = link.parentElement;
                    while (parent) {
                        if (parent.tagName === 'DETAILS') parent.setAttribute('open', '');
                        parent = parent.parentElement;
                    }
                }
            });
        }
        
        window.navigateIssues = function(direction) {
            if (allIssues.length === 0) return;
            
            // Remove current-match from old
            if (currentIssueIndex >= 0 && currentIssueIndex < allIssues.length) {
                allIssues[currentIssueIndex].classList.remove('current-match');
            }
            
            if (direction === 'next') {
                currentIssueIndex = (currentIssueIndex + 1) % allIssues.length;
            } else {
                currentIssueIndex = (currentIssueIndex - 1 + allIssues.length) % allIssues.length;
            }
            
            const el = allIssues[currentIssueIndex];
            el.classList.add('current-match');
            el.scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'nearest' });
        }

        window.exportBrokenLinks = function() {
            if (!lastBrokenLinksData.length) { alert("No data"); return; }
            let csv = '#,Link Title,URL,Status\n';
            lastBrokenLinksData.forEach((l, i) => {
                csv += `${i+1},"${l.title.replace(/"/g,'""')}","${l.url}","${l.status}"\n`;
            });
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `broken_links_${Date.now()}.csv`;
            document.body.appendChild(a); a.click(); document.body.removeChild(a);
        }
        
        window.clearAuditResults = function() {
            document.getElementById('auditResultsArea').classList.add('hidden');
            lastBrokenLinksData = [];
            allIssues = [];
            currentIssueIndex = -1;
            
            const iframeDoc = document.getElementById('previewFrame').contentDocument;
            if (iframeDoc) {
                iframeDoc.querySelectorAll('.highlight-broken, .highlight-warning').forEach(el => {
                    el.classList.remove('highlight-broken', 'highlight-warning', 'current-match');
                    el.removeAttribute('title');
                });
            }
        }
        
        // Helper to re-apply audit highlights when view toggles
        function reapplyAuditHighlights(doc) {
            // Re-find elements based on the data we have
            // Since elements are destroyed on view toggle, we need to re-scan content
            // However, the cleanest way is to just keep the `lastBrokenLinksData` and re-highlight by URL
            lastBrokenLinksData.forEach(item => {
                const links = doc.querySelectorAll(`a[href="${item.url}"]`);
                const className = item.status.includes('Broken') ? 'highlight-broken' : 'highlight-warning';
                links.forEach(l => {
                    l.classList.add(className);
                    l.title = item.status;
                    if(!allIssues.includes(l)) allIssues.push(l);
                });
            });
        }

        // --- SEARCH FUNCTIONS (UPDATED) ---
        window.highlightURLs = function() {
          const searchTerm = document.getElementById('searchInput').value.trim();
          if (!originalContent || !searchTerm) return;
          lastSearchTerm = searchTerm;
          
          // Clear existing before new search
          window.clearHighlights();
          
          const iframeDoc = document.getElementById('previewFrame').contentDocument;
          allMatches = [];
          const searchLower = searchTerm.toLowerCase();
          
          // STRICT REQUIREMENT: Only search <a> tags, check href and content
          iframeDoc.querySelectorAll('a').forEach(link => {
             const href = link.getAttribute('href') || '';
             const text = link.textContent || '';
             
             if (href.toLowerCase().includes(searchLower) || text.toLowerCase().includes(searchLower)) {
                 link.classList.add('highlight');
                 allMatches.push(link);
                 
                 // Open parent details if hidden
                 let p = link.parentElement;
                 while(p) { 
                     if(p.tagName === 'DETAILS') p.setAttribute('open',''); 
                     p = p.parentElement; 
                 }
             }
          });

          const searchMsg = document.getElementById('searchMessage');
          const prevBtn = document.getElementById('prevBtn');
          const nextBtn = document.getElementById('nextBtn');
          const clearBtn = document.getElementById('clearHighlightsBtn');

          if (allMatches.length > 0) {
              searchMsg.innerHTML = `<div class="text-green-800 bg-green-100 p-3 rounded border border-green-800 mt-3 font-bold">Found ${allMatches.length} matches</div>`;
              prevBtn.disabled = false;
              nextBtn.disabled = false;
              clearBtn.disabled = false;
              
              // Select first match immediately
              window.navigateMatches('next');
          } else {
              searchMsg.innerHTML = '<div class="text-red-700 bg-red-100 p-3 rounded border border-red-700 mt-3 font-bold">No matches found</div>';
              prevBtn.disabled = true;
              nextBtn.disabled = true;
              clearBtn.disabled = false; 
          }
        }
        
        window.navigateMatches = function(direction) {
            if (!allMatches.length) return;
            
            // Remove styling from current match if valid
            if (currentMatchIndex > -1 && allMatches[currentMatchIndex]) {
                allMatches[currentMatchIndex].classList.remove('current-match');
            }
            
            if (direction === 'next') {
                currentMatchIndex++;
                if (currentMatchIndex >= allMatches.length) {
                    currentMatchIndex = 0; // Wrap to start
                }
            } else {
                // Prev
                currentMatchIndex--;
                if (currentMatchIndex < 0) {
                    currentMatchIndex = allMatches.length - 1; // Wrap to end
                }
            }
            
            const el = allMatches[currentMatchIndex];
            if (el) {
                el.classList.add('current-match');
                el.scrollIntoView({behavior: 'smooth', block: 'center', inline: 'center'});
                document.getElementById('matchCounter').innerText = `Match ${currentMatchIndex+1} of ${allMatches.length}`;
            }
        }
        
        window.clearHighlights = function() {
             const iframeDoc = document.getElementById('previewFrame').contentDocument;
             // Just remove classes, no unwrapping needed for <a> tags
             if(iframeDoc) {
                 iframeDoc.querySelectorAll('.highlight').forEach(el => {
                     el.classList.remove('highlight', 'current-match');
                 });
             }
             allMatches = [];
             currentMatchIndex = -1;
             document.getElementById('searchMessage').innerHTML = '';
             document.getElementById('matchCounter').innerText = '';
             document.getElementById('prevBtn').disabled = true;
             document.getElementById('nextBtn').disabled = true;
             document.getElementById('clearHighlightsBtn').disabled = true;
        }

        window.showPlaceholder();

    })();
  </script>
</body>
</html>
