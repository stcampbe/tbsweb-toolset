<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AutoTabler™ - HTML Table Wizard</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/js-beautify/1.14.0/beautify-html.min.js"></script>
    <!-- Font Awesome CDN for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <style>
        /* Custom styles for the editor */
        html, body {
            height: 100%; /* Ensure html and body take full viewport height */
            margin: 0;
            padding: 0;
            overflow: hidden; /* Prevent body from scrolling; all scrolling should be within panels */
        }

        body {
            font-family: 'Inter', sans-serif; /* Using Inter font */
            display: flex;
            flex-direction: column;
            background-color: #09090b; /* Very dark zinc */
        }
        .table-wizard-header {
            padding: 1rem;
            display: flex; /* Use flexbox for alignment */
            align-items: center; /* Vertically align items */
            gap: 1rem; /* Space between title and buttons */
            flex-wrap: wrap; /* Allow wrapping on smaller screens */
        }

        .table-wizard-header h1 {
            font-size: 1.25rem; /* text-4xl */
            font-weight: bold;
            color: #ffffff;
            margin-right: auto; /* Push buttons to the right */
        }
        .editor-container { /* This will now be the main-wrapper, similar to Rich Text Editor */
            display: flex;
            flex-grow: 1; /* Allow container to grow and fill available space */
            padding: 0 1rem 1rem 1rem;
            gap: 1rem; /* Space between editor and sidebar (now removed, but gap remains for consistency) */
            margin: 0;
            width: 100%; /* Full width */
            height: 100%; /* Explicitly make editor-container take full height of flex parent (body) */
            box-sizing: border-box; /* Include padding in total height */
            overflow-y: hidden; /* Prevent editor container from scrolling its children */
            overflow-x: hidden; /* Prevent horizontal scrolling */
        }
        .code-panel { /* Main panel for editor and controls */
            background-color: #18181b; /* Darker zinc */
            border-radius: 0.75rem; /* rounded-xl */
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3); /* Darker shadow */
            padding: 1rem;
            display: flex;
            flex-direction: column; /* Keep column for header, content area, and footer */
            flex-grow: 1; /* Allow panels to grow and shrink horizontally */
            flex-shrink: 1;
            height: 100%; /* Take full height of container */
            box-sizing: border-box; /* Include padding and border in element's total width/height */
            overflow-y: hidden; /* Prevent main panels from scrolling; internal elements will manage their own scroll */
            overflow-x: hidden; /* Prevent horizontal scrollbar on panels unless explicitly needed */
        }

        /* Monaco Editor specific styling */
        #editor-container {
            min-height: 200px;
            flex-grow: 1; /* Allow editor to grow and take available space */
            height: 100%; /* Make Monaco take full height of its flex parent */
            border: 1px solid #3f3f46; /* Medium zinc border */
            border-radius: 0.5rem; /* rounded-lg */
            overflow: hidden;
            /* Monaco editor will handle its own internal scrolling due to automaticLayout: true */
        }

        h1 {
            color: #ffffff; /* White text for H1 in editor panel */
            margin-bottom: 1rem;
            text-align: center;
        }
        h2 {
            color: #ffffff; /* White text for H2 in panel headers */
            font-size: 1.5rem; /* text-2xl */
            font-weight: 600; /* semi-bold */
        }
        h3 {
            color: #ffffff; /* White text for H3 in panel headers */
            font-size: 1.125rem; /* text-lg */
            font-weight: 600; /* semi-bold */
            margin-bottom: 1rem;
        }
        label {
            color: #d4d4d8; /* Zinc-300 for labels */
        }
        input[type="text"], input[type="number"] {
            background-color: #27272a; /* Darker zinc for input */
            color: #ffffff; /* White text for input */
            border-color: #3f3f46; /* Medium zinc border for input */
        }
        input[type="text"]::placeholder, input[type="number"]::placeholder {
            color: #a1a1aa; /* Zinc-400 for placeholder text */
        }

        /* Responsive adjustments */
        @media (max-width: 1023px) { /* Adjust breakpoint for flex-direction to column */
            .editor-container {
                flex-direction: column; /* Stack vertically on small screens */
            }
            .code-panel {
                width: 100%; /* Full width on small screens */
            }
        }

        /* Styles for button group (reused from Rich Text Editor) */
        .button-group {
            display: flex;
            width: 100%;
            border-radius: 0.5rem;
            box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
            border: 1px solid #3f3f46;
            flex-wrap: wrap;
        }

        .button-group button {
            flex: 1;
            border-radius: 0;
            border: none;
            margin: 0;
            padding: 0.5rem 0.75rem;
            font-size: 0.875rem;
            line-height: 1.25rem;
            position: relative;
            color: #ffffff;
            font-weight: bold;
            background-color: #27272a;
            transition: background-color 0.2s ease;
        }

        .button-group button:hover {
            background-color: #3f3f46;
            z-index: 1;
        }
        /* Active button in button group */
        .button-group button.active {
            background-color: #3b82f6; /* Blue-500 */
            color: #ffffff;
        }


        /* Adjust border between buttons in the main button groups */
        .button-group button:not(:last-child) {
            border-right: 1px solid rgba(63, 63, 70, 0.5);
        }

        .button-group button:first-child {
            border-top-left-radius: 0.5rem;
            border-bottom-left-radius: 0.5rem;
        }

        .button-group button:last-child {
            border-top-right-radius: 0.5rem;
            border-bottom-right-radius: 0.5rem;
        }


        /* Message box animation */
        .message-box-fade-in {
            animation: fadeIn 0.5s ease-out forwards;
        }

        .message-box-fade-out {
            animation: fadeOut 0.5s ease-in forwards;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        @keyframes fadeOut {
            from { opacity: 1; transform: translateY(0); }
            to { opacity: 0; transform: translateY(-10px); }
        }

        /* Custom styles for Pill-style Toggle Switches */
        .toggle-switch-container {
            display: flex;
            align-items: center;
            justify-content: space-between; /* Toggle left, label right */
            width: 100%;
            margin-bottom: 0.25rem; /* Reduced margin-bottom */
            padding: 0.25rem 0; /* Reduced padding */
            gap: 0.5rem; /* Added gap between toggle and label */
        }

        .toggle-switch-label {
            color: #d4d4d8;
            font-size: 0.875rem; /* Slightly smaller font */
            flex-grow: 1; /* Allow label to take available space */
            text-align: left; /* Ensure label text is left-aligned */
            cursor: pointer; /* Indicate it's clickable for the toggle */
        }

        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 40px; /* Slightly smaller width */
            height: 22px; /* Slightly smaller height */
            border-radius: 11px; /* Half of height for pill shape */
            background-color: #71717a;
            cursor: pointer;
            transition: background-color 0.3s ease;
            flex-shrink: 0;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-switch-slider {
            position: absolute;
            content: "";
            height: 18px; /* Slightly smaller inner circle */
            width: 18px; /* Slightly smaller inner circle */
            left: 2px;
            bottom: 2px;
            background-color: #ffffff;
            border-radius: 50%;
            transition: transform 0.3s ease;
        }

        /* Checked state styles (applied to the .toggle-switch label itself) */
        .toggle-switch.is-checked {
            background-color: #3b82f6; /* Blue-500 */
        }

        .toggle-switch.is-checked .toggle-switch-slider {
            transform: translateX(18px); /* Adjusted transform for smaller toggle */
        }

        /* New styles for the button list (sidebar action buttons) */
        .button-list {
            display: flex;
            flex-direction: column;
            width: 100%;
            border: 1px solid #3f3f46;
            border-radius: 0.5rem;
            overflow: hidden;
            margin-bottom: 1rem;
        }

        .button-list button {
            width: 100%;
            border-radius: 0;
            margin: 0;
            border: none;
            border-bottom: 1px solid rgba(63, 63, 70, 0.5);
            padding: 0.5rem 0.75rem;
            text-align: center;
            font-weight: 600;
            background-color: #27272a;
            color: #ffffff;
            transition: background-color 0.2s ease;
        }

        .button-list button:last-child {
            border-bottom: none;
        }

        .button-list button:hover {
            background-color: #3f3f46;
        }

        .options-section { /* Renamed for clarity, now a simple div for grouping */
            background-color: #3f3f46; /* Medium zinc for section background */
            border-radius: 0.5rem;
            padding: 0.75rem 1rem; /* Direct padding for content, no header separate */
            flex: 1; /* Allow sections to grow and shrink within the row */
            /* min-width: 280px; Removed min-width from here */
        }

        .options-section h4 { /* Styling for the section titles */
            font-size: 1rem;
            font-weight: bold;
            color: #ffffff;
            margin-bottom: 0.75rem; /* Space below title */
            padding-bottom: 0.5rem; /* Separator from content */
            border-bottom: 1px solid #52525b; /* Lighter zinc border */
        }

        /* Adjusted grid layout for options within sections */
        .options-grid {
            display: grid;
            grid-template-columns: 1fr; /* Single column for options within a section */
            gap: 0.25rem; /* Reduced vertical gap between options */
            padding-top: 0.5rem; /* Space between title and first option */
        }
        /* Style for alignment button group container */
        .alignment-group-container {
            margin-bottom: 0.75rem; /* Space above each alignment group */
        }

        .alignment-group-container label {
            font-size: 0.9rem; /* Slightly larger label for alignment groups */
            font-weight: 600;
            color: #e4e4e7; /* Zinc-200 */
            margin-bottom: 0.3rem; /* Space between label and buttons */
            display: block; /* Make label take full width */
        }
        /* Styling for text input boxes within options */
        .option-text-input {
            display: flex;
            align-items: center;
            /* Changed order in HTML, so align items start and use gap */
            gap: 0.5rem; /* Space between input and label */
            margin-bottom: 0.25rem;
            justify-content: flex-start; /* Align contents to start */
        }
        .option-text-input label {
            flex-shrink: 0; /* Prevent label from shrinking */
            font-size: 0.875rem; /* Match toggle label font size */
        }
        .option-text-input input[type="text"] {
            /* flex-grow: 1; Removed flex-grow */
            width: 80px; /* Fixed shorter width for input */
            padding: 0.2rem 0.4rem; /* Smaller padding */
            font-size: 0.875rem; /* Match toggle label font size */
            height: 22px; /* Match toggle height */
            border-radius: 0.25rem; /* Slightly rounded corners */
        }


        /* Responsive tables styling for horizontal scrolling (already existing) */
        .table-responsive {
            overflow-x: auto; /* Enable horizontal scrolling */
            -webkit-overflow-scrolling: touch; /* Smooth scrolling on iOS */
        }

        /* Styling for disabled button */
        .button-list button:disabled,
        .flex.justify-center.space-x-2 button:disabled,
        .flex.items-center.mb-4 button:disabled,
        .modal-content button:disabled { /* Apply to all buttons within these containers and modal buttons */
            background-color: #4a4a4a !important; /* Darker gray for disabled state, use !important to override other styles */
            cursor: not-allowed !important;
            opacity: 0.6 !important;
        }

        /* Modal styles (reused from Rich Text Editor) */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .modal-content {
            background-color: #18181b; /* Darker zinc */
            padding: 1rem;
            border-radius: 0.75rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            color: #ffffff;
            text-align: left; /* Left align content */
            max-width: 95%; /* Increased max-width for better use of space */
            width: 1700px; /* Increased width to accommodate 3-column layout */
            max-height: 90vh; /* Max height to prevent overflow on smaller screens */
            overflow-y: auto; /* Enable scrolling for modal content */
            display: flex; /* Make modal content a flex container */
            flex-direction: column; /* Stack children vertically initially */
        }

        /* New flex container for the three options sections */
        .modal-options-row {
            display: grid; /* Changed to grid for better column control */
            grid-template-columns: repeat(3, 1fr); /* Three equal columns */
            gap: 1rem; /* Gap between option sections */
            margin-bottom: 0.5rem; /* Space before modal buttons */
            flex-grow: 1; /* Allow this row to grow and push buttons to bottom */
        }

        @media (max-width: 900px) { /* Adjust grid for medium screens */
            .modal-options-row {
                grid-template-columns: repeat(2, 1fr); /* Two columns on medium screens */
            }
        }

        @media (max-width: 600px) { /* Adjust grid for small screens */
            .modal-options-row {
                grid-template-columns: 1fr; /* Single column on small screens */
            }
        }

        .modal-content h3 {
            font-size: 1.5rem;
            font-weight: bold;
            margin-bottom: 1rem;
            text-align: left; /* Ensure title is left aligned */
        }

        .modal-content p {
            margin-bottom: 1.5rem;
        }

        .modal-content .modal-buttons {
            margin-top: auto; /* Push buttons to the bottom */
            display: flex;
            justify-content: flex-end; /* Push buttons to the right */
            gap: 1rem; /* Space between buttons */
        }

        .modal-content .modal-buttons button {
            background-color: #52525b; /* Zinc-600 */
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            font-weight: bold;
            transition: background-color 0.2s ease;
            flex-shrink: 0;
        }

        .modal-content .modal-buttons button:hover {
            background-color: #3f3f46; /* Zinc-700 */
        }

        /* Styles for the new dropdown for table search */
        .table-select-container { /* Changed class name for consistency */
            display: flex; /* Already flex */
            align-items: center; /* Already centered */
            gap: 0.5rem; /* Already has gap */
            color: #d4d4d8; /* Already has color */
        }

        #table-search-dropdown { /* TARGET THE ID SPECIFICALLY */
            background-color: #27272a; /* Keep existing styles */
            color: #ffffff;
            border: 1px solid #3f3f46;
            border-radius: 0.25rem;
            padding: 0.4rem 0.6rem;
            font-size: 0.875rem;
            
            /* --- FIXED WIDTH PROPERTIES --- */
            width: 380px; /* Adjust this value as needed for desired fixed width */
            flex-shrink: 0; /* Prevent it from shrinking on smaller screens */
            /* Removed flex-grow: 1; */
        }

        #table-search-dropdown:focus { /* Keep existing focus styles */
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.5);
        }

        .table-select-container select:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.5);
        }

        /* Monaco Editor highlight for selected line */
        .selected-line-highlight {
            background-color: rgba(59, 130, 246, 0.2); /* Blue with some transparency */
            border-radius: 4px;
        }

        /* --- New/Modified styles for Customize Modal Layout --- */
        #customize-modal-overlay .modal-content {
            width: 95%; /* Adjust width for the new horizontal layout */
            max-width: 1700px; /* Max width for larger screens */
            height: 90vh; /* Fixed height for consistency */
            max-height: 90vh; /* Ensure it doesn't exceed viewport height */
            display: flex;
            flex-direction: column; /* Default to column on small screens */
            overflow: hidden; /* Prevent modal content from scrolling itself, inner panels will scroll */
        }


        /* Make modal-content horizontal on medium and larger screens */
        @media (min-width: 768px) { /* md breakpoint */
            #customize-modal-overlay .modal-content {
                flex-direction: column; /* Keep column for header, main content, and buttons */
            }
        }

        .customize-main-content-wrapper {
            display: flex;
            flex-direction: column; /* Stack preview and options vertically on small screens */
            flex-grow: 1; /* Allow this wrapper to take available height */
            gap: 1rem; /* Space between preview and options */
            overflow: hidden; /* Contain inner scrolling */
            padding: 1rem 0 0 0; /* Padding for the main content area */
        }

        @media (min-width: 768px) { /* md breakpoint */
            .customize-main-content-wrapper {
                flex-direction: row; /* Horizontal layout on larger screens */
            }
        }

        .customize-preview-wrapper { /* New wrapper for iframe to control its styling/overflow */
            width: 100%; /* Full width on small screens */
            height: 70%; /* Take 70% height on small screens */
            flex-shrink: 1; /* Allow it to shrink */
            flex-grow: 1; /* Allow it to grow */
            display: flex;
            flex-direction: column;
            border-radius: 0.5rem;
            overflow-y: auto; /* Allow vertical scrolling for the wrapper */
            overflow-x: hidden; /* Prevent horizontal scrolling for the wrapper */
            box-shadow: inset 0 0 5px rgba(0,0,0,0.5); /* Inner shadow for depth */
        }

        @media (min-width: 768px) { /* md breakpoint */
            .customize-preview-wrapper {
                width: 75%; /* 3/4 width on larger screens */
                height: auto; /* Auto height to fill flex container */
            }
        }

        #customize-preview-iframe {
            width: 100%;
            height: 100%; /* Take full height of its parent wrapper */
            border: 1px solid #475569; /* Slate-600 border */
            border-radius: 0.375rem;
            background-color: #e2e8f0; /* Light blue-gray for iframe background */
        }

        .customize-options-panel {
            width: 100%; /* Full width on small screens */
            height: 30%; /* Take 30% height on small screens */
            flex-shrink: 1;
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            gap: 1rem; /* Gap between option sections */
            overflow-y: auto; /* Scrollable for options */
            /* Removed padding-right: 0.5rem; and margin-left: 1rem; */
            overflow-x: hidden; /* Ensure no horizontal scrollbar here */
        }

        @media (min-width: 768px) { /* md breakpoint */
            .customize-options-panel {
                width: 25%; /* 1/4 width on larger screens */
                height: auto; /* Auto height to fill flex container */
                /* Removed margin-left: 1rem; and padding-left: 0; */
            }
        }

        .customize-options-panel .options-section {
            background-color: #27272a; /* Darker zinc for options sections */
            padding: 1rem; /* Consistent padding */
            border-radius: 0.5rem;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            flex-shrink: 0; /* Prevent sections from shrinking, let scroll take over */
            /* Removed min-width: 280px; */
        }
        
        /* --- Styles for Attached Button Groups --- */
        .attached-button-group {
            display: inline-flex;
            box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
        }
        .attached-button-group > button:first-child {
            border-top-right-radius: 0;
            border-bottom-right-radius: 0;
        }
        .attached-button-group > button:last-child {
            border-top-left-radius: 0;
            border-bottom-left-radius: 0;
            border-left: 1px solid rgba(255, 255, 255, 0.1);
        }
        .trash-button {
            padding-left: 0.75rem;
            padding-right: 0.75rem;
        }

    </style>
</head>
<body>
    <header class="table-wizard-header">
        <h1 class="text-left">AutoTabler™ - HTML Table Wizard</h1>
        <a href="/tbsweb-toolset/rich-content-wizard/" class="px-3 py-1 text-sm bg-blue-600 text-white rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50 font-bold">Content Wizard</a>
        <a href="/tbsweb-toolset/table-wizard/" class="px-3 py-1 text-sm text-white rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50 font-bold bg-gray-400 cursor-not-allowed opacity-60" disabled="">Table Wizard</a>
        <a href="/tbsweb-toolset/qa-wizard/" class="px-3 py-1 text-sm bg-blue-600 text-white rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50 font-bold">QA Wizard</a></header>
    <div class="editor-container">
        <!-- Main Content Area (Monaco Editor and Action Buttons) -->
        <div class="code-panel">
            <div class="flex items-center mb-2 flex-wrap">
    <!-- NEW: Wrapper for left-aligned buttons with space-x-2 -->
    <div class="flex space-x-2 items-center"> <!-- Added space-x-2 here -->
        <div class="attached-button-group">
            <button id="open-options-modal-btn" class="px-4 py-2 text-base bg-blue-700 text-white rounded-l-md hover:bg-blue-800 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50 font-semibold">
                Universal Format
            </button>
            <button id="reset-universal-btn" class="trash-button bg-blue-800 text-white rounded-r-md hover:bg-blue-900 focus:outline-none focus:ring-2 focus:ring-blue-600 focus:ring-opacity-50 font-semibold" title="Reset Universal Formatting">
                <i class="fas fa-trash-alt"></i>
            </button>
        </div>
        <div class="attached-button-group">
            <button id="auto-responsive-btn" class="px-4 py-2 text-base bg-orange-700 text-white rounded-l-md hover:bg-orange-800 focus:outline-none focus:ring-2 focus:ring-orange-500 focus:ring-opacity-50 font-semibold">
                Auto-Responsive
            </button>
            <button id="reset-responsive-btn" class="trash-button bg-orange-800 text-white rounded-r-md hover:bg-orange-900 focus:outline-none focus:ring-2 focus:ring-orange-600 focus:ring-opacity-50 font-semibold" title="Remove Responsive Wrappers">
                <i class="fas fa-trash-alt"></i>
            </button>
        </div>
        <div class="attached-button-group">
            <button id="auto-scope-btn" class="px-4 py-2 text-base bg-green-700 text-white rounded-l-md hover:bg-green-800 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-opacity-50 font-semibold">
                Auto-Scope/ID
            </button>
            <button id="reset-scopeid-btn" class="trash-button bg-green-800 text-white rounded-r-md hover:bg-green-900 focus:outline-none focus:ring-2 focus:ring-green-600 focus:ring-opacity-50 font-semibold" title="Reset All Scopes and IDs">
                <i class="fas fa-trash-alt"></i>
            </button>
        </div>
        <div class="attached-button-group">
        <button id="eng-number-button" class="px-3 py-1 text-sm bg-purple-700 text-white rounded-l-md hover:bg-purple-800 focus:outline-none focus:ring-2 focus:ring-purple-600 focus:ring-opacity-50 font-bold">
            ENG Numbering
        </button>
        <button id="fra-number-button" class="px-3 py-1 text-sm bg-purple-700 text-white rounded-r-md hover:bg-purple-800 focus:outline-none focus:ring-2 focus:ring-purple-600 focus:ring-opacity-50 font-bold">
            FRA Numbering
        </button>
        </div>
        <button id="autoTableIDBtn" class="px-3 py-1 text-sm bg-gray-700 text-white rounded-md hover:bg-gray-800 focus:outline-none focus:ring-2 focus:ring-gray-600 focus:ring-opacity-50 font-bold">
            Auto Table ID's
        </button>
        <button id="autoEncodeBtn" class="px-3 py-1 text-sm bg-red-700 text-white rounded-md hover:bg-red-800 focus:outline-none focus:ring-2 focus:ring-red-600 focus:ring-opacity-50 font-semibold">
            Auto-Encode
        </button>
        <button id="autoFormatBtn" class="px-3 py-1 text-sm bg-red-700 text-white rounded-md hover:bg-red-800 focus:outline-none focus:ring-2 focus:ring-red-600 focus:ring-opacity-50 font-semibold">
            Auto-Indent
        </button>
    </div>
    <!-- Existing right-aligned group -->
    
</div>
<div class="flex mb-2 px-2 py-2 space-x-2 items-center bg-gray-800 rounded-md">
        <label for="table-search-dropdown" class="text-sm font-medium">Table Select:</label>
        <select id="table-search-dropdown" class="text-sm">
            <option value="">-- Select a table --</option>
        </select>
        <div class="attached-button-group">
        <button id="customize-button" class="px-3 py-1 text-sm bg-blue-700 text-white rounded-l-md hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-blue-600 focus:ring-opacity-50 font-bold">
            Custom Format
        </button>
    <button id="reset-tableformat-btn" class="trash-button bg-blue-800 text-white rounded-r-md hover:bg-blue-900 focus:outline-none focus:ring-2 focus:ring-blue-600 focus:ring-opacity-50 font-semibold" title="Reset Table Formatting">
                <i class="fas fa-trash-alt"></i>
            </button>
    </div>
        <div class="attached-button-group">
        <button id="force-scope-button" class="px-3 py-1 text-sm bg-green-700 text-white rounded-l-md hover:bg-green-600 focus:outline-none focus:ring-2 focus:ring-green-600 focus:ring-opacity-50 font-bold">
            Force Scope
        </button>
        <button id="force-id-button" class="px-3 py-1 text-sm bg-green-700 text-white hover:bg-green-600 focus:outline-none focus:ring-2 focus:ring-green-600 focus:ring-opacity-50 font-bold">
            Force ID/Headers
        </button>
        <button id="reset-tablescopeid-btn" class="trash-button bg-green-800 text-white rounded-r-md hover:bg-green-900 focus:outline-none focus:ring-2 focus:ring-green-600 focus:ring-opacity-50 font-semibold" title="Reset Table Scope/IDs">
                <i class="fas fa-trash-alt"></i>
            </button>
        </div>
</div>
			<div class="flex items-center mb-4 flex-wrap">
                    <div class="inline-flex rounded-md shadow-sm" role="group">
                        <button id="copyCodeBtn" class="px-4 py-1 text-sm bg-gray-700 text-white rounded-l-md hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-opacity-50 font-semibold">
                            Copy Code
                        </button>
                        <button id="clearAllBtn" class="px-4 py-1 text-sm bg-gray-700 text-white rounded-r-md hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-opacity-50 font-bold">
                            Clear All
                        </button>
                    </div>
                    <div class="inline-flex space-x-2 ml-4">
                        <button id="importHtmlBtn" class="px-3 py-1 text-sm bg-purple-700 text-white rounded-md hover:bg-purple-800 focus:outline-none focus:ring-2 focus:ring-purple-600 focus:ring-opacity-50 font-bold">Import HTML</button>
                        <button id="exportHtmlBtn" class="px-3 py-1 text-sm bg-red-700 text-white rounded-md hover:bg-red-800 focus:outline-none focus:ring-2 focus:ring-red-600 focus:ring-opacity-50 font-bold">Export HTML</button>
                        <input type="file" id="htmlFileInput" accept=".html" style="display: none;">
                    </div>
                </div>

            

            <!-- Monaco Editor takes full remaining space -->
            <div id="editor-container"></div>
			<!-- Message Box for alerts/errors -->
            <div id="message-box" class="p-4 rounded-lg text-sm text-center transition-all duration-300 ease-in-out mb-4 mt-4 bg-gray-400" role="alert">No messages</div>
        </div>
    </div>

    <!-- Universal Format Modal Overlay and Content -->
    <div id="options-modal-overlay" class="modal-overlay hidden">
        <div class="modal-content">
            <div class="flex justify-between items-center mb-4">
                <h3 class="text-xl font-bold text-white">Format All Tables</h3>
                <button id="close-options-modal-btn" class="text-gray-400 hover:text-gray-200">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                </button>
            </div>

            <div class="modal-options-row">
                <!-- Table Properties Section -->
                <div class="options-section">
                    <h4>Base Properties</h4>
                    <div class="options-grid">
                        <!-- ID Tables Checkbox -->
                        <div class="toggle-switch-container">
                            <label class="toggle-switch is-checked" for="id-checkbox">
                                <input type="checkbox" id="id-checkbox" class="hidden" checked>
                                <span class="toggle-switch-slider"></span>
                            </label>
                            <span class="toggle-switch-label text-gray-200">ID Tables</span>
                        </div>
                        <!-- Table ID Prefix Input -->
                        <div class="option-text-input">
                            <input type="text" id="page-id-prefix-input" class="w-auto" style="width: 60px;" placeholder="tbl">
                            <label for="page-id-prefix-input" class="text-gray-200">Table ID Prefix</label>
                        </div>
                        <!-- Figure Table ID Prefix Input -->
                        <div class="option-text-input">
                            <input type="text" id="figure-data-id-prefix-input" class="w-auto" style="width: 60px;" placeholder="ftbl">
                            <label for="figure-data-id-prefix-input" class="text-gray-200">Figure Table ID Prefix</label>
                        </div>
                        <!-- Fix Empty Cells -->
                        <div class="toggle-switch-container">
                            <label class="toggle-switch is-checked" for="fix-empty-cells-checkbox">
                                <input type="checkbox" id="fix-empty-cells-checkbox" class="hidden" checked>
                                <span class="toggle-switch-slider"></span>
                            </label>
                            <span class="toggle-switch-label text-gray-200">Fix Empty Cells</span>
                        </div>
                        <!-- Make TFOOT from LAST COLSPAN -->
                        <div class="toggle-switch-container">
                            <label class="toggle-switch is-checked" for="make-tfoot-from-colspan-checkbox">
                                <input type="checkbox" id="make-tfoot-from-colspan-checkbox" class="hidden" checked>
                                <span class="toggle-switch-slider"></span>
                            </label>
                            <span class="toggle-switch-label text-gray-200">TFOOT from LAST COLSPAN</span>
                        </div>
						<!-- TFOOT before TBODY -->
                        <div class="toggle-switch-container">
                            <label class="toggle-switch is-checked" for="make-tfoot-before-tbody-checkbox">
                                <input type="checkbox" id="make-tfoot-before-tbody-checkbox" class="hidden" checked>
                                <span class="toggle-switch-slider"></span>
                            </label>
                            <span class="toggle-switch-label text-gray-200">TFOOT before TBODY</span>
                        </div>
                        <!-- Captions (placeholder) Toggle -->
                        <div class="toggle-switch-container">
                            <label class="toggle-switch is-checked" for="caption-checkbox">
                                <input type="checkbox" id="caption-checkbox" class="hidden" checked>
                                <span class="toggle-switch-slider"></span>
                            </label>
                            <span class="toggle-switch-label text-gray-200">Caption (set manually)</span>
                        </div>
                        <!-- Auto-Caption Toggle -->
                        <div class="toggle-switch-container">
                            <label class="toggle-switch" for="auto-caption-checkbox">
                                <input type="checkbox" id="auto-caption-checkbox" class="hidden">
                                <span class="toggle-switch-slider"></span>
                            </label>
                            <span class="toggle-switch-label text-gray-200">Auto-Caption</span>
                        </div>
						<!-- Auto-Caption Toggle -->
                        <div class="toggle-switch-container">
                            <label class="toggle-switch" for="inv-caption-checkbox">
                                <input type="checkbox" id="inv-caption-checkbox" class="hidden">
                                <span class="toggle-switch-slider"></span>
                            </label>
                            <span class="toggle-switch-label text-gray-200">Invisible Captions</span>
                        </div>
                        
                        <!-- Remove p tags -->
                        <div class="toggle-switch-container">
                            <label class="toggle-switch" for="remove-p-tags-checkbox">
                                <input type="checkbox" id="remove-p-tags-checkbox" class="hidden">
                                <span class="toggle-switch-slider"></span>
                            </label>
                            <span class="toggle-switch-label text-gray-200">Remove &lt;p&gt; Tags</span>
                        </div>
                        
                        <!-- Add Small to TABLE (renamed and moved) Checkbox -->
                        <div class="toggle-switch-container">
                            <label class="toggle-switch" for="class-small-checkbox">
                                <input type="checkbox" id="class-small-checkbox" class="hidden">
                                <span class="toggle-switch-slider"></span>
                            </label>
                            <span class="toggle-switch-label text-gray-200">Add <strong>small</strong> to TABLE</span>
                        </div>
                        <!-- Add small to ALL TR -->
                        <div class="toggle-switch-container">
                            <label class="toggle-switch" for="add-small-to-tr-checkbox">
                                <input type="checkbox" id="add-small-to-tr-checkbox" class="hidden">
                                <span class="toggle-switch-slider"></span>
                            </label>
                            <span class="toggle-switch-label text-gray-200">Add <strong>small</strong> to ALL TR</span>
                        </div>
                    </div>
                </div>

                <!-- Table Structure Section -->
                <div class="options-section">
                    <h4>Structure and Styling</h4>
                    <div class="options-grid">
                        <!-- Basic Classes Checkbox -->
                        <div class="toggle-switch-container">
                            <label class="toggle-switch is-checked" for="class-tables-checkbox">
                                <input type="checkbox" id="class-tables-checkbox" class="hidden" checked>
                                <span class="toggle-switch-slider"></span>
                            </label>
                            <span class="toggle-switch-label text-gray-200">Basic Classes</span>
                        </div>
                        <!-- Column Headers + THEAD Checkbox -->
                        <div class="toggle-switch-container">
                            <label class="toggle-switch is-checked" for="header-checkbox">
                                <input type="checkbox" id="header-checkbox" class="hidden" checked>
                                <span class="toggle-switch-slider"></span>
                            </label>
                            <span class="toggle-switch-label text-gray-200">TH COL Headers (1st row)</span>
                        </div>
                        <!-- Row Headers in TBODY Checkbox -->
                        <div class="toggle-switch-container">
                            <label class="toggle-switch is-checked" for="row-header-checkbox">
                                <input type="checkbox" id="row-header-checkbox" class="hidden" checked>
                                <span class="toggle-switch-slider"></span>
                            </label>
                            <span class="toggle-switch-label text-gray-200">TH ROW Headers (1st col)</span>
                        </div>
                        <!-- Active Column Headers Checkbox -->
                        <div class="toggle-switch-container">
                            <label class="toggle-switch is-checked" for="active-col-headers-checkbox">
                                <input type="checkbox" id="active-col-headers-checkbox" class="hidden" checked>
                                <span class="toggle-switch-slider"></span>
                            </label>
                            <span class="toggle-switch-label text-gray-200"><strong>active</strong> COL Headers</span>
                        </div>
                        <!-- Active Colspan Headers Checkbox -->
                        <div class="toggle-switch-container">
                            <label class="toggle-switch is-checked" for="active-colspan-headers-checkbox">
                                <input type="checkbox" id="active-colspan-headers-checkbox" class="hidden" checked>
                                <span class="toggle-switch-slider"></span>
                            </label>
                            <span class="toggle-switch-label text-gray-200"><strong>active</strong> COLSPAN Headers</span>
                        </div>
                        <!-- Active Row Headers Checkbox -->
                        <div class="toggle-switch-container">
                            <label class="toggle-switch" for="active-row-headers-checkbox">
                                <input type="checkbox" id="active-row-headers-checkbox" class="hidden">
                                <span class="toggle-switch-slider"></span>
                            </label>
                            <span class="toggle-switch-label text-gray-200"><strong>active</strong> ROW Headers</span>
                        </div>
                        <!-- Bordered Checkbox -->
                        <div class="toggle-switch-container">
                            <label class="toggle-switch is-checked" for="bordered-checkbox">
                                <input type="checkbox" id="bordered-checkbox" class="hidden" checked>
                                <span class="toggle-switch-slider"></span>
                            </label>
                            <span class="toggle-switch-label text-gray-200">Add <strong>bordered</strong></span>
                        </div>
                        <!-- Striped Checkbox -->
                        <div class="toggle-switch-container">
                            <label class="toggle-switch" for="striped-checkbox">
                                <input type="checkbox" id="striped-checkbox" class="hidden">
                                <span class="toggle-switch-slider"></span>
                            </label>
                            <span class="toggle-switch-label text-gray-200">Add <strong>striped</strong></span>
                        </div>
                        <!-- Hover Checkbox -->
                        <div class="toggle-switch-container">
                            <label class="toggle-switch" for="hover-checkbox">
                                <input type="checkbox" id="hover-checkbox" class="hidden">
                                <span class="toggle-switch-slider"></span>
                            </label>
                            <span class="toggle-switch-label text-gray-200">Add <strong>hover</strong></span>
                        </div>
                        <!-- Bold Totals here -->
                        <div class="toggle-switch-container">
                            <label class="toggle-switch" for="bold-totals-checkbox">
                                <input type="checkbox" id="bold-totals-checkbox" class="hidden">
                                <span class="toggle-switch-slider"></span>
                            </label>
                            <span class="toggle-switch-label text-gray-200">Bold Totals</span>
                        </div>
                        <!-- Finance Table here -->
                        <div class="toggle-switch-container">
                            <label class="toggle-switch" for="finance-table-checkbox">
                                <input type="checkbox" id="finance-table-checkbox" class="hidden">
                                <span class="toggle-switch-slider"></span>
                            </label>
                            <span class="toggle-switch-label text-gray-200">Finance Tables</span>
                        </div>
                        
                    </div>
                </div>

                <!-- Table Styling Section -->
                <div class="options-section">
                    <h4>Alignment</h4>
                    <div class="options-grid">
                        

                        <!-- Caption Alignment Button Group -->
                        <div class="alignment-group-container">
                            <label for="caption-alignment">Caption</label>
                            <div id="caption-alignment-group" class="button-group">
                                <button data-align="left" class="active">Left</button>
                                <button data-align="center">Center</button>
                                <button data-align="right">Right</button>
                            </div>
                        </div>

                        <!-- Column Headers Alignment Button Group -->
                        <div class="alignment-group-container">
                            <label for="col-headers-alignment">Column Headers</label>
                            <div id="col-headers-alignment-group" class="button-group">
                                <button data-align="none" class="active">None</button>
                                <button data-align="left">Left</button>
                                <button data-align="center">Center</button>
                                <button data-align="right">Right</button>
                            </div>
                        </div>

                        <!-- Row Headers Alignment Button Group -->
                        <div class="alignment-group-container">
                            <label for="row-headers-alignment">Row Headers</label>
                            <div id="row-headers-alignment-group" class="button-group">
                                <button data-align="none" class="active">None</button>
                                <button data-align="left">Left</button>
                                <button data-align="center">Center</button>
                                <button data-align="right">Right</button>
                            </div>
                        </div>

                        <!-- Colspan Headers Alignment Button Group -->
                        <div class="alignment-group-container">
                            <label for="colspan-headers-alignment">Colspan Headers</label>
                            <div id="colspan-headers-alignment-group" class="button-group">
                                <button data-align="none" class="active">None</button>
                                <button data-align="left">Left</button>
                                <button data-align="center">Center</button>
                                <button data-align="right">Right</button>
                            </div>
                        </div>

                        <!-- Data Cells Alignment Button Group -->
                        <div class="alignment-group-container">
                            <label for="data-cells-alignment">Data Cells</label>
                            <div id="data-cells-alignment-group" class="button-group">
                                <button data-align="none" class="active">None</button>
                                <button data-align="left">Left</button>
                                <button data-align="center">Center</button>
                                <button data-align="right">Right</button>
                            </div>
                        </div>
                        
                    </div>
                </div>
            </div>

            <div class="modal-buttons">
                <button id="format-button-modal" class="px-4 py-2 text-sm bg-blue-700 text-white rounded-md hover:bg-blue-800 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50 font-semibold">
                    Format Tables
                </button>
            </div>
        </div>
    </div>

    <!-- Customize Table Modal Overlay and Content -->
    <div id="customize-modal-overlay" class="modal-overlay hidden">
        <div class="modal-content">
            <div class="flex justify-between items-center mb-4">
                <h3 class="text-xl font-bold text-white">Customize Table</h3>
                <button id="close-customize-modal-btn" class="text-gray-400 hover:text-gray-200">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                </button>
            </div>

            <!-- New flex container for main layout: preview on left, options on right -->
            <div class="customize-main-content-wrapper">
                <!-- Preview Wrapper (3/4 width on md and up) -->
                <div class="customize-preview-wrapper flex flex-col">
                    <!-- Removed: NEW: Interaction Mode Toggle -->
                    <!-- <div class="interaction-mode-toggle">
                        <div id="interaction-mode-group" class="button-group">
                            <button id="select-mode-btn" data-mode="select" class="active">Select Mode</button>
                            <button id="type-mode-btn" data-mode="type">Type Mode</button>
                        </div>
                    </div> -->
                    <iframe id="customize-preview-iframe" class="flex-grow"></iframe>
                </div>

                <!-- Options Panel (1/4 width on md and up) -->
                <div class="customize-options-panel">
                    <!-- Table Properties Section -->
                    <div class="options-section">
                        <h4>Base Properties</h4>
                        <div class="options-grid">
                            <!-- Table ID Prefix Input (Renamed to Custom ID) -->
                            <div class="option-text-input">
                                <label for="customize-page-id-prefix-input" class="text-gray-200">Custom ID</label>
                                <input type="text" id="customize-page-id-prefix-input" class="flex-grow bg-zinc-700 text-white border border-zinc-500 rounded-md p-1" placeholder="my-custom-id">
                            </div>
							<!-- Fix Empty Cells -->
                            <div class="toggle-switch-container">
                                <label class="toggle-switch" for="customize-fix-empty-cells-checkbox">
                                    <input type="checkbox" id="customize-fix-empty-cells-checkbox" class="hidden" checked>
                                    <span class="toggle-switch-slider"></span>
                                </label>
                                <span class="toggle-switch-label text-gray-200">Fix Empty Cells</span>
                            </div>

                            <!-- Make TFOOT from LAST COLSPAN -->
                            <div class="toggle-switch-container">
                                <label class="toggle-switch" for="customize-make-tfoot-from-colspan-checkbox">
                                    <input type="checkbox" id="customize-make-tfoot-from-colspan-checkbox" class="hidden">
                                    <span class="toggle-switch-slider"></span>
                                </label>
                                <span class="toggle-switch-label text-gray-200">TFOOT from LAST COLSPAN</span>
                            </div>
							<!-- TFOOT before TBODY -->
                        <div class="toggle-switch-container">
                            <label class="toggle-switch is-checked" for="customize-make-tfoot-before-tbody-checkbox">
                                <input type="checkbox" id="customize-make-tfoot-before-tbody-checkbox" class="hidden">
                                <span class="toggle-switch-slider"></span>
                            </label>
                            <span class="toggle-switch-label text-gray-200">TFOOT before TBODY</span>
                        </div>
							<!-- Captions (placeholder) Toggle -->
                        <div class="toggle-switch-container">
                            <label class="toggle-switch" for="customize-caption-checkbox">
                                <input type="checkbox" id="customize-caption-checkbox" class="hidden">
                                <span class="toggle-switch-slider"></span>
                            </label>
                            <span class="toggle-switch-label text-gray-200">Caption</span>
                        </div>
                            <!-- Auto-Caption Toggle -->
                        <div class="toggle-switch-container">
                            <label class="toggle-switch" for="customize-inv-caption-checkbox">
                                <input type="checkbox" id="customize-inv-caption-checkbox" class="hidden">
                                <span class="toggle-switch-slider"></span>
                            </label>
                            <span class="toggle-switch-label text-gray-200">Invisible Captions</span>
                        </div>
                            <!-- Remove p tags -->
                            <div class="toggle-switch-container">
                                <label class="toggle-switch" for="customize-remove-p-tags-checkbox">
                                    <input type="checkbox" id="customize-remove-p-tags-checkbox" class="hidden">
                                    <span class="toggle-switch-slider"></span>
                                </label>
                                <span class="toggle-switch-label text-gray-200">Remove &lt;p&gt; Tags</span>
                            </div>
                            
                            <!-- Add Small to TABLE (renamed and moved) Checkbox -->
                            <div class="toggle-switch-container">
                                <label class="toggle-switch" for="customize-class-small-checkbox">
                                    <input type="checkbox" id="customize-class-small-checkbox" class="hidden">
                                    <span class="toggle-switch-slider"></span>
                                </label>
                                <span class="toggle-switch-label text-gray-200">Add <strong>small</strong> to TABLE</span>
                            </div>
                            <!-- Add small to ALL TR -->
                            <div class="toggle-switch-container">
                                <label class="toggle-switch" for="customize-add-small-to-tr-checkbox">
                                    <input type="checkbox" id="customize-add-small-to-tr-checkbox" class="hidden">
                                    <span class="toggle-switch-slider"></span>
                                </label>
                                <span class="toggle-switch-label text-gray-200">Add <strong>small</strong> to ALL TR</span>
                            </div>
                        </div>
                    </div>

                    <!-- Table Structure Section -->
                    <div class="options-section">
                        <h4>Structure and Styling</h4>
                        <div class="options-grid">
						<div class="toggle-switch-container">
                                <label class="toggle-switch" for="customize-class-tables-checkbox">
                                    <input type="checkbox" id="customize-class-tables-checkbox" class="hidden" checked>
                                    <span class="toggle-switch-slider"></span>
                                </label>
                                <span class="toggle-switch-label text-gray-200">Basic Classes</span>
                            </div>
                            <!-- Column Headers + THEAD Checkbox -->
                            <div class="toggle-switch-container">
                                <label class="toggle-switch" for="customize-header-checkbox">
                                    <input type="checkbox" id="customize-header-checkbox" class="hidden" checked>
                                    <span class="toggle-switch-slider"></span>
                                </label>
                                <span class="toggle-switch-label text-gray-200">TH COL Headers (1st row)</span>
                            </div>
                            <!-- Row Headers in TBODY Checkbox -->
                            <div class="toggle-switch-container">
                                <label class="toggle-switch" for="customize-row-header-checkbox">
                                    <input type="checkbox" id="customize-row-header-checkbox" class="hidden" checked>
                                    <span class="toggle-switch-slider"></span>
                                </label>
                                <span class="toggle-switch-label text-gray-200">TH ROW Headers (1st col)</span>
                            </div>
                            <!-- Active Column Headers Checkbox -->
                            <div class="toggle-switch-container">
                                <label class="toggle-switch" for="customize-active-col-headers-checkbox">
                                    <input type="checkbox" id="customize-active-col-headers-checkbox" class="hidden" checked>
                                    <span class="toggle-switch-slider"></span>
                                </label>
                                <span class="toggle-switch-label text-gray-200"><strong>active</strong> COL Headers</span>
                            </div>
                            <!-- Active Colspan Headers Checkbox -->
                            <div class="toggle-switch-container">
                                <label class="toggle-switch" for="customize-active-colspan-headers-checkbox">
                                    <input type="checkbox" id="customize-active-colspan-headers-checkbox" class="hidden" checked>
                                    <span class="toggle-switch-slider"></span>
                                </label>
                                <span class="toggle-switch-label text-gray-200"><strong>active</strong> COLSPAN Headers</span>
                            </div>
                            <!-- Active Row Headers Checkbox -->
                            <div class="toggle-switch-container">
                                <label class="toggle-switch" for="customize-active-row-headers-checkbox">
                                    <input type="checkbox" id="customize-active-row-headers-checkbox" class="hidden">
                                    <span class="toggle-switch-slider"></span>
                                </label>
                                <span class="toggle-switch-label text-gray-200"><strong>active</strong> ROW Headers</span>
                            </div>
                            <!-- Bordered Checkbox -->
                            <div class="toggle-switch-container">
                                <label class="toggle-switch" for="customize-bordered-checkbox">
                                    <input type="checkbox" id="customize-bordered-checkbox" class="hidden" checked>
                                    <span class="toggle-switch-slider"></span>
                                </label>
                                <span class="toggle-switch-label text-gray-200">Add <strong>bordered</strong></span>
                            </div>
                            <!-- Striped Checkbox -->
                            <div class="toggle-switch-container">
                                <label class="toggle-switch" for="customize-striped-checkbox">
                                    <input type="checkbox" id="customize-striped-checkbox" class="hidden">
                                    <span class="toggle-switch-slider"></span>
                                </label>
                                <span class="toggle-switch-label text-gray-200">Add <strong>striped</strong></span>
                            </div>
                            <!-- Hover Checkbox -->
                            <div class="toggle-switch-container">
                                <label class="toggle-switch" for="customize-hover-checkbox">
                                    <input type="checkbox" id="customize-hover-checkbox" class="hidden">
                                    <span class="toggle-switch-slider"></span>
                                </label>
                                <span class="toggle-switch-label text-gray-200">Add <strong>hover</strong></span>
                            </div>
                            <!-- Bold Totals here -->
                            <div class="toggle-switch-container">
                                <label class="toggle-switch" for="customize-bold-totals-checkbox">
                                    <input type="checkbox" id="customize-bold-totals-checkbox" class="hidden">
                                    <span class="toggle-switch-slider"></span>
                                </label>
                                <span class="toggle-switch-label text-gray-200">Bold Totals</span>
                            </div>
                            <!-- Finance Table here -->
                            <div class="toggle-switch-container">
                                <label class="toggle-switch" for="customize-finance-table-checkbox">
                                    <input type="checkbox" id="customize-finance-table-checkbox" class="hidden">
                                    <span class="toggle-switch-slider"></span>
                                </label>
                                <span class="toggle-switch-label text-gray-200">Finance Tables</span>
                            </div>
                            
                        </div>
                    </div>

                    <!-- Table Styling Section -->
                    <div class="options-section">
                        <h4>Alignment</h4>
                        <div class="options-grid">
                            
                            

                            <!-- Caption Alignment Button Group -->
                            <div class="alignment-group-container">
                                <label for="customize-caption-alignment">Caption</label>
                                <div id="customize-caption-alignment-group" class="button-group">
                                    <button data-align="left" class="active">Left</button>
                                    <button data-align="center">Center</button>
                                    <button data-align="right">Right</button>
                                </div>
                            </div>

                            <!-- Column Headers Alignment Button Group -->
                            <div class="alignment-group-container">
                                <label for="customize-col-headers-alignment">Column Headers</label>
                                <div id="customize-col-headers-alignment-group" class="button-group">
                                    <button data-align="none" class="active">None</button>
                                    <button data-align="left">Left</button>
                                    <button data-align="center">Center</button>
                                    <button data-align="right">Right</button>
                                </div>
                            </div>

                            <!-- Row Headers Alignment Button Group -->
                            <div class="alignment-group-container">
                                <label for="customize-row-headers-alignment">Row Headers</label>
                                <div id="customize-row-headers-alignment-group" class="button-group">
                                    <button data-align="none" class="active">None</button>
                                    <button data-align="left">Left</button>
                                    <button data-align="center">Center</button>
                                    <button data-align="right">Right</button>
                                </div>
                            </div>

                            <!-- Colspan Headers Alignment Button Group -->
                            <div class="alignment-group-container">
                                <label for="customize-colspan-headers-alignment">Colspan Headers</label>
                                <div id="customize-colspan-headers-alignment-group" class="button-group">
                                    <button data-align="none" class="active">None</button>
                                    <button data-align="left">Left</button>
                                    <button data-align="center">Center</button>
                                    <button data-align="right">Right</button>
                                </div>
                            </div>

                            <!-- Data Cells Alignment Button Group -->
                            <div class="alignment-group-container">
                                <label for="customize-data-cells-alignment">Data Cells</label>
                                <div id="customize-data-cells-alignment-group" class="button-group">
                                    <button data-align="none" class="active">None</button>
                                    <button data-align="left">Left</button>
                                    <button data-align="center">Center</button>
                                    <button data-align="right">Right</button>
                                </div>
                            </div>
                            
                        </div>
                    </div>
                </div>
            </div>

            <div class="modal-buttons mt-4"> <!-- Added mt-4 for spacing -->
                <button id="format-specific-table-button" class="px-4 py-2 text-sm bg-blue-700 text-white rounded-md hover:bg-blue-800 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50 font-semibold">
                    Format Table
                </button>
            </div>
        </div>
    </div>


    <!-- Monaco Editor Loader -->
    <script src="https://cdn.jsdelivr.net/npm/monaco-editor@0.49.0/min/vs/loader.js"></script>
    <script>
        let monacoEditor; // Declare editor variable globally
        let entityDecorations = []; // Variable to store Monaco decorations for entities
        let messageTimeoutId; // Timeout for message box
        let tableDataMap = new Map(); // Stores {optionValue: {startIndex: ...}} for jump functionality
        let currentHighlightDecorationId = []; // Stores the ID of the current highlight decoration
        // Removed: let previewInteractionMode = 'select'; // 'select' or 'type'

        // Initialize global state variables for alignment options
        // These are for the UNIVERSAL format modal
        window.captionAlignment = 'left'; // Changed to 'left'
        window.colHeaderAlignment = 'none';
        window.rowHeaderAlignment = 'none';
        window.colspanHeaderAlignment = 'none'; // Changed to 'none'
        window.dataCellsAlignment = 'none';

        // Global variables for CUSTOMIZE modal alignment options (initialize to default for specific table)
        window.customizeCaptionAlignment = 'left'; // Changed to 'left'
        window.customizeColHeaderAlignment = 'none';
        window.customizeRowHeaderAlignment = 'none';
        window.customizeColspanHeaderAlignment = 'none'; // Changed to 'none'
        window.customizeDataCellsAlignment = 'none';

        // Helper function to get the current HTML from the editor
        function getEditorContent() {
            return monacoEditor ? monacoEditor.getValue() : '';
        }

        // Helper function to set the HTML content in the editor
        function setEditorContent(content) {
            if (monacoEditor) {
                monacoEditor.setValue(content);
            }
        }

        /**
         * Clears any active Monaco editor line highlighting.
         */
        function clearMonacoHighlight() {
            if (monacoEditor && currentHighlightDecorationId.length > 0) {
                // Corrected: deltaDecorations is on the model
                monacoEditor.getModel().deltaDecorations(currentHighlightDecorationId, []);
                currentHighlightDecorationId = [];
            }
        }

        /**
         * Applies highlighting to HTML character entities in the Monaco editor.
         */
        function applyEntityHighlighting() {
            if (!monacoEditor) return;

            const model = monacoEditor.getModel();
            if (!model) return;

            const newDecorations = [];
            const text = model.getValue();
            // Regex to find HTML entities like &nbsp; &#160; &amp;
            const regex = /&[a-zA-Z0-9#]+;/g;

            let match;
            while ((match = regex.exec(text)) !== null) {
                const startPos = model.getPositionAt(match.index);
                const endPos = model.getPositionAt(match.index + match[0].length);

                newDecorations.push({
                    range: new monaco.Range(startPos.lineNumber, startPos.column, endPos.lineNumber, endPos.column),
                    options: {
                        inlineClassName: 'entity-highlight',
                        hoverMessage: { value: 'HTML Character Entity' } // Optional: show tooltip on hover
                    }
                });
            }

            // Corrected: deltaDecorations is on the model
            entityDecorations = model.deltaDecorations(entityDecorations, newDecorations);
        }

        /**
         * Encodes a string to Base64.
         * @param {string} str The string to encode.
         * @returns {string} The Base64 encoded string.
         */
        function encodeBase64(str) {
            return btoa(unescape(encodeURIComponent(str)));
        }

        /**
         * Decodes a Base64 string.
         * @param {string} str The Base64 string to decode.
         * @returns {string} The decoded string.
         */
        function decodeBase64(str) {
            return decodeURIComponent(escape(atob(str)));
        }

        /**
         * Protects all data- attributes by Base64 encoding their values and replacing them with a temporary attribute.
         * This function operates purely on the HTML string using regex to avoid DOM parsing issues with complex attribute values.
         * @param {string} htmlString - The HTML content to process.
         * @returns {string} The HTML with protected data- attributes.
         */
        function protectDataAttributes(htmlString) {
            const regex = /(data-[a-zA-Z0-9-]+)="([^"]*)"/g;
            return htmlString.replace(regex, (match, attrName, value) => {
                const encodedValue = encodeBase64(value);
                return `data-temp-protected-${attrName}="${encodedValue}"`;
            });
        }

        /**
         * Restores protected data- attributes by Base64 decoding their values and replacing them back.
         * The decoded value's internal double quotes are explicitly re-escaped as &quot; to prevent corruption during later DOM operations.
         * This function operates purely on the HTML string using regex.
         * @param {string} htmlString - The HTML content to process.
         * @returns {string} The HTML with original data- attributes restored.
         */
        function restoreDataAttributes(htmlString) {
            const regex = /data-temp-protected-(data-[a-zA-Z0-9-]+)="([^"]*)"/g;
            return htmlString.replace(regex, (match, originalAttrName, encodedValue) => {
                try {
                    let decodedValue = decodeBase64(encodedValue);
                    let safeValue = decodedValue.replace(/"/g, '&quot;');
                    safeValue = safeValue.replace(/&#34;/g, '&quot;');
                    return `${originalAttrName}="${safeValue}"`;
                } catch (e) {
                    console.error("Error decoding or re-escaping Base64 data-attribute:", e);
                    return '';
                }
            });
        }

        /**
         * Converts common character entities and named entities to their numeric HTML entity equivalents.
         * This function operates on an HTML string, parsing it to a temporary DOM, modifying text nodes,
         * and then serializing it back to a string, ensuring numeric entities are preserved.
         * @param {string} htmlString - The HTML content to process.
         * @returns {string} The processed HTML string with numeric entities.
         */
        function convertAllEntitiesToNumeric(htmlString) {
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = htmlString; // This parses entities to characters

            const walker = document.createTreeWalker(
                tempDiv,
                NodeFilter.SHOW_TEXT,
                {
                    acceptNode: function(textNode) {
                        let parent = textNode.parentNode;
                        while (parent) {
                            const tagName = parent.tagName ? parent.tagName.toLowerCase() : '';
                            if (tagName === 'script' || tagName === 'style' || tagName === 'time') {
                                return NodeFilter.FILTER_REJECT;
                            }
                            parent = parent.parentNode;
                        }
                        return NodeFilter.FILTER_ACCEPT;
                    }
                },
                false

            );

            let currentNode;
            const textNodesToProcess = [];
            while (currentNode = walker.nextNode()) {
                textNodesToProcess.push(currentNode);
            }

            textNodesToProcess.forEach(textNode => {
                let text = textNode.nodeValue;
                // Replace specific named entities/characters with their numeric character references
                text = text.replace(/’/g, '&#8217;');     // literal ’
                text = text.replace(/&rsquo;/g, '&#8217;'); // &rsquo;
                text = text.replace(/“/g, '&#8220;');     // literal “
                text = text.replace(/&ldquo;/g, '&#8220;'); // &ldquo;
                text = text.replace(/”/g, '&#8221;');     // literal ”
                text = text.replace(/&rdquo;/g, '&#8221;'); // &rdquo;
                text = text.replace(/«/g, '&#171;');     // literal «
                text = text.replace(/&laquo;/g, '&#171;'); // &laquo;
                text = text.replace(/»/g, '&#187;');     // literal »
                text = text.replace(/&raquo;/g, '&#187;'); // &raquo;
                text = text.replace(/\u00A0/g, '&#160;'); // This converts literal NBSP char to numeric entity
                text = text.replace(/&nbsp;/g, '&#160;'); // This handles named NBSP entity to numeric

                textNode.nodeValue = text;
            });

            let processedHtml = tempDiv.innerHTML; // This re-serializes characters to entities

            // Final string-based replacements to ensure numeric entities are explicitly present
            // This is a safeguard against browser's innerHTML serialization re-converting entities.
            processedHtml = processedHtml.replace(/&nbsp;/g, '&#160;');
            processedHtml = processedHtml.replace(/&rsquo;/g, '&#8217;');
            processedHtml = processedHtml.replace(/&ldquo;/g, '&#8220;');
            processedHtml = processedHtml.replace(/&rdquo;/g, '&#8221;');
            processedHtml = processedHtml.replace(/&laquo;/g, '&#171;');
            processedHtml = processedHtml.replace(/&raquo;/g, '&#187;');

            // Handle double encoding if it occurs (e.g., &amp;#160; -> &#160;)
            processedHtml = processedHtml.replace(/&amp;#(\d+);/g, '&#$1;');

            return processedHtml;
        }

        // Array of all interactive buttons to control their disabled state
        const allInteractiveButtons = []; // Initialized here, populated later

        /**
         * Updates the disabled state of all interactive buttons.
         * Buttons are disabled if any button has 'data-temp-active' set to 'true'.
         */
        function updateAllInteractiveButtonStates() {
            const anyTempMessageActive = allInteractiveButtons.some(btn => btn.getAttribute('data-temp-active') === 'true');

            allInteractiveButtons.forEach(btn => {
                btn.disabled = btn.getAttribute('data-temp-active') === 'true' || (anyTempMessageActive && btn.getAttribute('data-temp-active') !== 'true');
            });
            // Specific handling for modal close button at the top right
            // Check if closeOptionsModalButton is defined before trying to access it
            if (typeof closeOptionsModalButton !== 'undefined' && closeOptionsModalButton) {
                closeOptionsModalButton.disabled = anyTempMessageActive;
            }
            if (typeof closeCustomizeModalButton !== 'undefined' && closeCustomizeModalButton) {
                closeCustomizeModalButton.disabled = anyTempMessageActive;
            }
        }

        /**
         * Displays a message in the message box with animation.
         * @param {string} message - The message to display.
         * @param {string} type - 'success', 'error', or 'info' for styling.
         */
        function showMessage(message, type) {
            // Clear any existing timeout to stop previous fade-out/reset sequence
            if (messageTimeoutId) {
                clearTimeout(messageTimeoutId);
                // Also remove the animation classes immediately if a new message comes in during an animation
                messageBox.classList.remove('message-box-fade-in', 'message-box-fade-out');
                // Ensure any pending animationend handler from previous message is removed
                messageBox.removeEventListener('animationend', messageBoxAnimationHandler);
                messageTimeoutId = null; // Clear the ID for safety
            }

            // Remove previous background/text colors and 'hidden' state
            messageBox.classList.remove('hidden', 'bg-green-700', 'bg-red-700', 'bg-blue-700');
            messageBox.classList.add('text-white'); // Ensure text is white for messages

            // Set content and add fade-in animation
            messageBox.textContent = message;
            messageBox.classList.add('message-box-fade-in');

            // Apply specific background color based on message type
            if (type === 'success') {
                messageBox.classList.add('bg-green-700');
            } else if (type === 'error') {
                messageBox.classList.add('bg-red-700');
            } else { // info
                messageBox.classList.add('bg-blue-700');
            }
            console.log(`Message shown: "${message}" (${type})`);

            // Use a named function for the animationend handler so it can be reliably removed
            // (Defined outside showMessage or as a global, or self-removing anonymous function)
            // For simplicity, let's make it an inner function that assigns itself to a global var if needed
            function messageBoxAnimationHandler() {
                // This handler runs when the fade-out animation completes
                messageBox.classList.remove('message-box-fade-out'); // Remove the fade-out class
                messageBox.removeEventListener('animationend', messageBoxAnimationHandler); // Remove itself

                // --- CRITICAL CHANGES HERE ---
                messageBox.textContent = 'No messages'; // Revert text
                messageBox.classList.remove('bg-green-700', 'bg-red-700', 'bg-blue-700', 'text-white'); // Remove message-specific colors
                messageBox.classList.add('bg-gray-400'); // Revert to default background
                console.log('Message box reset to "No messages".');
            }


            // Set timeout for message display duration
            messageTimeoutId = setTimeout(() => {
                messageBox.classList.remove('message-box-fade-in'); // Remove fade-in class
                messageBox.classList.add('message-box-fade-out'); // Start fade-out animation

                // Attach the animationend listener for when fade-out completes
                // This handler will perform the reset action
                messageBox.addEventListener('animationend', messageBoxAnimationHandler);

            }, 4500); // Duration before fade-out starts
        }

        /**
         * Opens the options modal.
         */
        function openOptionsModal() {
            optionsModalOverlay.classList.remove('hidden');
            initializeToggleSwitchesVisuals(optionsModalOverlay); // Initialize visuals when opening
        }

        /**
         * Closes the options modal.
         * Also sends a message to the customize preview iframe to reset cell states.
         */
        function closeOptionsModal() {
            optionsModalOverlay.classList.add('hidden');
        }

        /**
         * Closes the customize table modal.
         * Also sends a message to the customize preview iframe to reset cell states.
         */
        function closeCustomizeModal() {
            customizeModalOverlay.classList.add('hidden');
            if (customizePreviewIframe && customizePreviewIframe.contentWindow) {
                // Send a message to the iframe to reset its cell states
                customizePreviewIframe.contentWindow.postMessage({ type: 'resetCellStates' }, '*');
            }
        }

        /**
         * Function to handle button group clicks for alignment
         * @param {string} groupId - The ID of the button group container.
         * @param {string} alignmentVarName - The name of the global window variable to update.
         * @param {HTMLElement} [parentContainer=document] - The parent element to search for the group in (e.g., a modal).
         * @param {Function} [callback] - Optional callback function to execute after updating.
         */
        function setupButtonGroup(groupId, alignmentVarName, parentContainer = document, callback = null) {
            const group = parentContainer.querySelector('#' + groupId);
            if (!group) {
                console.warn(`Button group with ID "${groupId}" not found in parentContainer.`);
                return;
            }
            Array.from(group.children).forEach(button => {
                button.addEventListener('click', () => {
                    console.log(`Button "${button.dataset.align || button.dataset.mode}" clicked for group "${groupId}"`);
                    // Remove 'active' class from all buttons in this group
                    Array.from(group.children).forEach(btn => btn.classList.remove('active'));
                    // Add 'active' class to the clicked button
                    button.classList.add('active');

                    // If a global alignment variable name is provided, update it
                    if (alignmentVarName) {
                        window[alignmentVarName] = button.dataset.align;
                        console.log(`Global variable ${alignmentVarName} updated to: ${window[alignmentVarName]}`);
                    }
                    if (callback) {
                        callback();
                    }
                });
            });
        }

        /**
         * Applies an alignment class to an element, removing any conflicting alignment classes first.
         * If 'none' is selected, existing alignment classes are preserved.
         * @param {HTMLElement} element - The HTML element to apply alignment to.
         * @param {string} alignment - The alignment to apply ('left', 'center', 'right', or 'none').
         * @param {string[]} alignmentClasses - An array of all possible alignment classes.
         */
        function applyAlignment(element, alignment, alignmentClasses) {
			if (!element) {
				console.warn("Attempted to apply alignment to a null or undefined element.");
				return;
			}
			console.log(`Attempting to apply alignment "${alignment}" to element:`, element.tagName, element.textContent.trim().substring(0, 20) + '...');

			// If a specific alignment (left, center, right) is selected, remove all conflicting ones first
			alignmentClasses.forEach(cls => {
				if (element.classList.contains(cls)) {
					console.log(`  Removing conflicting class: ${cls}`);
					element.classList.remove(cls);
				}
			});

			if (alignment === 'none') {
				// If 'none' is selected, and after removing conflicting classes, check if class attribute is empty
				if (element.hasAttribute('class') && element.classList.length === 0) {
					element.removeAttribute('class');
					console.log('  Alignment is "none", and class attribute was empty, so it was removed.');
				} else {
					console.log('  Alignment is "none", no specific alignment class added, other classes preserved.');
				}
				return; // Exit as no new alignment class needs to be added
			}

			// Add the selected alignment class
			console.log(`  Adding new class: text-${alignment}`);
			element.classList.add(`text-${alignment}`);
			console.log('  Element classList after alignment:', Array.from(element.classList).join(' '));
		}
        /**
         * Calculates the effective number of columns in a given row, considering colspans.
         * @param {HTMLTableRowElement} row - The table row element.
         * @returns {number} The total number of columns spanned by cells in the row.
         */
        function getEffectiveColumnCount(row) {
            if (!row) return 0;
            let count = 0;
            Array.from(row.children).forEach(cell => {
                count += parseInt(cell.getAttribute('colspan') || '1', 10);
            });
            return count;
        }

        /**
         * Populates the table search dropdown with IDs and captions from tables in the editor.
         * It also stores the starting character index of each table in the Monaco editor content
         * for efficient jumping.
         */
        function populateTableSearchDropdown(keepSelectionValue) {
    if (!monacoEditor || !tableSearchDropdown) return;

    // Store the currently selected value if not provided
    const currentSelectedValue = keepSelectionValue !== undefined ? keepSelectionValue : tableSearchDropdown.value;

    const htmlContent = monacoEditor.getValue();
    const parser = new DOMParser();
    const doc = parser.parseFromString(htmlContent, 'text/html');
    const tables = Array.from(doc.querySelectorAll('table'));

    // Clear existing options and map
    tableSearchDropdown.innerHTML = '<option value="">-- Select a table --</option>';
    tableDataMap = new Map();

    let unidCounter = 1;
    tables.forEach((table, originalTableIndex) => {
        let tableId = table.id;
        let tableCaption = '';

        const captionElement = table.querySelector('caption');
        if (captionElement && captionElement.textContent.trim()) {
            tableCaption = captionElement.textContent.trim();
        }

        let optionValue;
        let startIndex = -1;

        if (tableId) {
            optionValue = `id:${tableId}`;
            const idRegex = new RegExp(`<table[^>]*id=["']${tableId}["'][^>]*>`, 'i');
            const idMatch = htmlContent.match(idRegex);
            if (idMatch) {
                startIndex = idMatch.index;
            }
        } else {
            optionValue = `unid:${unidCounter}`; // Unique ID for this dropdown option
            let tempHtml = htmlContent;
            let count = 0;
            let regex = /<table/gi;
            let match;
            while ((match = regex.exec(tempHtml)) !== null) {
                if (count === originalTableIndex) {
                    startIndex = match.index;
                    break;
                }
                count++;
            }
            unidCounter++;
        }

        if (startIndex !== -1) {
            const option = document.createElement('option');
            option.value = optionValue;
            option.textContent = `${tableCaption ? captionElement.textContent.trim() + ' ' : ''}${tableId ? '(ID: ' + tableId + ')' : '(Table ' + (originalTableIndex + 1) + ')'}`;
            tableSearchDropdown.appendChild(option);

            const tableOuterHtml = table.outerHTML;
            tableDataMap.set(optionValue, {
                startIndex: startIndex,
                outerHTML: tableOuterHtml,
                length: tableOuterHtml.length
            });
        } else {
            console.warn(`Could not find table "${tableId || ('Table ' + (originalTableIndex + 1))}" in editor content by regex.`);
        }
    });

    // --- NEW: Re-select the previously selected value ---
    if (currentSelectedValue) {
        // Check if the option still exists after re-population
        const optionExists = Array.from(tableSearchDropdown.options).some(
            option => option.value === currentSelectedValue
        );
        if (optionExists) {
            tableSearchDropdown.value = currentSelectedValue;
            // If the selected value is re-applied, and the modal is open, update preview
            if (!customizeModalOverlay.classList.contains('hidden') && customizeButton.disabled === false) {
                 // Check if customize button is not disabled to ensure it's an active interaction
                // and not just a background update.
                updateCustomizeModalPreview();
            }
        } else {
            // If the previously selected option no longer exists (e.g., table was removed),
            // reset to default and clear any highlights
            tableSearchDropdown.value = '';
            clearMonacoHighlight();
            updateCustomizeModalPreview(''); // Clear preview if table removed
        }
    } else {
        // If nothing was selected before, clear any highlights
        clearMonacoHighlight();
        updateCustomizeModalPreview(''); // Clear preview
    }
}

        /**
         * Contains the core logic for formatting a single HTML table.
         * This function is designed to be reusable by both universal and specific table formatting.
         * @param {HTMLElement} table - The table DOM element to format.
         * @param {object} options - An object containing all formatting options (checkbox states, alignment values).
         */
        function formatTableLogic(table, options) {
    console.log(`--- Applying formatting logic to table ---`);

    const financeRegex = /^\s*[-+]?(?:\d+|\d{1,3}(?:\s\d{3})*)(?:[.,]\d+)?\s*$/;
    const smallClass = 'small';
    const alignmentClasses = ['text-left', 'text-center', 'text-right'];

    // --- 1. Initial Cleanup: Remove all IDs, HEADERS, SCOPES, and all class attributes ---
    // Remove all classes initially to ensure a clean slate, especially alignment classes
    Array.from(table.querySelectorAll('*')).forEach(el => {
        el.removeAttribute('id');
        el.removeAttribute('headers');
        el.removeAttribute('scope');
        // Clear all classes at the very beginning to prevent inherited issues
        if (el.hasAttribute('class')) {
            el.removeAttribute('class');
            console.log(`Removed all class attributes from ${el.tagName} during initial cleanup.`);
        }
    });
    console.log('Removed empty class attributes from elements initially.');

    // --- 2. Apply Table-level ID and Classes ---
    if (options.specificTableId) {
        let customId = options.tableIdPrefix;
        if (customId && customId.trim() !== '') {
            table.id = customId.trim();
        } else {
            table.removeAttribute('id');
        }
    } else if (options.applyId) {
        let prefix = options.tableIdPrefix || 'tbl';
        if (options.isFigureTable) {
            prefix = options.figureDataIdPrefix || 'ftbl';
        }
        table.id = `${prefix}${options.assignedIdCounter}`;
    } else {
        table.removeAttribute('id');
    }

    let currentClasses = table.className.split(' ').filter(c => c.trim() !== '');
    const newClasses = new Set();
    const controlledUniversalClasses = ['table', 'table-bordered', 'table-striped', 'table-hover', 'table-condensed', smallClass];

    if (options.specificTableId) {
        currentClasses.forEach(cls => newClasses.add(cls));
    } else {
        currentClasses.filter(c => !controlledUniversalClasses.includes(c)).forEach(cls => newClasses.add(cls));
    }
    
    if (options.applyClassTables) {
        newClasses.add('table');
        newClasses.add('table-condensed');
    } else {
        newClasses.delete('table');
        newClasses.delete('table-condensed');
    }

    if (options.applyBordered) newClasses.add('table-bordered'); else newClasses.delete('table-bordered');
    if (options.applyStriped) newClasses.add('table-striped'); else newClasses.delete('table-striped');
    if (options.applyHover) newClasses.add('table-hover'); else newClasses.delete('table-hover');
    if (options.applyClassSmall) newClasses.add(smallClass); else newClasses.delete(smallClass);

    table.className = Array.from(newClasses).join(' ');
    if (table.hasAttribute('class') && table.classList.length === 0) {
        table.removeAttribute('class');
    }

    // --- 3. Handle Caption ---
    let existingCaptionElement = table.querySelector('caption');
    let existingCaptionContent = existingCaptionElement ? existingCaptionElement.innerHTML : '';
    let existingCaptionClasses = existingCaptionElement ? Array.from(existingCaptionElement.classList) : [];

    const shouldHaveCaption = options.applyCaption || options.applyAutoCaption;

    if (shouldHaveCaption) {
        if (!existingCaptionElement) {
            existingCaptionElement = document.createElement('caption');
            if (table.firstChild) table.insertBefore(existingCaptionElement, table.firstChild);
            else table.appendChild(existingCaptionElement);
        }
        
        if (existingCaptionClasses.length > 0) existingCaptionElement.className = existingCaptionClasses.join(' ');
        else existingCaptionElement.removeAttribute('class');
        
        applyAlignment(existingCaptionElement, options.currentCaptionAlignment, alignmentClasses);

        if (options.applyAutoCaption) {
            let extractedContent = '';
            if (options.specificTableId) {
                const firstRow = table.querySelector('tr');
                if (firstRow) {
                    const firstCell = firstRow.firstElementChild;
                    if (firstCell && (firstCell.tagName.toLowerCase() === 'th' || firstCell.tagName.toLowerCase() === 'td')) {
                        const colspan = parseInt(firstCell.getAttribute('colspan') || '1', 10);
                        const totalColumns = getEffectiveColumnCount(firstRow);
                        if (colspan === totalColumns && firstCell.textContent.trim() !== '') {
                            extractedContent = firstCell.textContent.trim();
                        }
                    }
                }
            } else {
                let prevSibling = (table.parentNode.classList.contains('table-responsive') ? table.parentNode : table).previousElementSibling;
                while (prevSibling) {
                    if (['P', 'H1', 'H2', 'H3', 'H4', 'H5', 'H6'].includes(prevSibling.tagName)) {
                        extractedContent = prevSibling.textContent.trim();
                        prevSibling.remove();
                        break;
                    }
                    if (prevSibling.nodeType === Node.TEXT_NODE && prevSibling.textContent.trim() !== '') break;
                    prevSibling = prevSibling.previousElementSibling;
                }
            }
            existingCaptionElement.textContent = extractedContent || `[insert table caption]`;
        } else if (!existingCaptionElement.textContent.trim() || existingCaptionElement.textContent.trim() === '[insert table caption]') {
            existingCaptionElement.textContent = existingCaptionContent || `[insert table caption]`;
        }
        if (existingCaptionElement.hasAttribute('class') && existingCaptionElement.classList.length === 0) {
            existingCaptionElement.removeAttribute('class');
        }
    } else {
        if (existingCaptionElement) existingCaptionElement.remove();
    }

    const currentCaption = table.querySelector('caption');
    if (currentCaption) {
        let currentNode = currentCaption.nextSibling;
        while (currentNode) {
            const next = currentNode.nextSibling;
            if (currentNode.nodeType === Node.TEXT_NODE && currentNode.nodeValue.trim() === '') {
                currentNode.parentNode.removeChild(currentNode);
            } else if (currentNode.nodeType === Node.ELEMENT_NODE && ['BR', 'P', 'DIV'].includes(currentNode.tagName.toUpperCase()) && currentNode.textContent.trim() === '') {
                currentNode.parentNode.removeChild(currentNode);
            } else if (currentNode.nodeType === Node.ELEMENT_NODE && ['THEAD', 'TBODY', 'TFOOT', 'COLGROUP'].includes(currentNode.tagName.toUpperCase())) {
                break;
            }
            currentNode = next;
        }
    }

    // --- 4. Reconstruct thead, tbody, tfoot (populate lists of rows, but don't append yet) ---
    table.querySelectorAll('thead, tbody, tfoot, colgroup').forEach(el => el.remove());

    const originalTableRows = Array.from(table.querySelectorAll('tr'));
    let headerRowCount = 0;
    if (options.applyHeader) {
        let maxRowSpanEnd = -1;
        for (let i = 0; i < originalTableRows.length; i++) {
            const currentRow = originalTableRows[i];
            headerRowCount = i + 1;
            const cellsInCurrentRow = Array.from(currentRow.querySelectorAll('th, td'));
            cellsInCurrentRow.forEach(cell => {
                const rowspan = parseInt(cell.getAttribute('rowspan') || '1', 10);
                maxRowSpanEnd = Math.max(maxRowSpanEnd, i + rowspan - 1);
            });
            if (i >= maxRowSpanEnd) {
                break;
            }
        }
    }

    const rowsForThead = [];
    const rowsForTbody = [];
    const rowsForTfoot = [];

    originalTableRows.forEach((row, index) => {
        if (index < headerRowCount) {
            const clonedRow = row.cloneNode(true);
            Array.from(clonedRow.querySelectorAll('td')).forEach(td => {
                const newTh = document.createElement('th');
                Array.from(td.attributes).forEach(attr => newTh.setAttribute(attr.name, attr.value));
                newTh.innerHTML = td.innerHTML;
                td.parentNode.replaceChild(newTh, td);
            });
            rowsForThead.push(clonedRow);
        } else {
            rowsForTbody.push(row);
        }
    });

    if (options.applyMakeTfootFromColspan && rowsForTbody.length > 0) {
        const lastRowInTbodyTemp = rowsForTbody[rowsForTbody.length - 1];
        let totalColumns = 0;
        const firstRowForColCount = rowsForThead.length > 0 ? rowsForThead[0] : (rowsForTbody.length > 0 ? rowsForTbody[0] : null);
        if(firstRowForColCount) totalColumns = getEffectiveColumnCount(firstRowForColCount);
        
        if (totalColumns > 0 && lastRowInTbodyTemp.cells.length === 1) {
            const singleCell = lastRowInTbodyTemp.firstElementChild;
            const colspan = parseInt(singleCell.getAttribute('colspan') || '1', 10);
            if (colspan >= totalColumns) {
                rowsForTfoot.push(rowsForTbody.pop());
            }
        }
    }

    const newTheadElement = document.createElement('thead');
    rowsForThead.forEach(row => newTheadElement.appendChild(row));

    const newTbodyElement = document.createElement('tbody');
    rowsForTbody.forEach(row => newTbodyElement.appendChild(row));

    const newTfootElement = document.createElement('tfoot');
    rowsForTfoot.forEach(row => newTfootElement.appendChild(row));


    // --- 5. Apply Row Header and its Alignment (only to newTbodyElement rows) ---
    Array.from(newTbodyElement.querySelectorAll('tr')).forEach(row => {
        const firstCell = row.firstElementChild;
        if (firstCell) {
            const existingClasses = Array.from(firstCell.classList).join(' ');
            if (options.applyRowHeader) {
                if (firstCell.tagName.toLowerCase() !== 'th') {
                    const newTh = document.createElement('th');
                    Array.from(firstCell.attributes).forEach(attr => { if (attr.name !== 'class') newTh.setAttribute(attr.name, attr.value); });
                    newTh.innerHTML = firstCell.innerHTML;
                    newTh.className = existingClasses;
                    row.replaceChild(newTh, firstCell);
                    applyAlignment(newTh, options.currentRowHeaderAlignment, alignmentClasses);
                } else {
                    applyAlignment(firstCell, options.currentRowHeaderAlignment, alignmentClasses);
                }
            } else {
                if (firstCell.tagName.toLowerCase() !== 'td') {
                    const newTd = document.createElement('td');
                    Array.from(firstCell.attributes).forEach(attr => { if (attr.name !== 'class') newTd.setAttribute(attr.name, attr.value); });
                    newTd.innerHTML = firstCell.innerHTML;
                    newTd.className = existingClasses;
                    row.replaceChild(newTd, firstCell);
                    applyAlignment(newTd, 'none', alignmentClasses);
                } else {
                    applyAlignment(firstCell, 'none', alignmentClasses);
                }
            }
            if (firstCell.hasAttribute('class') && firstCell.classList.length === 0) {
                firstCell.removeAttribute('class');
            }
        }
    });

    // --- 6. Apply Data Cells Alignment, Fix Empty Cells, Remove P Tags (ONLY to thead and tbody cells) ---
    // The previous implementation used separate loops for thead and tbody.
    // Let's combine them and add the explicit tfoot check at the beginning of the loop
    // to ensure NO td in tfoot gets processed for data cell alignment.
    
    // Process cells in thead
    Array.from(newTheadElement.querySelectorAll('th, td')).forEach(cell => {
        // --- NEW CRITICAL CHECK for TFOOT TD ---
        // This should not be strictly necessary for thead, but as a robust example
        // to show how we can completely skip if an element somehow gets here.
        if (cell.closest('tfoot') && cell.tagName.toLowerCase() === 'td') {
            console.log('Skipping TD in TFOOT (Thead loop).');
            return; // Skip this cell entirely
        }

        if (options.applyFixEmptyCells) {
            const containsNBSP = cell.innerHTML.includes('&nbsp;') || cell.innerHTML.includes('&#160;');
            if (cell.textContent.trim() === '' && !containsNBSP) {
                cell.innerHTML = '&#160;';
            }
        }
        if (options.applyRemovePTags) {
            Array.from(cell.querySelectorAll('p')).forEach(p => {
                while (p.firstChild) p.parentNode.insertBefore(p.firstChild, p);
                p.remove();
            });
        }
        
        if (cell.tagName.toLowerCase() === 'td') {
            if (options.applyFinanceTable && financeRegex.test(cell.textContent.trim())) {
                applyAlignment(cell, 'right', alignmentClasses);
                cell.classList.add('nowrap');
            }
        } else if (cell.tagName.toLowerCase() === 'th' && options.applyFinanceTable && financeRegex.test(cell.textContent.trim())) {
            applyAlignment(cell, 'right', alignmentClasses);
            cell.classList.add('nowrap');
        }

        if (cell.hasAttribute('class') && cell.classList.length === 0) {
            cell.removeAttribute('class');
        }
    });

    // Process cells in tbody
    Array.from(newTbodyElement.querySelectorAll('th, td')).forEach(cell => {
        // --- NEW CRITICAL CHECK for TFOOT TD ---
        // This is where the problematic TD might still be getting processed
        if (cell.closest('tfoot') && cell.tagName.toLowerCase() === 'td') {
            console.log('Skipping TD in TFOOT (Tbody loop).');
            // Explicitly remove any alignment classes that might have been applied by other means
            cell.classList.remove(...alignmentClasses);
            cell.classList.remove('nowrap');
            if (cell.hasAttribute('class') && cell.classList.length === 0) {
                cell.removeAttribute('class');
            }
            return; // Skip this cell entirely from further processing in this loop
        }

        if (options.applyFixEmptyCells) {
            const containsNBSP = cell.innerHTML.includes('&nbsp;') || cell.innerHTML.includes('&#160;');
            if (cell.textContent.trim() === '' && !containsNBSP) {
                cell.innerHTML = '&#160;';
            }
        }
        if (options.applyRemovePTags) {
            Array.from(cell.querySelectorAll('p')).forEach(p => {
                while (p.firstChild) p.parentNode.insertBefore(p.firstChild, p);
                p.remove();
            });
        }
        
        if (cell.tagName.toLowerCase() === 'td') {
            if (options.applyFinanceTable && financeRegex.test(cell.textContent.trim())) {
                applyAlignment(cell, 'right', alignmentClasses);
                cell.classList.add('nowrap');
            } else {
                applyAlignment(cell, options.currentDataCellsAlignment, alignmentClasses);
                cell.classList.remove('nowrap');
            }
        } else if (cell.tagName.toLowerCase() === 'th' && options.applyFinanceTable && financeRegex.test(cell.textContent.trim())) {
            applyAlignment(cell, 'right', alignmentClasses);
            cell.classList.add('nowrap');
        }
        
        if (cell.hasAttribute('class') && cell.classList.length === 0) {
            cell.removeAttribute('class');
        }
    });

    // --- 7. Apply Bold Totals (only to newTbodyElement rows) ---
    Array.from(newTbodyElement.querySelectorAll('tr')).forEach(row => {
        const thInRow = row.querySelector('th');
        let isTotalRow = thInRow && (thInRow.textContent.trim().toLowerCase() === 'total' || thInRow.textContent.trim().toLowerCase() === 'subtotal');
        Array.from(row.querySelectorAll('td')).forEach(td => {
            if (options.applyBoldTotals && isTotalRow) {
                if (!td.querySelector('strong')) {
                    td.innerHTML = `<strong>${td.innerHTML}</strong>`;
                }
            } else {
                if (td.querySelector('strong')) {
                    td.innerHTML = td.querySelector('strong').innerHTML;
                }
            }
        });
        if (row.hasAttribute('class') && row.classList.length === 0) {
            row.removeAttribute('class');
        }
    });

    // --- 8. Append the structural elements to the table ---
    if (newTheadElement.children.length > 0) table.appendChild(newTheadElement);
    if (newTbodyElement.children.length > 0) table.appendChild(newTbodyElement);
    if (newTfootElement.children.length > 0) table.appendChild(newTfootElement);

    // --- 9. Apply Small Class to TRs ---
    if (options.applyAddSmallToTr) {
        Array.from(table.querySelectorAll('tr')).forEach(tr => tr.classList.add(smallClass));
    } else {
        Array.from(table.querySelectorAll('tr')).forEach(tr => tr.classList.remove(smallClass));
    }

    // --- 10. Apply Active Classes and Header Alignments ---
    Array.from(table.querySelectorAll('thead tr')).forEach(tr => tr.classList.remove('active'));
    if (options.applyActiveColHeaders) {
        Array.from(newTheadElement.querySelectorAll('tr')).forEach(tr => tr.classList.add('active'));
    }

    if (options.activeColspanHeadersCheckboxValue) {
        Array.from(newTbodyElement.querySelectorAll('th[colspan]')).forEach(th => th.classList.add('active'));
    }
    if (options.activeRowHeadersCheckboxValue) {
        Array.from(newTbodyElement.querySelectorAll('tr > th:first-child')).forEach(th => th.classList.add('active'));
    }

    Array.from(newTheadElement.querySelectorAll('th')).forEach(th => {
        applyAlignment(th, options.currentColHeaderAlignment, alignmentClasses);
        if (th.hasAttribute('class') && th.classList.length === 0) {
            th.removeAttribute('class');
        }
    });
    Array.from(newTbodyElement.querySelectorAll('th[colspan]')).forEach(th => {
        applyAlignment(th, options.currentColspanHeaderAlignment, alignmentClasses);
        if (th.hasAttribute('class') && th.classList.length === 0) {
            th.removeAttribute('class');
        }
    });
    if (options.applyRowHeader && newTheadElement.rows.length > 0 && newTheadElement.rows[0].cells.length > 0) {
         applyAlignment(newTheadElement.rows[0].cells[0], options.currentRowHeaderAlignment, alignmentClasses);
         if (newTheadElement.rows[0].cells[0].hasAttribute('class') && newTheadElement.rows[0].cells[0].classList.length === 0) {
            newTheadElement.rows[0].cells[0].removeAttribute('class');
         }
    }

    // --- NEW MOST AGGRESSIVE FINAL TFOOT TD CLEANUP ---
    // This targets ONLY TDs within tfoot elements and removes all alignment classes.
    // This is the last possible place for this class to be removed.
    Array.from(table.querySelectorAll('tfoot td')).forEach(td => {
        console.log(`Final AGGRESSIVE TFOOT TD cleanup: Cleaning cell with content: "${td.textContent.trim()}"`);
        td.classList.remove(...alignmentClasses); // Explicitly remove all alignment classes
        td.classList.remove('nowrap'); // Explicitly remove nowrap
        if (td.hasAttribute('class') && td.classList.length === 0) {
            td.removeAttribute('class');
            console.log(`Removed empty class attribute from tfoot td.`);
        }
    });

    // --- 11. FINAL GENERAL CLASS CLEANUP: Remove any remaining empty class attributes ---
    Array.from(table.querySelectorAll('*')).forEach(el => {
        if (el.hasAttribute('class') && el.classList.length === 0) {
            el.removeAttribute('class');
            console.log(`Final overall cleanup: Removed empty class attribute from ${el.tagName}.`);
        }
    });

    return table;
}


        /**
         * Formats all HTML tables in the editor based on universal options.
         */
        function formatHtmlTables() {
            closeOptionsModal();
            if (!monacoEditor) { showMessage('Editor is still loading, please hold on.', 'info'); return; }
            const htmlText = getEditorContent();
            if (!htmlText.trim()) { showMessage('No HTML content to format.', 'info'); return; }

            formatButton.textContent = 'Formatting...';
            formatButton.setAttribute('data-temp-active', 'true');
            updateAllInteractiveButtonStates();

            try {
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = htmlText;
                const tables = tempDiv.querySelectorAll('table');
                if (tables.length === 0) { showMessage('No HTML tables found to format.', 'info'); return; }

                let tblCounter = 1;
                let ftblCounter = 1;

                tables.forEach(table => {
                    const isFigureTable = table.closest('figure') !== null;
                    const options = {
                        applyId: idCheckbox.checked,
                        tableIdPrefix: pageIdPrefixInput.value.trim(),
                        figureDataIdPrefix: figureDataIdPrefixInput.value.trim(),
                        applyClassTables: classTablesCheckbox.checked,
                        applyCaption: captionCheckbox.checked,
                        applyAutoCaption: autoCaptionCheckbox.checked,
                        applyFixEmptyCells: fixEmptyCellsCheckbox.checked,
                        applyRemovePTags: removePTagsCheckbox.checked,
                        applyMakeTfootFromColspan: makeTfootFromColspanCheckbox.checked,
                        applyAddSmallToTr: addSmallToTrCheckbox.checked,
                        applyHeader: headerCheckbox.checked,
                        applyRowHeader: rowHeaderCheckbox.checked,
                        applyBordered: borderedCheckbox.checked,
                        applyStriped: stripedCheckbox.checked,
                        applyHover: hoverCheckbox.checked,
                        applyActiveColHeaders: activeColHeadersCheckbox.checked,
                        activeColspanHeadersCheckboxValue: activeColspanHeadersCheckbox.checked,
                        activeRowHeadersCheckboxValue: activeRowHeadersCheckbox.checked,
                        applyClassSmall: classSmallCheckboxElement.checked,
                        applyFinanceTable: financeTableCheckbox.checked,
                        applyBoldTotals: boldTotalsCheckbox.checked,
                        currentCaptionAlignment: window.captionAlignment,
                        currentColHeaderAlignment: window.colHeaderAlignment,
                        currentRowHeaderAlignment: window.rowHeaderAlignment,
                        currentColspanHeaderAlignment: window.colspanHeaderAlignment,
                        currentDataCellsAlignment: window.dataCellsAlignment,
                        assignedIdCounter: isFigureTable ? ftblCounter++ : tblCounter++,
                        isFigureTable: isFigureTable,
                        specificTableId: false
                    };
                    formatTableLogic(table, options);
                });

                let formattedContent = tempDiv.innerHTML;
                formattedContent = protectDataAttributes(formattedContent);
                formattedContent = html_beautify(formattedContent, { indent_size: 4, space_in_paren: true });
                formattedContent = restoreDataAttributes(formattedContent);
                formattedContent = convertAllEntitiesToNumeric(formattedContent);
                setEditorContent(formattedContent);
                const prevSelectedTable = tableSearchDropdown.value; // Capture BEFORE update
    applyEntityHighlighting();
    populateTableSearchDropdown(prevSelectedTable); // Pass it here!

            } catch (e) {
                console.error("Error formatting HTML tables:", e);
                showMessage('An error occurred during formatting.', 'error');
            } finally {
                setTimeout(() => {
        formatButton.textContent = 'Format Tables';
        formatButton.removeAttribute('data-temp-active');
        updateAllInteractiveButtonStates();
        showMessage('HTML tables formatted successfully!', 'success');
    }, 1500);
            }
        }
		
// --- Refined autoScopeTableIDs Function (Handling empty A1 cell) ---
function autoScopeTableIDs(tableElement, tableIndex, forceComplexity = undefined) {
    if (!tableElement || tableElement.tagName !== 'TABLE') {
        console.error("Invalid input: autoScopeTableIDs requires a TABLE element.");
        return "";
    }

    let tableBaseId = tableElement.id;
    if (!tableBaseId) {
        tableBaseId = `t${tableIndex + 1}`;
        tableElement.id = tableBaseId;
    }

    let a1Cell = null;
    const firstRow = tableElement.rows[0];
    if (firstRow && firstRow.cells.length > 0) {
        a1Cell = firstRow.cells[0];
    }
    const isA1Empty = a1Cell && a1Cell.textContent.trim() === '';

    Array.from(tableElement.querySelectorAll('thead th, thead td, tbody th, tbody td')).forEach(cell => {
        cell.removeAttribute('id');
        cell.removeAttribute('headers');
        cell.removeAttribute('scope');
        if (cell === a1Cell && isA1Empty) {
            cell.innerHTML = '&#160;';
        }
    });

    const firstRowForColCount = tableElement.querySelector('tr');
    const totalColumns = firstRowForColCount ? getEffectiveColumnCount(firstRowForColCount) : 0;

    let isComplexTable;
    if (forceComplexity === 'simple') {
        isComplexTable = false;
    } else if (forceComplexity === 'complex') {
        isComplexTable = true;
    } else {
        const tbodyCells = Array.from(tableElement.querySelectorAll('tbody th, tbody td'));
        isComplexTable = tbodyCells.some(cell => cell.hasAttribute('rowspan') || cell.hasAttribute('colspan'));
    }

    if (!isComplexTable) {
        Array.from(tableElement.querySelectorAll('thead th, tbody th')).forEach(th => {
            if (th === a1Cell && isA1Empty) return;

            const parentSection = th.closest('thead, tbody');
            if (parentSection && parentSection.tagName === 'THEAD') {
                th.setAttribute('scope', th.hasAttribute('colspan') ? 'colgroup' : 'col');
            } else if (parentSection && parentSection.tagName === 'TBODY') {
                if (th.hasAttribute('rowspan')) {
                    th.setAttribute('scope', 'rowgroup');
                } else if (th.hasAttribute('colspan')) {
                    const colspanVal = parseInt(th.getAttribute('colspan') || '1', 10);
                    th.setAttribute('scope', (totalColumns > 0 && colspanVal >= totalColumns) ? 'colgroup' : 'row');
                } else {
                    th.setAttribute('scope', 'row');
                }
            }
        });
    } else {
        let colHeaderCounter = 0, colSpanHeaderCounter = 0, rowHeaderCounter = 0;
        let rowSpanHeaderCounter = 0, rowColSpanHeaderCounter = 0, headerIdCounter = 0;

        Array.from(tableElement.querySelectorAll('thead th, tbody th')).forEach(cell => {
            if (cell === a1Cell && isA1Empty) return;
            
            const parentSection = cell.closest('thead, tbody');
            let idPrefix = `${tableBaseId}-`;
            let counter;

            if (parentSection && parentSection.tagName === 'THEAD') {
                if (cell.hasAttribute('colspan')) {
                    idPrefix += 'csh-'; counter = colSpanHeaderCounter++;
                } else {
                    idPrefix += 'ch-'; counter = colHeaderCounter++;
                }
            } else if (parentSection && parentSection.tagName === 'TBODY') {
                if (cell.hasAttribute('colspan')) {
                    const colspanVal = parseInt(cell.getAttribute('colspan') || '1', 10);
                    if (totalColumns > 0 && colspanVal >= totalColumns) {
                        idPrefix += 'rcsh-'; counter = rowColSpanHeaderCounter++;
                    } else {
                        idPrefix += 'rh-'; counter = rowHeaderCounter++;
                    }
                } else if (cell.hasAttribute('rowspan')) {
                    idPrefix += 'rsh-'; counter = rowSpanHeaderCounter++;
                } else {
                    idPrefix += 'rh-'; counter = rowHeaderCounter++;
                }
            } else {
                idPrefix += 'th-'; counter = headerIdCounter++;
            }
            cell.id = `${idPrefix}${counter}`;
        });

        const rows = Array.from(tableElement.rows);
        const grid = [];
        const theadHeaders = Array(totalColumns).fill(null);

        rows.forEach((row, rowIndex) => {
            let currentCol = 0;
            Array.from(row.cells).forEach(cell => {
                const parentSection = cell.closest('thead, tbody, tfoot');
                if (parentSection && parentSection.tagName === 'TFOOT') return;

                while (grid[rowIndex] && grid[rowIndex][currentCol]) {
                    currentCol++;
                }
                if (!grid[rowIndex]) grid[rowIndex] = [];

                const colspan = parseInt(cell.getAttribute('colspan') || '1', 10);
                const rowspan = parseInt(cell.getAttribute('rowspan') || '1', 10);

                if (parentSection && parentSection.tagName === 'THEAD' && cell.tagName === 'TH') {
                    for (let c = 0; c < colspan; c++) {
                        theadHeaders[currentCol + c] = cell;
                    }
                }

                for (let r = 0; r < rowspan; r++) {
                    if (!grid[rowIndex + r]) grid[rowIndex + r] = [];
                    for (let c = 0; c < colspan; c++) {
                        grid[rowIndex + r][currentCol + c] = cell;
                    }
                }
                currentCol += colspan;
            });
        });

        rows.forEach((row, rowIndex) => {
            const parentSection = row.closest('thead, tbody, tfoot');
            if (!parentSection || parentSection.tagName !== 'TBODY') return;

            let rowHeadersInThisRow = [];
            let latestFullColspan = null;

            for (let r = rowIndex - 1; r >= 0; r--) {
                const cellInColumnZero = grid[r] ? grid[r][0] : null;
                if (cellInColumnZero && cellInColumnZero.tagName === 'TH' && parseInt(cellInColumnZero.getAttribute('colspan') || '1', 10) >= totalColumns) {
                    latestFullColspan = cellInColumnZero;
                    break;
                }
            }
            
            Array.from(row.cells).forEach(cell => {
                if (cell.tagName === 'TH') {
                    rowHeadersInThisRow.push(cell);
                }
            });

            Array.from(row.cells).forEach((cell) => {
                const isFullWidthColspanTH = cell.tagName === 'TH' &&
                                             cell.hasAttribute('colspan') &&
                                             parseInt(cell.getAttribute('colspan') || '1', 10) >= totalColumns;

                if (isFullWidthColspanTH) {
                    cell.removeAttribute('headers');
                    return; 
                }

                const headersToApply = new Set();

                if (latestFullColspan) {
                    headersToApply.add(latestFullColspan.id);
                }
                
                let cellColIndex = -1;
                for (let c = 0; c < (grid[rowIndex]?.length || 0); c++) {
                    if (grid[rowIndex][c] === cell) {
                        cellColIndex = c;
                        break;
                    }
                }
                if (cellColIndex !== -1 && theadHeaders[cellColIndex] && theadHeaders[cellColIndex].id) {
                    headersToApply.add(theadHeaders[cellColIndex].id);
                }

                rowHeadersInThisRow.forEach(rh => {
                    if (rh !== cell) {
                        headersToApply.add(rh.id);
                    }
                });

                if (headersToApply.size > 0) {
                    cell.setAttribute('headers', Array.from(headersToApply).join(' '));
                } else {
                    cell.removeAttribute('headers');
                }
            });
        });
    }

    Array.from(tableElement.querySelectorAll('*')).forEach(el => {
        if (el.hasAttribute('class') && el.classList.length === 0) {
            el.removeAttribute('class');
        }
    });

    return tableElement.outerHTML;
}

function cleanEmptyHeadersAttribute(htmlString) {
    // Use a regular expression to find headers="" or headers='' (case-insensitive for attribute name)
    // and replace them with an empty string.
    // This targets attributes with no content between the quotes.
    const cleanedHtml = htmlString.replace(/\sheaders=["']{2}/gi, '');
    return cleanedHtml;
}
        /**
         * Gathers options from the customize modal and formats the selected table in memory.
         * @returns {string} The HTML string of the formatted table.
         */
        function generatePreviewTableHtml() {
            const selectedValue = tableSearchDropdown.value;
            const tableInfo = tableDataMap.get(selectedValue);
            if (!tableInfo) return '';

            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = tableInfo.outerHTML;
            const clonedTable = tempDiv.querySelector('table');
            if (!clonedTable) { console.error("Failed to clone table for preview."); return ''; }

            const customId = customizePageIdPrefixInput.value.trim();
            if (customId) clonedTable.id = customId;
            else clonedTable.removeAttribute('id');

            const customizeOptions = {
                tableIdPrefix: customId,
                applyClassTables: customizeClassTablesCheckbox.checked,
                applyCaption: customizeCaptionCheckbox.checked,
                applyFixEmptyCells: customizeFixEmptyCellsCheckbox.checked,
                applyRemovePTags: customizeRemovePTagsCheckbox.checked,
                applyMakeTfootFromColspan: customizeMakeTfootFromColspanCheckbox.checked,
                applyAddSmallToTr: customizeAddSmallToTrCheckbox.checked,
                applyHeader: customizeHeaderCheckbox.checked,
                applyRowHeader: customizeRowHeaderCheckbox.checked,
                applyBordered: customizeBorderedCheckbox.checked,
                applyStriped: customizeStripedCheckbox.checked,
                applyHover: customizeHoverCheckbox.checked,
                applyActiveColHeaders: customizeActiveColHeadersCheckbox.checked,
                activeColspanHeadersCheckboxValue: customizeActiveColspanHeadersCheckbox.checked,
                activeRowHeadersCheckboxValue: customizeActiveRowHeadersCheckbox.checked,
                applyClassSmall: customizeClassSmallCheckboxElement.checked,
                applyFinanceTable: customizeFinanceTableCheckbox.checked,
                applyBoldTotals: customizeBoldTotalsCheckbox.checked,
                currentCaptionAlignment: window.customizeCaptionAlignment,
                currentColHeaderAlignment: window.customizeColHeaderAlignment,
                currentRowHeaderAlignment: window.customizeRowHeaderAlignment,
                currentColspanHeaderAlignment: window.customizeColspanHeaderAlignment,
                currentDataCellsAlignment: window.customizeDataCellsAlignment,
                specificTableId: selectedValue,
            };

            const formattedTableElement = formatTableLogic(clonedTable, customizeOptions);
            let formattedTableOuterHTML = formattedTableElement.outerHTML;
            formattedTableOuterHTML = protectDataAttributes(formattedTableOuterHTML);
            formattedTableOuterHTML = html_beautify(formattedTableOuterHTML, { indent_size: 4, space_in_paren: true });
            formattedTableOuterHTML = restoreDataAttributes(formattedTableOuterHTML);
            formattedTableOuterHTML = convertAllEntitiesToNumeric(formattedTableOuterHTML);

            return formattedTableOuterHTML;
        }

        /**
         * Updates the customize modal's preview iframe based on current option selections.
         * @param {string} [htmlContentToPreview] - Optional. If provided, this HTML is used for the iframe.
         * Otherwise, generatePreviewTableHtml() is called to create the HTML.
         */
        function updateCustomizeModalPreview(htmlContentToPreview) {
            if (htmlContentToPreview === undefined) {
                htmlContentToPreview = generatePreviewTableHtml();
            }
            updateCustomizePreview(htmlContentToPreview);
        }

        /**
         * Updates the content of the customize preview iframe.
         * This now also injects the necessary JavaScript for cell editing and highlighting.
         * @param {string} tableHtmlString - The HTML string of the table to display in the iframe.
         */
        function updateCustomizePreview(tableHtmlString) {
            if (!customizePreviewIframe) {
                console.warn("Customize preview iframe not found.");
                return;
            }

            const iframeDoc = customizePreviewIframe.contentDocument || customizePreviewIframe.contentWindow.document;

            const baseHtml = `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Table Preview</title>
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.4/css/all.css">
    <link rel="stylesheet" href="https://www.canada.ca/etc/designs/canada/wet-boew/css/theme.min.css">
    <link rel="stylesheet" href="https://cdn.design-system.alpha.canada.ca/@cdssnc/gcds-components@latest/dist/gcds/gcds.css">
    <style>
        td.highlighted-cell, th.highlighted-cell, caption.highlighted-cell {
            background-color: #add8e6 !important; /* Light blue highlight, use !important to override theme styles */
            border: 2px solid #3b82f6;
        }
        /* New styles for row/column highlights */
        .highlighted-row {
            background-color: #cceeff !important; /* Lighter blue for row highlight */
        }
        .highlighted-column {
            background-color: #e6f7ff !important; /* Even lighter blue for column highlight */
        }
    </style>
</head>
<body><main property="mainContentOfPage" resource="#wb-main" typeof="WebPageElement">
    <div class="container"><div class="table-responsive">
            ${tableHtmlString}
    </div></div></main>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.2.4/jquery.min.js"><\/script>
    <script src="https://www.canada.ca/etc/designs/canada/wet-boew/js/wet-boew.min.js"><\/script>
    <script src="https://www.canada.ca/etc/designs/canada/wet-boew/js/theme.min.js"><\/script>
    <script>
        // JavaScript to be injected into the iframe
        document.addEventListener('DOMContentLoaded', () => {
            // Removed: let currentMode = 'select'; // Default mode
            const table = document.querySelector('table');
            if (!table) return;

            // Filter out cells that are descendants of tfoot
            const allCells = Array.from(table.querySelectorAll('th, td, caption')).filter(cell => !cell.closest('tfoot'));

            function clearAllHighlights() {
                document.querySelectorAll('.highlighted-cell').forEach(hCell => hCell.classList.remove('highlighted-cell'));
                document.querySelectorAll('.highlighted-row').forEach(hRow => hRow.classList.remove('highlighted-row'));
                document.querySelectorAll('.highlighted-column').forEach(hCol => hCol.classList.remove('highlighted-column'));
            }

            // Removed: function updateCellBehavior() { ... }

            // Helper to get all cells in a specific visual column index (accounting for colspans/rowspans)
            function getCellsInVisualColumn(table, targetVisualColIndex) {
                const columnCells = new Set(); // Use a Set to avoid duplicates
                const rows = Array.from(table.rows);
                
                // grid will store the visual layout of cells,
                // grid[rowIndex][visualColIndex] = cellElement
                const grid = []; 

                rows.forEach((row, rowIndex) => {
                    // Skip rows that are part of tfoot
                    if (row.closest('tfoot')) {
                        return;
                    }

                    let currentVisualCol = 0;
                    grid[rowIndex] = grid[rowIndex] || [];

                    Array.from(row.cells).forEach(cell => {
                        // Move currentVisualCol past any cells from previous rows that span into this position
                        while (grid[rowIndex][currentVisualCol]) {
                            currentVisualCol++;
                        }

                        const colspan = parseInt(cell.getAttribute('colspan') || '1', 10);
                        const rowspan = parseInt(cell.getAttribute('rowspan') || '1', 10);

                        // If this cell starts at or covers the target visual column index
                        if (currentVisualCol <= targetVisualColIndex && targetVisualColIndex < currentVisualCol + colspan) {
                            columnCells.add(cell);
                        }

                        // Mark this cell's space in the grid for its rowspan and colspan
                        for (let r = 0; r < rowspan; r++) {
                            for (let c = 0; c < colspan; c++) {
                                if (!grid[rowIndex + r]) {
                                    grid[rowIndex + r] = [];
                                }
                                grid[rowIndex + r][currentVisualCol + c] = cell; // Store reference to the cell
                            }
                        }
                        currentVisualCol += colspan;
                    });
                });
                return Array.from(columnCells);
            }

            // Handle clicks on cells (simplified as there's no mode toggle)
            allCells.forEach(cell => {
                cell.addEventListener('click', function(event) {
                    event.stopPropagation(); // Prevent event from bubbling to document
                    clearAllHighlights(); // Clear all existing highlights

                    const row = this.closest('tr');
                    const table = this.closest('table');

                    // Do not select cells within tfoot or if their containing row is tfoot
                    if (this.closest('tfoot')) {
                        return;
                    }

                    if ((event.ctrlKey || event.metaKey) && event.shiftKey) { // Ctrl/Cmd + Shift + Click: Select WHOLE COLUMN
                        // Determine the visual column index of the clicked cell
                        let clickedCellVisualColIndex = -1;
                        let grid = [];
                        Array.from(table.rows).forEach((r, rIndex) => {
                            grid[rIndex] = grid[rIndex] || [];
                            let cIndex = 0;
                            Array.from(r.cells).forEach(c => {
                                while(grid[rIndex][cIndex]) cIndex++;
                                const colspan = parseInt(c.getAttribute('colspan') || '1', 10);
                                const rowspan = parseInt(c.getAttribute('rowspan') || '1', 10);
                                if (c === this) clickedCellVisualColIndex = cIndex;
                                for(let rs = 0; rs < rowspan; rs++) {
                                    for (let cs = 0; cs < colspan; cs++) {
                                        if(!grid[rIndex+rs]) grid[rIndex+rs] = [];
                                        grid[rIndex+rs][cIndex+cs] = c;
                                    }
                                }
                                cIndex += colspan;
                            });
                        });
                        
                        if(clickedCellVisualColIndex !== -1) {
                            const cellsInColumn = getCellsInVisualColumn(table, clickedCellVisualColIndex);
                            cellsInColumn.forEach(c => c.classList.add('highlighted-column', 'highlighted-cell'));
                        }

                    } else if (event.shiftKey) { // Shift + Click: Select WHOLE ROW
                        if(row) {
                            row.classList.add('highlighted-row');
                            Array.from(row.cells).forEach(c => c.classList.add('highlighted-cell'));
                        }
                    } else if (this.tagName.toLowerCase() === 'th' && row) { // Original header selection logic for THs (if no modifiers)
                        if (row.parentNode.tagName.toLowerCase() === 'tbody' && row.firstElementChild === this) {
                            row.classList.add('highlighted-row');
                            Array.from(row.cells).forEach(c => c.classList.add('highlighted-cell'));
                        } 
                        else if (row.parentNode.tagName.toLowerCase() === 'thead') {
                            let clickedCellVisualColIndex = -1;
                            let grid = [];
                             Array.from(table.rows).forEach((r, rIndex) => {
                                grid[rIndex] = grid[rIndex] || [];
                                let cIndex = 0;
                                Array.from(r.cells).forEach(c => {
                                    while(grid[rIndex][cIndex]) cIndex++;
                                    const colspan = parseInt(c.getAttribute('colspan') || '1', 10);
                                    const rowspan = parseInt(c.getAttribute('rowspan') || '1', 10);
                                    if (c === this) clickedCellVisualColIndex = cIndex;
                                    for(let rs = 0; rs < rowspan; rs++) {
                                        for (let cs = 0; cs < colspan; cs++) {
                                            if(!grid[rIndex+rs]) grid[rIndex+rs] = [];
                                            grid[rIndex+rs][cIndex+cs] = c;
                                        }
                                    }
                                    cIndex += colspan;
                                });
                            });
                            if(clickedCellVisualColIndex !== -1) {
                                const cellsInColumn = getCellsInVisualColumn(table, clickedCellVisualColIndex);
                                cellsInColumn.forEach(c => c.classList.add('highlighted-column', 'highlighted-cell'));
                            }
                        }
                        else { 
                            this.classList.add('highlighted-cell');
                        }
                    } else { 
                        this.classList.add('highlighted-cell');
                    }
                });
            });

            // Clear highlight when clicking anywhere outside a cell
            document.body.addEventListener('click', function() {
                clearAllHighlights();
            });

            // Listen for messages from the parent
            window.addEventListener('message', (event) => {
                if (event.data && event.data.type === 'updateTableId' && table) {
                    const newId = event.data.newId;
                    if (newId) {
                        table.id = newId;
                    } else {
                        table.removeAttribute('id');
                    }
                } else if (event.data && event.data.type === 'resetCellStates') {
                    clearAllHighlights(); // Clear all highlights on reset
                }
            });


             // Notify parent that iframe is ready to receive mode
            window.parent.postMessage({ type: 'iframeReady' }, '*');
        });
    <\/script>
</body>
</html>`;

            iframeDoc.open();
            iframeDoc.write(baseHtml); 
            iframeDoc.close();
        }


        /**
         * Formats a specific HTML table in the editor based on options from the customize modal.
         */
        async function formatSpecificTable() {
            closeCustomizeModal(); // Close the customize modal

            const selectedValue = tableSearchDropdown.value;
            if (!selectedValue) {
                showMessage('No table selected for customization.', 'info');
                return;
            }

            const tableInfo = tableDataMap.get(selectedValue);
            if (!tableInfo || tableInfo.startIndex === -1) {
                showMessage('Selected table not found in editor content.', 'error');
                return;
            }

            const currentEditorContent = getEditorContent();

            // Perform the formatting on a *copy* of the table HTML
            const formattedTableOuterHTML = generatePreviewTableHtml(); // Re-use logic for consistency

            // Replace the original table's content in the full editor content
            const newEditorContent = currentEditorContent.substring(0, tableInfo.startIndex) +
                                     formattedTableOuterHTML +
                                     currentEditorContent.substring(tableInfo.startIndex + tableInfo.length);

            setEditorContent(newEditorContent);
            applyEntityHighlighting();
            populateTableSearchDropdown(); // Re-populate dropdown as content/IDs might have changed

            // Temporarily disable buttons and show feedback
            formatSpecificTableButton.textContent = 'Formatting...';
            formatSpecificTableButton.classList.add('bg-green-500', 'hover:bg-green-600');
            formatSpecificTableButton.classList.remove('bg-blue-700', 'hover:bg-blue-800');
            formatSpecificTableButton.setAttribute('data-temp-active', 'true');
            updateAllInteractiveButtonStates();

            setTimeout(() => {
                formatSpecificTableButton.textContent = 'Format Table';
                formatSpecificTableButton.classList.remove('bg-green-500', 'hover:bg-green-600');
                formatSpecificTableButton.classList.add('bg-blue-700', 'hover:bg-blue-800');
                formatSpecificTableButton.removeAttribute('data-temp-active');
                updateAllInteractiveButtonStates();
                showMessage('Selected table customized successfully!', 'success'); // Show success message
            }, 1500);
        }

        /**
         * Resets universal formatting for all tables in the editor.
         */
        function resetUniversalFormatting() {
            if (!monacoEditor) { showMessage('Editor is not ready.', 'info'); return; }

            const editorContent = getEditorContent();
            if (!editorContent.trim()) { showMessage('Nothing to reset.', 'info'); return; }

            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = editorContent;

            const tables = tempDiv.querySelectorAll('table');
            if (tables.length === 0) {
                showMessage('No tables found to reset.', 'info');
                return;
            }

            const classesToRemove = ['table', 'table-bordered', 'table-striped', 'table-hover', 'table-condensed', 'small', 'text-left', 'text-center', 'text-right', 'nowrap']; // Added text-align classes and nowrap
    const alignmentClasses = ['text-left', 'text-center', 'text-right']; // Still needed for specific alignment handling

    tables.forEach(table => {
        table.removeAttribute('id');
        table.classList.remove(...classesToRemove);

        table.querySelectorAll('tr, th, td, caption').forEach(el => {
            el.classList.remove('active', ...alignmentClasses);
            if (el.tagName === 'TR') {
                el.classList.remove('small');
            }
            // Add removal of 'nowrap' for individual cells
            if (el.tagName === 'TD' || el.tagName === 'TH') {
                el.classList.remove('nowrap');
            }
        });
    });
            
            // Clean up any empty class attributes left behind
            tempDiv.querySelectorAll('*').forEach(el => {
                if (el.hasAttribute('class') && el.classList.length === 0) {
                    el.removeAttribute('class');
                }
            });

            let finalHtml = tempDiv.innerHTML;
            finalHtml = html_beautify(finalHtml, { indent_size: 4, space_in_paren: true });
            setEditorContent(finalHtml);
            applyEntityHighlighting();
            populateTableSearchDropdown();
            showMessage('Universal formatting has been reset.', 'success');
        }

        /**
         * Resets responsive wrappers from all tables.
         */
        function resetResponsiveWrappers() {
            if (!monacoEditor) { showMessage('Editor is not ready.', 'info'); return; }
            const editorContent = getEditorContent();
            if (!editorContent.trim()) { showMessage('Nothing to reset.', 'info'); return; }

            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = editorContent;

            const responsiveDivs = tempDiv.querySelectorAll('div.table-responsive');
            if (responsiveDivs.length === 0) {
                showMessage('No responsive wrappers found to remove.', 'info');
                return;
            }

            responsiveDivs.forEach(div => {
                // Move all children of the div out, right before the div
                while (div.firstChild) {
                    div.parentNode.insertBefore(div.firstChild, div);
                }
                // Remove the now-empty div
                div.parentNode.removeChild(div);
            });

            let finalHtml = tempDiv.innerHTML;
            finalHtml = html_beautify(finalHtml, { indent_size: 4, space_in_paren: true });
            setEditorContent(finalHtml);
            applyEntityHighlighting();
            populateTableSearchDropdown();
            showMessage('Responsive wrappers have been removed.', 'success');
        }

        /**
         * Resets all scopes and IDs from all tables.
         */
        function resetAllScopesAndIDs() {
            if (!monacoEditor) { showMessage('Editor is not ready.', 'info'); return; }
            const editorContent = getEditorContent();
            if (!editorContent.trim()) { showMessage('Nothing to reset.', 'info'); return; }

            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = editorContent;

            const cells = tempDiv.querySelectorAll('table th, table td');
            if (cells.length === 0) {
                showMessage('No table cells found to reset.', 'info');
                return;
            }

            cells.forEach(cell => {
                cell.removeAttribute('scope');
                cell.removeAttribute('id');
                cell.removeAttribute('headers');
            });

            let finalHtml = tempDiv.innerHTML;
            finalHtml = html_beautify(finalHtml, { indent_size: 4, space_in_paren: true });
            setEditorContent(finalHtml);
            applyEntityHighlighting();
            populateTableSearchDropdown();
            showMessage('All scopes, IDs, and headers have been reset.', 'success');
        }

        /**
         * Resets formatting for a single, selected table.
         */
        function resetTableFormatting() {
    const selectedValue = tableSearchDropdown.value;
    if (!selectedValue) {
        showMessage('Please select a table to reset.', 'info');
        return;
    }
    const tableInfo = tableDataMap.get(selectedValue);
    if (!tableInfo) { return; }

    const tempDiv = document.createElement('div');
    tempDiv.innerHTML = tableInfo.outerHTML;
    const table = tempDiv.querySelector('table');

    // FIX: remove ID
    table.removeAttribute('id');

    const classesToRemove = ['table', 'table-bordered', 'table-striped', 'table-hover', 'table-condensed', 'small', 'text-left', 'text-center', 'text-right', 'nowrap'];
    const alignmentClasses = ['text-left', 'text-center', 'text-right'];

    table.classList.remove(...classesToRemove);
    if (table.hasAttribute('class') && table.classList.length === 0) {
        table.removeAttribute('class');
    }

    table.querySelectorAll('tr, th, td, caption').forEach(el => {
        el.classList.remove('active', ...alignmentClasses);
        if (el.tagName === 'TR') el.classList.remove('small');
        if (el.tagName === 'TD' || el.tagName === 'TH') {
            el.classList.remove('nowrap');
        }
        // NEW: Check and remove empty class attributes on cells, rows, and caption
        if (el.hasAttribute('class') && el.classList.length === 0) {
            el.removeAttribute('class');
        }
    });

    let modifiedTableHtml = tempDiv.innerHTML;
    modifiedTableHtml = html_beautify(modifiedTableHtml, { indent_size: 4, space_in_paren: true });

    const currentEditorContent = getEditorContent();
    const newEditorContent = currentEditorContent.substring(0, tableInfo.startIndex) +
                             modifiedTableHtml +
                             currentEditorContent.substring(tableInfo.startIndex + tableInfo.length);
    
    setEditorContent(newEditorContent);
    applyEntityHighlighting();
    populateTableSearchDropdown();
    showMessage(`Formatting for table "${selectedValue}" has been reset.`, 'success');
}

// Ensure the `formatTableLogic` function also performs a final cleanup of empty class attributes.
// This is important because it's called by both universal and specific formatting.
function formatTableLogic(table, options) {
    console.log(`--- Applying formatting logic to table ---`);

    const financeRegex = /^\s*[-+]?(?:\d+|\d{1,3}(?:\s\d{3})*)(?:[.,]\d+)?\s*$/;
    const smallClass = 'small';
    const alignmentClasses = ['text-left', 'text-center', 'text-right'];

    // --- UNCONDITIONALLY REMOVE ALL IDs, HEADERS, AND SCOPES AT THE START from cells ---
    // This existing block is good for clearing prior states but not specifically for empty classes
    Array.from(table.querySelectorAll('*')).forEach(el => {
        el.removeAttribute('id');
        el.removeAttribute('headers');
        el.removeAttribute('scope');
        // This line attempts to remove empty class, but can be reinforced at the end.
        if (el.hasAttribute('class') && el.classList.length === 0) {
            el.removeAttribute('class');
            console.log(`Removed empty class attribute from ${el.tagName} during initial cleanup.`);
        }
    });
    console.log('Removed empty class attributes from elements initially.');

    // Clear existing active, centering, and alignment classes from all cells
    Array.from(table.querySelectorAll('th, tr, td, caption')).forEach(el => {
        el.classList.remove('active');
        el.classList.remove('nowrap'); // Also clear nowrap for finance
    });
    console.log('Classes cleared from all relevant elements for current table.');

    // ID Assignment Logic (Table ID)
    if (options.specificTableId) {
        let customId = options.tableIdPrefix;
        if (customId && customId.trim() !== '') {
            table.id = customId.trim();
            console.log(`Customized table ID set to: ${table.id}`);
        } else {
            table.removeAttribute('id');
            console.log('Customized table ID removed as input was empty.');
        }
    } else if (options.applyId) {
        let prefix = options.tableIdPrefix || 'tbl';
        if (options.isFigureTable) {
            prefix = options.figureDataIdPrefix || 'ftbl';
        }
        table.id = `${prefix}${options.assignedIdCounter}`;
        console.log(`Universal format assigned ID: ${table.id} (isFigureTable: ${options.isFigureTable})`);
    } else {
        table.removeAttribute('id');
        console.log('Removed ID from table as "ID Tables" option (Universal) is off.');
    }

    let currentClasses = table.className.split(' ').filter(c => c.trim() !== '');
    const newClasses = new Set();
    const controlledUniversalClasses = ['table', 'table-bordered', 'table-striped', 'table-hover', 'table-condensed', smallClass];

    if (options.specificTableId) {
        currentClasses.forEach(cls => newClasses.add(cls));
        console.log('Customize flow: Retaining all original classes.');
    } else {
        currentClasses.filter(c => !controlledUniversalClasses.includes(c)).forEach(cls => newClasses.add(cls));
        console.log('Universal flow: Filtering controlled classes.');
    }
    
    // Apply Basic Classes
    if (options.applyClassTables) {
        newClasses.add('table');
        newClasses.add('table-condensed');
    } else {
        newClasses.delete('table');
        newClasses.delete('table-condensed');
    }

    // Apply other classes based on options
    if (options.applyBordered) newClasses.add('table-bordered'); else newClasses.delete('table-bordered');
    if (options.applyStriped) newClasses.add('table-striped'); else newClasses.delete('table-striped');
    if (options.applyHover) newClasses.add('table-hover'); else newClasses.delete('table-hover');
    if (options.applyClassSmall) newClasses.add(smallClass); else newClasses.delete(smallClass);

    table.className = Array.from(newClasses).join(' ');
    // NEW: After setting class name for the table, check if it's empty
    if (table.hasAttribute('class') && table.classList.length === 0) {
        table.removeAttribute('class');
    }


    const originalTableRows = Array.from(table.querySelectorAll('tr'));

    let headerRowCount = 0;
    if (options.applyHeader) {
        let maxRowSpanEnd = -1;

        for (let i = 0; i < originalTableRows.length; i++) {
            const currentRow = originalTableRows[i];
            headerRowCount = i + 1;

            const cellsInCurrentRow = Array.from(currentRow.querySelectorAll('th, td'));
            cellsInCurrentRow.forEach(cell => {
                const rowspan = parseInt(cell.getAttribute('rowspan') || '1', 10);
                maxRowSpanEnd = Math.max(maxRowSpanEnd, i + rowspan - 1);
            });

            if (i >= maxRowSpanEnd) {
                break;
            }
        }
    }

    let existingCaptionElement = table.querySelector('caption');
    let existingCaptionContent = existingCaptionElement ? existingCaptionElement.innerHTML : '';
    let existingCaptionClasses = existingCaptionElement ? Array.from(existingCaptionElement.classList) : [];

    table.querySelectorAll('thead, tbody, tfoot, colgroup').forEach(el => el.remove());

    const newThead = document.createElement('thead');
    let newTbody = document.createElement('tbody');

    originalTableRows.forEach((row, index) => {
        if (index < headerRowCount) {
            const clonedRow = row.cloneNode(true);
            Array.from(clonedRow.querySelectorAll('td')).forEach(td => {
                const newTh = document.createElement('th');
                Array.from(td.attributes).forEach(attr => newTh.setAttribute(attr.name, attr.value));
                newTh.innerHTML = td.innerHTML;
                td.parentNode.replaceChild(newTh, td);
            });
            newThead.appendChild(clonedRow);
        } else {
            newTbody.appendChild(row);
        }
    });

    if (newThead.children.length > 0) table.appendChild(newThead);
    table.appendChild(newTbody);

    let captionElement = table.querySelector('caption');
    const shouldHaveCaption = options.applyCaption || options.applyAutoCaption;

    if (shouldHaveCaption) {
        if (!captionElement) {
            captionElement = document.createElement('caption');
            if (table.firstChild) table.insertBefore(captionElement, table.firstChild);
            else table.appendChild(captionElement);
        }
        
        if (existingCaptionClasses.length > 0) captionElement.className = existingCaptionClasses.join(' ');
        else captionElement.removeAttribute('class');
        
        applyAlignment(captionElement, options.currentCaptionAlignment, alignmentClasses);

        if (options.applyAutoCaption) {
            let extractedContent = '';
            if (options.specificTableId) {
                const firstRow = table.querySelector('tr');
                if (firstRow) {
                    const firstCell = firstRow.firstElementChild;
                    if (firstCell && (firstCell.tagName.toLowerCase() === 'th' || firstCell.tagName.toLowerCase() === 'td')) {
                        const colspan = parseInt(firstCell.getAttribute('colspan') || '1', 10);
                        const totalColumns = getEffectiveColumnCount(firstRow);
                        if (colspan === totalColumns && firstCell.textContent.trim() !== '') {
                            extractedContent = firstCell.textContent.trim();
                        }
                    }
                }
            } else {
                let prevSibling = (table.parentNode.classList.contains('table-responsive') ? table.parentNode : table).previousElementSibling;
                while (prevSibling) {
                    if (['P', 'H1', 'H2', 'H3', 'H4', 'H5', 'H6'].includes(prevSibling.tagName)) {
                        extractedContent = prevSibling.textContent.trim();
                        prevSibling.remove();
                        break;
                    }
                    if (prevSibling.nodeType === Node.TEXT_NODE && prevSibling.textContent.trim() !== '') break;
                    prevSibling = prevSibling.previousElementSibling;
                }
            }
            captionElement.textContent = extractedContent || `[insert table caption]`;
        } else if (!captionElement.textContent.trim() || captionElement.textContent.trim() === '[insert table caption]') {
            captionElement.textContent = existingCaptionContent || `[insert table caption]`;
        }
        // NEW: Check and remove empty class attributes on caption
        if (captionElement.hasAttribute('class') && captionElement.classList.length === 0) {
            captionElement.removeAttribute('class');
        }
    } else {
        if (captionElement) captionElement.remove();
    }

    const currentCaption = table.querySelector('caption');
    const currentThead = table.querySelector('thead');
    if (currentCaption && currentThead) {
        let currentNode = currentCaption.nextSibling;
        while (currentNode && currentNode !== currentThead) {
            const next = currentNode.nextSibling;
            if (currentNode.nodeType === Node.TEXT_NODE && currentNode.nodeValue.trim() === '') {
                currentNode.parentNode.removeChild(currentNode);
            } else if (currentNode.nodeType === Node.ELEMENT_NODE && ['BR', 'P', 'DIV'].includes(currentNode.tagName.toUpperCase()) && currentNode.textContent.trim() === '') {
                currentNode.parentNode.removeChild(currentNode);
            }
            currentNode = next;
        }
    }

    if (options.applyMakeTfootFromColspan) {
        const currentTbody = table.querySelector('tbody');
        if (currentTbody && currentTbody.rows.length > 0) {
            const lastRow = currentTbody.rows[currentTbody.rows.length - 1];
            let totalColumns = 0;
            const firstRowForColCount = table.querySelector('tr');
            if(firstRowForColCount) totalColumns = getEffectiveColumnCount(firstRowForColCount);
            
            if (totalColumns > 0 && lastRow.cells.length === 1) {
                const singleCell = lastRow.firstElementChild;
                const colspan = parseInt(singleCell.getAttribute('colspan') || '1', 10);
                if (colspan >= totalColumns) {
                    let tfoot = table.querySelector('tfoot');
                    if (!tfoot) {
                        tfoot = document.createElement('tfoot');
                        table.appendChild(tfoot);
                    }
                    tfoot.appendChild(lastRow);
                    if (currentTbody.rows.length === 0) currentTbody.remove();
                }
            }
        }
    }

    const tbodyRows = Array.from(newTbody.querySelectorAll('tr'));
    tbodyRows.forEach(row => {
        const firstCell = row.firstElementChild;
        if (firstCell) {
            const existingClasses = Array.from(firstCell.classList).join(' ');
            if (options.applyRowHeader) {
                if (firstCell.tagName.toLowerCase() !== 'th') {
                    const newTh = document.createElement('th');
                    Array.from(firstCell.attributes).forEach(attr => { if (attr.name !== 'class') newTh.setAttribute(attr.name, attr.value); });
                    newTh.innerHTML = firstCell.innerHTML;
                    newTh.className = existingClasses;
                    row.replaceChild(newTh, firstCell);
                    applyAlignment(newTh, options.currentRowHeaderAlignment, alignmentClasses);
                } else {
                    applyAlignment(firstCell, options.currentRowHeaderAlignment, alignmentClasses);
                }
            } else {
                if (firstCell.tagName.toLowerCase() !== 'td') {
                    const newTd = document.createElement('td');
                    Array.from(firstCell.attributes).forEach(attr => { if (attr.name !== 'class') newTd.setAttribute(attr.name, attr.value); });
                    newTd.innerHTML = firstCell.innerHTML;
                    newTd.className = existingClasses;
                    row.replaceChild(newTd, firstCell);
                    applyAlignment(newTd, 'none', alignmentClasses);
                } else {
                    applyAlignment(firstCell, 'none', alignmentClasses);
                }
            }
            // NEW: After alignment, check if cell's class attribute is empty
            if (firstCell.hasAttribute('class') && firstCell.classList.length === 0) {
                firstCell.removeAttribute('class');
            }
        }
    });

    if (options.applyAddSmallToTr) {
        Array.from(table.querySelectorAll('tr')).forEach(tr => tr.classList.add(smallClass));
    } else {
        Array.from(table.querySelectorAll('tr')).forEach(tr => tr.classList.remove(smallClass));
    }

    Array.from(table.querySelectorAll('th, td')).forEach(cell => {
        if (options.applyFixEmptyCells) {
            const containsNBSP = cell.innerHTML.includes('&nbsp;') || cell.innerHTML.includes('&#160;');
            if (cell.textContent.trim() === '' && !containsNBSP) {
                cell.innerHTML = '&#160;';
            }
        }
        if (options.applyRemovePTags) {
            Array.from(cell.querySelectorAll('p')).forEach(p => {
                while (p.firstChild) p.parentNode.insertBefore(p.firstChild, p);
                p.remove();
            });
        }
        if (cell.tagName.toLowerCase() === 'td') {
            if (options.applyFinanceTable && financeRegex.test(cell.textContent.trim())) {
                applyAlignment(cell, 'right', alignmentClasses);
                cell.classList.add('nowrap');
            } else {
                applyAlignment(cell, options.currentDataCellsAlignment, alignmentClasses);
                cell.classList.remove('nowrap');
            }
        }
        // NEW: After all cell-specific class manipulations, remove empty class attributes
        if (cell.hasAttribute('class') && cell.classList.length === 0) {
            cell.removeAttribute('class');
        }
    });

    Array.from(table.querySelectorAll('tbody tr')).forEach(row => {
        const thInRow = row.querySelector('th');
        let isTotalRow = thInRow && (thInRow.textContent.trim().toLowerCase() === 'total' || thInRow.textContent.trim().toLowerCase() === 'subtotal');
        Array.from(row.querySelectorAll('td')).forEach(td => {
            if (options.applyBoldTotals && isTotalRow) {
                if (!td.querySelector('strong')) {
                    td.innerHTML = `<strong>${td.innerHTML}</strong>`;
                }
            } else {
                if (td.querySelector('strong')) {
                    td.innerHTML = td.querySelector('strong').innerHTML;
                }
            }
        });
        // NEW: Check and remove empty class attributes on row
        if (row.hasAttribute('class') && row.classList.length === 0) {
            row.removeAttribute('class');
        }
    });

    Array.from(table.querySelectorAll('thead tr')).forEach(tr => tr.classList.remove('active'));
    if (options.applyActiveColHeaders) {
        Array.from(newThead.querySelectorAll('tr')).forEach(tr => tr.classList.add('active'));
    }

    if (options.activeColspanHeadersCheckboxValue) {
        Array.from(newTbody.querySelectorAll('th[colspan]')).forEach(th => th.classList.add('active'));
    }
    if (options.activeRowHeadersCheckboxValue) {
        Array.from(newTbody.querySelectorAll('tr > th:first-child')).forEach(th => th.classList.add('active'));
    }

    Array.from(newThead.querySelectorAll('th')).forEach(th => {
        applyAlignment(th, options.currentColHeaderAlignment, alignmentClasses);
        // NEW: Check and remove empty class attributes on th
        if (th.hasAttribute('class') && th.classList.length === 0) {
            th.removeAttribute('class');
        }
    });
    Array.from(newTbody.querySelectorAll('th[colspan]')).forEach(th => {
        applyAlignment(th, options.currentColspanHeaderAlignment, alignmentClasses);
        // NEW: Check and remove empty class attributes on th
        if (th.hasAttribute('class') && th.classList.length === 0) {
            th.removeAttribute('class');
        }
    });
    if (options.applyRowHeader && newThead.rows.length > 0 && newThead.rows[0].cells.length > 0) {
         applyAlignment(newThead.rows[0].cells[0], options.currentRowHeaderAlignment, alignmentClasses);
         // NEW: Check and remove empty class attributes on this specific th
         if (newThead.rows[0].cells[0].hasAttribute('class') && newThead.rows[0].cells[0].classList.length === 0) {
            newThead.rows[0].cells[0].removeAttribute('class');
         }
    }

    // FINAL CLEANUP: Iterate over all elements within the table one last time
    // to catch any remaining empty class attributes that might have been missed.
    Array.from(table.querySelectorAll('*')).forEach(el => {
        if (el.hasAttribute('class') && el.classList.length === 0) {
            el.removeAttribute('class');
            console.log(`Final cleanup: Removed empty class attribute from ${el.tagName}.`);
        }
    });
    return table;
}

        /**
         * Resets scopes and IDs for a single, selected table.
         */
        function resetTableScopeAndID() {
             const selectedValue = tableSearchDropdown.value;
            if (!selectedValue) {
                showMessage('Please select a table to reset.', 'info');
                return;
            }
            const tableInfo = tableDataMap.get(selectedValue);
            if (!tableInfo) { return; }

            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = tableInfo.outerHTML;
            const table = tempDiv.querySelector('table');

            table.querySelectorAll('th, td').forEach(cell => {
                cell.removeAttribute('scope');
                cell.removeAttribute('id');
                cell.removeAttribute('headers');
            });

            let modifiedTableHtml = tempDiv.innerHTML;
            modifiedTableHtml = html_beautify(modifiedTableHtml, { indent_size: 4, space_in_paren: true });

            const currentEditorContent = getEditorContent();
            const newEditorContent = currentEditorContent.substring(0, tableInfo.startIndex) +
                                     modifiedTableHtml +
                                     currentEditorContent.substring(tableInfo.startIndex + tableInfo.length);
            
            setEditorContent(newEditorContent);
            applyEntityHighlighting();
            populateTableSearchDropdown();
            showMessage(`Scopes and IDs for table "${table.id || selectedValue}" have been reset.`, 'success');
        }

        /**
         * Applies unique IDs to all tables in the editor.
         */
        function autoTableIDs() {
            if (!monacoEditor) { showMessage('Editor is not ready.', 'info'); return; }
            const editorContent = getEditorContent();
            if (!editorContent.trim()) { showMessage('No content to add IDs to.', 'info'); return; }

            autoTableIDBtn.textContent = 'IDing...';
            autoTableIDBtn.setAttribute('data-temp-active', 'true');
            updateAllInteractiveButtonStates();

            try {
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = editorContent;

                const tables = tempDiv.querySelectorAll('table');
                if (tables.length === 0) {
                    showMessage('No tables found to ID.', 'info');
                    return; // finally block will still run
                }

                let tblCounter = 1;
                let ftblCounter = 1;

                tables.forEach(table => {
                    if (table.closest('figure')) {
                        table.id = `ftbl${ftblCounter++}`;
                    } else {
                        table.id = `tbl${tblCounter++}`;
                    }
                });

                let finalHtml = tempDiv.innerHTML;
                finalHtml = html_beautify(finalHtml, { indent_size: 4, space_in_paren: true });
                setEditorContent(finalHtml);
                applyEntityHighlighting();
                populateTableSearchDropdown();
                showMessage('Table IDs have been automatically assigned.', 'success');
            } catch (e) {
                console.error("Error assigning table IDs:", e);
                showMessage('An error occurred while assigning IDs.', 'error');
            } finally {
                setTimeout(() => {
                    autoTableIDBtn.textContent = "Auto Table ID's";
                    autoTableIDBtn.removeAttribute('data-temp-active');
                    updateAllInteractiveButtonStates();
                }, 1500);
            }
        }

        /**
         * Formats a string containing numbers to a specific language format.
         * @param {string} text - The string to format.
         * @param {string} lang - The target language ('eng' or 'fra').
         * @returns {string} The formatted string.
         */
        function formatNumberString(text, lang) {
    const regex = /([+\-]?)\s*([\$€]?)\s*([\d][\d\s,.'&#160;&nbsp;]*)\s*([\$€%]?)/g;

    return text.replace(regex, (match, sign, preSymbol, numberStr, postSymbol) => {
        if (!/\d/.test(numberStr)) return match;

        // Heuristic to ignore version numbers, IP addresses, or codes.
        if ((numberStr.match(/\./g) || []).length > 1 && (numberStr.match(/,/g) || []).length === 0) {
            return match;
        }

        let parsableStr = numberStr
            .replace(/&nbsp;/g, ' ')
            .replace(/&#160;/g, ' ')
            .trim();

        const hasComma = parsableStr.includes(',');
        const hasPeriod = parsableStr.includes('.');

        if (hasComma && hasPeriod) {
            // Both comma and period present. Determine decimal.
            // If comma appears after period, it's European style (1.234,56)
            if (parsableStr.indexOf(',') > parsableStr.indexOf('.')) {
                parsableStr = parsableStr.replace(/\./g, '').replace(',', '.');
            } else {
                // If period appears after comma, it's American style (1,234.56)
                parsableStr = parsableStr.replace(/,/g, '');
            }
        } else if (hasComma) {
            // Only commas present. Heuristic: if last part is 1 or 2 digits, assume decimal.
            const parts = parsableStr.split(',');
            const lastPart = parts[parts.length - 1];
            if (lastPart.length === 1 || lastPart.length === 2) {
                parsableStr = parsableStr.replace(/,/g, (m, offset, str) => {
                    if (offset === str.lastIndexOf(',')) return '.';
                    return '';
                });
            } else {
                // Otherwise, assume all commas are thousands separators.
                parsableStr = parsableStr.replace(/,/g, '');
            }
        } else if (hasPeriod) {
            // Only periods present. Heuristic: if last part is 3 digits, assume thousands.
            const parts = parsableStr.split('.');
            const lastPart = parts[parts.length - 1];
            if (lastPart.length === 3 && parts.length > 1) {
                parsableStr = parsableStr.replace(/\./g, '');
            }
            // Otherwise, assume it's a decimal separator, keep it as is.
        }
        parsableStr = parsableStr.replace(/\s/g, ''); // Remove any remaining spaces


        const num = parseFloat(parsableStr);
        if (isNaN(num)) {
            return match;
        }

        const symbol = preSymbol || postSymbol;
        const originalDecimalPartLength = (parsableStr.split('.')[1] || '').length;

        // Determine formatting options
        // For financial numbers, typically 2 decimal places are preferred.
        // But if the original number had more, we should preserve that.
        let minFractions = 0;
        let maxFractions = 0;

        if (num % 1 === 0) { // If it's an integer
            minFractions = 0;
            maxFractions = 0; // No decimals for integers unless specified by context
        } else { // If it has decimal places
            minFractions = originalDecimalPartLength;
            // Ensure at least 2 decimal places for financial numbers, but keep original if more
            maxFractions = Math.max(2, originalDecimalPartLength);
        }

        // 2. Format to the target locale
        if (lang === 'eng') {
            let formattedNum = num.toLocaleString('en-CA', {
                minimumFractionDigits: minFractions,
                maximumFractionDigits: maxFractions
            });

            // Specific check for integers to avoid '.00' if original had no decimals
            // `toLocaleString` handles thousands separators automatically based on locale.
            if (num % 1 === 0 && originalDecimalPartLength === 0) {
                 formattedNum = num.toLocaleString('en-CA', {
                    minimumFractionDigits: 0,
                    maximumFractionDigits: 0
                });
            }

            if (symbol === '$' || symbol === '€') return `${sign}${symbol}${formattedNum}`;
            if (symbol === '%') return `${sign}${formattedNum}${symbol}`;
            return `${sign}${formattedNum}`;
        } else if (lang === 'fra') {
            let formattedNum = num.toLocaleString('fr-CA', {
                minimumFractionDigits: minFractions,
                maximumFractionDigits: maxFractions
            });

            formattedNum = formattedNum.replace(/\u00A0/g, ' '); // Convert system NBSP to normal space temporarily
            formattedNum = formattedNum.replace(/ /g, '\u00A0'); // Replace normal spaces with NBSP for thousands
            formattedNum = formattedNum.replace(/,/g, ','); // Ensure decimal comma is preserved

            // Specific check for integers to avoid ',00' if original had no decimals
            if (num % 1 === 0 && originalDecimalPartLength === 0) {
                formattedNum = num.toLocaleString('fr-CA', {
                    minimumFractionDigits: 0,
                    maximumFractionDigits: 0
                });
                // Re-apply NBSP if the integer formatting removed them
                formattedNum = formattedNum.replace(/\u00A0/g, ' ');
                formattedNum = formattedNum.replace(/ /g, '\u00A0');
            }


            if (symbol === '$' || symbol === '€' || symbol === '%') {
                return `${sign}${formattedNum}\u00A0${symbol}`;
            }
            return `${sign}${formattedNum}`;
        }
        return match;
    });
}

        /**
         * Main function to trigger number formatting across all tables.
         * @param {string} lang - The target language ('eng' or 'fra').
         */
        function formatTableNumbers(lang) {
            if (!monacoEditor) {
                showMessage('Editor is not ready.', 'info');
                return;
            }
            const editorContent = getEditorContent();
            if (!editorContent.trim()) {
                showMessage('No content to format.', 'info');
                return;
            }

            const btn = lang === 'eng' ? document.getElementById('eng-number-button') : document.getElementById('fra-number-button');
            const originalText = btn.textContent;
            btn.textContent = 'Formatting...';
            btn.setAttribute('data-temp-active', 'true');
            updateAllInteractiveButtonStates();

            try {
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = editorContent;

                const cells = tempDiv.querySelectorAll('table td, table th');

                cells.forEach(cell => {
                    const walker = document.createTreeWalker(cell, NodeFilter.SHOW_TEXT, null, false);
                    const nodesToProcess = [];
                    let node;
                    while (node = walker.nextNode()) {
                        nodesToProcess.push(node);
                    }

                    nodesToProcess.forEach(textNode => {
                        const formattedText = formatNumberString(textNode.nodeValue, lang);
                        textNode.nodeValue = formattedText;
                    });
                });

                let finalHtml = tempDiv.innerHTML;
                
                // After DOM manipulation, replace literal non-breaking spaces with the desired entity for editor consistency.
                finalHtml = finalHtml.replace(/\u00A0/g, '&#160;');
                
                // Run auto-encode logic
                finalHtml = convertAllEntitiesToNumeric(finalHtml);

                finalHtml = html_beautify(finalHtml, { indent_size: 4, space_in_paren: true });
                setEditorContent(finalHtml);
                applyEntityHighlighting();
                populateTableSearchDropdown();
                showMessage(`Numbers formatted for ${lang === 'eng' ? 'English' : 'French'}.`, 'success');

            } catch (e) {
                console.error(`Error formatting numbers for ${lang}:`, e);
                showMessage('An error occurred during number formatting.', 'error');
            } finally {
                setTimeout(() => {
                    btn.textContent = originalText;
                    btn.removeAttribute('data-temp-active');
                    updateAllInteractiveButtonStates();
                }, 1500);
            }
        }


        // DOM element references (moved after functions to ensure they are available)
        const formatButton = document.getElementById('format-button-modal');
		const autoScopeBtn = document.getElementById('auto-scope-btn');
        const openOptionsModalButton = document.getElementById('open-options-modal-btn');
        const optionsModalOverlay = document.getElementById('options-modal-overlay');
        const closeOptionsModalButton = document.getElementById('close-options-modal-btn');

        // Universal Format Modal controls
        const idCheckbox = document.getElementById('id-checkbox');
        const pageIdPrefixInput = document.getElementById('page-id-prefix-input');
        const figureDataIdPrefixInput = document.getElementById('figure-data-id-prefix-input');
        const classTablesCheckbox = document.getElementById('class-tables-checkbox');
        const captionCheckbox = document.getElementById('caption-checkbox');
        const autoCaptionCheckbox = document.getElementById('auto-caption-checkbox');
        const fixEmptyCellsCheckbox = document.getElementById('fix-empty-cells-checkbox');
        const removePTagsCheckbox = document.getElementById('remove-p-tags-checkbox');
        const makeTfootFromColspanCheckbox = document.getElementById('make-tfoot-from-colspan-checkbox');
        const addSmallToTrCheckbox = document.getElementById('add-small-to-tr-checkbox');
        const headerCheckbox = document.getElementById('header-checkbox');
        const rowHeaderCheckbox = document.getElementById('row-header-checkbox');

        const borderedCheckbox = document.getElementById('bordered-checkbox');
        const stripedCheckbox = document.getElementById('striped-checkbox');
        const hoverCheckbox = document.getElementById('hover-checkbox');
        const activeColHeadersCheckbox = document.getElementById('active-col-headers-checkbox');
        const activeColspanHeadersCheckbox = document.getElementById('active-colspan-headers-checkbox');
        const activeRowHeadersCheckbox = document.getElementById('active-row-headers-checkbox');
        const classSmallCheckboxElement = document.getElementById('class-small-checkbox');

        const financeTableCheckbox = document.getElementById('finance-table-checkbox');
        const boldTotalsCheckbox = document.getElementById('bold-totals-checkbox');

        const messageBox = document.getElementById('message-box');

        // New button references for integrated features
        const clearAllBtn = document.getElementById('clearAllBtn');
        const autoEncodeBtn = document.getElementById('autoEncodeBtn');
        const autoFormatBtn = document.getElementById('autoFormatBtn');
        const copyCodeBtn = document.getElementById('copyCodeBtn');
        const importHtmlBtn = document.getElementById('importHtmlBtn');
        const exportHtmlBtn = document.getElementById('exportHtmlBtn');
        const htmlFileInput = document.getElementById('htmlFileInput');
        const autoResponsiveBtn = document.getElementById('auto-responsive-btn');
        const autoTableIDBtn = document.getElementById('autoTableIDBtn');

        // New dropdown for table search and customize button
        const tableSearchDropdown = document.getElementById('table-search-dropdown');
        const customizeButton = document.getElementById('customize-button');
		const forceScopeButton = document.getElementById('force-scope-button');
		const forceIdButton = document.getElementById('force-id-button');
		const resetUniversalBtn = document.getElementById('reset-universal-btn');
        const resetResponsiveBtn = document.getElementById('reset-responsive-btn');
        const resetScopeIdBtn = document.getElementById('reset-scopeid-btn');
        const resetTableFormatBtn = document.getElementById('reset-tableformat-btn');
        const resetTableScopeIDBtn = document.getElementById('reset-tablescopeid-btn');

        // Customize Table Modal elements
        const customizeModalOverlay = document.getElementById('customize-modal-overlay');
        const closeCustomizeModalButton = document.getElementById('close-customize-modal-btn');
        const formatSpecificTableButton = document.getElementById('format-specific-table-button');
        const customizePreviewIframe = document.getElementById('customize-preview-iframe');

        // Customize Modal controls (all prefixed with customize-)
        const customizePageIdPrefixInput = document.getElementById('customize-page-id-prefix-input'); // Renamed to Custom ID
		const customizeMakeTfootFromColspanCheckbox = document.getElementById('customize-make-tfoot-from-colspan-checkbox');
		const customizeCaptionCheckbox = document.getElementById('customize-caption-checkbox');
        const customizeFixEmptyCellsCheckbox = document.getElementById('customize-fix-empty-cells-checkbox');
        const customizeRemovePTagsCheckbox = document.getElementById('customize-remove-p-tags-checkbox');
        const customizeClassSmallCheckboxElement = document.getElementById('customize-class-small-checkbox');
        const customizeAddSmallToTrCheckbox = document.getElementById('customize-add-small-to-tr-checkbox');
		const customizeClassTablesCheckbox = document.getElementById('customize-class-tables-checkbox');
        const customizeHeaderCheckbox = document.getElementById('customize-header-checkbox');
        const customizeRowHeaderCheckbox = document.getElementById('customize-row-header-checkbox');
        const customizeBorderedCheckbox = document.getElementById('customize-bordered-checkbox');
        const customizeStripedCheckbox = document.getElementById('customize-striped-checkbox');
        const customizeHoverCheckbox = document.getElementById('customize-hover-checkbox');
        const customizeActiveColHeadersCheckbox = document.getElementById('customize-active-col-headers-checkbox');
        const customizeActiveColspanHeadersCheckbox = document.getElementById('customize-active-colspan-headers-checkbox');
        const customizeActiveRowHeadersCheckbox = document.getElementById('customize-active-row-headers-checkbox');
        const customizeFinanceTableCheckbox = document.getElementById('customize-finance-table-checkbox');
        const customizeBoldTotalsCheckbox = document.getElementById('bold-totals-checkbox');


        // Populate allInteractiveButtons array after all button elements are defined
        allInteractiveButtons.push(
            formatButton,
            openOptionsModalButton,
            clearAllBtn,
            autoEncodeBtn,
            autoFormatBtn,
            copyCodeBtn,
            importHtmlBtn,
            exportHtmlBtn,
            customizeButton,
            formatSpecificTableButton,
			autoScopeBtn,       
            forceScopeButton,     
            forceIdButton,
            autoResponsiveBtn,
            autoTableIDBtn,
            resetUniversalBtn,
            resetResponsiveBtn,
            resetScopeIdBtn,
            resetTableFormatBtn,
            resetTableScopeIDBtn
        );

        // Event listeners for modals
        openOptionsModalButton.addEventListener('click', openOptionsModal);
        closeOptionsModalButton.addEventListener('click', closeOptionsModal);
        formatButton.addEventListener('click', formatHtmlTables); // Universal Format button
		
        if (autoResponsiveBtn) {
            autoResponsiveBtn.addEventListener('click', () => {
                if (!monacoEditor) { showMessage('Editor is still loading.', 'info'); return; }

                // Temporarily disable buttons and show feedback
                autoResponsiveBtn.textContent = 'Applying...';
                autoResponsiveBtn.setAttribute('data-temp-active', 'true');
                updateAllInteractiveButtonStates();

                try {
                    const editorContent = getEditorContent();
                    const tempDiv = document.createElement('div');
                    tempDiv.innerHTML = editorContent;
                    
                    const tables = tempDiv.querySelectorAll('table');
                    if (tables.length === 0) {
                        showMessage('No tables found to apply responsive wrappers.', 'info');
                        // Use finally block to reset button state
                        return;
                    }

                    let wrappedCount = 0;

                    tables.forEach(table => {
                        const parent = table.parentElement;
                        // Check if parent is NOT a responsive div
                        if (!parent || !parent.classList.contains('table-responsive')) {
                            // It's not wrapped, so wrap it
                            const responsiveDiv = document.createElement('div');
                            responsiveDiv.className = 'table-responsive';
                            if (table.parentNode) {
                                table.parentNode.insertBefore(responsiveDiv, table);
                                responsiveDiv.appendChild(table);
                                wrappedCount++;
                            }
                        }
                    });

                    let finalHtml = tempDiv.innerHTML;
                    finalHtml = html_beautify(finalHtml, { indent_size: 4, space_in_paren: true });
                    setEditorContent(finalHtml);
                    applyEntityHighlighting();
                    populateTableSearchDropdown();

                    showMessage(`${wrappedCount} responsive wrappers added.`, 'success');

                } catch (e) {
                    console.error("Error applying responsive wrappers:", e);
                    showMessage('An error occurred. Check console for details.', 'error');
                } finally {
                    setTimeout(() => {
                        autoResponsiveBtn.textContent = 'Auto-Responsive';
                        autoResponsiveBtn.removeAttribute('data-temp-active');
                        updateAllInteractiveButtonStates();
                    }, 1500);
                }
            });
        }
        
		if (autoScopeBtn) {
            autoScopeBtn.addEventListener('click', () => {
                // Temporarily disable buttons and show feedback
                autoScopeBtn.textContent = 'Scoping...';
                autoScopeBtn.setAttribute('data-temp-active', 'true'); // Set temp active
                updateAllInteractiveButtonStates(); // Update states for ALL buttons

                const editorContent = monacoEditor.getValue();
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = editorContent;
                const allTables = tempDiv.querySelectorAll('table');

                if (allTables.length === 0) {
                    // ... (no tables found handling) ...
                    return;
                }

                allTables.forEach((table, index) => {
                    autoScopeTableIDs(table, index);
                });

                let finalFormattedHtml = tempDiv.innerHTML;
                finalFormattedHtml = cleanEmptyHeadersAttribute(finalFormattedHtml);

                monacoEditor.setValue(finalFormattedHtml);
                applyEntityHighlighting();
                populateTableSearchDropdown();

                // Re-enable and revert specific button state after operation
                setTimeout(() => {
                    autoScopeBtn.textContent = 'Auto-Scope/ID';
                    autoScopeBtn.removeAttribute('data-temp-active'); // Remove temp active
                    updateAllInteractiveButtonStates(); // Update states for ALL buttons
                    showMessage('Auto-scoping complete!', 'success');
                }, 1500);
            });
        }

if (forceScopeButton) {
            forceScopeButton.addEventListener('click', () => {
        const selectedValue = tableSearchDropdown.value;
        if (!selectedValue) {
            showMessage('Please select a table to force scope.', 'info');
            return;
        }

        // ... (temp-active and other button state management) ...

        try {
            const tableInfo = tableDataMap.get(selectedValue);
            if (!tableInfo || tableInfo.startIndex === -1) {
                showMessage('Selected table not found in editor content.', 'error');
                return;
            }

            const currentEditorContent = monacoEditor.getValue();
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = tableInfo.outerHTML;
            const tableToProcess = tempDiv.querySelector('table');

            autoScopeTableIDs(tableToProcess, 0, 'simple');

            const modifiedTableHtml = tableToProcess.outerHTML;

            // CHANGE 'const' to 'let' here
            let newEditorContent = currentEditorContent.substring(0, tableInfo.startIndex) +
                                   modifiedTableHtml +
                                   currentEditorContent.substring(tableInfo.startIndex + tableInfo.length);

            newEditorContent = cleanEmptyHeadersAttribute(newEditorContent); // Reassignment happens here

            monacoEditor.setValue(newEditorContent);
            applyEntityHighlighting();
            populateTableSearchDropdown();

            showMessage('Force Scope applied successfully!', 'success');

        } catch (e) {
            console.error("Error forcing scope:", e);
            showMessage('An error occurred during force scope. Check console.', 'error');
                } finally {
                    // Re-enable and revert button state after operation
                    forceScopeButton.textContent = 'Force Scope';
                    forceScopeButton.classList.remove('bg-green-500', 'hover:bg-green-600');
                    forceScopeButton.classList.add('bg-green-700', 'hover:bg-green-600');
                    forceScopeButton.removeAttribute('data-temp-active');
                    updateAllInteractiveButtonStates(); // Re-enable other buttons
                }
            });
        }


        // Event listener for Force ID/Headers button
        if (forceIdButton) {
            forceIdButton.addEventListener('click', () => {
        const selectedValue = tableSearchDropdown.value;
        if (!selectedValue) {
            showMessage('Please select a table to force ID/Headers.', 'info');
            return;
        }

        // ... (temp-active and other button state management) ...

        try {
            const tableInfo = tableDataMap.get(selectedValue);
            if (!tableInfo || tableInfo.startIndex === -1) {
                showMessage('Selected table not found in editor content.', 'error');
                return;
            }

            const currentEditorContent = monacoEditor.getValue();
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = tableInfo.outerHTML;
            const tableToProcess = tempDiv.querySelector('table');

            autoScopeTableIDs(tableToProcess, 0, 'complex');

            const modifiedTableHtml = tableToProcess.outerHTML;

            // CHANGE 'const' to 'let' here
            let newEditorContent = currentEditorContent.substring(0, tableInfo.startIndex) +
                                   modifiedTableHtml +
                                   currentEditorContent.substring(tableInfo.startIndex + tableInfo.length);

            newEditorContent = cleanEmptyHeadersAttribute(newEditorContent); // Reassignment happens here

            monacoEditor.setValue(newEditorContent);
            applyEntityHighlighting();
            populateTableSearchDropdown();

            showMessage('Force ID/Headers applied successfully!', 'success');

        } catch (e) {
            console.error("Error forcing ID/Headers:", e); // This is the line reported by user (3189:23 for them)
            showMessage('An error occurred during force ID/Headers. Check console for details.', 'error');
                } finally {
                    // Re-enable and revert button state after operation
                    forceIdButton.textContent = 'Force ID/Headers';
                    forceIdButton.classList.remove('bg-green-500', 'hover:bg-green-600');
                    forceIdButton.classList.add('bg-green-700', 'hover:bg-green-600');
                    forceIdButton.removeAttribute('data-temp-active');
                    updateAllInteractiveButtonStates(); // Re-enable other buttons
                }
            });
        }

        // NEW: Event listeners for reset buttons
        resetUniversalBtn.addEventListener('click', resetUniversalFormatting);
        resetResponsiveBtn.addEventListener('click', resetResponsiveWrappers);
        resetScopeIdBtn.addEventListener('click', resetAllScopesAndIDs);
        resetTableFormatBtn.addEventListener('click', resetTableFormatting);
        resetTableScopeIDBtn.addEventListener('click', resetTableScopeAndID);
        autoTableIDBtn.addEventListener('click', autoTableIDs);

        // NEW: Event listeners for number formatting buttons
        const engNumberButton = document.getElementById('eng-number-button');
        const fraNumberButton = document.getElementById('fra-number-button');

        engNumberButton.addEventListener('click', () => formatTableNumbers('eng'));
        fraNumberButton.addEventListener('click', () => formatTableNumbers('fra'));


        customizeButton.addEventListener('click', () => {
            if (!tableSearchDropdown.value) {
                showMessage('Please select a table from the dropdown first.', 'info');
                return;
            }
            customizeModalOverlay.classList.remove('hidden'); 
            tableSearchDropdown.dispatchEvent(new Event('change'));
        });
        closeCustomizeModalButton.addEventListener('click', closeCustomizeModal);
        formatSpecificTableButton.addEventListener('click', formatSpecificTable); // Specific Table Format button


        // Setup all new alignment button groups for UNIVERSAL modal
        setupButtonGroup('caption-alignment-group', 'captionAlignment');
        setupButtonGroup('col-headers-alignment-group', 'colHeaderAlignment');
        setupButtonGroup('row-headers-alignment-group', 'rowHeaderAlignment');
        setupButtonGroup('colspan-headers-alignment-group', 'colspanHeaderAlignment');
        setupButtonGroup('data-cells-alignment-group', 'dataCellsAlignment');

        // Setup all new alignment button groups for CUSTOMIZE modal, with preview update callback
        setupButtonGroup('customize-caption-alignment-group', 'customizeCaptionAlignment', customizeModalOverlay, updateCustomizeModalPreview);
        setupButtonGroup('customize-col-headers-alignment-group', 'customizeColHeaderAlignment', customizeModalOverlay, updateCustomizeModalPreview);
        setupButtonGroup('customize-row-headers-alignment-group', 'customizeRowHeaderAlignment', customizeModalOverlay, updateCustomizeModalPreview);
        setupButtonGroup('customize-colspan-headers-alignment-group', 'customizeColspanHeaderAlignment', customizeModalOverlay, updateCustomizeModalPreview);
        setupButtonGroup('customize-data-cells-alignment-group', 'customizeDataCellsAlignment', customizeModalOverlay, updateCustomizeModalPreview);

		
        // Mutual exclusivity logic for Finance Table checkbox and Alignment button groups
        if (financeTableCheckbox) {
             financeTableCheckbox.addEventListener('change', function() {
                const parentLabel = this.closest('.toggle-switch');
                parentLabel.classList.toggle('is-checked', this.checked);
            });
        }
        if (customizeFinanceTableCheckbox) {
             customizeFinanceTableCheckbox.addEventListener('change', function() {
                const parentLabel = this.closest('.toggle-switch');
                parentLabel.classList.toggle('is-checked', this.checked);
                updateCustomizeModalPreview(); // Trigger preview update
            });
        }

		
	
        // Mutual exclusivity logic for Captions (placeholder) and Auto-Caption (Universal Modal)
        captionCheckbox.addEventListener('change', function() {
            const parentLabel = this.closest('.toggle-switch');
            parentLabel.classList.toggle('is-checked', this.checked);
            if (this.checked) {
                autoCaptionCheckbox.checked = false;
                autoCaptionCheckbox.closest('.toggle-switch').classList.remove('is-checked');
            }
        });

        autoCaptionCheckbox.addEventListener('change', function() {
            const parentLabel = this.closest('.toggle-switch');
            parentLabel.classList.toggle('is-checked', this.checked);
            if (this.checked) {
                captionCheckbox.checked = false;
                captionCheckbox.closest('.toggle-switch').classList.remove('is-checked');
            }
        });
        
        // Mutual exclusivity logic for Captions (placeholder) and Auto-Caption (Customize Modal)
        customizeCaptionCheckbox.addEventListener('change', function() {
    const parentLabel = this.closest('.toggle-switch');
    parentLabel.classList.toggle('is-checked', this.checked);
    updateCustomizeModalPreview(); // Ensure preview updates when caption is toggled
});


        /**
         * Initializes the visual state of toggle switches.
         * This function ONLY applies the 'is-checked' class based on the checkbox's 'checked' property.
         * @param {HTMLElement} [container=document] - The container element to search for toggle switches.
         */
        function initializeToggleSwitchesVisuals(container = document) {
            container.querySelectorAll('.toggle-switch input[type="checkbox"]').forEach(checkbox => {
                const parentLabel = checkbox.closest('.toggle-switch');
                if (checkbox.checked) {
                    parentLabel.classList.add('is-checked');
                } else {
                    parentLabel.classList.remove('is-checked');
                }
            });
        }


        function openOptionsModalCustomize() {
            const selectedValue = tableSearchDropdown.value;
            const tableInfo = tableDataMap.get(selectedValue);
            let selectedTableElement = null;

            if (tableInfo) {
                const doc = new DOMParser().parseFromString(tableInfo.outerHTML, 'text/html');
                selectedTableElement = doc.querySelector('table');
            }

            customizePageIdPrefixInput.value = selectedTableElement ? selectedTableElement.id : '';

            if (selectedTableElement) {
                const tableClasses = Array.from(selectedTableElement.classList);
                
                customizeMakeTfootFromColspanCheckbox.checked = true; // Default to true, as it's an action
                customizeFixEmptyCellsCheckbox.checked = true; // Default to true, as it's an action
                customizeRemovePTagsCheckbox.checked = false; // Default to false, as it's a destructive action

                customizeCaptionCheckbox.checked = !!selectedTableElement.querySelector('caption');

                customizeClassSmallCheckboxElement.checked = tableClasses.includes('small');
                const allTrs = Array.from(selectedTableElement.querySelectorAll('tr'));
                customizeAddSmallToTrCheckbox.checked = allTrs.length > 0 && allTrs.every(tr => tr.classList.contains('small'));

                customizeClassTablesCheckbox.checked = tableClasses.includes('table') && tableClasses.includes('table-condensed');
                const thead = selectedTableElement.querySelector('thead');
                customizeHeaderCheckbox.checked = thead && thead.querySelector('tr th') !== null;
                const tbody = selectedTableElement.querySelector('tbody');
                customizeRowHeaderCheckbox.checked = tbody && Array.from(tbody.querySelectorAll('tr')).some(row => row.firstElementChild?.tagName.toLowerCase() === 'th');

                customizeBorderedCheckbox.checked = tableClasses.includes('table-bordered');
                customizeStripedCheckbox.checked = tableClasses.includes('table-striped');
                customizeHoverCheckbox.checked = tableClasses.includes('table-hover');
                
                customizeActiveColHeadersCheckbox.checked = thead && Array.from(thead.querySelectorAll('tr')).some(tr => tr.classList.contains('active'));
                customizeActiveColspanHeadersCheckbox.checked = Array.from(selectedTableElement.querySelectorAll('th[colspan]')).some(th => th.classList.contains('active'));
                customizeActiveRowHeadersCheckbox.checked = Array.from(selectedTableElement.querySelectorAll('tbody tr > th:first-child')).some(th => th.classList.contains('active'));
                
                const lastTbodyRow = selectedTableElement.querySelector('tbody > tr:last-child');
                const lastRowIsTotal = lastTbodyRow && lastTbodyRow.querySelector('th')?.textContent.toLowerCase().includes('total');
                customizeBoldTotalsCheckbox.checked = lastRowIsTotal && Array.from(lastTbodyRow.querySelectorAll('td')).some(td => td.querySelector('strong'));

                customizeFinanceTableCheckbox.checked = Array.from(selectedTableElement.querySelectorAll('td')).some(td => td.classList.contains('nowrap'));
                
                const setAlignmentButtonState = (groupId, element, defaultAlign) => {
                    let inferredAlignment = defaultAlign;
                    if (element) {
                        if (element.classList.contains('text-left')) inferredAlignment = 'left';
                        else if (element.classList.contains('text-center')) inferredAlignment = 'center';
                        else if (element.classList.contains('text-right')) inferredAlignment = 'right';
                    }
                    customizeModalOverlay.querySelectorAll(`#${groupId} button`).forEach(btn => {
                        btn.classList.toggle('active', btn.dataset.align === inferredAlignment);
                    });
                    return inferredAlignment;
                };

                const captionElement = selectedTableElement.querySelector('caption');
                window.customizeCaptionAlignment = setAlignmentButtonState('customize-caption-alignment-group', captionElement, 'left');
                window.customizeColHeaderAlignment = setAlignmentButtonState('customize-col-headers-alignment-group', thead?.querySelector('th'), 'none');
                window.customizeRowHeaderAlignment = setAlignmentButtonState('customize-row-headers-alignment-group', tbody?.querySelector('tr > th:first-child'), 'none');
                window.customizeColspanHeaderAlignment = setAlignmentButtonState('customize-colspan-headers-alignment-group', selectedTableElement.querySelector('th[colspan]'), 'none');
                window.customizeDataCellsAlignment = setAlignmentButtonState('customize-data-cells-alignment-group', selectedTableElement.querySelector('tbody td'), 'none');

            } else {
                // Default resets if no table selected
                customizePageIdPrefixInput.value = '';
                [
                    customizeMakeTfootFromColspanCheckbox, customizeFixEmptyCellsCheckbox,
                    customizeCaptionCheckbox, customizeClassSmallCheckboxElement, customizeAddSmallToTrCheckbox,
                    customizeClassTablesCheckbox, customizeHeaderCheckbox, customizeRowHeaderCheckbox,
                    customizeBorderedCheckbox, customizeActiveColHeadersCheckbox, customizeActiveColspanHeadersCheckbox
                ].forEach(cb => cb.checked = true);

                // Reset alignments
                customizeModalOverlay.querySelectorAll('.button-group button.active').forEach(b => b.classList.remove('active'));
                customizeModalOverlay.querySelector('#customize-caption-alignment-group button[data-align="left"]').classList.add('active');
                customizeModalOverlay.querySelectorAll('#customize-col-headers-alignment-group button[data-align="none"], #customize-row-headers-alignment-group button[data-align="none"], #customize-colspan-headers-alignment-group button[data-align="none"], #customize-data-cells-alignment-group button[data-align="none"]').forEach(b => b.classList.add('active'));
                window.customizeCaptionAlignment = 'left';
                window.customizeColHeaderAlignment = 'none';
                window.customizeRowHeaderAlignment = 'none';
                window.customizeColspanHeaderAlignment = 'none';
                window.customizeDataCellsAlignment = 'none';
            }
            
            initializeToggleSwitchesVisuals(customizeModalOverlay);
            updateCustomizeModalPreview(tableInfo ? tableInfo.outerHTML : '');
        }

        // New button event listeners for Clear All, Auto-Encode, Auto-Indent, Copy Code, Import/Export
        copyCodeBtn.addEventListener('click', async () => {
            const codeContent = monacoEditor ? monacoEditor.getValue() : '';
            try {
                // Use a temporary textarea for copying to clipboard as navigator.clipboard.writeText might not work in iframes
                const tempTextArea = document.createElement('textarea');
                tempTextArea.value = codeContent;
                document.body.appendChild(tempTextArea);
                tempTextArea.select();
                document.execCommand('copy');
                document.body.removeChild(tempTextArea);

                const originalText = copyCodeBtn.textContent;
                copyCodeBtn.textContent = 'Copied!';
                copyCodeBtn.classList.add('bg-green-500', 'hover:bg-green-600');
                copyCodeBtn.classList.remove('bg-zinc-700', 'hover:bg-zinc-600');
                copyCodeBtn.setAttribute('data-temp-active', 'true');
                updateAllInteractiveButtonStates();
                setTimeout(() => {
                    copyCodeBtn.textContent = originalText;
                    copyCodeBtn.classList.remove('bg-green-500', 'hover:bg-green-600');
                    copyCodeBtn.classList.add('bg-zinc-700', 'hover:bg-zinc-600');
                    copyCodeBtn.removeAttribute('data-temp-active');
                    updateAllInteractiveButtonStates();
                }, 1500);
            } catch (err) {
                console.error('Failed to copy text: ', err);
                showMessage('Failed to copy code. Please try again or copy manually.', 'error');
            }
        });

        autoFormatBtn.addEventListener('click', () => {
            if (monacoEditor) {
                let currentContent = monacoEditor.getValue();
                currentContent = protectDataAttributes(currentContent); // Protect attributes

                let formattedContent = html_beautify(currentContent, {
                    indent_size: 4,
                    space_in_paren: true
                });

                formattedContent = restoreDataAttributes(formattedContent); // Restore attributes
                formattedContent = convertAllEntitiesToNumeric(formattedContent); // Ensure entities are correct

                monacoEditor.setValue(formattedContent);
                applyEntityHighlighting();

                const originalText = autoFormatBtn.textContent;
                autoFormatBtn.textContent = 'Formatted!';
                autoFormatBtn.classList.add('bg-green-500', 'hover:bg-green-600');
                autoFormatBtn.classList.remove('bg-red-700', 'hover:bg-red-800');
                autoFormatBtn.setAttribute('data-temp-active', 'true');
                updateAllInteractiveButtonStates();
                setTimeout(() => {
                    autoFormatBtn.textContent = originalText;
                    autoFormatBtn.classList.remove('bg-green-500', 'hover:bg-green-600');
                    autoFormatBtn.classList.add('bg-red-700', 'hover:bg-red-800');
                    autoFormatBtn.removeAttribute('data-temp-active');
                    updateAllInteractiveButtonStates();
                }, 1500);
            }
        });

        autoEncodeBtn.addEventListener('click', () => {
            if (monacoEditor) {
                let currentContent = monacoEditor.getValue();
                currentContent = protectDataAttributes(currentContent); // Protect attributes
                let encodedContent = convertAllEntitiesToNumeric(currentContent); // Apply encoding
                encodedContent = restoreDataAttributes(encodedContent); // Restore attributes

                monacoEditor.setValue(encodedContent);
                applyEntityHighlighting();

                const originalText = autoEncodeBtn.textContent;
                autoEncodeBtn.textContent = 'Encoded!';
                autoEncodeBtn.classList.add('bg-green-500', 'hover:bg-green-600');
                autoEncodeBtn.classList.remove('bg-red-700', 'hover:bg-red-800');
                autoEncodeBtn.setAttribute('data-temp-active', 'true');
                updateAllInteractiveButtonStates();
                setTimeout(() => {
                    autoEncodeBtn.textContent = originalText;
                    autoEncodeBtn.classList.remove('bg-green-500', 'hover:bg-green-600');
                    autoEncodeBtn.classList.add('bg-red-700', 'hover:bg-red-800');
                    autoEncodeBtn.removeAttribute('data-temp-active');
                    updateAllInteractiveButtonStates();
                }, 1500);
            }
        });

        exportHtmlBtn.addEventListener('click', () => {
            const htmlContent = monacoEditor ? monacoEditor.getValue() : '';
            const blob = new Blob([htmlContent], { type: 'text/html' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'table_formatter_output.html'; // Default filename
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            const originalText = exportHtmlBtn.textContent;
            exportHtmlBtn.textContent = 'Exported!';
            exportHtmlBtn.classList.add('bg-green-500', 'hover:bg-green-600');
            exportHtmlBtn.classList.remove('bg-red-700', 'hover:bg-red-800');
            exportHtmlBtn.setAttribute('data-temp-active', 'true');
            updateAllInteractiveButtonStates();
            setTimeout(() => {
                exportHtmlBtn.textContent = originalText;
                exportHtmlBtn.classList.remove('bg-green-500', 'hover:bg-green-600');
                exportHtmlBtn.classList.add('bg-red-700', 'hover:bg-red-800');
                exportHtmlBtn.removeAttribute('data-temp-active');
                updateAllInteractiveButtonStates();
            }, 1500);
        });

        importHtmlBtn.addEventListener('click', () => htmlFileInput.click());
        htmlFileInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const importedContent = e.target.result;
                    if (monacoEditor) {
                        monacoEditor.setValue(importedContent);
                        applyEntityHighlighting();
                    }
                    const originalText = importHtmlBtn.textContent;
                    importHtmlBtn.textContent = 'Imported!';
                    importHtmlBtn.classList.add('bg-green-500', 'hover:bg-green-600');
                    importHtmlBtn.classList.remove('bg-purple-700', 'hover:bg-purple-800');
                    importHtmlBtn.setAttribute('data-temp-active', 'true');
                    updateAllInteractiveButtonStates();
                    setTimeout(() => {
                        importHtmlBtn.textContent = originalText;
                        importHtmlBtn.classList.remove('bg-green-500', 'hover:bg-green-600');
                        importHtmlBtn.classList.add('bg-purple-700', 'hover:bg-purple-800');
                        htmlFileInput.value = null; // Clear the input so same file can be imported again
                        importHtmlBtn.removeAttribute('data-temp-active');
                        updateAllInteractiveButtonStates();
                    }, 1500);
                };
                reader.readAsText(file);
            }
        });

        clearAllBtn.addEventListener('click', () => {
            if (monacoEditor) {
                monacoEditor.setValue('');
                showMessage('Editor content cleared.', 'info');
                const originalText = clearAllBtn.textContent;
                clearAllBtn.textContent = 'Cleared!';
                clearAllBtn.classList.add('bg-green-500', 'hover:bg-green-600');
                clearAllBtn.classList.remove('bg-zinc-700', 'hover:bg-zinc-600');
                clearAllBtn.setAttribute('data-temp-active', 'true');
                updateAllInteractiveButtonStates();
                setTimeout(() => {
                    clearAllBtn.textContent = originalText;
                    clearAllBtn.classList.remove('bg-green-500', 'hover:bg-green-600');
                    clearAllBtn.classList.add('bg-zinc-700', 'hover:bg-zinc-600');
                    clearAllBtn.removeAttribute('data-temp-active');
                    updateAllInteractiveButtonStates();
                }, 1500);
            }
        });

        // Event listener for the table search dropdown
        tableSearchDropdown.addEventListener('change', () => {
            const selectedValue = tableSearchDropdown.value;
            clearMonacoHighlight();

            if (selectedValue && monacoEditor) {
                const model = monacoEditor.getModel();
                const tableInfo = tableDataMap.get(selectedValue);

                if (tableInfo && tableInfo.startIndex !== -1) {
                    const position = model.getPositionAt(tableInfo.startIndex);
                    monacoEditor.revealLineInCenter(position.lineNumber, monaco.editor.ScrollType.Smooth);
                    
                    const endPosition = model.getPositionAt(tableInfo.startIndex + tableInfo.length);

                    currentHighlightDecorationId = model.deltaDecorations([], [{
                        range: new monaco.Range(position.lineNumber, position.column, endPosition.lineNumber, endPosition.column),
                        options: { isTransparent: true, className: 'selected-line-highlight' }
                    }]);
                    
                    openOptionsModalCustomize();
                } else {
                    updateCustomizePreview('');
                }
            } else {
                updateCustomizePreview('');
            }
        });

        // Listen for messages from the iframe (for content updates)
        window.addEventListener('message', (event) => {
            if (event.data && event.data.type === 'iframeReady') {
                // When iframe is ready, send the initial mode (no longer needed, but keeping for general iframe communication)
            } else if (event.data && event.data.type === 'updateTableContent') {
                const updatedTableHtml = event.data.tableHtml;
                const selectedValue = tableSearchDropdown.value;
                const tableInfo = tableDataMap.get(selectedValue);

                if (tableInfo && monacoEditor) {
                    const newLength = updatedTableHtml.length;
                    
                    monacoEditor.executeEdits('iframe-update', [{
                        range: new monaco.Range(
                            monacoEditor.getModel().getPositionAt(tableInfo.startIndex).lineNumber,
                            monacoEditor.getModel().getPositionAt(tableInfo.startIndex).column,
                            monacoEditor.getModel().getPositionAt(tableInfo.startIndex + tableInfo.length).lineNumber,
                            monacoEditor.getModel().getPositionAt(tableInfo.startIndex + tableInfo.length).column
                        ),
                        text: updatedTableHtml
                    }]);

                    tableInfo.length = newLength;
                    tableInfo.outerHTML = updatedTableHtml;
                    applyEntityHighlighting();
                    tableSearchDropdown.value = selectedValue;
                }
            }
        });

        // Wrap Monaco editor initialization and main event listener attachments in window.onload
        window.onload = function() {
            console.log('Window loaded, initializing Monaco Editor...'); // Debugging log
            require.config({ paths: { 'vs': 'https://cdn.jsdelivr.net/npm/monaco-editor@0.49.0/min/vs' }});
            require(['vs/editor/editor.main'], function() {
                monacoEditor = monaco.editor.create(document.getElementById('editor-container'), {
                    value: `<table>
      <tbody>
        <tr>
          <td>&nbsp;</td>
          <td>North</td>
          <td>South</td>
          <td>East</td>
          <td>West</td>
        </tr>
        <tr>
          <td>Electronics</td>
          <td>100</td>
          <td>150,50</td>
          <td>120 000</td>
          <td>180.75</td>
        </tr>
        <tr>
          <td>Apparel</td>
          <td>80.00</td>
          <td>-120</td>
          <td>90 000.50</td>
          <td>+110,25</td>
        </tr>
        <tr>
          <td>Books</td>
          <td>50</td>
          <td>70</td>
          <td>60</td>
          <td>90</td>
        </tr>
         <tr>
          <td>Food</td>
          <td>120</td>
          <td>100</td>
          <td>140</td>
          <td>140</td>
        </tr>
        <tr>
          <td colspan="5">This is a colspan spanning the entire table.</td>
        </tr>
      </tbody>
    </table>
<figure>
    <table id="tbl11">
        <thead>
            <tr>
                <th rowspan="2">Category</th>
                <th colspan="2">Q1 Sales</th>
                <th colspan="2">Q2 Sales</th>
            </tr>
            <tr>
                <th>Jan</th>
                <th>Feb</th>
                <th>Mar</th>
                <th>Apr</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <th>Electronics</th>
                <td>100</td>
                <td>150</td>
                <td>120</td>
                <td>180</td>
            </tr>
            <tr>
                <th>Apparel</th>
                <td>80</td>
                <td>-120</td>
                <td>90</td>
                <td>110</td>
            </tr>
            <tr>
                <th>Books</th>
                <td>50</td>
                <td>70</td>
                <td>60</td>
                <td>90</td>
            </tr>
        </tbody>
    </table>
</figure>
    <p>Table with existing ID and caption:</p>
    <table id="myExistingTable" class="some-custom-class">
        <caption>Existing Caption with more info</caption>
        <thead>
            <tr><th colspan="2">Existing Header Group</th></tr>
        </thead>
        <tbody>
            <tr><td>Data 1</td><td>Data 2</td></tr>
        </tbody>
    </table>
    <table>
        <thead>
            <tr>
                <th>Header 1</th>
                <th>Header 2</th>
                <th>Header 3</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <th>Row Header A</th>
                <td></td> <!-- Test empty td -->
                <td>Data A2</td>
            </tr>
            <tr>
                <th></th> <!-- Test empty th -->
                <td>Data B1</td>
                <td>Data B2</td>
            </tr>
            <tr>
                <td> <p></p> </td> <!-- Test td with empty p tag -->
                <td>Data C1</td>
                <td>Data C2</td>
            </tr>
            <tr>
                <td>  </td> <!-- Test td with only spaces -->
                <td>Data D1</td>
                <td>Data D2</td>
            </tr>
            <tr>
                <td>&nbsp;</td> <!-- Test td with existing nbsp -->
                <td>Data E1</td>
                <td>Data E2</td>
            </tr>
        </tbody>
    </table>

    `,
                    language: 'html',
                    theme: 'vs-dark',
                    automaticLayout: true,
                    minimap: { enabled: false }
                });

                populateTableSearchDropdown();

                monacoEditor.onDidChangeModelContent(() => {
                    clearTimeout(window.monacoUpdateTimeout);
                    window.monacoUpdateTimeout = setTimeout(() => {
                        applyEntityHighlighting();
                        populateTableSearchDropdown();
                    }, 500); // 500ms delay
                });


                applyEntityHighlighting();

                customizePageIdPrefixInput.addEventListener('input', function() {
                    updateCustomizeModalPreview();
                    customizePreviewIframe.contentWindow.postMessage({ type: 'updateTableId', newId: this.value.trim() }, '*');
                });

                const allCustomizeCheckboxes = [
                    customizeMakeTfootFromColspanCheckbox, customizeCaptionCheckbox, customizeFixEmptyCellsCheckbox, customizeRemovePTagsCheckbox,
                    customizeClassSmallCheckboxElement, customizeAddSmallToTrCheckbox, customizeClassTablesCheckbox,
                    customizeHeaderCheckbox, customizeRowHeaderCheckbox, customizeBorderedCheckbox,
                    customizeStripedCheckbox, customizeHoverCheckbox, customizeActiveColHeadersCheckbox,
                    customizeActiveColspanHeadersCheckbox, customizeActiveRowHeadersCheckbox, customizeBoldTotalsCheckbox,
                    customizeFinanceTableCheckbox
                ];

                allCustomizeCheckboxes.forEach(checkbox => {
                    checkbox.addEventListener('change', function() {
                        const parentLabel = this.closest('.toggle-switch');
                        parentLabel.classList.toggle('is-checked', this.checked);
                        updateCustomizeModalPreview();
                    });
                });

                const universalFormatCheckboxes = [
                    idCheckbox, makeTfootFromColspanCheckbox, captionCheckbox,
                    autoCaptionCheckbox, fixEmptyCellsCheckbox, removePTagsCheckbox,
                    classSmallCheckboxElement, addSmallToTrCheckbox, classTablesCheckbox, headerCheckbox,
                    rowHeaderCheckbox, activeColHeadersCheckbox, activeColspanHeadersCheckbox, activeRowHeadersCheckbox,
                    borderedCheckbox, stripedCheckbox, hoverCheckbox, boldTotalsCheckbox, financeTableCheckbox
                ];

                universalFormatCheckboxes.forEach(checkbox => {
                    checkbox.addEventListener('change', function() {
                        this.closest('.toggle-switch').classList.toggle('is-checked', this.checked);
                    });
                });
            });
        };
    </script>
</body>
</html>
