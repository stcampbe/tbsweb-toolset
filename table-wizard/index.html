<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Monaco HTML Table Formatter</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for overall layout and aesthetics (Dark Theme) */
        body {
            font-family: 'Inter', sans-serif; /* Using Inter font */
            display: flex;
            justify-content: center;
            align-items: flex-start; /* Align to top for better vertical flow */
            min-height: 100vh;
            background-color: #0f172a; /* Very dark blue-gray background (slate-900) */
            padding: 1.5rem 1rem; /* Reduced vertical padding */
            box-sizing: border-box; /* Ensure padding doesn't cause overflow */
        }
        .main-wrapper { /* New wrapper for sidebar and main content */
            background-color: #1e293b; /* Dark blue-gray background (slate-800) */
            border-radius: 1.25rem; /* Slightly less rounded corners */
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.4); /* Slightly less strong shadow */
            padding: 2rem; /* Reduced padding */
            width: 100%;
            max-width: 1100px; /* Slightly reduced max width */
            display: flex;
            flex-direction: column; /* Default to column on small screens */
            gap: 1.5rem; /* Reduced gap between sections */
        }

        /* Responsive layout for desktop (sidebar on right, editor on left) */
        @media (min-width: 1024px) { /* Apply on large screens and up (lg breakpoint) */
            .main-wrapper {
                flex-direction: row-reverse; /* Row-reverse direction for desktop to put sidebar on right */
                align-items: flex-start; /* Align items to the top */
                justify-content: space-between; /* Space between sidebar and main content */
            }
            #options-sidebar {
                width: 300px; /* Reduced fixed width for the sidebar */
                flex-shrink: 0; /* Prevent sidebar from shrinking */
                padding-left: 1rem; /* Reduced space to the left of the sidebar */
            }
            #main-content {
                flex-grow: 1; /* Allow main content to take remaining space */
                max-width: calc(100% - 300px - 1.5rem); /* Calculate max width considering sidebar and gap */
            }
        }

        #editor-container { /* Container for Monaco Editor */
            border: 1px solid #4a5568; /* Darker border for editor */
            border-radius: 0.625rem; /* Slightly less rounded corners for editor */
            height: 550px; /* Slightly reduced height for the editor */
            overflow: hidden; /* Ensure rounded corners clip content */
            margin-bottom: 1.5rem; /* Reduced space between editor and buttons */
        }

        /* Responsive tables styling for horizontal scrolling */
        .table-responsive {
            overflow-x: auto; /* Enable horizontal scrolling */
            -webkit-overflow-scrolling: touch; /* Smooth scrolling on iOS */
        }

        /* Message box animation */
        .message-box-fade-in {
            animation: fadeIn 0.5s ease-out forwards;
        }

        .message-box-fade-out {
            animation: fadeOut 0.5s ease-in forwards;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        @keyframes fadeOut {
            from { opacity: 1; transform: translateY(0); }
            to { opacity: 0; transform: translateY(-10px); }
        }

        /* Fieldset specific styling */
        fieldset {
            border: none; /* Explicitly remove border */
            border-radius: 0.625rem; /* Slightly less rounded */
            padding: 0.75rem 1rem; /* Reduced vertical and horizontal padding for better spacing */
            margin-bottom: 1rem; /* Reduced space between fieldsets */
        }

        /* Custom styles for Pill-style Toggle Switches */
        .toggle-switch {
            position: relative;
            display: inline-flex;
            align-items: center;
            cursor: pointer;
            user-select: none;
            font-size: 0.9375rem; /* Slightly smaller font size for label */
        }

        .toggle-switch input[type="checkbox"] {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-switch .slider {
            background-color: #4a5568; /* Darker gray for default state (gray-700) */
            border-radius: 9999px; /* Fully rounded */
            width: 2.5rem; /* ~40px */
            height: 1.25rem; /* ~20px */
            transition: background-color 0.3s ease;
            position: relative;
            flex-shrink: 0; /* Prevent slider from shrinking */
        }

        .toggle-switch .slider:before {
            content: '';
            position: absolute;
            height: 1rem; /* ~16px */
            width: 1rem; /* ~16px */
            left: 2px;
            bottom: 2px;
            background-color: white;
            border-radius: 50%;
            transition: transform 0.3s ease;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }

        .toggle-switch input[type="checkbox"]:checked + .slider {
            background-color: #3b82f6; /* Tailwind blue-500 on checked */
        }

        .toggle-switch input[type="checkbox"]:checked + .slider:before {
            transform: translateX(1.25rem); /* Move slider to the right (40px - 16px - 2*2px = 20px move) */
        }

        .toggle-switch .toggle-label {
            color: #e2e8f0; /* Light text for toggle labels (gray-200) */
            font-size: 0.875rem; /* Reduced font size for labels (text-sm) */
        }
    </style>
</head>
<body>
    <div class="main-wrapper">
        <!-- Sidebar for Options -->
        <div id="options-sidebar" class="p-6 bg-gray-800 rounded-xl shadow-inner border border-gray-700">
            <h2 class="text-xl font-semibold text-gray-100 mb-4 text-left">Page Settings</h2> <!-- Reduced text size -->

            <!-- Table Identification & Basic Settings -->
            <fieldset>
                <div class="grid grid-cols-1 gap-y-3 gap-x-6 mb-3"> <!-- Reduced gap-y and mb -->
                    <!-- ID Prefix Input -->
                    <div class="flex items-center gap-2"> <!-- Reduced gap -->
                        <label for="id-prefix-input" class="text-gray-200 text-sm font-medium">ID Prefix:</label>
                        <input type="text" id="id-prefix-input" value="tbl" class="w-24 px-2 py-1 border border-gray-600 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-400 focus:border-blue-400 text-sm bg-gray-700 text-white"> <!-- Reduced width, padding, and text size -->
                    </div>
                    <!-- ID Tables Checkbox -->
                    <label class="toggle-switch">
                        <input type="checkbox" id="id-checkbox" class="hidden"> <!-- Unchecked by default -->
                        <span class="slider"></span>
                        <span class="toggle-label ml-2 text-gray-200">ID Tables</span> <!-- Reduced ml -->
                    </label>
                    <!-- Caption Tables Checkbox -->
                    <label class="toggle-switch">
                        <input type="checkbox" id="caption-checkbox" class="hidden" checked>
                        <span class="slider"></span>
                        <span class="toggle-label ml-2 text-gray-200">Caption Tables</span>
                    </label>
                    <!-- Child option for Caption Tables, with indentation -->
                    <div class="pl-6 grid grid-cols-1 gap-y-3 gap-x-6"> <!-- Reduced pl and gap-y -->
                        <label class="toggle-switch">
                            <input type="checkbox" id="center-caption-checkbox" class="hidden">
                            <span class="slider"></span>
                            <span class="toggle-label ml-2 text-gray-200">Center Captions</span>
                        </label>
                    </div>

                    <!-- Moved Column Headers + THEAD here -->
                    <label class="toggle-switch">
                        <input type="checkbox" id="header-checkbox" class="hidden" checked>
                        <span class="slider"></span>
                        <span class="toggle-label ml-2 text-gray-200">Column Headers + THEAD</span>
                    </label>
                    <!-- Moved Row Headers in TBODY here -->
                    <label class="toggle-switch">
                        <input type="checkbox" id="row-header-checkbox" class="hidden" checked>
                        <span class="slider"></span>
                        <span class="toggle-label ml-2 text-gray-200">Row Headers in TBODY</span>
                    </label>

                    <!-- Responsive Tables Checkbox -->
                    <label class="toggle-switch">
                        <input type="checkbox" id="responsive-tables-checkbox" class="hidden" checked>
                        <span class="slider"></span>
                        <span class="toggle-label ml-2 text-gray-200">Responsive Tables</span>
                    </label>
                    <!-- Child option for Responsive Tables, with indentation -->
                    <div class="pl-6 grid grid-cols-1 gap-y-3 gap-x-6"> <!-- Reduced pl and gap-y -->
                        <label class="toggle-switch">
                            <input type="checkbox" id="responsive-small-checkbox" class="hidden">
                            <span class="slider"></span>
                            <span class="toggle-label ml-2 text-gray-200">Add Small</span>
                        </label>
                    </div>
                </div>
            </fieldset>

            <!-- Class & Structure Options -->
            <fieldset>
                <div class="grid grid-cols-1 gap-y-3 gap-x-6 mb-3"> <!-- Reduced gap-y and mb -->
                    <!-- Class Tables Checkbox (Parent for new style options) -->
                    <label class="toggle-switch">
                        <input type="checkbox" id="class-tables-checkbox" class="hidden" checked>
                        <span class="slider"></span>
                        <span class="toggle-label ml-2 text-gray-200">Class Tables</span>
                    </label>
                    <!-- Child options for Class Tables, with indentation -->
                    <div class="pl-6 grid grid-cols-1 gap-y-3 gap-x-6"> <!-- Reduced pl and gap-y -->
                        <label class="toggle-switch">
                            <input type="checkbox" id="bordered-checkbox" class="hidden" checked>
                            <span class="slider"></span>
                            <span class="toggle-label ml-2 text-gray-200">Bordered</span>
                        </label>
                        <label class="toggle-switch">
                            <input type="checkbox" id="striped-checkbox" class="hidden">
                            <span class="slider"></span>
                            <span class="toggle-label ml-2 text-gray-200">Striped</span>
                        </label>
                        <label class="toggle-switch">
                            <input type="checkbox" id="hover-checkbox" class="hidden">
                            <span class="slider"></span>
                            <span class="toggle-label ml-2 text-gray-200">Hover</span>
                        </label>
                        <label class="toggle-switch">
                            <input type="checkbox" id="active-col-headers-checkbox" class="hidden" checked>
                            <span class="slider"></span>
                            <span class="toggle-label ml-2 text-gray-200">Active Column Headers</span>
                        </label>
                        <label class="toggle-switch">
                            <input type="checkbox" id="active-row-headers-checkbox" class="hidden">
                            <span class="slider"></span>
                            <span class="toggle-label ml-2 text-gray-200">Active Row Headers</span>
                        </label>
                        <label class="toggle-switch">
                            <input type="checkbox" id="active-colspan-headers-checkbox" class="hidden" checked>
                            <span class="slider"></span>
                            <span class="toggle-label ml-2 text-gray-200">Active Colspan Headers</span>
                        </label>
                        <!-- Moved "Center Column Headers" here -->
                        <label class="toggle-switch">
                            <input type="checkbox" id="center-column-headers-checkbox" class="hidden">
                            <span class="slider"></span>
                            <span class="toggle-label ml-2 text-gray-200">Center Column Headers</span>
                        </label>
                        <!-- Moved and renamed "Center Body Headers" here -->
                        <label class="toggle-switch">
                            <input type="checkbox" id="center-colspan-headers-checkbox" class="hidden">
                            <span class="slider"></span>
                            <span class="toggle-label ml-2 text-gray-200">Center Colspan Headers</span>
                        </label>
                        <!-- New Center All Data Option -->
                        <label class="toggle-switch">
                            <input type="checkbox" id="center-all-data-checkbox" class="hidden">
                            <span class="slider"></span>
                            <span class="toggle-label ml-2 text-gray-200">Center All Data</span>
                        </label>
                         <!-- Moved Finance Table here -->
                        <label class="toggle-switch">
                            <input type="checkbox" id="finance-table-checkbox" class="hidden">
                            <span class="slider"></span>
                            <span class="toggle-label ml-2 text-gray-200">Finance Table</span>
                        </label>
                        <!-- Moved Bold Totals here -->
                        <label class="toggle-switch">
                            <input type="checkbox" id="bold-totals-checkbox" class="hidden">
                            <span class="slider"></span>
                            <span class="toggle-label ml-2 text-gray-200">Bold Totals</span>
                        </label>
                        <label class="toggle-switch">
                            <input type="checkbox" id="class-small-checkbox" class="hidden">
                            <span class="slider"></span>
                            <span class="toggle-label ml-2 text-gray-200">Add Small</span>
                        </label>
                    </div>
                </div>
            </fieldset>
        </div>

        <!-- Main Content Area (Editor, Buttons, Message Box) -->
        <div id="main-content" class="flex flex-col flex-grow">
            <h1 class="text-4xl font-bold text-white mb-4 text-left">HTML Table Formatter</h1>

            <!-- Container for Monaco Editor -->
            <div id="editor-container"></div>

            <!-- Action Buttons -->
            <div class="flex flex-col sm:flex-row justify-center gap-4">
                <button id="format-button" class="flex-1 bg-gradient-to-r from-blue-800 to-blue-950 hover:from-blue-700 hover:to-blue-900 text-white font-bold py-3 px-6 rounded-xl shadow-lg transition duration-300 ease-in-out transform hover:scale-105 focus:outline-none focus:ring-4 focus:ring-blue-500">
                    Format Tables
                </button>
                <button id="clear-button" class="flex-1 bg-gradient-to-r from-gray-800 to-gray-950 hover:from-gray-700 hover:to-gray-900 text-white font-bold py-3 px-6 rounded-xl shadow-lg transition duration-300 ease-in-out transform hover:scale-105 focus:outline-none focus:ring-4 focus:ring-gray-500">
                    Clear Editor
                </button>
            </div>

            <!-- Message Box for alerts/errors -->
            <div id="message-box" class="hidden p-4 rounded-lg text-sm text-center transition-all duration-300 ease-in-out mt-6" role="alert"></div> <!-- Reduced mt -->
        </div>
    </div>

    <!-- Monaco Editor Loader -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.29.1/min/vs/loader.min.js"></script>
    <script>
        let monacoEditor; // Declare editor variable globally

        // Initialize Monaco Editor after the loader script is available
        require.config({ paths: { 'vs': 'https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.29.1/min/vs' }});
        require(['vs/editor/editor.main'], function() {
            monacoEditor = monaco.editor.create(document.getElementById('editor-container'), {
                value: `<table>
      <tbody>
        <tr>
          <td>&nbsp;</td>
          <td>North</td>
          <td>South</td>
          <td>East</td>
          <td>West</td>
        </tr>
        <tr>
          <td>Electronics</td>
          <td>100</td>
          <td>150,50</td>
          <td>120 000</td>
          <td>180.75</td>
        </tr>
        <tr>
          <td>Apparel</td>
          <td>80.00</td>
          <td>-120</td>
          <td>90 000.50</td>
          <td>+110,25</td>
        </tr>
        <tr>
          <td>Books</td>
          <td>50</td>
          <td>70</td>
          <td>60</td>
          <td>90</td>
        </tr>
         <tr>
          <td>Food</td>
          <td>120</td>
          <td>100</td>
          <td>140</td>
          <td>140</td>
        </tr>
        <tr>
          <td>Total</td>
          <td>1500</td>
          <td>2500</td>
          <td>3600</td>
          <td>4500</td>
        </tr>
      </tbody>
    </table>
<table id="tbl11">
    <thead>
        <tr>
            <th rowspan="2">Category</th>
            <th colspan="2">Q1 Sales</th>
            <th colspan="2">Q2 Sales</th>
        </tr>
        <tr>
            <th>Jan</th>
            <th>Feb</th>
            <th>Mar</th>
            <th>Apr</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <th>Electronics</th>
            <td>100</td>
            <td>150</td>
            <td>120</td>
            <td>180</td>
        </tr>
        <tr>
            <th>Apparel</th>
            <td>80</td>
            <td>-120</td>
            <td>90</td>
            <td>110</td>
        </tr>
        <tr>
            <th>Books</th>
            <td>50</td>
            <td>70</td>
            <td>60</td>
            <td>90</td>
        </tr>
        <tr>
            <th colspan="5">Summary by Region</th>
        </tr>
        <tr>
            <th>North Region Total</th>
            <td colspan="2">1500</td>
            <td colspan="2">2500</td>
        </tr>
        <tr>
            <th>South Region Total</th>
            <td colspan="2">3600</td>
            <td colspan="2">4500</td>
        </tr>
    </tbody>
</table>
    <table>
        <thead>
            <tr>
                <th>Header 1</th>
                <th>Header 2</th>
                <th>Header 3</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <th>Row Header A</th>
                <td>Data A1</td>
                <td>Data A2</td>
            </tr>
            <tr>
                <th>Row Header B</th>
                <td>Data B1</td>
                <td>Data B2</td>
            </tr>
        </tbody>
    </table>

    <p>Table with existing ID and caption:</p>
    <table id="myExistingTable" class="some-custom-class">
        <caption>Existing Caption with more info</caption>
        <thead>
            <tr><th colspan="2">Existing Header Group</th></tr>
        </thead>
        <tbody>
            <tr><td>Data 1</td><td>Data 2</td></tr>
        </tbody>
    </table>
    `,
                language: 'html',
                theme: 'vs-dark', /* Changed to dark theme for Monaco */
                automaticLayout: true, /* Resize editor when container resizes */
                minimap: { enabled: false } /* Disable minimap for cleaner look */
            });
        });

        const formatButton = document.getElementById('format-button');
        const clearButton = document.getElementById('clear-button');

        const idCheckbox = document.getElementById('id-checkbox');
        const idPrefixInput = document.getElementById('id-prefix-input');
        // Removed autoIdScopeCheckboxElement declaration and its corresponding HTML element
        const classTablesCheckbox = document.getElementById('class-tables-checkbox');
        const captionCheckbox = document.getElementById('caption-checkbox');
        const centerCaptionCheckbox = document.getElementById('center-caption-checkbox');
        const headerCheckbox = document.getElementById('header-checkbox');
        const rowHeaderCheckbox = document.getElementById('row-header-checkbox');

        const responsiveTablesCheckbox = document.getElementById('responsive-tables-checkbox');
        const responsiveSmallCheckbox = document.getElementById('responsive-small-checkbox');

        const borderedCheckbox = document.getElementById('bordered-checkbox');
        const stripedCheckbox = document.getElementById('striped-checkbox');
        const hoverCheckbox = document.getElementById('hover-checkbox');
        const activeColHeadersCheckbox = document.getElementById('active-col-headers-checkbox');
        const activeColspanHeadersCheckbox = document.getElementById('active-colspan-headers-checkbox');
        const activeRowHeadersCheckbox = document.getElementById('active-row-headers-checkbox');
        const classSmallCheckboxElement = document.getElementById('class-small-checkbox');


        const centerColumnHeadersCheckbox = document.getElementById('center-column-headers-checkbox');
        const centerColspanHeadersCheckbox = document.getElementById('center-colspan-headers-checkbox');
        const centerAllDataCheckbox = document.getElementById('center-all-data-checkbox');
        const financeTableCheckbox = document.getElementById('finance-table-checkbox');

        const boldTotalsCheckbox = document.getElementById('bold-totals-checkbox');

        const messageBox = document.getElementById('message-box');

        let messageTimeoutId;

        /**
         * Displays a message in the message box with animation.
         * @param {string} message - The message to display.
         * @param {string} type - 'success', 'error', or 'info' for styling.
         */
        function showMessage(message, type) {
            if (messageTimeoutId) {
                clearTimeout(messageTimeoutId);
                messageBox.classList.remove('message-box-fade-in', 'message-box-fade-out');
            }

            messageBox.textContent = message;
            messageBox.classList.remove('hidden', 'bg-green-700', 'text-white', 'bg-red-700', 'text-white', 'bg-blue-700', 'text-white');
            messageBox.classList.add('message-box-fade-in');

            if (type === 'success') {
                messageBox.classList.add('bg-green-700', 'text-white');
            } else if (type === 'error') {
                messageBox.classList.add('bg-red-700', 'text-white');
            } else { // info
                messageBox.classList.add('bg-blue-700', 'text-white');
            }

            messageTimeoutId = setTimeout(() => {
                messageBox.classList.remove('message-box-fade-in');
                messageBox.classList.add('message-box-fade-out');
                messageBox.addEventListener('animationend', function handler() {
                    messageBox.classList.add('hidden');
                    messageBox.classList.remove('message-box-fade-out');
                    messageBox.removeEventListener('animationend', handler);
                });
            }, 4500);
        }

        /**
         * This function simply returns the trimmed original string.
         * @param {string} str - The string to trim.
         * @returns {string} The original string, trimmed.
         */
        function padString(str) {
            return str.trim();
        }

        // Mutual exclusivity logic for Center All Data and Finance Table
        centerAllDataCheckbox.addEventListener('change', function() {
            if (this.checked) {
                financeTableCheckbox.checked = false;
            }
        });

        financeTableCheckbox.addEventListener('change', function() {
            if (this.checked) {
                centerAllDataCheckbox.checked = false;
            }
        });


        /**
         * Formats the HTML content, specifically targeting and cleaning up tables,
         * and optionally applies various styling and structural enhancements.
         */
        function formatHtmlTables() {
            // Ensure monacoEditor is initialized before trying to get its value
            if (!monacoEditor) {
                showMessage('Editor is still loading, please wait.', 'info');
                return;
            }

            const htmlText = monacoEditor.getValue();
            if (!htmlText.trim()) {
                showMessage('No HTML content to format.', 'info');
                return;
            }

            try {
                // We use a dummy div to parse the HTML snippet without needing full document structure.
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = htmlText;

                // Select all table elements within the parsed snippet
                const tables = tempDiv.querySelectorAll('table');

                if (tables.length === 0) {
                    showMessage('No HTML tables found to format.', 'info');
                    return;
                }

                const applyId = idCheckbox.checked;
                const customIdPrefix = idPrefixInput.value.trim();
                const currentIdRegex = new RegExp(`^(${customIdPrefix}\\d+(_r\\d+_c\\d+)?)$`);

                const applyClassTables = classTablesCheckbox.checked;
                const applyCaption = captionCheckbox.checked;
                const applyCenterCaption = centerCaptionCheckbox.checked;
                const applyHeader = headerCheckbox.checked; // Column Headers + THEAD
                const applyRowHeader = rowHeaderCheckbox.checked; // Row Headers in TBODY

                const applyResponsiveTables = responsiveTablesCheckbox.checked;
                const applyResponsiveSmall = responsiveSmallCheckbox.checked;

                const borderedCheckbox = document.getElementById('bordered-checkbox');
                const stripedCheckbox = document.getElementById('striped-checkbox');
                const hoverCheckbox = document.getElementById('hover-checkbox');
                const activeColHeaders = activeColHeadersCheckbox.checked;
                const activeColspanHeaders = activeColspanHeadersCheckbox.checked;
                const activeRowHeaders = activeRowHeadersCheckbox.checked;
                const applyClassSmall = classSmallCheckboxElement.checked;


                const applyFinanceTable = financeTableCheckbox.checked;
                const applyBoldTotals = boldTotalsCheckbox.checked;
                const applyCenterColumnHeaders = centerColumnHeadersCheckbox.checked;
                const applyCenterColspanHeaders = centerColspanHeadersCheckbox.checked;
                const applyCenterAllData = centerAllDataCheckbox.checked;

                const financeClasses = ['text-right', 'nowrap'];
                const centerClass = 'text-center';
                const alignmentClasses = ['text-left', 'text-center', 'text-right'];
                const financeRegex = /^\s*[-+]?(?:\d+|\d{1,3}(?:\s\d{3})*)(?:[.,]\d+)?\s*$/;
                const responsiveDivClass = 'table-responsive';
                const smallClass = 'small';

                let tableCounter = 1;

                tables.forEach(table => {
                    let responsiveDiv = table.parentNode;
                    const parentIsResponsiveDiv = responsiveDiv && responsiveDiv.classList.contains(responsiveDivClass);

                    if (applyResponsiveTables) {
                        if (!parentIsResponsiveDiv) {
                            responsiveDiv = document.createElement('div');
                            responsiveDiv.classList.add(responsiveDivClass);
                            table.parentNode.insertBefore(responsiveDiv, table);
                            responsiveDiv.appendChild(table);
                        }
                        if (applyResponsiveSmall) {
                            responsiveDiv.classList.add(smallClass);
                        } else {
                            responsiveDiv.classList.remove(smallClass);
                        }
                    } else {
                        if (parentIsResponsiveDiv) {
                            responsiveDiv.classList.remove(smallClass);
                            responsiveDiv.parentNode.insertBefore(table, responsiveDiv);
                            responsiveDiv.remove();
                        }
                    }

                    // --- UNCONDITIONALLY REMOVE ALL IDs, HEADERS, AND SCOPES AT THE START ---
                    // This fulfills "get rid of the ID's and headers when clicking format"
                    table.removeAttribute('id'); // Remove ID from the table itself
                    Array.from(table.querySelectorAll('th, td')).forEach(cell => {
                        cell.removeAttribute('id');
                        cell.removeAttribute('headers');
                        cell.removeAttribute('scope');
                    });
                    // --- END UNCONDITIONAL REMOVAL ---


                    // --- Table Complexity Detection ---
                    let isComplexTable = false;
                    Array.from(table.querySelectorAll('th, td')).forEach(cell => {
                        const colspan = parseInt(cell.getAttribute('colspan') || '1', 10);
                        const rowspan = parseInt(cell.getAttribute('rowspan') || '1', 10);
                        if (colspan > 1 || rowspan > 1) {
                            isComplexTable = true;
                        }
                    });
                    // --- END Table Complexity Detection ---


                    // Clear existing active, centering, and alignment classes from all cells
                    Array.from(table.querySelectorAll('th, tr, td')).forEach(el => {
                        el.classList.remove('active');
                        el.classList.remove(centerClass);
                        alignmentClasses.forEach(cls => el.classList.remove(cls));
                    });

                    // Conditional re-application of table ID based on applyId checkbox
                    if (applyId) {
                        table.id = `${customIdPrefix}${tableCounter}`;
                    }

                    const controlledClasses = ['table', 'table-bordered', 'table-striped', 'table-hover', 'table-condensed', smallClass];
                    let currentClasses = table.className.split(' ').filter(c => c.trim() !== '');
                    const newClasses = new Set(currentClasses.filter(c => !controlledClasses.includes(c)));

                    if (applyClassTables) {
                        newClasses.add('table');
                        newClasses.add('table-condensed');
                        if (borderedCheckbox.checked) newClasses.add('table-bordered');
                        if (stripedCheckbox.checked) newClasses.add('table-striped');
                        if (hoverCheckbox.checked) newClasses.add('table-hover');
                        if (applyClassSmall) newClasses.add(smallClass);
                    }
                    table.className = Array.from(newClasses).join(' ');

                    // Capture original rows here. This refers to the state before thead/tbody manipulations.
                    const originalTableRows = Array.from(table.querySelectorAll('tr'));

                    let headerRowCount = 0;
                    // Determine how many rows belong to the header (thead)
                    if (applyHeader) { // "Column Headers + THEAD"
                        let maxRowSpanEnd = -1;

                        for (let i = 0; i < originalTableRows.length; i++) {
                            const currentRow = originalTableRows[i];
                            headerRowCount = i + 1;

                            const cellsInCurrentRow = Array.from(currentRow.querySelectorAll('th, td'));
                            cellsInCurrentRow.forEach(cell => {
                                const rowspan = parseInt(cell.getAttribute('rowspan') || '1', 10);
                                maxRowSpanEnd = Math.max(maxRowSpanEnd, i + rowspan - 1);
                            });

                            if (i >= maxRowSpanEnd) {
                                break;
                            }
                        }
                    }

                    // Remove existing thead/tbody/tfoot elements to rebuild them
                    table.querySelectorAll('thead, tbody, tfoot').forEach(el => el.remove());

                    const newThead = document.createElement('thead');
                    const newTbody = document.createElement('tbody');

                    // Distribute original rows into newThead and newTbody based on headerRowCount
                    originalTableRows.forEach((row, index) => {
                        if (index < headerRowCount) {
                            // If this row is part of the header, convert its <td> elements to <th>
                            const clonedRow = row.cloneNode(true); // Clone to avoid modifying original array while iterating
                            Array.from(clonedRow.querySelectorAll('td')).forEach(td => {
                                const newTh = document.createElement('th');
                                // Copy all attributes from td to th
                                Array.from(td.attributes).forEach(attr => {
                                    newTh.setAttribute(attr.name, attr.value);
                                });
                                newTh.innerHTML = td.innerHTML; // Copy content
                                td.parentNode.replaceChild(newTh, td);
                            });
                            newThead.appendChild(clonedRow);
                        } else {
                            newTbody.appendChild(row);
                        }
                    });

                    // Append the new thead and tbody to the table
                    if (newThead.children.length > 0) {
                        table.appendChild(newThead);
                    }
                    table.appendChild(newTbody);

                    if (applyCaption) {
                        let captionElement = table.querySelector('caption');
                        if (!captionElement) {
                            captionElement = document.createElement('caption');
                            if (table.firstChild) {
                                table.insertBefore(captionElement, table.firstChild);
                            } else {
                                table.appendChild(captionElement);
                            }
                        }

                        // Always remove existing text-left before applying
                        captionElement.classList.remove('text-left', centerClass);

                        if (applyCenterCaption) {
                            captionElement.classList.add(centerClass);
                        } else {
                            captionElement.classList.add('text-left');
                        }


                        const currentCaptionText = captionElement.textContent.trim();
                        const regex = /^(Table\s+\d+\.)(\s.*)?$/i;

                        if (regex.test(currentCaptionText)) {
                            captionElement.textContent = currentCaptionText.replace(regex, `Table ${tableCounter}.$2`);
                        } else {
                            captionElement.textContent = `Table ${tableCounter}.`;
                        }

                    } else {
                        const existingCaption = table.querySelector('caption');
                        if (existingCaption) {
                            existingCaption.remove();
                        }
                    }

                    // Convert first TD in tbody rows to TH if applyRowHeader is true
                    const tbodyRows = Array.from(newTbody.querySelectorAll('tr'));
                    tbodyRows.forEach(row => {
                        const firstCell = row.firstElementChild;
                        if (firstCell) {
                            if (applyRowHeader) { // "Row Headers in TBODY"
                                if (firstCell.tagName.toLowerCase() === 'td') {
                                    const newTh = document.createElement('th');
                                    Array.from(firstCell.attributes).forEach(attr => {
                                        newTh.setAttribute(attr.name, attr.value);
                                    });
                                    newTh.innerHTML = firstCell.innerHTML;
                                    newTh.classList.add('text-left');
                                    row.replaceChild(newTh, firstCell);
                                }
                            } else {
                                if (firstCell.tagName.toLowerCase() === 'th') {
                                    const newTd = document.createElement('td');
                                    Array.from(firstCell.attributes).forEach(attr => {
                                        newTd.setAttribute(attr.name, attr.value);
                                    });
                                    newTd.innerHTML = firstCell.innerHTML;
                                    newTd.classList.remove('text-left');
                                    row.replaceChild(newTd, firstCell);
                                }
                            }
                        }
                    });

                    // Re-query the table cells after all structural manipulations for accurate ID/headers application
                    const currentTableCells = Array.from(table.querySelectorAll('th, td'));

                    // --- Auto-ID/Headers Logic now wrapped in applyId condition ---
                    // This will only run if the "ID Tables" checkbox is checked.
                    const currentTableRows = Array.from(table.querySelectorAll('tr'));
                    const grid = [];
                    let currentTableThIdCounter = 0; // Reset counter for each table

                    if (applyId) { // Only apply IDs and headers if 'ID Tables' is checked
                        if (isComplexTable) {
                            // Pass 1: Populate grid and assign sequential IDs to all THs.
                            currentTableRows.forEach((row, rowIndex) => {
                                grid[rowIndex] = grid[rowIndex] || [];
                                let currentGridCol = 0;
                                Array.from(row.children).forEach(cell => {
                                    const colspan = parseInt(cell.getAttribute('colspan') || '1', 10);
                                    const rowspan = parseInt(cell.getAttribute('rowspan') || '1', 10);

                                    // Find the next available column in the current grid row
                                    while (grid[rowIndex][currentGridCol]) {
                                        currentGridCol++;
                                    }

                                    let cellId = '';
                                    if (cell.tagName.toLowerCase() === 'th') {
                                        currentTableThIdCounter++;
                                        cellId = `${table.id || customIdPrefix}${tableCounter}_${currentTableThIdCounter}`;
                                        cell.id = cellId;
                                    }

                                    for (let r = 0; r < rowspan; r++) {
                                        grid[rowIndex + r] = grid[rowIndex + r] || [];
                                        for (let c = 0; c < colspan; c++) {
                                            grid[rowIndex + r][currentGridCol + c] = {
                                                cell: cell,
                                                isHeader: cell.tagName.toLowerCase() === 'th',
                                                id: cellId,
                                                rowspan: rowspan,
                                                colspan: colspan,
                                                startGridRow: rowIndex,
                                                startGridCol: currentGridCol
                                            };
                                        }
                                    }
                                    currentGridCol += colspan;
                                });
                            });

                            // Pass 2: Apply 'headers' attributes to THs and TDs.
                            currentTableRows.forEach((row, rowIndex) => {
                                let currentGridCol = 0;
                                Array.from(row.children).forEach(cell => {
                                    const cellColspan = parseInt(cell.getAttribute('colspan') || '1', 10);

                                    while (grid[rowIndex] && grid[rowIndex][currentGridCol] && grid[rowIndex][currentGridCol].cell !== cell) {
                                        currentGridCol++;
                                    }
                                    
                                    const cellInfo = grid[rowIndex][currentGridCol];
                                    if (!cellInfo) {
                                        currentGridCol += cellColspan;
                                        return;
                                    }

                                    let headersToApply = new Set();

                                    if (cell.tagName.toLowerCase() === 'th') {
                                        // TH in THEAD (sub-headers like Jan, Feb, or main colspan headers)
                                        if (cell.closest('thead')) {
                                            if (rowIndex > 0) {
                                                for (let c_above = 0; c_above < grid[rowIndex - 1].length; c_above++) {
                                                    const parentCellInfo = grid[rowIndex - 1][c_above];
                                                    if (parentCellInfo && parentCellInfo.isHeader && parentCellInfo.id && parentCellInfo.cell.closest('thead')) {
                                                        const parentEndGridCol = parentCellInfo.startGridCol + parentCellInfo.colspan - 1;
                                                        if (currentGridCol >= parentCellInfo.startGridCol && currentGridCol <= parentEndGridCol) {
                                                            headersToApply.add(parentCellInfo.id);
                                                            break;
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        // TH in TBODY (row headers or tbody colspan headers)
                                        else if (cell.closest('tbody')) {
                                            const topTheadRowspanCellInfo = grid[0][0];
                                            if (topTheadRowspanCellInfo && topTheadRowspanCellInfo.isHeader && topTheadRowspanCellInfo.id &&
                                                topTheadRowspanCellInfo.rowspan > 1 && topTheadRowspanCellInfo.startGridCol === 0) {
                                                headersToApply.add(topTheadRowspanCellInfo.id);
                                            }

                                            for (let r_search = 0; r_search < rowIndex; r_search++) {
                                                if (grid[r_search] && grid[r_search][0] && grid[r_search][0].isHeader && grid[r_search][0].id &&
                                                    grid[r_search][0].cell.closest('tbody') && parseInt(grid[r_search][0].cell.getAttribute('colspan') || '1', 10) > 1) {
                                                    const groupHeaderEndRow = grid[r_search][0].startGridRow + grid[r_search][0].rowspan - 1;
                                                    if (rowIndex >= grid[r_search][0].startGridRow && rowIndex <= groupHeaderEndRow) {
                                                        headersToApply.add(grid[r_search][0].id);
                                                    }
                                                }
                                            }
                                        }

                                        if (headersToApply.size > 0) {
                                            cell.setAttribute('headers', Array.from(headersToApply).sort().join(' '));
                                        } else {
                                            cell.removeAttribute('headers');
                                        }

                                    } else if (cell.tagName.toLowerCase() === 'td') {
                                        // 1. Column Headers from THEAD
                                        Array.from(newThead.querySelectorAll('th')).forEach(theadTh => {
                                            const theadThId = theadTh.id;
                                            if (!theadThId) return;

                                            let theadThGridInfo = null;
                                            for(let r_g = 0; r_g < grid.length; r_g++) {
                                                if(grid[r_g]) {
                                                    for(let c_g = 0; c_g < grid[r_g].length; c_g++) {
                                                        if(grid[r_g][c_g] && grid[r_g][c_g].cell === theadTh) {
                                                            theadThGridInfo = grid[r_g][c_g];
                                                            break;
                                                        }
                                                    }
                                                }
                                                if(theadThGridInfo) break;
                                            }

                                            if (!theadThGridInfo) return;

                                            const overlapsHorizontally = (currentGridCol <= (theadThGridInfo.startGridCol + theadThGridInfo.colspan - 1) &&
                                                                        (currentGridCol + cellColspan - 1) >= theadThGridInfo.startGridCol);
                                            const isVerticallyApplicable = (rowIndex >= theadThGridInfo.startGridRow);

                                            if (overlapsHorizontally && isVerticallyApplicable) {
                                                const isTheadTopLeftRowspan = theadThGridInfo.startGridRow === 0 && theadThGridInfo.startGridCol === 0 && theadThGridInfo.rowspan > 1;
                                                if (isTheadTopLeftRowspan && currentGridCol !== 0) {
                                                    return;
                                                }
                                                headersToApply.add(theadThId);
                                            }
                                        });

                                        // 2. Row Header (from TBODY - TH in the same row, first column, colspan=1)
                                        const rowHeaderInCurrentRow = grid[rowIndex][0] && grid[rowIndex][0].isHeader && grid[rowIndex][0].cell.closest('tbody') && parseInt(grid[rowIndex][0].cell.getAttribute('colspan') || '1', 10) === 1 ? grid[rowIndex][0].cell : null;
                                        if (rowHeaderInCurrentRow && rowHeaderInCurrentRow.id) {
                                            headersToApply.add(rowHeaderInCurrentRow.id);
                                        }

                                        // 3. TBODY Colspan Headers (row group headers like tbl11_8, tbl11_14) that apply to this TD
                                        for (let r_group = 0; r_group < rowIndex; r_group++) {
                                            if (grid[r_group] && grid[r_group][0] && grid[r_group][0].isHeader && grid[r_group][0].id &&
                                                grid[r_group][0].cell.closest('tbody') && parseInt(grid[r_group][0].cell.getAttribute('colspan') || '1', 10) > 1) {
                                                const groupHeaderEndRow = grid[r_group][0].startGridRow + grid[r_group][0].rowspan - 1;
                                                if (rowIndex >= grid[r_group][0].startGridRow && rowIndex <= groupHeaderEndRow) {
                                                    headersToApply.add(grid[r_group][0].id);
                                                }
                                            }
                                        }

                                        if (headersToApply.size > 0) {
                                            cell.setAttribute('headers', Array.from(headersToApply).sort().join(' '));
                                        } else {
                                            cell.removeAttribute('headers');
                                        }
                                    }

                                    currentGridCol += cellColspan;
                                });
                            });

                        } else {
                            // Simple table: Apply Scope attributes if not complex
                            table.querySelectorAll('thead th').forEach(th => {
                                th.setAttribute('scope', 'col');
                                th.removeAttribute('id');
                                th.removeAttribute('headers');
                            });
                            table.querySelectorAll('tbody th:first-child').forEach(th => {
                                th.setAttribute('scope', 'row');
                                th.removeAttribute('id');
                                th.removeAttribute('headers');
                            });
                            table.querySelectorAll('td').forEach(td => {
                                td.removeAttribute('headers');
                                td.removeAttribute('id');
                            });
                        }
                    } // End of applyId condition
                    // --- END Auto-ID/Headers Logic ---

                    // Add <colgroup> and <col> tags based on the grid structure
                    const existingColgroup = table.querySelector('colgroup');
                    if (existingColgroup) {
                        existingColgroup.remove(); // Remove existing to recreate
                    }
                    // Only add colgroup if IDs are being applied, as grid structure relies on it
                    if (applyId && totalLogicalCols > 0) {
                        const newColgroup = document.createElement('colgroup');
                        // Always create a colgroup for the first column
                        const firstColGroup = document.createElement('colgroup');
                        firstColGroup.appendChild(document.createElement('col'));
                        newColgroup.appendChild(firstColGroup);

                        // Create a separate colgroup for the remaining columns (if any)
                        if (totalLogicalCols > 1) {
                            const remainingColGroup = document.createElement('colgroup');
                            for (let i = 1; i < totalLogicalCols; i++) { // Start from second logical column
                                remainingColGroup.appendChild(document.createElement('col'));
                            }
                            newColgroup.appendChild(remainingColGroup);
                        }
                        if (newColgroup.children.length > 0) {
                           table.prepend(newColgroup); // Add colgroup at the beginning of the table
                        }
                    }


                    // Apply finance classes or center all data, respecting mutual exclusivity
                    currentTableCells.forEach(cell => {
                        if (cell.tagName.toLowerCase() === 'td') {
                            if (applyFinanceTable) {
                                if (financeRegex.test(cell.textContent.trim())) {
                                    financeClasses.forEach(cls => cell.classList.add(cls));
                                } else {
                                    financeClasses.forEach(cls => cell.classList.remove(cls));
                                }
                            } else {
                                financeClasses.forEach(cls => cell.classList.remove(cls)); // Ensure finance classes are removed if option is off
                            }

                            if (applyCenterAllData) {
                                cell.classList.add(centerClass);
                            } else {
                                // Only remove centerClass if financeTable is also off, to avoid conflict
                                if (!applyFinanceTable) {
                                    cell.classList.remove(centerClass);
                                }
                            }
                        }
                    });

                    const boldableRows = Array.from(table.querySelectorAll('tbody tr'));
                    boldableRows.forEach(row => {
                        const thInRow = row.querySelector('th');
                        let isTotalRow = false;

                        if (thInRow && (thInRow.textContent.trim().toLowerCase() === 'total' || thInRow.textContent.trim().toLowerCase() === 'subtotal')) {
                            isTotalRow = true;
                        }

                        const tdsInRow = Array.from(row.querySelectorAll('td'));
                        tdsInRow.forEach(td => {
                            if (applyBoldTotals && isTotalRow) {
                                if (td.firstElementChild && td.firstElementChild.tagName.toLowerCase() === 'strong') {
                                    // If strong tag already exists, just update its content
                                    td.firstElementChild.innerHTML = td.textContent.trim();
                                } else {
                                    const strongElement = document.createElement('strong');
                                    strongElement.innerHTML = td.innerHTML;
                                    td.innerHTML = '';
                                    td.appendChild(strongElement);
                                }
                            } else {
                                if (td.firstElementChild && td.firstElementChild.tagName.toLowerCase() === 'strong') {
                                    const originalContent = td.firstElementChild.innerHTML;
                                    td.innerHTML = originalContent; // Remove strong tag, keep content
                                }
                            }
                        });
                    });

                    Array.from(table.querySelectorAll('thead tr')).forEach(tr => tr.classList.remove('active'));


                    const theadThs = Array.from(newThead.querySelectorAll('th'));
                    const tbodyThs = Array.from(newTbody.querySelectorAll('th'));

                    if (activeColHeaders) {
                        Array.from(newThead.querySelectorAll('tr')).forEach(tr => {
                            tr.classList.add('active');
                        });
                    }

                    if (activeColspanHeaders) {
                        tbodyThs.forEach(th => {
                            if (th.hasAttribute('colspan') && parseInt(th.getAttribute('colspan')) > 1) {
                                th.classList.add('active');
                            }
                        });
                    }

                    if (activeRowHeaders) {
                        tbodyThs.forEach(th => {
                            if (th.parentNode.firstElementChild === th) {
                                th.classList.add('active');
                            }
                        });
                    }

                    // Center Column Headers Logic (for thead th)
                    theadThs.forEach(th => {
                        const hasExistingAlignment = alignmentClasses.some(cls => th.classList.contains(cls));
                        if (applyCenterColumnHeaders) {
                            if (!hasExistingAlignment) {
                                th.classList.add(centerClass);
                            }
                        } else {
                            // Already removed at the top, but ensure no accidental re-addition
                        }
                    });

                    // Center Colspan Headers Logic (for tbody th with colspan)
                    tbodyThs.forEach(th => {
                        const hasExistingAlignment = alignmentClasses.some(cls => th.classList.contains(cls));
                        if (th.hasAttribute('colspan')) {
                            if (applyCenterColspanHeaders) {
                                if (!hasExistingAlignment) {
                                    th.classList.add(centerClass);
                                }
                            } else {
                                // Already removed at the top
                            }
                        } else {
                            // Not a colspan header, alignment determined by other settings or default
                        }
                    });

                    const finalTableRowsCleaned = Array.from(table.querySelectorAll('tr'));
                    finalTableRowsCleaned.forEach((row) => {
                        const cells = Array.from(row.querySelectorAll('th, td'));
                        cells.forEach((cell) => {
                            if (cell.firstElementChild && cell.firstElementChild.tagName.toLowerCase() === 'strong') {
                                cell.firstElementChild.textContent = cell.firstElementChild.textContent.trim();
                            } else {
                                cell.textContent = cell.textContent.trim();
                            }
                        });
                    });

                    tableCounter++;
                });

                monacoEditor.setValue(tempDiv.innerHTML);
                showMessage('HTML tables formatted successfully!', 'success');

            } catch (e) {
                console.error("Error formatting HTML tables:", e);
                showMessage('An error occurred during formatting. Please check your HTML.', 'error');
            }
        }

        formatButton.addEventListener('click', formatHtmlTables);
        clearButton.addEventListener('click', () => {
            if (monacoEditor) {
                monacoEditor.setValue('');
                showMessage('Editor content cleared.', 'info');
            }
        });
    </script>
</body>
</html>
